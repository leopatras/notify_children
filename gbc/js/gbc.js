/// FOURJS_START_COPYRIGHT(D,2014)
/// Property of Four Js*
/// (c) Copyright Four Js 2014, 2024. All Rights Reserved.
/// * Trademark of Four Js Development Tools Europe Ltd
///   in the United States and elsewhere
///
/// This file can be modified by licensees according to the
/// product manual.
/// FOURJS_END_COPYRIGHT

"use strict";

/*jshint -W121 */
Array.prototype.remove = function(item) {
  let i;
  while ((i = this.indexOf(item)) >= 0) {
    this.splice(i, 1);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.removeMatching = function(fn) {
  let i = 0;
  if (fn instanceof Function) {
    while (i < this.length) {
      if (fn(this[i])) {
        this.splice(i, 1);
      } else {
        i++;
      }
    }
  }
  return this;
};

/*jshint -W121 */
Array.prototype.removeAt = function(index) {
  if (index > -1) {
    this.splice(index, 1);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.insert = function(item, index) {
  if (index > -1) {
    this.splice(index, 0, item);
  }
  return this;
};

/*jshint -W121 */
Array.prototype.flatten = function() {
  return this.reduce(function(flat, toFlatten) {
    return flat.concat(Array.isArray(toFlatten) ? toFlatten.flatten() : toFlatten);
  }, []);
};

/*jshint -W121 */
Array.prototype.add = function(toAdd, index) {
  this.splice(index, 0, toAdd);
};

if (!Array.prototype.find) {
  /*jshint -W121 */
  Array.prototype.find = function(fn) {
    let i = 0;
    const len = this.length;
    for (; i < len; i++) {
      if (fn(this[i], i, this)) {
        return this[i];
      }
    }
    return null;
  };
}
if (!Array.prototype.findIndex) {
  /*jshint -W121 */
  Array.prototype.findIndex = function(fn) {
    let i = 0;
    const len = this.length;
    for (; i < len; i++) {
      if (fn(this[i])) {
        return i;
      }
    }
    return -1;
  };
}
if (!Array.prototype.contains) {
  /*jshint -W121 */
  Array.prototype.contains = function(element) {
    return this.indexOf(element) >= 0;
  };
}
if (!Array.from) {
  /*jshint -W121 */
  Array.from = function(arr) {
    return Array.prototype.slice.call(arr, 0);
  };
}

if (!Array.prototype.last) {
  /*jshint -W121 */
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
}
;

"use strict";
(function() {
  /**
   *
   * @param {string} name
   * @returns {null|number}
   */
  Element.prototype.getIntAttribute = function(name) {
    const result = parseInt(this.getAttribute(name), 10);
    return Object.isNaN(result) ? null : result;
  };

  const classedEventRE = /([^.]+)+(\..+)?/;

  /**
   *
   * @param {string} type
   * @param {string=} subFilter
   * @param {Function} callback
   */
  Element.prototype.on = function(type, subFilter, callback) {
    this._registeredEvents = this._registeredEvents || {};
    const supportsPassiveEvents = !window.browserInfo.isIE && !window.browserInfo.isEdge;
    const t = classedEventRE.exec(type || ""),
      event = t && t[1],
      passive = (event === "wheel" || event === "touchstart" || event === "touchmove") && supportsPassiveEvents,
      eventClass = t && t[2];
    if (event) {
      const registered = (this._registeredEvents[event] = this._registeredEvents[event] || {
        __default: []
      });
      let cb;
      if (!callback) {
        cb = subFilter;
      } else {
        cb = function(ev) {
          if (!subFilter || this.querySelectorAll(subFilter).contains(ev.target) ||
            this.querySelectorAll(subFilter + " *").contains(ev.target)) {
            callback(ev);
          }
        }.bind(this);
      }
      (registered[eventClass || "__default"] = registered[eventClass || "__default"] || []).push(cb);
      this.addEventListener(event, cb, passive ? {
        passive: true
      } : false);
    }
    return this;
  };

  /**
   *
   * @param {string} type
   */
  Element.prototype.off = function(type) {
    this._registeredEvents = this._registeredEvents || {};
    const t = classedEventRE.exec(type || "") || [],
      event = t[1],
      eventClass = t[2];
    if (event) {
      const registered = this._registeredEvents[event] || {};
      if (eventClass) {
        if (registered[eventClass]) {
          while (registered[eventClass].length) {
            this.removeEventListener(event, registered[eventClass].pop());
          }
        }
      } else {
        const keys = Object.keys(registered);
        for (const element of keys) {
          while (registered[element].length) {
            this.removeEventListener(event, registered[element].pop());
          }
        }
      }
    }
    return this;
  };

  /**
   *
   * @param {Function=} callback
   * @param noScrollContainer
   */
  Element.prototype.domFocus = function(callback, noScrollContainer) {
    const activeElement = document.activeElement;
    const mustPreventScroll = !!(noScrollContainer);
    // We don't want modifier keys to raise focus change and to be recorded
    // if modal system is opened we should not change the focus // TODO have better way to do this
    // if gbc chrome bar filter has focus you should not change it // TODO have better way to do this
    const gbcFilterInputHasFocus = Boolean(activeElement) && activeElement.hasClass("gbc_FilterInput");
    if (gbc.systemModalOpened === false && gbcFilterInputHasFocus === false && this !== activeElement) {
      if (noScrollContainer && !this.setActive) {
        // hack to prevent automatic scrolling when focus()
        // TODO is it still necessary now ? focus has a new option to preventScroll
        const scrollTop = noScrollContainer.scrollTop;
        const scrollLeft = noScrollContainer.scrollLeft;

        this.on("focus.NOScrollFocus", function() {
          noScrollContainer.scrollTop = scrollTop;
          noScrollContainer.scrollLeft = scrollLeft;
          this.off("focus.NOScrollFocus");
        }.bind(this));

        this.focus({
          preventScroll: mustPreventScroll
        });
      } else if (noScrollContainer) {
        try {
          this.setActive(); // IE: setActive gives the focus but don't scroll into view
        } catch (e) {
          this.focus({
            preventScroll: mustPreventScroll
          });
        }
      } else {
        this.focus({
          preventScroll: mustPreventScroll
        });
      }
    }
    if (callback) {
      window.requestAnimationFrame(callback);
    }
  };

  Element.prototype.hasParentOfType = function(nodeName) {
    let el = this;
    while (el.parentNode !== null) {
      el = el.parentNode;
      if (el.nodeName === nodeName) {
        return true;
      }
    }
    return false;
  };

  Element.prototype.setCursorPosition = function(pos, pos2) {
    if (!pos2 || pos2 === 0) {
      pos2 = pos;
    }
    try {
      if (!this.hasParentOfType("#document-fragment") && this.setSelectionRange) {
        this.setSelectionRange(pos, pos2);
      }
    } catch (e) {}
  };

  /**
   *
   * @param {HTMLElement} element
   */
  Element.prototype.replaceWith = function(element) {
    this.parentNode.insertBefore(element, this);
    this.remove();
  };

  if (!('remove' in Element.prototype)) {
    Element.prototype.remove = function() {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
    };
  }

  /**
   *
   * @param {HTMLElement} element
   */
  Element.prototype.prependChild = function(element) {
    let refElement = null;
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      refElement = this.childNodes[0];
    } else {
      refElement = this.children[0];
    }
    this.insertBefore(element, refElement);
  };

  /**
   *
   * @param index
   * @param {HTMLElement} parentNode
   */
  Element.prototype.insertAt = function(index, parentNode) {
    let parentChildren = null;
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      parentChildren = parentNode.childNodes;
    } else {
      parentChildren = parentNode.children;
    }

    if (index === 0) {
      if (parentChildren.length) {
        parentNode.prependChild(this);
      } else {
        parentNode.appendChild(this);
      }
    } else {
      const where = Boolean(index) && parentChildren[index];
      if (where) {
        if (where !== this) {
          parentNode.insertBefore(this, where);
        }
      } else {
        parentNode.appendChild(this);
      }
    }
  };
  /**
   *
   * @param {HTMLElement} refNode
   */
  Element.prototype.insertAfter = function(refNode) {
    if (refNode && refNode.parentNode) {
      refNode.parentNode.insertBefore(this, refNode.nextSibling);
    }
  };
  /**
   * Remove all children
   */
  Element.prototype.empty = function() {
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }
  };
  /**
   *
   * @param className
   * @returns {HTMLElement}
   */
  Element.prototype.parent = function(className) {
    // TODO simplify no need to have "found" variable
    let found = false,
      parent = this.parentNode;
    while (!found) {
      if (!parent) {
        found = true;
        break;
      }
      if (parent.nodeType === Node.ELEMENT_NODE && parent.hasClass(className)) {
        found = true;
        break;
      }
      parent = parent.parentNode;
    }
    return parent;
  };

  /**
   * Returns element if it has classname or first parent which has classname
   * @param {string} className
   * @returns {HTMLElement}
   */
  Element.prototype.elementOrParent = function(className) {
    if (this.hasClass(className)) {
      return this;
    } else {
      return this.parent(className);
    }
  };

  /**
   * Returns if current element is the same or is child of a specified element
   * @param {HTMLElement} elem - sepcified element
   * @returns {boolean}
   */
  Element.prototype.isElementOrChildOf = function(elem) {
    let current = this;
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE && current === elem) {
        return true;
      }
      current = current.parentNode;
    }
    return false;
  };

  /**
   *
   * @returns {boolean}
   */
  Element.prototype.isInDOM = function() {
    let found = false,
      parent = this.parentNode;
    while (!found) {
      if (!parent) {
        break;
      }
      if (parent === window.document.body) {
        found = true;
        break;
      }
      parent = parent.parentNode;
    }
    return found;
  };

  /**
   * @return {boolean}
   */
  Element.prototype.isOverflowingY = function() {
    return this.scrollHeight > this.clientHeight;
  };

  /**
   * @return {boolean}
   */
  Element.prototype.isOverflowingX = function() {
    return this.scrollWidth > this.clientWidth;
  };

  /**
   *
   * @param className
   * @returns {HTMLElement}
   */
  Element.prototype.child = function(className) {
    const children = this.children;
    let found = null;
    for (const element of children) {
      if (element.hasClass(className)) {
        found = element;
        break;
      }
    }
    return found;
  };

  /**
   *
   * @param tagName
   * @returns {HTMLElement}
   */
  Element.prototype.childTag = function(tagName) {
    const children = this.children;
    let found = null;
    for (const element of children) {
      if (element.tagName.toLowerCase() === tagName.toLowerCase()) {
        found = element;
        break;
      }
    }
    return found;
  };

  /**
   *
   * @param className
   * @returns {Node[]}
   */
  Element.prototype.allchild = function(className) {
    const children = this.children,
      result = [];
    for (const element of children) {
      if (element.hasClass(className)) {
        result.push(element);
      }
    }
    return result;
  };

  /**
   *
   * @param item
   * @returns {Node[]}
   */
  Element.prototype.childrenExcept = function(item) {
    const children = this.children,
      result = [];
    for (const element of children) {
      if (element !== item) {
        result.push(element);
      }
    }
    return result;
  };

  /**
   *
   * @param {string} cssClass
   * @returns {boolean}
   */
  Element.prototype.hasClass = function(cssClass) {
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      return (this.getAttribute("class") || "").split(" ").indexOf(cssClass) >= 0;
    } else {
      return this.classList.contains(cssClass);
    }
  };

  /**
   *
   * @param {string} cssClass
   * @returns {HTMLElement}
   */
  Element.prototype.addClass = function(cssClass) {
    if ((window.browserInfo.isIE || window.browserInfo.isEdge) && this instanceof SVGElement) {
      const currentClasses = (this.getAttribute("class") || "").split(" "),
        exists = currentClasses.indexOf(cssClass);
      if (exists >= 0) {
        currentClasses.splice(exists, 1);
      }
      currentClasses.push(cssClass);
      this.setAttribute("class", currentClasses.join(" "));
    } else {
      this.classList.add(cssClass);
    }
    return this;
  };

  /**
   *
   * @returns {HTMLElement}
   */
  Element.prototype.addClasses = function() {
    for (let i = 0; i < arguments.length; ++i) {
      this.classList.add(arguments[i]);
    }
    return this;
  };

  /**
   * Switch between classes
   * @param {string} cssClass1 - class added if switcher is true
   * @param {string|boolean} cssClass2 - class added if switcher is false
   * @param {boolean=} switcher
   * @returns {HTMLElement}
   */
  Element.prototype.toggleClass = function(cssClass1, cssClass2, switcher) {
    if (typeof switcher === "undefined") {
      switcher = cssClass2;
      if (window.browserInfo.isIE) {
        if (switcher) {
          this.classList.add(cssClass1);
        } else {
          this.classList.remove(cssClass1);
        }
      } else {
        if (switcher === true || switcher === false) {
          this.classList.toggle(cssClass1, switcher);
        } else {
          this.classList.toggle(cssClass1);
        }
      }
    } else {
      if (switcher) {
        this.classList.remove(cssClass2);
        this.classList.add(cssClass1);
      } else {
        this.classList.remove(cssClass1);
        this.classList.add(cssClass2);
      }
    }
    return this;
  };

  /**
   *
   * @param {string} cssClass
   * @returns {HTMLElement}
   */
  Element.prototype.removeClass = function(cssClass) {
    this.classList.remove(cssClass);
    return this;
  };

  /**
   *
   * @returns {HTMLElement}
   */
  Element.prototype.removeAllClasses = function() {
    this.setAttribute("class", "");
    return this;
  };

  Element.prototype.index = function() {
    let index = 0;
    let i = 0;
    const parent = this.parentNode,
      children = parent.childNodes,
      len = children.length;
    for (; i < len; i++) {
      const item = children[i];
      if (item === this) {
        return index;
      }
      if (item.nodeType === Node.ELEMENT_NODE) {
        index++;
      }
    }
    return -1;
  };

  Element.prototype.selectText = function() {
    let range, selection;
    if (document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(this);
      range.select();
    } else if (window.getSelection) {
      selection = window.getSelection();
      range = document.createRange();
      range.selectNodeContents(this);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };
  Element.prototype.closest = function(className) {
    if (this.hasClass(className)) {
      return this;
    } else {
      return this.parent(className);
    }
  };

  if (!NodeList.prototype.contains) {
    /*jshint -W121 */
    NodeList.prototype.contains = function(element) {
      let i = 0;
      const len = this.length;
      for (; i < len; i++) {
        if (this[i] === element) {
          return true;
        }
      }
      return false;
    };
  }

  if (!SVGElement.prototype.getElementsByClassName) {
    SVGElement.prototype.getElementsByClassName = function(cssClass) {
      return this.querySelectorAll(cssClass);
    };
  }

  Element.prototype.emitEvent = function(type) {
    const event = new Event(type, {
      bubbles: false,
      cancelable: true
    });
    this.dispatchEvent(event);
  };
})();
;

"use strict";
(function() {

  /**
   * Handle double tap events
   * @param {string} context gives a namespace to the event
   * @param {Function=} callback
   */
  Element.prototype.onDoubleTap = function(context, callback) {
    if (window.isTouchDevice()) {
      let lastTapTime = 0;

      this.on('touchstart.doubleTap_' + context, function(eventStart) {

        // Unbind touch end & move events
        this.off('touchend.doubleTap_' + context);
        this.off('touchmove.doubleTap_' + context);

        // No multi-touch
        if (eventStart.touches.length === 1) {

          let moveEventTriggered = false;
          // Check if a touch move is triggered
          this.on('touchmove.doubleTap_' + context, function(eventMove) {
            moveEventTriggered = true;
          });

          this.on('touchend.doubleTap_' + context, function(eventEnd) {

            // Unbind touch end & move events
            this.off('touchmove.doubleTap_' + context);
            this.off('touchend.doubleTap_' + context);

            const currentTime = new Date().getTime();
            const dblTapDuration = currentTime - lastTapTime;

            // double tap condition: duration between 2 taps & no touchMove event
            const isDblTab = (dblTapDuration < 350 && dblTapDuration > 1) && !moveEventTriggered;

            if (isDblTab) {
              // Double Tapped
              callback(eventEnd);
              eventEnd.preventCancelableDefault();

              // reset
              lastTapTime = 0;
              moveEventTriggered = false;
            } else {
              // In this case we are on the first tap event
              // if a touchMove event was triggered don't go further it is not a double tap
              if (moveEventTriggered) {
                lastTapTime = 0;
              } else {
                // no touchMove event: store time of first tap to check duration with the second...
                lastTapTime = currentTime;
              }
            }
          });
        }
      });
    }
    return this;
  };

  /**
   * Unregister doubleTap event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offDoubleTap = function(context) {
    if (window.isTouchDevice()) {
      this.off("touchend.doubleTap_" + context);
    }
  };

  /**
   * Handle swipe events
   * @param {string} context gives a namespace to the event
   * @param {Function} swipeCallback function executed after each successful swipe
   * @param {Object} options
   * @param {Array} options.direction : give direction to listen to: ['left', 'right', 'top', 'bottom']. By default, we will listen to all.
   * @param {number=} options.velocity : minimum velocity (px/ms) that gesture has to obtain to execute callback. Default value is 0.2.
   * @param {number=} options.distance : fraction of swiped distance over element. If swiped distance is higher that provided value
   *      we will always generate a successful swipe even if velocity was very low. Default value is 0.1. (0.1 = 10% of element size as swipe)
   * @param {boolean=} options.debounce : true/false to limit the touchmove call. False by default.
   * @param {Element|Array<Element>} [options.ignore] : if event target of swipe start is one of or a child of one of the given element(s),
   *      we don't consider this move as a swipe
   * @param {Function=} options.startCallback : callback executed on each touchstart/mousedown action. Null by default.
   * @param {Function=} options.moveCallback : callback executed during touchmove/mousemove actions. Take note that this callback will be raised massively and may induce performance issues. Null by default.
   * @param {Function=} options.endCallback : callback executed after each touchend/mouseup action. Null by default.
   */
  Element.prototype.onSwipe = function(context, swipeCallback, options) {
    options = (typeof options === "object") ? options : {};

    // watched swipe directions
    const direction = options.direction ? options.direction : ["left", "right", "top", "bottom"];
    const watchedDirection = {};
    for (const element of direction) {
      watchedDirection[element] = true;
    }
    let _touchStartX = null;
    let _touchStartY = null;
    let _touchStartTime = null;

    const unifyTouchEvent = function(evt) {
      return evt.changedTouches ? evt.changedTouches[0] : evt;
    };

    /** Touch/Mouse Events **/
    const endSwipe = function(evt) {
      if (!evt.touches || evt.touches.length === 0) { // we don't manage multiples touch

        // on touch/mouse release unbind move/up events
        this.off('mouseup.swipe_' + context);
        this.off('touchend.swipe_' + context);
        this.off('mouseleave.swipe_' + context);
        this.off('touchleave.swipe_' + context);
        if (options.moveCallback) {
          this.off('mousemove.swipe_' + context);
          this.off('touchmove.swipe_' + context);
        }

        let swipedVelocity = 0;
        let swipedFraction = 0;

        if (_touchStartX && _touchStartY && evt) {
          // swipe direction, distance and velocity calculation
          const xUp = unifyTouchEvent(evt).clientX;
          const yUp = unifyTouchEvent(evt).clientY;
          const xDiff = _touchStartX - xUp;
          const yDiff = _touchStartY - yUp;
          const xIndex = Math.sign(xDiff);
          const yIndex = Math.sign(yDiff);

          // Get most significant direction
          const absXMove = Math.abs(xDiff);
          const absYMove = Math.abs(yDiff);
          const isXSwipe = absXMove > absYMove;
          const maxMove = Math.max(absXMove, absYMove);
          if (maxMove > 15) { // exclude micro gestures and clicks from calculation
            const totalDistance = isXSwipe ? this.clientWidth : this.clientHeight;
            swipedFraction = (maxMove / totalDistance).toFixed(2);
          } else if (maxMove > 0) {
            swipedFraction = 0.05;
          }

          const duration = new Date().getTime() - _touchStartTime;
          const velocity = options.velocity ? options.velocity : 0.2;
          const distanceToSwipe = options.distance ? options.distance : 0.1;
          swipedVelocity = maxMove / duration;

          // swipe if minimum velocity of gesture (distance/duration of swipe) or swiped 50% of viewport width
          if (swipedVelocity >= velocity || swipedFraction > distanceToSwipe) {
            swipedFraction = 1 - swipedFraction;
            if (isXSwipe) {
              if (xIndex > 0) {
                /* left swipe */
                if (watchedDirection.left) {
                  swipeCallback("left");
                }
              } else {
                if (watchedDirection.right) {
                  swipeCallback("right");
                }
              }
            } else {
              if (yIndex > 0) {
                if (watchedDirection.top) {
                  swipeCallback("top");
                }
              } else {
                if (watchedDirection.bottom) {
                  swipeCallback("bottom");
                }
              }
            }
          }
        }

        if (options.endCallback) {
          options.endCallback(evt, swipedVelocity, swipedFraction);
        }

        // reset values
        _touchStartX = null;
        _touchStartY = null;
        _touchStartTime = null;
      }
    };

    this.offSwipe(context);

    let endHandler = endSwipe;
    // touch/mouse down event callback
    const startSwipe = function(evt) {
      if (options.ignore) {
        if (!Array.isArray(options.ignore)) {
          options.ignore = [options.ignore];
        }
        if (options.ignore.find(function(item) {
            return evt.target && evt.target.isElementOrChildOf(item);
          })) {
          return;
        }
      }
      if (evt.ctrlKey === false && (!evt.touches || evt.touches.length === 1)) {
        // do not swipe if CTRL key pressed and do not add additional bindings if multiple fingers
        if (evt.cancelable) { // prevent text selection
          evt.preventDefault();
        }

        this.on('mouseup.swipe_' + context, endHandler);
        this.on('touchend.swipe_' + context, endHandler);
        this.on('mouseleave.swipe_' + context, endHandler);
        this.on('touchleave.swipe_' + context, endHandler);

        if (options.moveCallback) {
          // touch/mouse move callback
          const moveHandler = function(evt) {
            if (evt.cancelable) { // to avoid browser back native
              evt.preventDefault();
            }
            options.moveCallback(evt, _touchStartX, _touchStartY);
          };
          this.on('mousemove.swipe_' + context, moveHandler);
          this.on('touchmove.swipe_' + context, moveHandler);
        }

        _touchStartX = unifyTouchEvent(evt).clientX;
        _touchStartY = unifyTouchEvent(evt).clientY;
        _touchStartTime = new Date().getTime();
        if (options.startCallback) {
          options.startCallback(evt);
        }
      }
    };

    let startHandler = startSwipe;
    if (options.debounce) {
      startHandler = startSwipe.debounce().bind(this);
      endHandler = endSwipe.debounce().bind(this);
    }
    this.on('mousedown.swipe_' + context, startHandler);
    this.on('touchstart.swipe_' + context, startHandler);
  };

  /**
   * Unregister swipe event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offSwipe = function(context) {
    this.off('mousemove.swipe_' + context);
    this.off('touchmove.swipe_' + context);
    this.off('mousedown.swipe_' + context);
    this.off('touchstart.swipe_' + context);
    this.off('mouseup.swipe_' + context);
    this.off('touchend.swipe_' + context);
    this.off('mouseleave.swipe_' + context);
    this.off('touchleave.swipe_' + context);
  };

  /**
   * Handle long touch events
   * @param {string} context gives a namespace to the event
   * @param {Function=} callback
   * @param {Object} options
   *    touchDuration : define the duration before triggering the callback
   */
  Element.prototype.onLongTouch = function(context, callback, options) {
    if (window.isTouchDevice()) {
      const touchDuration = (options && options.touchDuration) || 500;
      const preventDefault = (options && options.preventDefault) || true; // TODO Wrong it is always true
      let timer = null;

      this.on('touchstart.longTouch_' + context, function(event) {
        if (preventDefault) {
          event.preventCancelableDefault();
        }
        timer = setTimeout(function() {
          callback(event);
        }.bind(this), touchDuration);
      });

      this.on('touchend.longTouch_' + context, function() {
        if (timer) {
          clearTimeout(timer);
        }
      });
    }
    return this;
  };

  /**
   * Unregister longTouch event
   * @param {string} context : namespace of the event to unregister
   */
  Element.prototype.offLongTouch = function(context) {
    if (window.isTouchDevice()) {
      this.off("touchstart.longTouch_" + context);
      this.off("touchend.longTouch_" + context);
    }
  };

})();
;

"use strict";

/*jshint -W121 */
Event.prototype.preventCancelableDefault = function() {
  if (typeof this.cancelable !== 'boolean' || this.cancelable) {
    // The event can be canceled, so we do so.
    this.preventDefault();
    return true;
  } else {
    // The event cannot be canceled, so it is not safe
    // to call preventDefault() on it.
    console.warn("Event couldn't be canceled");
    return false;
  }
};

// TODO should be gbcPreventDefault
Event.prototype.gbcDontPreventDefault = null;

// When an event is not created by GBC (ex for Webcomponents) some functions must be defined in the event.
/*jshint -W121 */
Event.prototype.normalizeEventForGBC = function(event) {
  if (!event.preventCancelableDefault) {
    event.preventCancelableDefault = Event.prototype.preventCancelableDefault;
  }
};
;

"use strict";

/*
 ** The Math.sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.
 */
if (!Math.sign) {
  Math.sign = function(x) {
    return ((x > 0) - (x < 0)) || +x;
  };
}

/**
 * Check if a string is an Integer
 * @param {string} str - string to be tested
 * @returns {boolean} true if str is an Integer
 */
Math.isStringInteger = function(str) {
  return Number.isInteger(parseInt(str, 10));
};

/**
 * @param {number} x The value to clamp
 * @param {number} min The minimum value
 * @param {number} max The maximum value
 * @returns The value clamped between the min and max value
 */
Math.clamp = function(x, min, max) {
  return Math.min(Math.max(x, min), max);
};
;

"use strict";

/*
 ** Function decodeInteger
 **
 ** Decode an integer in Big-Endian binary notation
 ** and store it into a JavaScript native integer.
 **
 ** Truncate the value parameter if longer than 4 bytes.
 **
 ** String value: the integer in BE binary notation
 ** returns int: the integer in JavaScript native integer
 */
Number.decodeInteger = function(value) {
  if (value.length > 4) {
    value = value.substring(0, 4);
  }
  let ret = "";
  for (let i = 0; i < value.length; ++i) {
    let hex = value.charCodeAt(i).toString(16);
    if (hex.length < 2) {
      hex = "0" + hex;
    }
    ret += hex;
  }
  value = parseInt(ret, 16);
  return value;
};

/*
 ** Function encodeInteger
 **
 ** Encode a JavaScript native integer and store it
 ** into an integer in Big-Endian binary notation.
 **
 ** Truncate the value parameter if longer than 4 bytes.
 ** (the VM protocol's header only handles 4 bytes integer)
 **
 ** int value: the integer in JavaScript native integer
 ** returns String: the integer in BE binary notation
 */
Number.encodeInteger = function(value) {
  value = value.toString(16);
  if (value.length > 8) {
    value = value.substring(value.length - 8, value.length);
  } else if (value.length < 8) {
    while (value.length < 8) {
      value = "0" + value;
    }
  }
  const valueArr = value.match(/.{2}/g);
  for (let i = 0; i < valueArr.length; ++i) {
    valueArr[i] = String.fromCharCode(parseInt(valueArr[i], 16));
  }
  value = valueArr.join("");
  return value;
};

Number.isNaN = Number.isNaN || window.isNaN;

/*jshint -W121 */
Number.prototype.pad = function(total) {
  const len = total - this.toString().length,
    result = [];
  for (var i = 0; i < len; i++) {
    result[i] = "0";
  }
  result[i] = this;
  return result.join("");
};

Number.compare = function(a, b) {
  if (a === b) {
    return 0;
  }
  if (a < b) {
    return -1;
  }
  return 1;
};
;

"use strict";

/**
 * swaps key/values
 *
 * @param {Object} obj the source object
 * @returns {Object} a newly created object that represents the swapped object
 */
Object.swap = function(obj) {
  const result = {};
  if (obj) {
    for (let property in obj) {
      if (obj.hasOwnProperty(property)) {
        result[obj[property]] = property;
      }
    }
  }
  return result;
};

Object.isString = function(obj) {
  return typeof obj === "string";
};
Object.isNumber = function(obj) {
  return typeof obj === "number";
};
Object.isFunction = function(obj) {
  return typeof obj === "function";
};
Object.isBoolean = function(obj) {
  return obj === true || obj === false;
};

Object.isNaN = function(i) {
  return window.isNaN(i);
};

if (!Object.values) {
  /**
   * IE11 Polyfill
   * @param obj
   * @returns {Array} Array of values
   */
  Object.values = function(obj) {
    return Object.keys(obj).map(function(e) {
      return obj[e];
    });
  };
}

/**
 * IE11 Polyfill
 */
if (typeof Object.assign !== 'function') {
  Object.assign = function(target, varArgs) {
    if (target === null) { // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }
    const to = Object(target);
    for (let index = 1; index < arguments.length; index++) {
      const nextSource = arguments[index];
      if (nextSource !== null) { // Skip over if undefined or null
        for (let nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}
;

"use strict";

// jshint ignore:start
String.prototype.getBytesCount = function() {
  const log = Math.log(256);
  let total = 0;
  for (let i = 0; i < this.length; i++) {
    const charCode = this.charCodeAt(i);
    total += Math.ceil(Math.log(charCode) / log);
  }
  return total;
};

// Replace char at index
String.prototype.replaceAt = function(index, character) {
  return this.substr(0, index) + character + this.substr(index + character.length);
};
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}

if (!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^\s+/, "").replace(/\s+$/, "");
  };
}

String.prototype.capitalize = function() {
  return this.substr(0, 1).toUpperCase() + this.substr(1).toLowerCase();
};

if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    const total = Math.floor(Number(count));
    if (total > 0) {
      return new Array(total + 1).join(this);
    } else {
      return "";
    }
  };
}

/**
 * generate a random hexadecimal string
 * @param length
 * @returns {string}
 */
String.random = function(length = 16) {
  const bytes = new Uint8Array(Math.ceil(length / 2));
  window.crypto.getRandomValues(bytes);
  return Array.from(bytes)
    .map(byte => byte.toString(16).padStart(2, '0'))
    .join('')
    .slice(0, length);
};

const ESC_MAP = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

// escape most problematic html chars from the string
String.prototype.escapeHTML = function() {
  return this.replace(/[&<>'"]/g, function(c) {
    return ESC_MAP[c];
  });
};

String.prototype.htmlDecode = function() {
  const doc = new DOMParser().parseFromString(this, "text/html");
  return doc.documentElement.textContent;
};

/**
 * put quote around font name when it contains a space
 * @return {string}
 */
String.prototype.escapeFontFamily = function() {
  let fontList = [];

  fontList = this.split(",").map(function(font) {
    return (font.indexOf(" ") >= 0 ? '"' + font.trim() + '"' : font)
  });

  return fontList.join(",");
};

/**
 * The splice() method changes the content of a string by removing a range of
 * characters and/or adding new characters.
 *
 * @this {String}
 * @param {number} start Index at which to start changing the string.
 * @param {number} delCount An integer indicating the number of old chars to remove.
 * @param {string} newSubStr The String that is spliced in.
 * @return {string} A new string with the spliced substring.
 */
String.prototype.splice = function(start, delCount, newSubStr) {
  return this.slice(0, start) + newSubStr + this.slice(start + Math.abs(delCount));
};

/**
 * Verif if the unicode char code belong to the encoding table
 * @param table table of authorized utf-16 codes
 * @param charCode utf-16 char code
 * @return {boolean} true if the char exist in the table
 */
String.charExistInEncoding = function(table, charCode) {
  for (let i = 0; i < table.length && table[i][0] <= charCode; i++) {
    if (table[i][0] <= charCode && charCode <= table[i][1]) {
      return true;
    }
  }

  return false;
}

/**
 * @return {boolean} true if the current encoding is single byte
 */
String.isSingleByteEncoding = function() {
  const encoding = gbc.classes.EncodingHelper.getVMEncoding();

  return encoding !== 'utf-8' && encoding !== 'big5' && encoding !== 'cp950';
}

/**
 * Remove unauthorized char for the current encoding
 * @return {string} return a clean string
 */
String.prototype.removeUnknownChar = function() {
  return gbc.classes.EncodingHelper.removeUnknownChar(this);
}

/**
 * Give the display width of the current string
 * @return {number}
 */
String.prototype.displayWidth = function() {
  return gbc.classes.EncodingHelper.displayWidth(this);
};

/**
 * Give the byte length of the string for the current encoding (if unknown fallback to iso-8859)
 * @return {number}
 */
String.prototype.countBytes = function() {
  const encoding = gbc.classes.EncodingHelper.getVMEncoding();
  if (encoding === 'utf-8') {
    return gbc.classes.EncodingHelper.utf8Count(this);
  } else if (encoding === 'big5' || encoding === 'cp950') {
    return gbc.classes.EncodingHelper.big5Count(this);
  }

  //Use a single byte encoding as default
  return gbc.classes.EncodingHelper.iso8859Count(this);
}

// jshint ignore:end
;

"use strict";

/*jshint -W121 */
Function.prototype.debounce = function(threshold, execAsap) {
  let timeout = null;
  const func = this;
  return function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    const context = this;
    const delayed = function() {
      if (!execAsap) {
        func.apply(context, [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9]);
      }
      timeout = null;
    };

    if (timeout) {
      clearTimeout(timeout);
    } else if (execAsap) {
      func.apply(context, [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9]);
    }

    timeout = setTimeout(delayed, threshold || 100);
  };
};

Function.prototype.throttle = function(threshold) {
  const func = this;
  let throttling = false;
  const clear = function() {
    throttling = false;
  };
  return function() {
    if (!throttling) {
      func.apply(this, arguments);
      window.setTimeout(clear, threshold);
      throttling = true;
    }
  };
};

Function.noop = function() {};
Function.true = function() {
  return true;
};
Function.false = function() {
  return false;
};
;

"use strict";

/**
 * Return true if mobile browser, false otherwise
 * @returns bool if the browser is mobile
 */
/* jshint ignore:start */
window.isMobile = function() {
  const testExp = new RegExp('BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile|webOS', 'i');
  const isOtherMobile = (testExp.test(navigator.userAgent) === true);
  const isAndroid = window.isAndroid();
  const isIOS = window.isIOS();
  // window.orientation works well but is deprecated. So we use additional check.
  return typeof window.orientation !== "undefined" || isAndroid || isIOS || isOtherMobile;
};

window.isPhone = function() {
  if (window.isMobile()) {
    return Math.min(window.screen.width, window.screen.height) < 768;
  }
  return false;
};

window.isTablet = function() {
  if (window.isMobile()) {
    return Math.min(window.screen.width, window.screen.height) >= 768;
  }
  return false;
};

window.isAndroid = function() {
  if (window.androidEmulationDebug === true) {
    return true
  }
  const testExp = new RegExp('Android', 'i');
  // window.orientation works well but is deprecated. So we use additional check.
  return typeof window.orientation !== "undefined" && testExp.test(navigator.userAgent) === true;
};

window.isIOS = function() {
  const testExp = new RegExp('iPhone|iPad|iPod|GMI', 'i');
  if (testExp.test(window.navigator.userAgent)) {
    return true;
  } else {
    return window.navigator.maxTouchPoints &&
      window.navigator.maxTouchPoints > 2 &&
      /MacIntel/.test(window.navigator.platform);
  }
};

window.isTouchDevice = function() {
  return "ontouchstart" in document.documentElement || 'ontouchstart' in window ||
    navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
};

// detect mouse
window.hasMouse = function() {
  return window.matchMedia('(pointer:fine)').matches;
};

/* jshint ignore:end */
window.offset = function(elt) {
  const rect = elt[0].getBoundingClientRect();
  return {
    left: Math.round(rect.left),
    top: Math.round(rect.top),
    centerX: Math.round(rect.left + rect.width / 2),
    centerY: Math.round(rect.top + rect.height / 2)
  };
};

/**
 * Check if capslock is on
 * @param {KeyboardEvent} e - event emitted on keydown
 * @return {boolean} true if capsLock is on, false otherwise
 */
window.isCapslock = function(e) {
  if (e.which === 20) {
    // toggle capsLock state when the key is CapsLock
    this._capsLock = !this._capsLock;
  } else if (e?.getModifierState) {
    // Otherwise get the caps modifier of the key
    this._capsLock = e.getModifierState("CapsLock") || (e.which === 20 && !e.getModifierState("CapsLock"));
  }
  return this._capsLock;
};

/**
 * Test if a string is a valid URL
 *
 * @returns {boolean}
 */
window.isValidURL = function(str) {
  const pattern = new RegExp("(?:https?:\\/\\/)?(?:[a-zA-Z0-9]+\\.)+[a-zA-Z0-9]+(?:\\/[a-zA-Z0-9]+)*\\/?", "i");
  return pattern.test(str);
};

/**
 * Check if url has a parameter with corresponding value
 * @param {string} url - url to check parameter on
 * @param {string} param - parameter
 * @param {string} value - value of parameter
 * @returns {boolean} true if parameter with corresponding value has been found in url
 */
window.hasParameterValue = function(url, param, value) {
  const queryString = (param + "=" + value).toLowerCase();
  // extract url parameters only
  const start = url.lastIndexOf("?") + 1;
  let end = url.lastIndexOf("#"); // manage optional hash section located at the end of the url
  if (end < start) {
    end = url.length;
  }
  const variables = url.substring(start, end).toLowerCase().split("&"); // get array of parameters
  for (const element of variables) {
    if (element === queryString) {
      return true;
    }
  }
  return false;
};

/**
 * Check if url has the parameter set as active (1 value)
 * @param {string?} url - optional. If unset, we look by default for current browser url
 * @param {string} param - parameter name to check
 * @returns {boolean} true if parameter is set and enabled in url
 */
window.isURLParameterEnabled = function(url, param) {
  if (param === undefined) {
    param = url;
    url = window.location.search;
  }
  return window.hasParameterValue(url, param, "1");
};

/**
 * Check if url has the parameter set as inactive (0 value)
 * @param {string?} url - optional. If unset, we look by default for current browser url
 * @param {string} param - parameter name to check
 * @returns {boolean} true if parameter is set and disabled in url
 */
window.isURLParameterDisabled = function(url, param) {
  if (param === undefined) {
    param = url;
    url = window.location.search;
  }
  return window.hasParameterValue(url, param, "0");
};

window.isOrientationImplemented = typeof window.orientation !== "undefined";

(function(window) {
  window.waitMax = function(timeout, trigger, event, fallback) {
    let time = 0;
    const itv = window.setInterval(function() {
      if (trigger()) {
        window.clearInterval(itv);
        event();
      } else {
        time += 50;
        if (time > timeout) {
          window.clearInterval(itv);
          (fallback || event)();
        }
      }
    }, 50);
  };
})(window);
(function() {
  window.browserInfo = {
    isFirefox: false,
    isEdge: false,
    isIE: false,
    isChrome: false,
    isOpera: false,
    isSafari: false,
    isAndroid: false,
    isIOS: false
  };

  const sUsrAg = window.navigator.userAgent;

  if (sUsrAg.indexOf("Edge") > -1) {
    window.browserInfo.isEdge = true;
  } else if (sUsrAg.indexOf("Chrome") > -1) {
    window.browserInfo.isChrome = true;
  } else if (sUsrAg.indexOf("Safari") > -1) {
    window.browserInfo.isSafari = true;
  } else if (sUsrAg.indexOf("Opera") > -1) {
    window.browserInfo.isOpera = true;
  } else if (sUsrAg.indexOf("Firefox") > -1) {
    window.browserInfo.isFirefox = true;
  } else if (sUsrAg.indexOf("MSIE") > -1 || sUsrAg.indexOf("Trident") > -1) {
    window.browserInfo.isIE = true;
  }

  // activate androidEmulationDebug
  if (window.isURLParameterEnabled(window.location.search, "androidemulationdebug")) {
    window.androidEmulationDebug = true;
  }
  if (window.isAndroid()) {
    window.browserInfo.isAndroid = true;
  }
  if (window.isIOS()) {
    window.browserInfo.isIOS = true;
  }
})();

// Compute ScrollBar size
(function() {
  const div = document.createElement('div');
  div.style.width = "50px";
  div.style.height = "50px";
  div.style.overflowY = "scroll";
  div.style.position = "absolute";
  div.style.top = "-200px";
  div.style.left = "-200px";
  div.innerHTML = '<div style="height:100px;width:100%"></div>';

  document.body.appendChild(div);
  const w1 = div.offsetWidth;
  const w2 = div.children[0].offsetWidth;
  document.body.removeChild(div);

  window.scrollBarSize = w1 - w2;
})();

/**
 * Convert image to base64
 * @param {String} src
 * @param {Function} callback
 * @param {String} outputFormat - image/png, image/jpeg
 */
window.toDataURL = function(src, callback, outputFormat) {
  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.onload = function() {
    let canvas = document.createElement('CANVAS');
    const ctx = canvas.getContext('2d');
    let dataURL;
    // Resize the canvas to the original image dimensions
    canvas.height = this.naturalHeight;
    canvas.width = this.naturalWidth;
    ctx.drawImage(this, 0, 0);
    dataURL = canvas.toDataURL(outputFormat);
    callback(dataURL);
    canvas = null;
  };
  img.src = src;
  // Make sure the load event fires for cached images too
  if (img.complete || img.complete === undefined) {
    // Flush cache
    img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
    // Try again
    img.src = src;
  }
};
;

"use strict";

/**
 * Display a message as a critical error in an old console style
 * @param {string} message the message to display
 */
window.critical = function(message) {
  this.message = message;
  this._decorated = window.location.search.toLowerCase().indexOf("debugmode=1") >= 0;
  this._prepareStyle();
  document.body.innerHTML = "<div id='critical-overlay'></div><div id='term'>\n" + this._prepareMessage() +
    "</div>";
};
/**
 * shortcut method
 * @param {string} message the message to display
 * @return {Window.critical}the critical instance
 */
window.critical.display = function(message) {
  return new window.critical(message);
};

window.critical.prototype = {

  /**
   * prepare css style of critical error
   * @private
   */
  _prepareStyle: function() {
    const link = document.createElement("style");
    if (this._decorated) {
      link.innerHTML =
        "* {margin: 0;padding: 0;outline: none;font-family:monospace;}" +
        "html,body{width:100%;height:100%;margin:0;padding:0;border:0;background:#000;color:lime;}" +
        "body{box-shadow: 0 0 1px 3px rgba(10, 10, 10, .7);overflow: hidden;user-select: none;}" +
        "body:before{width: 100%;height: 100%;position: absolute;" +
        "background-color: #000;background: linear-gradient(#fff 50%, #000 50%);background-size: 100% 4px;background-repeat: repeat-y;" +
        "opacity: .14;box-shadow: inset 0 0 10px 10px rgba(0, 0, 0, .8);z-index: 12;animation: pulse 5s linear infinite;content: '';}" +
        "body:after{content:'';width: 100%;height: 100%;background-color: #00ff77;background: radial-gradient(ellipse at center, rgba(0,0,0,1) 0%,rgba(0,0,0,0.62) 45%,rgba(0,9,4,0.6) 47%,rgba(0,255,119,1) 100%);opacity: .1;z-index: 11;}" +
        "#term{text-align:center;position: absolute;top: 0px;left: 0px;bottom: -1px;right: -10px;overflow: hidden;z-index: 1;font-size:1.4em;padding:2em;white-space:pre;background: radial-gradient(ellipse at center, rgba(0,255,119,0.45) 0%,rgba(255,255,255,0) 100%);transform-origin: 50% 50%;transform: perspective(200px) rotateX(.1deg) skewX(1deg) scale(1.02);opacity: .9;}" +
        "#critical-overlay {width: 100%;height: 100%;position: absolute;left: 0;top: 0;margin-left: 0;margin-top: 0;z-index: 100;}" +
        "#critical-overlay:before {content: '';position: absolute;top: 0;left: 0;width: 100%;height: 50px;background: #fff;background: linear-gradient(to bottom, rgba(255,0,0,0) 0%,rgba(255,250,250,1) 50%,rgba(255,255,255,0.98) 51%,rgba(255,0,0,0) 100%);opacity: .02;animation: vline 1.25s linear infinite;}" +
        "@keyframes pulse {0% {transform: scale(1.001);opacity: .14;}8% {transform: scale(1.000);opacity: .13;}" +
        "15% {transform: scale(1.004);opacity: .14;}30% {transform: scale(1.002);opacity: .11;}" +
        "100% {transform: scale(1.000);opacity: .14;}}" +
        "@keyframes vline {0% {top: 0px;}100% {top: 100%;}}";
    } else {
      link.innerHTML =
        "* {margin: 0;padding: 0;outline: none;font-family:monospace;}" +
        "html,body{width:100%;height:100%;margin:0;padding:0;border:0;text-align:center;}" +
        "#term{white-space:pre;}";
    }
    document.head.appendChild(link);
  },

  /**
   *  console style full line template
   */
  _line: "#".repeat(80) + "\n",

  /**
   *  console style empty line template
   */
  _empty: "#" + " ".repeat(78) + "#\n",

  /**
   * get a console styled formatted text
   * @param {string} text text to display in line
   * @param {number} size size of alignment text
   * @return {string} the console styled text
   * @private
   */
  _prepareLine: function(text, size) {
    const before = Math.floor((78 - size) / 2),
      after = 78 - text.length - before;
    return "#" + " ".repeat(before) + text + " ".repeat(after) + "#\n";
  },
  /**
   * get a full text message in a console style
   * @return {string} the text to display
   * @private
   */
  _prepareMessage: function() {
    const msg = this.message.match(/.{1,76}/g),
      size = Math.max.apply(null, msg.map(function(item) {
        return item.length;
      }));
    let text = "\n",
      i = 0;
    const before = Math.max(Math.floor((19 - msg.length) / 2), 1),
      after = Math.max(19 - msg.length - before, 1);
    text += this._line;
    for (; i < before; i++) {
      text += this._empty;
    }
    text += this._prepareLine("Genero Browser Client", 21);
    text += this._prepareLine("---------------------", 21);
    text += this._empty;
    for (i = 0; i < msg.length; i++) {
      text += this._prepareLine(msg[i], size);
    }

    for (i = 0; i < after; i++) {
      text += this._empty;
    }
    text += this._prepareLine("See browser's console for details.", 33);
    text += this._empty;
    text += this._line;
    return text;
  }
};
;

"use strict";

(function(context) {
  const nativeJsface = context.jsface;
  const noop = function() {};

  /**
   * @typedef {Function} ClassFunctor
   * @param {Object.<string, function|*>} $super
   */

  /**
   * ### __jsface override__
   * adds some new features:
   *
   * * introduce $super keyword
   * * ability to declare mixins in class definition
   *
   * See {@link augmentedFace.Class} to create classes
   * @namespace window.augmentedFace
   */
  context.augmentedFace = /** @lends window.augmentedFace */ {
    /**
     * Creates a class
     * @example
     * // Simple class, no inheritance
     * var MyClass = augmentedFace.Class({
     *   myMethod : function(){
     *     this.myMember = 1;
     *   }
     * });
     * @example
     * // Simple class, inherits from MyClass, overrides myMethod
     * augmentedFace.Class(MyClass, {
     *   myMethod : function(){
     *     this.myMember = 2;
     *   }
     * });
     * @example
     * // Simple class, inherits from MyClass, calls superclass' myMethod
     * augmentedFace.Class(MyClass, function($super){
     *   return {
     *     myMethod : function(){
     *       this.myMember = 2;
     *     }
     *   };
     * });
     * @method Class
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @param {?boolean=} _checkMembers internal flag
     * @returns {Function} the constructed class
     */
    Class: function(params, api, _checkMembers) {
      let parent = 0,
        inheritance = [],
        ascendance = [];
      if (!api) {
        api = params;
        params = 0;
      }
      switch (typeof params) {
        case "function":
          parent = params;
          break;
        case "object":
          parent = params.base || 0;
          break;
        default:
          break;
      }

      const $super = {
        constructor: parent || noop
      };

      if (parent) {
        const memberKeys = Object.keys(parent.prototype);
        for (const methodName of memberKeys) {
          const method = parent.prototype[methodName];
          if (typeof method === "function") {
            $super[methodName] = method;
          } else if (methodName === "__name") {
            $super.__name = method;
          } else if (methodName === "__ascendance") {
            ascendance = method.slice();
          } else if (methodName === "__inheritance") {
            inheritance = method.slice();
            inheritance.push($super.__name);
          }
        }
      }

      api = (typeof api === "function" ? api($super) : api) || {};
      if (!api.__name && ascendance.indexOf("WidgetBase") >= 0) {
        throw api;
      }
      if (!api.__virtual) {
        ascendance.push(api.__name);
      }
      if (ascendance.indexOf("WidgetBase") >= 0) {
        this._widgetSpecificApi(api, ascendance);
      }
      api.__inheritance = inheritance;
      api.isInstanceOf = function(type) {
        return Boolean(type) &&
          Boolean(type.prototype) &&
          type.prototype.__name === this.__name ||
          this.__inheritance.indexOf(type.prototype.__name) >= 0;
      };
      if (!api.hasOwnProperty("constructor")) {
        api.constructor =
          function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
            $super.constructor.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
          };
      }
      if (_checkMembers !== false) {
        this._checkMembers(api);
      }

      return nativeJsface.Class(parent, api);
    },
    _widgetSpecificApi: function(api, ascendance) {
      if (api.__ignoreInheritance) {
        api.__ascendance = ["WidgetBase"];
        if (!api.__virtual) {
          api.__ascendance.push(api.__name);
        }
      } else {
        api.__ascendance = ascendance;
      }
      api.__ascendanceClasses = ascendance.map(function(item) {
        return "gbc_" + item;
      }).join(" ");
    },
    _checkMembers: function(api) {
      Object.keys(api).forEach(function(mk) {
        switch (mk) {
          case "__inheritance":
          case "__ascendance":
          case "usedStyleAttributes":
          case "__dataContentPlaceholderSelector":
          case "watchedAttributes":
          case "$static":
            return;
          default:
            break;
        }
        switch (typeof api[mk]) {
          case "function":
          case "string":
          case "number":
          case "boolean":
            return;
          case "object":
            if (api[mk] === null) {
              return;
            }
            break;
          default:
            break;
        }
        gbc.warn("class definition issue, member seems shared", api.__name, mk, typeof api[mk]);
      });
    },

    /**
     * Creates a single instance of a class
     * @method Singleton
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     *
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @returns {*} the constructed instance
     */
    Singleton: function(params, api) {
      const SingletonClass = this.Class(params, api, false);
      SingletonClass.prototype.__unique = true;
      return new SingletonClass();
    },

    /**
     * Creates a static class. Should not be instantiated
     * @method StaticClass
     * @param {ClassFunctor|Object|number} [params]
     * if *params* is omitted, the defined class will not have a superclass
     * @param {ClassFunctor|Object|number} api
     * if *api* is omitted, the *params* parameter will be used as api description
     * The *api* parameter can be:
     * * an object, describing the different members of the class
     * * a function, that will return an object as above desciption, but with the ability to inject *$super* accessor
     * @returns {*} the constructed class
     */
    StaticClass: function(params, api) {
      if (!api) {
        api = params;
        params = 0;
      }
      if (api) {
        if (typeof api === "function") {
          const originalApi = api;
          api = function($super) {
            const result = originalApi($super);
            if (result) {
              result.$singleton = true;
            }
            return result;
          };
        } else {
          api.$singleton = true;
        }
      }
      return this.Class(params, api, false);
    }
  };
})(window);
;

"use strict";

(function(w) {
  const modules = [];
  let resolvedModules = 0;
  const loadedModules = {};
  let injection = [];
  const loadModule = function(module) {
    module.exec.apply(w, injection);
  };
  const resolve = function() {
    let moduleIndex = 0;
    for (;;) {
      if (moduleIndex >= modules.length) {
        break;
      }
      const module = modules[moduleIndex];
      if (module) {
        let dependencyIndex = 0;
        for (;;) {
          if (!module.after || dependencyIndex >= module.after.length) {
            break;
          }
          const dependency = module.after[dependencyIndex];
          if (dependency && loadedModules[dependency]) {
            module.after[dependencyIndex] = null;
            module.dependencyResolved++;
          }
          dependencyIndex++;

        }
        if (module.after.length === module.dependencyResolved) {
          loadedModules[module.id] = true;
          loadModule(module);
          modules[moduleIndex] = null;
          resolvedModules++;
        } else {
          moduleIndex++;
        }
      } else {
        moduleIndex++;
      }
    }
  };
  const error = function() {
    let text = "Modulum.js: Cyclic dependency detected.\n";
    let i = 0,
      j = 0;
    for (; i < modules.length; i++) {
      if (modules[i]) {
        text += modules[i].id + " depends on [" + modules[i].after.join(", ") + "]\n";
        j++;
        if (j > 10) {
          text += "[...]";
          break;
        }
      }
    }
    window.critical.display(text);
  };
  const checkLoadedDependencies = function(module) {
    let result = true;
    const deps = module.after;
    let i = 0;
    const len = deps.length;
    for (; i < len; i++) {
      if (deps[i] && !loadedModules[deps[i]]) {
        result = false;
        break;
      } else {
        deps[i] = null;
        module.dependencyResolved++;
      }
    }
    return result;
  };

  /**
   * @typedef {Function} ModulumExec
   * @param {gbc} arg1
   * @param {classes} arg2
   */

  /**
   *
   * @param {string} module module name
   * @param {string[]|ModulumExec} dependencies module dependencies
   * @param {?ModulumExec=} exec module content
   */
  w.modulum = function(module, dependencies, exec) {
    if (!exec) {
      exec = dependencies;
      dependencies = null;
    }
    const mod = {
      id: module,
      after: dependencies,
      exec: exec,
      dependencyResolved: 0
    };
    if (!mod.after || checkLoadedDependencies(mod)) {
      loadedModules[mod.id] = true;
      loadModule(mod);
      modules.push(null);
      resolvedModules++;
    } else {
      modules.push(mod);
    }
  };

  /**
   *
   * @param {gbc} arg1 gbc context
   * @param {classes} arg2 classes context
   */
  w.modulum.inject = function(arg1, arg2) {
    injection = [arg1, arg2];
  };
  w.modulum.assemble = function() {
    let loaded = resolvedModules;
    while (loaded < modules.length) {
      resolve();
      if (loaded === resolvedModules) {
        error();
        throw new Error("cyclic dependencies");
      }
      loaded = resolvedModules;
    }
  };
})(window);
;
//
// Regular Expression for URL validation
//
// Author: Diego Perini
// Updated: 2010/12/05
// License: MIT
//
// Copyright (c) 2010-2013 Diego Perini (http://www.iport.it)
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
// the regular expression composed & commented
// could be easily tweaked for RFC compliance,
// it was expressly modified to fit & satisfy
// these test for an URL shortener:
//
//   http://mathiasbynens.be/demo/url-regex
//
// Notes on possible differences from a standard/generic validation:
//
// - utf-8 char class take in consideration the full Unicode range
// - TLDs have been made mandatory so single names like "localhost" fails
// - protocols have been restricted to ftp, http and https only as requested
//
// Changes:
//
// - IP address dotted notation validation, range: 1.0.0.0 - 223.255.255.255
//   first and last IP address of each class is considered invalid
//   (since they are broadcast/network addresses)
//
// - Added exclusion of private, reserved and/or local networks ranges
//
// Compressed one-line versions:
//
// Javascript version
//
// /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i
//
// PHP version
//
// _^(?:(?:https?|ftp)://)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x{00a1}-\x{ffff}0-9]-*)*[a-z\x{00a1}-\x{ffff}0-9]+)(?:\.(?:[a-z\x{00a1}-\x{ffff}0-9]-*)*[a-z\x{00a1}-\x{ffff}0-9]+)*(?:\.(?:[a-z\x{00a1}-\x{ffff}]{2,})))(?::\d{2,5})?(?:/\S*)?$_iuS
//
"use strict";

// Fourjs : few modifications about group matching and host restrictions loose

/// matches :
/// 1 - protocol
/// 2 - username
/// 3 - password
/// 4 - host
/// 5 - port
/// 6 - path
/// 7 - query string
/// 8 - hash

//window.re_weburl = new RegExp(
window.RegExpUrl = new RegExp(
  "^" +
  // leading spaces
  "\\s*" +
  // protocol identifier
  "(?:(https?|ftp|app|file)://)" +
  // user:pass authentication
  "(?:(\\S+)(?::(\\S*))?@)?" +

  "([^:/]+)" +

  //  "(" +

  // Fourjs : we don't filter ip

  // IP address exclusion
  // private & local networks
  ///"(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
  ///"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
  ///"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +

  // IP address dotted notation octets
  // excludes loopback network 0.0.0.0
  // excludes reserved space >= 224.0.0.0
  // excludes network & broacast addresses
  // (first & last IP address of each class)
  //  "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
  //  "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
  //  "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
  //  "|" +
  // host name
  //  "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
  // domain name
  //  "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +

  // Fourjs : we authorize localhost and one token host names
  // TLD identifier
  //  "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))*" +

  //  ")" +
  // port number
  "(?::(\\d{2,5}))?" +
  // resource path
  "(/[^\\?\\#]*)?" +

  // query string
  "(?:\\?([^\\#]+)?)?" +
  // hash
  "(?:\\#(\\S*))?" +

  // trailing spaces
  "\\s*" +
  "$", "i"
);
;

"use strict";

(function(context) {
  const _internal = {
    debug: false,
    styleSheetNamePrefix: "dyncss__",
    _buffered: false,

    createDOM: function(id, contents) {
      if (contents) {
        const cssContent = "<!--\n" + contents + "\n-->",
          styleSheetName = this.styleSheetNamePrefix + id;

        const sheet = document.createElement("style");
        sheet.addClass(styleSheetName);
        this.setCssContents(sheet, cssContent);
        return sheet;
      }
      return null;
    },
    appendDOM: function(sheet) {
      document.head.appendChild(sheet);
    },
    setCssContents: function(styleSheet, cssContent) {
      if (styleSheet) {
        if (styleSheet.styleSheet) {
          styleSheet.styleSheet.cssText = cssContent;
        } else {
          styleSheet.appendChild(document.createTextNode(cssContent));
        }
      }
    },
    contentFromRules: function(styles, builder) {
      if (styles) {
        const localStyles = JSON.parse(styles);
        if (localStyles) {
          const _builder = builder || [];
          const keys = Object.keys(localStyles);
          for (let ruleIndex = 0; ruleIndex < keys.length; ruleIndex++) {
            const rule = keys[ruleIndex],
              ruleStyles = localStyles[rule];
            const items = Object.keys(ruleStyles);
            if (items.length) {
              let added = 0;
              _builder.push(rule, "{");
              for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (ruleStyles[item] || ruleStyles[item] === 0 || ruleStyles[item] === false || ruleStyles[item] === "") {
                  added++;
                  _builder.push(item, ":", ruleStyles[item], ";");
                }
              }
              if (added) {
                _builder.push("}");
              } else {
                _builder.length = _builder.length - 2;
              }
            }
          }
          if (!builder && _builder.length) {
            return _builder.join(this.debug ? "\n" : "");
          }
        }
      }
      return null;
    },
    contentFromRuleSet: function(ruleSet) {
      const builder = [];
      if (ruleSet) {
        ruleSet.forEach(function(rule) {
          this.contentFromRules(rule, builder);
        }, this);
      }
      return builder.length ? builder.join(this.debug ? "\n" : "") : null;
    }
  };

  const DynStyleSheet = context.augmentedFace.Class({
    __name: "styler",
    /**
     * @type Map
     */
    _sections: null,
    _id: null,
    _isStandalone: false,

    /**
     * @type HTMLElement
     */
    _dom: null,
    _oldRaw: null,
    _rawContent: null,
    _dirty: false,
    _toDestroy: false,

    constructor: function(id) {
      this._sections = new Map();
      this._id = id;
      this._isStandalone = Boolean(id);
    },
    destroy: function() {
      if (this._sections) {
        this._sections.clear();
        this._sections = null;
      }
      this._id = null;
      if (this._dom) {
        this._dom.remove();
      }
      this._dom = null;
      this._oldRaw = null;
      this._rawContent = null;
    },
    render: function() {
      if (this._dirty) {
        const old = this._dom;
        this._oldRaw = this._rawContent;
        this._rawContent = this._getContents();
        if (this._oldRaw !== this._rawContent) {
          this._dom = _internal.createDOM(this._id || "default", this._rawContent);

          if (old) {
            old.remove();
          }
          if (this._dom) {
            _internal.appendDOM(this._dom);
          }
        }
        this._dirty = false;
      }
    },
    _getContents: function() {
      return _internal.contentFromRuleSet(this._sections);
    },

    clear: function() {
      if (this._sections) {
        this._sections.clear();
      } else {
        this._sections = new Map();
      }
      this._dirty = true;
    },

    setContents: function(id, rules) {
      const current = this._sections.get(id),
        newrules = JSON.stringify(rules);
      if (current !== newrules) {
        if (newrules === "{}") {
          this._sections.delete(id);
          if (this._sections.size === 0) { // empty style object. flag it to destroy it later during flush
            this._toDestroy = true;
          }
        } else {
          this._sections.set(id, newrules);
          this._toDestroy = false;
        }
        this._dirty = true;
      }
    }
  });

  /**
   * styler
   * ===============
   *
   * provides methods to work with styles
   * @namespace styler
   */
  context.styler = /** @lends styler */ {
    /**
     * @type Map
     */
    _cachedStyles: new Map(),

    appendStyleSheet: function(styles, id, standalone, sheetId) {
      const lid = sheetId || sheetId === 0 ? sheetId : id;
      const cacheKey = standalone ? lid : "__default";
      let cached = this._cachedStyles.get(cacheKey);
      if (!cached) {
        cached = new DynStyleSheet(standalone ? lid : null);
        this._cachedStyles.set(cacheKey, cached);
      }
      cached.setContents(id, styles);
      if (!_internal._buffered) {
        cached.render();
      }
    },

    isBuffering: function() {
      return Boolean(_internal._buffered);
    },

    bufferize: function() {
      _internal._buffered = true;
    },
    flush: function() {
      this._cachedStyles.forEach(function(style, key) {
        if (style) {
          if (style._toDestroy) {
            this._destroyStyleSheet(style, key);
          } else {
            style.render();
          }
        }
      }, this);
      _internal._buffered = false;
    },
    removeStyleSheet: function(key) {
      const style = this._cachedStyles.get(key);
      if (style) {
        this._destroyStyleSheet(style, key);
      }
    },
    _destroyStyleSheet: function(stylesheet, key) {
      stylesheet._toDestroy = false;
      stylesheet.clear();
      stylesheet.render();
      stylesheet.destroy();
      stylesheet = null;
      this._cachedStyles.delete(key);
    }
  };
})(window);
;

"use strict";

(function(window) {
  const empty = [];
  const noop = function() {
    // TODO document why this function is empty

  };
  const defaultChildrenSelector = function(item) {
    return item && item.children || empty;
  };

  /**
   * @class
   * @param {Object} data data
   */
  let Throu = function(data) {
    this._data = data;
    this._childrenSelector = defaultChildrenSelector;
    this._passes = [];
    this._beforePass = noop;
    this._afterPass = noop;
  };
  Throu.prototype = {
    setChildrenSelector: function(selector) {
      this._childrenSelector = selector;
    },
    unique: function(unique) {
      this._passes.push({
        pass: unique,
        unique: true
      });
    },
    pass: function(pass, childrenFirst, childrenSelector) {
      this._passes.push({
        pass: pass,
        childrenFirst: childrenFirst,
        childrenSelector: childrenSelector
      });
    },
    passIf: function(condition, pass, childrenFirst, childrenSelector) {
      this._passes.push({
        condition: condition,
        pass: pass,
        childrenFirst: childrenFirst,
        childrenSelector: childrenSelector
      });
    },
    beforePass: function(cb) {
      this._beforePass = cb;
    },
    afterPass: function(cb) {
      this._afterPass = cb;
    },
    run: function() {
      for (let p = 0; p < this._passes.length; p++) {
        const pass = this._passes[p];
        this._beforePass(p);
        if (!pass.condition || pass.condition()) {
          if (pass.unique) {
            pass.pass();
          } else {
            if (!pass.childrenFirst) {
              this._runPass(pass.pass, this._data, null, pass.childrenSelector);
            } else {
              this._runPassReverse(pass.pass, this._data, null, pass.childrenSelector);
            }
          }
        }
        this._afterPass(p);
      }
    },
    destroy: function() {
      this._data = null;
      this._passes.length = 0;
      this._childrenSelector = null;
    },
    _runPass: function(pass, item, parent, childrenSelector) {
      pass(item, parent);
      const children = (childrenSelector || this._childrenSelector)(item) || [];
      for (const element of children) {
        this._runPass(pass, element, item);
      }
    },
    _runPassReverse: function(pass, item, parent, childrenSelector) {
      const children = (childrenSelector || this._childrenSelector)(item) || [];
      for (const element of children) {
        this._runPassReverse(pass, element, item);
      }
      pass(item, parent);
    }
  };

  /**
   * @class
   * @param {Object} data data
   */
  let ThrouFlat = function(data) {
    this._data = data;
    this._childrenSelector = defaultChildrenSelector;
    this._flattened = [];
    this._passes = [];
    this._beforePass = noop;
    this._afterPass = noop;
    this._refreshFlattened();
  };
  ThrouFlat.prototype = {
    setChildrenSelector: function(selector) {
      this._childrenSelector = selector;
      this._refreshFlattened();
    },
    _runFlatten: function(parent, flat) {
      const children = this._childrenSelector(parent);
      for (const element of children) {
        flat.push({
          item: element,
          parent: parent
        });
        this._runFlatten(element, flat);
      }
    },
    _refreshFlattened: function() {
      this._flattened.length = 0;
      this._flattened.push({
        item: this._data,
        parent: null
      });
      this._runFlatten(this._data, this._flattened);
    },
    pass: function(pass, childrenFirst) {
      this._passes.push({
        pass: pass,
        childrenFirst: childrenFirst
      });
    },
    beforePass: function(cb) {
      this._beforePass = cb;
    },
    afterPass: function(cb) {
      this._afterPass = cb;
    },
    run: function() {
      for (let p = 0; p < this._passes.length; p++) {
        const pass = this._passes[p];
        this._beforePass(p);
        const l = this._flattened.length;
        for (let i = 0; i < l; i++) {
          const item = this._flattened[!pass.childrenFirst ? i : (l - i - 1)];
          pass.pass(item.item, item.parent);
        }
        this._afterPass(p);
      }
    },
    destroy: function() {
      this._data = null;
      this._flattened.length = 0;
      this._passes.length = 0;
      this._childrenSelector = null;
    }
  };

  window.Throu = Throu;
  window.ThrouFlat = ThrouFlat;
})(window);
;

"use strict";

/*
 see tools/doc/internaldoc/UR/implement.md for documentation
 bootstrapper for gbc environment
 will let embedding platforms do their job
 */

(function(context) {
  let runReady = function(data) {
    if (context.gbcWrapper._readyData.isLogReplay) {
      let procId = (context.gbcWrapper.protocolVersion && context.gbcWrapper.protocolVersion >= 2) ?
        context.gbc.classes.AuiProtocolReader.translate(data.meta)[0].attributes.procId : "0";
      var app = context.gbc.LogPlayerService.getApplication(0, null, procId);
      let receiveHook = context.gbcWrapper.on(context.gbcWrapper.events.RECEIVE, function(event, src, data) {
        let whenManaged = function() {
          if (app.ending || app.ended) {
            context.gbcWrapper.logProcessed(context.gbcWrapper.param(null, app));
          } else {
            app.layout.afterLayout(function() {
              context.gbcWrapper.logProcessed(context.gbcWrapper.param(null, app));
            }, true);
          }
        };
        if (app && !app.ending && !app.ended) {
          if (context.gbcWrapper.protocolVersion && context.gbcWrapper.protocolVersion >= 2) {
            if (data.procId === app.info().procId) {
              gbc.LogService.networkProtocol.log(`⇓ LOG-RCV order`, data.content);
              app.dvm.manageAuiOrders(data.content, whenManaged);
            }
          } else {
            app.dvm.manageAuiOrders(data, whenManaged);
          }
        }
      });
      app.getSession().onApplicationRemoved((event, src, application) => {
        if (application === app && receiveHook) {
          receiveHook();
        }
      }, true);
      context.gbcWrapper.URReady(context.gbcWrapper.param({
        UCName: "GBC",
        UCVersion: gbc.version,
        mobileUI: gbc.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0,
        media: gbc.ThemeService.getMediaString()
      }, {
        procId: procId
      }));
    } else {
      context.gbc.SessionService.startDirect(context.gbcWrapper, data);
    }
  };

  var readyCallbacks = [],
    /**
     *
     * @param event
     * @param src
     * @param data
     */
    doReadyCallbacks = function(event, src, data) {
      if (!context.gbcWrapper.ready) {
        if (!context.gbcWrapper._readyData) {
          context.gbcWrapper._readyData = data;
        }
        context.gbcWrapper.ready = true;
        var i = 0,
          len = readyCallbacks.length;
        for (; i < len; i++) {
          readyCallbacks[i]();
        }
        readyCallbacks = [];
      } else {
        runReady(data);
      }
    };
  /**
   * @namespace window.gbcWrapper
   */
  context.gbcWrapper = {
    events: {
      /**
       * Event ready
       * Fired once when platform declares its low level bindings are ready
       */
      READY: "ready",
      /**
       * Event close
       * Fired when platform's close button is clicked
       */
      CLOSE: "close",
      /**
       * Event end
       * Fired when an application ends
       */
      END: "end",
      /**
       * Event receive
       * Fired when data are received
       */
      RECEIVE: "receive",
      /**
       * Event nativeAction
       * Fired when native sends an action to be managed by UR (e.g. pushNotification, cordovaCallback
       */
      NATIVEACTION: "nativeAction",
      /**
       * Event destroyEvent
       * Fired when native sends a destroyEvent to be managed by UR
       */
      DESTROYEVENT: "destroyEvent",
      /**
       * Event debugNode
       * Fired when debugNode is selected in the debugger
       */
      DEBUGNODE: "debugNode",
      /**
       * Event query
       * Fired when native platforms needs to query the universal renderer
       * answer will be sent via queryResult
       */
      QUERY: "query",
      /**
       * Event servicesReady
       * Fired when all the services are initialized
       */
      SERVICESREADY: "servicesready"
    },
    /**
     * true when all platform bindings are ready to use
     */
    ready: false,

    /**
     * @typedef {Object} ReadyData
     * @property {Object<string, *>} [headers]
     * @property {string} [meta]
     * @property {boolean} [debugMode]
     * @property {boolean} [isLogReplay]
     * @property {Number} [logLevel]
     * @property {string} nativeResourcePrefix
     * @property {Object<string, string|Array<string>>} [forcedURfrontcalls]
     */

    /**
     * application start data
     * @type {?ReadyData}
     */
    _readyData: null,

    /**
     * @typedef {Object<string, string|Array<string>>} ForcedURFrontCalls
     */

    /**
     * list of frontcalls per module forced to be called at browser side
     * @type {Object<string, string|Array<string>>}
     */
    _forcedURfrontcalls: {
      "webcomponent": "*",
      "wci": ["childcount", "childinstances"],
      "qa": ["startqa", "removestoredsettings", "getattribute"]
    },

    /**
     * platform type
     * can be "browser" or "native"
     */
    platformType: context.gbcWrapperInfo.platformType || "browser",
    /**
     * platform name
     * can be "browser", "GDC", "GMA", "GMI"
     */
    platformName: context.gbcWrapperInfo.platformName || "browser",
    /**
     * protocol type
     * can be "ua" or "direct"
     */
    protocolType: context.gbcWrapperInfo.protocolType || "ua",
    /**
     * protocol version
     */
    protocolVersion: context.gbcWrapperInfo.protocolVersion,

    /**
     * inform the platform that Universal Renderer is fully initialized and wait for data
     * param {Object<string, *>} options additional information for the protocol
     */
    URReady: function(attr) {},

    /**
     * send data through the platform
     * @param {string} data stringified aui order
     * @param {Object<string, *>} options additional information for the protocol
     *   e.g. in no user activity actions, options will be set to {userActivity: "no"}
     */
    send: function(data, options) {},

    /**
     * inform the platform about a childstart
     */
    childStart: function() {},

    /**
     * send interrupt signal through the platform
     */
    interrupt: function() {},

    /**
     * send close signal through the platform
     */
    close: function() {},

    /**.
     * @callback frontcallCallback
     * @param {{status:number, result:string, errorMessage:string}} result
     */

    /**
     * call the platform's frontcall
     * @param {number} nodeId
     * @param {frontcallCallback} callback
     */
    frontcall: function(nodeId, callback) {},

    /**
     * Send answer of query event to native platform
     * @param {*} data the an object depending on the query
     */
    queryResult: function(data) {},

    /**
     * Show the native aui debugger
     * @param {Number} data the node id or -1
     */
    showDebugger: function(data) {},

    /**
     * Call a named native function
     * @param {{name:string, args:Array}} data native call info
     *
     * Possible call data are:
     *
     * > `{name:"windowTitle",args: [<document.title>]}`
     * > will update the document title to the native
     *
     * > `{name:"error",args: [<error message>]}`
     * > will send error messages to the native
     *
     * > `{name:"noBackAction"}`
     * > will inform the native there is no back resolved action (after a 'nativeAction' 'back')
     *
     */
    nativeCall: function(data) {},

    /**
     * Inform the native platform that a log was processed
     * Fired in UR log player mode when a log order is fully processed
     */
    logProcessed: function() {},

    /**
     * fires event in gbcWrapper
     * @param {string} eventType the event type
     * @param {*} [data] any data to fire with
     * DO NOT IMPLEMENT
     */
    emit: function(eventType, data) {},

    /**
     * gbcWrapper initializer
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __init: function() {
      console.log(
        "GBC", context.gbc.version + "-" + context.gbc.build,
        "- Platform:", context.gbcWrapper.platformName,
        "- Protocol:", context.gbcWrapper.protocolType,
        "- Protocol Version:", context.gbcWrapper.protocolVersion);
      context.gbcWrapper.on = function(eventType, eventHandler) {
        if (eventType === context.gbcWrapper.events.READY) {
          if (eventHandler instanceof Function) {
            if (this.ready) {
              eventHandler();
            } else {
              if (this._eventListener) {
                this._eventListener.when(eventType, eventHandler, true);
              } else {
                readyCallbacks.push(eventHandler);
              }
            }
            return;
          } else {
            throw new Error("gbcWrapper: onReady callback is not a function");
          }
        }
        if (this._eventListener) {
          return this._eventListener.when(eventType, eventHandler);
        }
      };
      if (context.gbcWrapper.protocolType === "direct") {
        context.__gbcDefer = function(start) {
          start();
        };
      }
    },

    /**
     * gbcWrapper prepare wrapper before real start
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __prepare: function() {
      var listener = context.gbcWrapper._eventListener =
        new context.gbc.classes.EventListener();
      context.gbcWrapper.emit = function(eventType, data) {
        this._eventListener.emit(eventType, data);
      };
      listener.when(context.gbcWrapper.events.READY, doReadyCallbacks);
      if (context.gbcWrapper.isBrowser()) {
        this.emit(context.gbcWrapper.events.READY);
      }
    },
    /**
     * gbcWrapper ending wrapper initialization after GBC ready
     * GBC internal
     * DO NOT IMPLEMENT
     * @private
     */
    __gbcReady: function() {
      if (context.gbcWrapper.protocolType === "direct") {
        context.gbcWrapper.on(context.gbcWrapper.events.QUERY, function(event, src, data) {
          context.gbc.NativeService.onQuery(data);
        });
        context.gbcWrapper.on(context.gbcWrapper.events.NATIVEACTION, function(event, src, data) {
          context.gbc.NativeService.onNativeAction(data);
        });
        context.gbcWrapper.on(context.gbcWrapper.events.DESTROYEVENT, function(event, src, data) {
          context.gbc.NativeService.onDestroyEvent(data);
        });
        context.gbcWrapper.on(context.gbcWrapper.events.CLOSE, function() {
          context.gbc.NativeService.onNativeAction({
            name: "close"
          });
        });
        context.gbcWrapper.on(context.gbcWrapper.events.END, function(event, src, data) {
          context.gbc.NativeService.onNativeEnd(data);
        });

        context.gbcWrapper.on(context.gbcWrapper.events.READY, function() {
          if (context.gbcWrapper._readyData.nativeResourcePrefix) {
            context.gbcWrapper.nativeResourcePrefix =
              context.gbcWrapper._readyData.nativeResourcePrefix.replace(/\/$/, "") + "/__dvm__/";
          } else {
            throw new Error("gbcWrapper: onReady data did not contain a valid 'nativeResourcePrefix'");
          }
          if (context.gbcWrapper._readyData.debugMode) {
            context.gbc.DebugService.activate();
          }
          if (context.gbcWrapper._readyData.language) {
            context.gbc.I18NService.setLng(context.gbcWrapper._readyData.language);
          }
          /**
           ~~ Notes about log level ~~
           "none"  is LogLevel 0 : only sent when GDC is launched without debug mode
           "error" is LogLevel 1 : param LOWEST  in GDC
           "warn"  is LogLevel 2 : param LOW     in GDC
           "info", "log", is LogLevel 3 : param HIGH in GDC
           "debug" is LogLevel 4 : param HIGHEST in GDC
          */
          context.gbc.LogService.changeLevel(
            ["none", "error", "warn", "log", "debug"][context.gbcWrapper._readyData.logLevel || 0] || "none"
          );
          if (context.gbcWrapper._readyData.forcedURfrontcalls) {
            context.gbcWrapper._forcedURfrontcalls = context.gbcWrapper._readyData.forcedURfrontcalls;
          }
          //
          runReady(context.gbcWrapper._readyData);
        });
      }
    },

    /**
     * returns if gbc runs whether in native mode or not
     * GBC internal
     * DO NOT IMPLEMENT
     * @return {boolean} true if gbc runs in native mode
     */
    isNative: function() {
      return this.platformType === "native";
    },

    /**
     * returns if gbc runs whether in browser mode or not
     * GBC internal
     * DO NOT IMPLEMENT
     * @return {boolean} true if gbc runs in browser mode
     */
    isBrowser: function() {
      return this.platformType === "browser";
    },

    /**
     * in native mode, will check if function call is forced to be done by UR
     * GBC internal
     * DO NOT IMPLEMENT
     * @param {string} moduleName the function call module
     * @param {string} functionName the function call name
     * @return {boolean} whtether or not function call is forced to by done by UR
     * @private
     */
    isFrontcallURForced: function(moduleName, functionName) {
      return Boolean(this._forcedURfrontcalls[moduleName]) &&
        ((this._forcedURfrontcalls[moduleName] === "*") ||
          (this._forcedURfrontcalls[moduleName].indexOf(functionName) >= 0));
    },

    /**
     * in GMA
     * @returns {boolean}
     */
    isGMA: function() {
      return this.platformName === "GMA";
    },

    param: function(data, application) {
      if (this.protocolVersion && this.protocolVersion >= 2) {
        if (data || (typeof data === "string") || (typeof data === "boolean") || (typeof data === "number")) {
          return {
            procId: application && application.procId || "",
            content: data
          };
        } else {
          return {
            procId: application && application.procId || ""
          };
        }
      } else {
        return data;
      }
    }
  };

})(window);
;

"use strict";

(function(context) {
  const debug = false;

  const data = context._multiWindowData = {};

  /* jshint -W106 */
  data.uid = context._gbc_uid = "window@" + String.random();
  data.directChildren = [];
  data.parentWindow = context.opener;

  if (debug) {
    context.console.log(`Initialized ${data.uid}`);
  }

  try {
    data.isRoot = !data.parentWindow || !data.parentWindow._multiWindowData;
  } catch (e) {
    data.isRoot = true;
  }
  if (data.isRoot) {
    data.rootWindow = context;
    data.treeChildren = [];
    data.treeCount = 1;
  }

  Object.defineProperty(context, "rootMultiWindow", {
    get: function() {
      return data.rootWindow;
    },
    enumerable: true,
    configurable: false
  });

  /**
   * register direct child
   * @param {window} win
   * @private
   */
  data._registerDirectChild = function(win) {
    data.directChildren.push(win);
    if (debug) {
      context.console.log(`${data.uid} added direct ${win._multiWindowData.uid}`);
    }
  };

  /**
   * register root child
   * @param {window} win
   * @private
   */
  data._registerRootChild = function(win) {
    data.treeChildren.push(win);
    data.treeCount++;
    win._multiWindowData.rootWindow = context;
    if (debug) {
      context.console.log(`${data.uid} added tree ${win._multiWindowData.uid}`);
    }
  };

  /**
   * register child window
   * @param {window} win
   * @param _notDirect
   */
  data.registerChildWindow = function(win, _notDirect) {
    if (!_notDirect) {
      data._registerDirectChild(win);
    }
    if (data.isRoot) {
      data._registerRootChild(win);
    } else {
      data.parentWindow._multiWindowData.registerChildWindow(win, true);
    }
  };

  /**
   *
   * @param {function} finder
   * @returns {Window|T}
   */
  data.findWindowBy = function(finder) {
    const root = data.rootWindow;
    return finder(root) ? root : root._multiWindowData.treeChildren.find(finder);
  };

  context.addEventListener("unload", () => {
    if (data.isRoot) {
      let newRootWindow = data.directChildren[0];
      if (newRootWindow) {
        let evt = new CustomEvent("multiWindowUnloadRoot", {
          detail: {
            context,
            data
          }
        });
        newRootWindow.dispatchEvent(evt);
      }
    } else {
      let parentWindow = data.parentWindow;
      if (parentWindow) {
        let evt = new CustomEvent("multiWindowUnload", {
          detail: {
            context,
            data
          }
        });
        parentWindow.dispatchEvent(evt);
      }
    }
  }, {
    once: true
  });

  context.addEventListener("multiWindowUnloadRoot", (evt) => {
    if (debug) {
      context.console.log(`getting root from ${evt.detail.data.uid}`);
    }
    for (let w of evt.detail.data.directChildren) {
      if (w !== context) {
        w._multiWindowData.parentWindow = context;
        data.directChildren.push(w);
        if (debug) {
          context.console.log(`${data.uid} re-attached direct ${w._multiWindowData.uid}`);
        }
      }
    }
    for (let w of evt.detail.data.treeChildren) {
      w._multiWindowData.rootWindow = context;
      if (debug) {
        context.console.log(`${data.uid} re-attached tree ${w._multiWindowData.uid}`);
      }
    }
    data.treeChildren = evt.detail.data.treeChildren.splice();
    data.treeChildren.remove(context);
    data.treeCount = evt.detail.data.treeCount - 1;
    if (debug) {
      context.console.log(`got root from ${evt.detail.data.uid}`);
    }
  });

  context.addEventListener("multiWindowUnload", evt => {
    for (let w of evt.detail.data.directChildren) {
      w._multiWindowData.parentWindow = context;
      data.directChildren.push(w);
      if (debug) {
        context.console.log(`${data.uid} re-attached direct ${w._multiWindowData.uid}`);
      }
    }
    data.directChildren.remove(evt.detail.context);
    if (debug) {
      context.console.log(`${data.uid} removed direct ${evt.detail.data.uid}`);
    }
    data.rootWindow._multiWindowData.treeChildren.remove(evt.detail.context);
    data.rootWindow._multiWindowData.treeCount--;
    evt.detail.data.rootWindow = null;
    if (debug) {
      data.rootWindow.console.log(`${data.rootWindow._multiWindowData.uid} removed tree ${evt.detail.data.uid}`);
    }
  });
  try {
    if (data.parentWindow && data.parentWindow._multiWindowData) {
      data.parentWindow._multiWindowData.registerChildWindow(context);
    }
  } catch (e) {}
})(window);
;

"use strict";

(function(contextWin) {
  // try to store js errors for forensics
  contextWin.__jsErrors = contextWin.__jsErrors || [];
  contextWin.__jsWarns = contextWin.__jsWarns || [];

  /**
   * @namespace classes
   * @alias classes
   */
  const classes = {};

  /**
   * Genero Browser Client main entry point service
   * @namespace gbc
   * @gbcService
   */
  const gbc = contextWin.augmentedFace.Singleton( /** @lends gbc.prototype */ {
    __name: "gbc",
    oo: contextWin.augmentedFace,
    uid: String.random(),
    version: "5.00.02" || "none",
    build: "202405151710" || "none",
    tag: "5.00.01" || "dev-snapshot",
    dirtyFlag: "-d202405172328" || "",
    lastCompDate: "202405172328" || "",
    prodMode: "cdev",
    copyrightYear: "2024",
    systemAppId: -1,
    queryStringTheme: null,
    qaMode: false,
    unitTestMode: false,
    canShowExitWarning: true,
    androidEmulationDebug: contextWin.androidEmulationDebug,
    browserMultiPage: false,
    bootstrapInfo: contextWin.__gbcBootstrap || {},
    dayjs: contextWin.dayjs,
    // jshint ignore:start
    dayjs_plugin_customParseFormat: contextWin.dayjs_plugin_customParseFormat,
    dayjs_plugin_localeData: contextWin.dayjs_plugin_localeData,
    // jshint ignore:end
    styler: contextWin.styler,
    StateMachine: contextWin.StateMachine,
    classes: classes,
    constants: {
      theme: {}
    },
    errorCount: 0,
    jsErrorCount: 0,
    systemModalOpened: false, // true if a modal system (about, settings, etc...) is currently opened

    /**
     * prepare GBC system environment
     * @memberOf gbc
     */
    preStart: function() {
      document.body.toggleClass("is-mobile-device", contextWin.isMobile());
      document.body.toggleClass("is-not-mobile-device", !contextWin.isMobile());
      document.body.toggleClass("is-touch-device", contextWin.isTouchDevice());
      document.body.toggleClass("is-not-touch-device", !contextWin.isTouchDevice());
      document.body.toggleClass("is-firefox", contextWin.browserInfo.isFirefox);
      document.body.toggleClass("is-edge", contextWin.browserInfo.isEdge);
      document.body.toggleClass("is-ie", contextWin.browserInfo.isIE);
      document.body.toggleClass("is-chrome", contextWin.browserInfo.isChrome);
      document.body.toggleClass("is-opera", contextWin.browserInfo.isOpera);
      document.body.toggleClass("is-safari", contextWin.browserInfo.isSafari);
      document.body.toggleClass("is-ios", contextWin.browserInfo.isIOS);
      document.body.toggleClass("is-android", contextWin.browserInfo.isAndroid);
      if (contextWin.gbc.bootstrapInfo.serverVersion) {
        contextWin.gbc.bootstrapInfo.serverVersion = contextWin.gbc.bootstrapInfo.serverVersion.replace(" - Build ", "-");
      }
      contextWin.gbc.bootstrapInfo.subAppInfo = parseInt(contextWin.gbc.bootstrapInfo.subAppInfo, 10) || 0;
      // Event activation changed
      contextWin.gbc.DebugService.whenActivationChanged(function(event, src, active) {
        contextWin.gbc.LogService.enableProviders(active);
      });
      contextWin.gbc.LogService.registerLogProvider(
        new classes.KeyboardPrefixedConsoleLogProvider("[KEYBOARD ]", "background: #AA6; color: #FFF"), "keyboard", "Keyboard");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.MousePrefixedConsoleLogProvider("[MOUSE    ]", "background: #A66; color: #FFF"), "mouse", "Mouse");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.UiPrefixedConsoleLogProvider("[UI       ]", "background: #015d51; color: #FFF"), "ui", "UI");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[SCHEDULER]", "background: #6A6; color: #FFF"), "scheduler", "Scheduler");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[CLIPBOARD]", "background: #8c0099; color: #FFF"), "clipboard", "Clipboard");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[FOCUS    ]", "background: #A6A; color: #FFF"), "focus", "Focus");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[gICAPI   ]", "background: #6AA; color: #FFF"), "gICAPI", "gICAPI");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.NetworkPrefixedConsoleLogProvider("[NETWORK  ]", "background: #66A; color: #FFF"), "networkProtocol",
        "Network");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[ServiceWorker]", "background: #66aa86; color: #FFF"), "sw", "ServiceWorker");
      contextWin.gbc.LogService.registerLogProvider(
        new classes.PrefixedConsoleLogProvider("[INPUT]", "background: #8A6; color: #FFF"), "input", "Input");
      contextWin.gbc.LogService.registerLogProvider(new classes.BufferedConsoleLogProvider(), null, "Default");

      // need to enable or disable debug mode explicitly
      // because DebugService can be also be activated by GAS parameters
      if (window.isURLParameterEnabled(contextWin.location.search, "debugmode")) {
        contextWin.gbc.DebugService.activate();
      } else if (window.isURLParameterDisabled(contextWin.location.search, "debugmode")) {
        contextWin.gbc.DebugService.disable();
      }

      contextWin.gbc.bootstrapInfo.gbcPath = "resources";

      // querystrings
      // activate QA info
      if (window.isURLParameterEnabled(contextWin.location.search, "qainfo")) {
        contextWin.gbc.qaMode = true;
      }
      // activate contextmenu
      if (window.isURLParameterEnabled(contextWin.location.search, "contextmenu")) {
        gbc.ThemeService.setValue("theme-disable-context-menu", false);
      }
      // activate mobileUI
      if (window.isURLParameterEnabled(contextWin.location.search, "mobileui")) {
        gbc.ThemeService.setValue("aui-mobileUI-default", true);
      }
      // activate browserMultiPage
      if (window.isURLParameterEnabled(contextWin.location.search, "browsermultipage")) {
        gbc.browserMultiPage = true;
      } else if (window.isURLParameterDisabled(contextWin.location.search, "browsermultipage")) {
        gbc.browserMultiPage = false;
      }

      // inhibit default browser behaviors
      document.body.addEventListener('keydown', function(event) {
        const contentEditable = Boolean(event.target.getAttribute("contenteditable")) &&
          event.target.getAttribute("contenteditable") !== "false";
        const isInputable = event.target.tagName === "TEXTAREA" || event.target.tagName === "INPUT" ||
          (event.target.tagName === "DIV" && contentEditable);

        if (event.ctrlKey) {
          if (event.which === 80 /* p */ || event.which === 83 /* s */ ) {
            event.preventCancelableDefault();
          }
          if (event.which === 65 /* a */ && !isInputable) {
            event.preventCancelableDefault();
          }
        }

        if (event.which === 8 /* backspace */ && (!isInputable || event.target.readOnly)) {
          event.preventCancelableDefault(); // inhibit previous page on backspace
        }

        // fallback to manage accelerators is focused unfortunately ended on body
        gbc.InitService.onKeyFallback(event);
      });

      if (contextWin.gbc.qaMode) {
        contextWin.gbc.classes.DebugHelper.activateDebugHelpers();
      }

      /**
       * Disable default IE behavior when pressing F1 key (which launches page toward microsoft website)
       * ref: https://agile.strasbourg.4js.com/jira/browse/ENGGCS-3879
       */
      if ('onhelp' in window) {
        // To avoid IE to display the help popup dialog on F1, we override associated 'onhelp' event
        window.onhelp = function() {
          return false;
        };
      }

      //DayJS config
      // jshint ignore:start
      contextWin.dayjs.extend(contextWin.dayjs_plugin_localeData);
      contextWin.dayjs.extend(contextWin.dayjs_plugin_customParseFormat);
      // jshint ignore:end

    },

    /**
     * start the GBC system (home page or application if bootstrapped)
     */
    start: function() {
      if (contextWin.gbc.__gbcStarted) {
        return;
      }

      if (window.isURLParameterEnabled("serviceworker")) {
        gbc.LogService.sw.log("Service Worker enabled");
        if (!('serviceWorker' in navigator)) {
          gbc.LogService.sw.warn("Service Worker not available on your system > Fallback on xhr");
        } else {
          navigator.serviceWorker.register('/service-worker.js').then(
            (registration) => {
              // registered!
              gbc.SW = registration.installing ||
                registration.waiting ||
                registration.active;
            },
            err => {
              gbc.LogService.sw.error("SW registration failed!");
            }
          );
          //listen for the latest sw
          navigator.serviceWorker.addEventListener('controllerchange', async () => {
            gbc.SW = navigator.serviceWorker.controller;
          });
          //listen for messages from the service worker
          navigator.serviceWorker.addEventListener('message', this.onMessage);
        }
      }

      contextWin.gbc.__gbcStarted = true;
      gbc.HostService.preStart();
      document.body.addClass("flexible_host_stretch_row");
      if (gbc.DebugService.isMonitorWindow()) {
        return;
      }
      contextWin.gbc.HostService.start();
    },

    onMessage: function(message) {
      //got a message from the service worker
      const {
        data
      } = message;
      gbc.LogService.sw.log('[GBC:RCV]<--', data);
      const app = gbc.SessionService.getCurrent().getCurrentApplication();
      const orders = data.VMresponse.filter(order => order.type === "om");
      if (orders.length > 0) {
        app.dvm.manageAuiOrders(orders);
        app.protocolInterface.uaProtocol.transition();
      }
    },
    sendMessage: function(msg) {
      //send some structured-cloneable data from the webpage to the sw
      if (navigator.serviceWorker.controller) {
        gbc.LogService.sw.log('[GBC:SEND]-->', msg);
        navigator.serviceWorker.controller.postMessage(msg);
      } else {
        throw Error("Service Worker API not available");
      }

    },

    /**
     * GBC system entry point
     */
    run: function(callback) {
      if (!gbc.__initialized) {
        modulum.assemble();
        const queryStringTheme = contextWin.location.search.match(/^(?:.*[?&])?theme=([^&$]+)(?:&.*)?$/);
        gbc.queryStringTheme = queryStringTheme && queryStringTheme[1];

        // handle SSO queryString
        const queryStringSSO = contextWin.location.search.match(/^(?:.*[?&])?gnonce=([^&$]+)(?:&.*)?$/);
        if (queryStringSSO && history.pushState) {
          // create new URL by removing &gnonce=XXX
          const params = new URLSearchParams(contextWin.location.search); // jshint ignore:line
          params.toString();
          params.delete('gnonce');
          let newQueryStr = params.toString().length > 0 ? '?' : '';
          newQueryStr = newQueryStr + params.toString();
          const newurl = window.location.protocol + "//" + window.location.host + window.location.pathname + newQueryStr;
          window.history.pushState({
            path: newurl
          }, '', newurl); //or use replaceState to update the history stack
        }

        //initTheme use uninitialized services (StoredSettingsService, LocalSettingsService, ...)
        gbc.ThemeService.initTheme(gbc.queryStringTheme, function() {
          gbc.InitService.initServices();
          gbc.preStart();
          const start = function() {
            gbc.start();
          };
          if (Object.isFunction(contextWin.__gbcDefer)) {
            contextWin.__gbcDefer(start);
          } else {
            contextWin.requestAnimationFrame(start);
          }
          gbc.__initialized = true;
          if (callback instanceof Function) {
            callback();
          }
        });
      }
    },
    /**
     * display before ending warning if needed when quitting the web page
     * @return {string}
     */
    showExitWarning: function() {
      if (gbc.ThemeService.getValue("theme-disable-ending-popup") !== true &&
        !contextWin.__desactivateEndingPopup &&
        !window.isURLParameterEnabled(contextWin.location.search, "noquitpopup") &&
        !contextWin.gbc.DebugService.isActive() && gbc.SessionService.getCurrent() && gbc.SessionService
        .getCurrent().getCurrentApplication()) {
        return "The Genero application is still running.\n" +
          "If you leave now, some data may be lost.\n" +
          "Please use the application user interface to exit the application before navigating away from this page.";
      }
    },
    /**
     * emulated window.alert
     * @param {string} text
     * @param {string} header
     * @param {Function?} closeCallback
     * @ignore
     */
    alert: function(text, header, closeCallback) {
      let modal = contextWin.gbc.classes.WidgetFactory.createWidget('Modal', {
        appHash: gbc.systemAppId
      });
      modal._gbcSystemModal();
      modal.setHeader(header);

      let contents = document.createElement("div");
      contents.setAttribute("style", "white-space: pre;");
      contents.textContent = text;

      modal.setContent(contents);
      document.body.appendChild(modal.getElement());
      modal.onClose(function() {
        modal.destroy();
        modal = null;
        contents = null;
        if (closeCallback) {
          closeCallback();
        }
      }.bind(this));

      modal.show();
    }
  });

  const rawError = function() {
    const args = Array.prototype.join.call(arguments, " ");
    contextWin.__jsErrors.push(args);
    console.error(args);
  };

  const stackCallback = function(stackframes) {
    rawError("ERROR - Stacktrace");
    const stringifiedStack = "    at " + stackframes.map(function(sf) {
      return sf.toString();
    }).join('\n    at ');
    rawError(stringifiedStack);
  };

  const stackErrorCallback = function(err) {
    rawError(err);
  };

  /**
   * log and stacktrace errors of the GBC system
   * @param errorText
   * @param error
   * @param _fromNativeCall
   * @ignore
   */
  gbc.error = function(errorText, error, _fromNativeCall) {
    const text = Object.isString(errorText) && errorText || error && error.toString && error.toString(),
      err = error || (errorText && errorText.stack);
    rawError(text);
    if (!_fromNativeCall) {
      gbc.__wrapper.nativeCall(gbc.__wrapper.param({
        name: "error",
        args: [text]
      }));
    }
    if (contextWin.StackTrace && err && typeof(err) !== "string") {
      contextWin.StackTrace.fromError(err).then(stackCallback).catch(stackErrorCallback);
    }
  };

  /**
   * log and stacktrace warning of the GBC system
   * @ignore
   */
  gbc.warn = function() {
    const args = Array.prototype.join.call(arguments, " ");
    contextWin.__jsWarns.push(args);
    console.warn(args);
  };

  /**
   *
   * @param msg
   * @param file
   * @param line
   * @param col
   * @param error
   * @ignore
   */
  contextWin.onerror = function(msg, file, line, col, error) {
    gbc.error(msg, error);
    if (window.isURLParameterEnabled(contextWin.location.search, "debugmode")) {
      window.critical.display(msg);
    }
  };

  /**
   * js stacktrace emulation
   * @ignore
   */
  gbc.stack = function() {
    if (contextWin.StackTrace) {
      contextWin.StackTrace.generateArtificially().then(stackCallback).catch(stackErrorCallback);
    }
  };

  contextWin.addEventListener("unload", function() {
    let i = 0;
    const sessions = gbc.SessionService && gbc.SessionService.getSessions(),
      len = sessions && sessions.length;
    if (len) {
      for (; i < len; i++) {
        if (sessions[i]) {
          sessions[i].closeSession(true);
        }
      }
    }
    gbc.InitService.emit(gbc.constants.widgetEvents.onUnload);
    gbc.DebugService.destroy();
    gbc.InitService.destroy();
    document.body.innerHTML = "";
  });

  /**
   * @ignore
   * @return {*|string}
   */
  contextWin.onbeforeunload = function() {
    //emit hook
    gbc.InitService.emit(gbc.constants.widgetEvents.onBeforeUnload);
    gbc.LogService.ui.log("window onBeforeUnload called");

    if (gbc.canShowExitWarning) {
      // Deprecated since Chrome 51 : https://www.chromestatus.com/feature/5349061406228480
      return gbc.showExitWarning();
    }
  };

  /**
   * @ignore
   * @return {*|string}
   */
  contextWin.onblur = function() {
    //emit hook
    if (gbc.InitService && gbc.constants.widgetEvents) {
      gbc.InitService.emit(gbc.constants.widgetEvents.onBlur);
    }
  };

  contextWin.modulum.inject(gbc, gbc.classes);

  /**
   * testing purpose only
   * @param callback
   * @ignore
   * @private
   */
  gbc.__isIdleTest = function(callback) {
    try {
      const session = contextWin.gbc && contextWin.gbc.SessionService && contextWin.gbc.SessionService.getCurrent();
      const qaReady = gbc && gbc.QAService && gbc.QAService.isQAReady && gbc.QAService.isQAReady();
      callback({
        session: Boolean(session),
        idle: (!session || !session.getCurrentApplication() || session.isCurrentIdle()),
        qaReady: qaReady,
        jsErrors: window.__jsErrors,
        jsWarns: window.__jsWarns
      });
    } catch (e) {
      const result = {
        ___TEST_EXCEPTION: true
      };
      result.message = e.toString();
      result.stack = e.stack && e.stack.toString();
      callback(result);
    }
  };

  if (window.isURLParameterEnabled(contextWin.location.search, "unittestmode")) {
    gbc.unitTestMode = true;
  }
  gbc.__wrapper = contextWin.gbcWrapper;

  contextWin.gbc = gbc;

  contextWin.gbcWrapper.__init();
})(window);
;

"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.accessoryType = {
  checkmark: "checkmark",
  detailButton: "detailButton",
  disclosureIndicator: "disclosureIndicator"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.selectionMode = {
  none: "",
  set: "set",
  unset: "unset",
  exset: "exset"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.textJustify = {
  left: "left",
  center: "center",
  right: "right"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.fontSize = {
  xxSmall: "xx-small",
  xSmall: "x-small",
  small: "small",
  medium: "medium",
  large: "large",
  xLarge: "x-large",
  xxLarge: "xx-large"
};

/**
 * Action visibility
 * Hidden field is a bitfield on 3 bits:
 * | bit 0             | bit 1               | bit 2
 * | hidden by runtime | hidden by frontend  | hidden by media
 * @readonly
 * @enum {number};
 */
gbc.constants.visibility = {
  visible: 0,
  hiddenByProgram: 1,
  hiddenByUser: 2,
  hiddenByMedia: 4
};

/**
 * Font pitch
 * @readonly
 * @enum {string};
 */
gbc.constants.fontPitch = {
  default: "default",
  fixed: "fixed",
  variable: "variable"
};

/**
 * Table column sort type
 * @readonly
 * @enum {string};
 */
gbc.constants.sortType = {
  none: "",
  ascending: "asc",
  descending: "desc"
};

/**
 * VM runtime status
 * @readonly
 * @enum {string};
 */
gbc.constants.runtimeStatus = {
  interactive: "interactive",
  processing: "processing",
  childstart: "childstart"
};

/**
 * Widget spacing policy
 * @readonly
 * @enum {string};
 */
gbc.constants.spacing = {
  compact: "compact",
  normal: "normal"
};

/**
 * Stretching orientation
 * @readonly
 * @enum {string};
 */
gbc.constants.stretch = {
  none: "none",
  x: "x",
  y: "y",
  both: "both"
};

/**
 * Scrollbars to display
 * @readonly
 * @enum {string};
 */
gbc.constants.scrollBars = {
  none: "none",
  vertical: "vertical",
  horizontal: "horizontal",
  both: "both"
};

/**
 * Widget size policy
 * @readonly
 * @enum {string};
 */
gbc.constants.sizePolicy = {
  initial: "initial",
  fixed: "fixed",
  dynamic: "dynamic"
};

/**
 * Action visibility policy
 * @readonly
 * @enum {string};
 */
gbc.constants.viewType = {
  showNever: "no",
  showAlways: "yes",
  showIfNoExplicitView: "auto"
};

/**
 * Form display mode
 * @readonly
 * @enum {string};
 */
gbc.constants.uiMode = {
  default: "default",
  traditional: "traditional"
};

/**
 * Dialog type
 * @readonly
 * @enum {string};
 */
gbc.constants.dialogType = {
  display: "Display",
  input: "Input",
  construct: "Construct",
  displayArray: "DisplayArray",
  inputArray: "InputArray"
};

/**
 * Text case shift
 * @readonly
 * @enum {string};
 */
gbc.constants.shift = {
  none: "none",
  up: "up",
  down: "down"
};

/**
 * Current drag and drop operation to do
 * @readonly
 * @enum {string};
 */
gbc.constants.dndOperation = {
  none: "none",
  copy: "copy",
  move: "move"
};

/**
 * Widget orientation
 * @readonly
 * @enum {string};
 */
gbc.constants.orientation = {
  vertical: "vertical",
  horizontal: "horizontal"
};

/**
 * Table's aggregate type
 * @readonly
 * @enum {string};
 */
gbc.constants.aggregateType = {
  sum: "sum",
  average: "avg",
  minimum: "min",
  maximum: "max",
  count: "count",
  program: "program"
};

/**
 * Current drag and drop visual feedback
 * @readonly
 * @enum {string};
 */
gbc.constants.dndFeedback = {
  insert: "insert",
  insertAfter: "insert_after",
  select: "select"
};

/**
 * Tab key field order
 * @readonly
 * @enum {number};
 */
gbc.constants.fieldOrder = {
  unconstrained: 0,
  constrained: 1,
  form: 2
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.precisionType = {
  year: "year",
  month: "month",
  day: "day",
  hour: "hour",
  minute: "minute",
  second: "second",
  fraction: "fraction"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.keyboardHint = {
  default: "default",
  number: "number",
  phone: "phone",
  email: "email"
};

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.windowType = {
  normal: "",
  left: "left",
  right: "right",
  navigator: "navigator",
  popup: "popup"
};

/**
 * @typedef = {number}; IntBoolean : 0,1
 */

/**
 * @typedef = {string}; Direction : 'nw'|'n'|'ne'|'e'|'se'|'s'|'sw'|'w'
 */

/**
 * @typedef = {string}; Color : 'black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'
 */
;

"use strict";

gbc.constants.debugInfo = {};
;

"use strict";

/**
 * @ignore
 */
gbc.constants.debugInfo.attributeCategory = {
  "acceleratorKey1": "General",
  "acceleratorKey3": "General",
  "acceleratorName": "General",
  "acceleratorName2": "General",
  "acceleratorName3": "General",
  "acceleratorName4": "General",
  "accessoryType": "General",
  "action": "General",
  "actionActive": "General",
  "actionIdRef": "General",
  "active": "General",
  "aggregateText": "General",
  "aggregateType": "General",
  "aggregateValue": "General",
  "anchor": "General",
  "autoNext": "General",
  "autoScale": "General",
  "blink": "TTY",
  "bold": "TTY",
  "border": "General",
  "bufferSize": "General",
  "build": "General",
  "buttonTextHidden": "General",
  "century": "General",
  "charLengthSemantics": "General",
  "className": "General",
  "clickedCanvasItemId": "General",
  "cloneColumns": "General",
  "cloneCount": "General",
  "colName": "General",
  "color": "TTY",
  "colorCondition": "TTY",
  "columnCount": "General",
  "comment": "General",
  "commentLine": "General",
  "commentLineHidden": "General",
  "componentType": "General",
  "compress": "General",
  "config": "General",
  "container": "General",
  "contextMenu": "General",
  "context": "General",
  "count": "General",
  "currentColumn": "General",
  "currentParentRow": "General",
  "currentRow": "General",
  "currentWindow": "General",
  "cursor": "General",
  "cursor2": "General",
  "dataType": "General",
  "dbCentury": "General",
  "dbDate": "General",
  "decimalSeparator": "General",
  "defaultValue": "General",
  "defaultView": "General",
  "delimiters": "General",
  "detailAction": "General",
  "dialogEventItem": "General",
  "dialogEventType": "General",
  "dialogType": "General",
  "diameter": "General",
  "dim": "TTY",
  "dirty": "General",
  "disabled": "General",
  "disclosureIndicator": "General",
  "dndAccepted": "General",
  "dndBuffer": "General",
  "dndCanCopy": "General",
  "dndCanMove": "General",
  "dndFeedback": "General",
  "dndIdRef": "General",
  "dndMimeTypes": "General",
  "dndOperation": "General",
  "dndRequiredMimeType": "General",
  "doubleClick": "General",
  "endX": "General",
  "endY": "General",
  "errorLine": "General",
  "exec": "General",
  "expanded": "General",
  "expandedColumn": "General",
  "extentDegrees": "General",
  "fieldId": "General",
  "fieldIdRef": "General",
  "fieldOrder": "General",
  "fieldSelection": "General",
  "fileName": "General",
  "fillColor": "General",
  "filter": "General",
  "flipped": "General",
  "focus": "General",
  "focusOnField": "General",
  "fontPitch": "General",
  "formLine": "General",
  "format": "General",
  "gridChildrenInParent": "Layout",
  "gridHeight": "Layout",
  "gridWidth": "Layout",
  "hasChildren": "General",
  "haveRowActions": "General",
  "height": "Layout",
  "helpNum": "General",
  "hidden": "Layout",
  "href": "General",
  "idColumn": "General",
  "idRef": "General",
  "image": "General",
  "imageCollapsed": "General",
  "imageColumn": "General",
  "imageExpanded": "General",
  "imageLeaf": "General",
  "include": "General",
  "initializer": "General",
  "inputWrap": "General",
  "isHotKey": "General",
  "isNodeColumn": "General",
  "isNull": "General",
  "isPassword": "TTY",
  "isSystem": "General",
  "isTimer": "General",
  "isTree": "General",
  "justify": "General",
  "keyboardHint": "General",
  "maxLength": "General",
  "media": "Responsive",
  "mediaAttribute": "Responsive",
  "menuLine": "General",
  "messageLine": "General",
  "minHeight": "Layout",
  "minWidth": "Layout",
  "moduleName": "General",
  "multiRowSelection": "General",
  "name": "General",
  "noEntry": "General",
  "noFilter": "General",
  "nodeIdRef": "General",
  "notEditable": "General",
  "notNull": "General",
  "noswipe": "Responsive",
  "numAlign": "General",
  "offset": "General",
  "orientation": "General",
  "pageSize": "General",
  "paramCount": "General",
  "parent": "General",
  "parentIdColumn": "General",
  "picture": "General",
  "placeholder": "General",
  "posX": "Layout",
  "posY": "Layout",
  "procId": "General",
  "procIdParent": "General",
  "procIdWaiting": "General",
  "program": "General",
  "promptLine": "General",
  "queryEditable": "General",
  "required": "General",
  "returnCount": "General",
  "reverse": "TTY",
  "row": "General",
  "rowBound": "General",
  "runtimeStatus": "General",
  "sample": "General",
  "screenRecord": "General",
  "scroll": "General",
  "scrollBars": "General",
  "selected": "General",
  "selection": "General",
  "shift": "General",
  "size": "General",
  "sizePolicy": "Layout",
  "sortColumn": "General",
  "sortType": "General",
  "spacing": "General",
  "split": "Responsive",
  "splitter": "General",
  "sqlDbName": "General",
  "sqlTabName": "General",
  "sqlType": "General",
  "startDegrees": "General",
  "startX": "General",
  "startY": "General",
  "step": "General",
  "stepX": "General",
  "stepY": "General",
  "stretch": "Layout",
  "stretchColumns": "Layout",
  "stretchMin": "Layout",
  "stretchMax": "Layout",
  "style": "General",
  "tabIndex": "General",
  "tabIndexRt": "General",
  "tabName": "General",
  "tag": "General",
  "targetType": "General",
  "text": "General",
  "thousandsSeparator": "General",
  "timeout": "General",
  "touched": "General",
  "ttyAttr": "General",
  "type": "General",
  "uiMode": "General",
  "underline": "TTY",
  "unhidable": "General",
  "unhidableColumns": "General",
  "unmovable": "General",
  "unmovableColumns": "General",
  "unsizable": "General",
  "unsizableColumns": "General",
  "unsortable": "General",
  "unsortableColumns": "General",
  "validate": "General",
  "value": "General",
  "valueChecked": "General",
  "valueMax": "General",
  "valueMin": "General",
  "valueUnchecked": "General",
  "varType": "General",
  "verify": "General",
  "version": "General",
  "visibleId": "General",
  "waiting": "General",
  "wantFixedPageSize": "General",
  "wantReturns": "General",
  "wantTabs": "General",
  "width": "Layout",
  "windowStyle": "General",
  "windowType": "General",
  "xyList": "General"
};
;

"use strict";
/**
 * @ignore
 */
gbc.constants.debugInfo.attributeInfo = {
  acceleratorKey1: {
    desc: "Accelerator Key related to mouse left button.",
    type: "string"
  },
  acceleratorKey3: {
    desc: "Accelerator Key related to mouse right button.",
    type: "string"
  },
  acceleratorName2: {
    desc: "The second accelerator key.",
    type: "string"
  },
  acceleratorName3: {
    desc: "The third accelerator key.",
    type: "string"
  },
  acceleratorName4: {
    desc: "The fourth accelerator key.",
    type: "string"
  },
  acceleratorName: {
    desc: "The accelerator key.",
    type: "string"
  },
  action: {
    desc: "The name of the action the Node is linked with",
    type: "string"
  },
  actionActive: {
    desc: "This action-view node is active, a Action can be invoked.",
    type: "number"
  },
  active: {
    desc: "This interactive node is active, a FormField can be edited, a Action can be invoked.",
    type: "IntBoolean"
  },
  aggregateText: {
    desc: "The aggregate caption. The default is 'Summary'.",
    type: "string"
  },
  aggregateType: {
    desc: "Displays an aggregate value.  final='1'",
    type: "AggregateType"
  },
  aggregateValue: {
    desc: "The aggregate value set by program.",
    type: "string"
  },
  anchor: {
    desc: "The direction of the CanvasText.",
    type: "Direction"
  },
  autoNext: {
    desc: "Leave the field automatically if the input buffer has been filled.",
    type: "IntBoolean"
  },
  autoScale: {
    desc: "",
    type: "IntBoolean"
  },
  blink: {
    desc: "The text of the field is blinking. Required for compatibility.",
    type: "IntBoolean"
  },
  bold: {
    desc: "The text of the field is bold.",
    type: "IntBoolean"
  },
  border: {
    desc: "The Window has a border-frame.",
    type: "IntBoolean"
  },
  bufferSize: {
    desc: "The number of rows needed by the front end to display the current array. Must be greater or equal as pageSize.",
    type: "number"
  },
  build: {
    desc: "DVM Only - The version and build of fglform used to compile the form.  volatile='1'",
    type: "string"
  },
  buttonTextHidden: {
    desc: "Defines if the text is displayed on toolBarItem.",
    type: "IntBoolean"
  },
  century: {
    desc: "The century attribute specifies how to expand abbreviated one- and two- digit year specifications in a DATE and DATETIME field.  Symbol Algorithm for Expanding Abbreviated Years.&lt;br/&gt;C or c Use the past, future, or current year closest to the current date.&lt;br/&gt;F or f Use the nearest year in the future to expand the entered value.&lt;br/&gt;P or p Use the nearest year in the past to expand the entered value.&lt;br/&gt;R or r Prefix the entered value with the first two digits of the current year.",
    type: "string"
  },
  className: {
    desc: "The class attribute as specified in the per file.",
    type: "string"
  },
  clickedCanvasItemId: {
    desc: "The id of the last clicked canvas item - for internal use only.  volatile='1' final='1'",
    type: "number"
  },
  cloneColumns: {
    desc: "Static elements cloned in matrix - number of columns",
    type: "number"
  },
  cloneCount: {
    desc: "Static elements cloned in matrix",
    type: "number"
  },
  colName: {
    desc: "The identifier to lookup this Node in the 4gl program.  The identifier to lookup this Edit in the 4gl program.  Convention Rule: all nodes having a colName attribute can be used within the 4gl program as replacement of the 'old' formfield.  Those statements are ScreenInteraction statements expecting the name of a formfield.  final='1'",
    type: "string"
  },
  color: {
    desc: "A color name, typical for text foreground.",
    type: "Color"
  },
  colorCondition: {
    desc: "DVM Only - an internal value corresponding to COLOR WHERE attribute.  volatile='1'",
    type: "string"
  },
  columnCount: {
    desc: "The number of columns of the current Matrix.",
    type: "number"
  },
  comment: {
    desc: "Item specific help-text.",
    type: "string"
  },
  commentLine: {
    desc: "DVM Only -",
    type: "number"
  },
  commentLineHidden: {
    desc: "DVM Only -",
    type: "number"
  },
  componentType: {
    desc: "",
    type: "string"
  },
  compress: {
    desc: "DVM Only - Remove fill characters after input has been done. Required for compatibility.",
    type: "IntBoolean"
  },
  config: {
    desc: "The config attribute as specified in the .per file.",
    type: "string"
  },
  container: {
    desc: "Defines the name of the parent MDI",
    type: "string"
  },
  contextMenu: {
    desc: "Indicates that the action must be displayed in the context menu.  no: never shown,  yes: always shown,  auto: is shown if there is no explicit view (toolbar, topmenu, button in form..)",
    type: "Trilean"
  },
  context: {
    desc: "dialog: an action on dialog level, subdialog: an action on subdialog level, row: an action with the attribute ROWBOUND, field: on action infield",
    type: "string"
  },
  count: {
    desc: "The count number of the Message.",
    type: "number"
  },
  currentColumn: {
    desc: "The id of the active column in a Table. The id of the first columns is 0.",
    type: "number"
  },
  currentParentRow: {
    desc: "Parent row of current row.",
    type: "number"
  },
  currentRow: {
    desc: "The index of the current row.",
    type: "number"
  },
  currentWindow: {
    desc: "The id of the active Window",
    type: "number"
  },
  cursor2: {
    desc: "The secondary position of the editor cursor, used for text selection.",
    type: "number"
  },
  cursor: {
    desc: "The current position of the editor cursor. The left most position is 0.",
    type: "number"
  },
  dataType: {
    desc: "Describes a data type in string format (ex:'DECIMAL(4.2)').",
    type: "string"
  },
  dbCentury: {
    desc: "The century to apply client specific date conversions.",
    type: "string"
  },
  dbDate: {
    desc: "The date format to apply client specific date conversions.",
    type: "string"
  },
  decimalSeparator: {
    desc: "Defines the decimal separator for numbers (used for numeric keypad).",
    type: "string"
  },
  defaultValue: {
    desc: "DVM Only - The initial value when making an INPUT.  The value the initialize the target-variable when making an INPUT WITHOUT DEFAULTS.  volatile='1'",
    type: "string"
  },
  defaultView: {
    desc: "Indicates in ringmenu/fkey/action button must be displayed.  no: never shown,  yes: always shown,  auto: button is shown if there is no explicit view (toolbar, topmenu..)",
    type: "Trilean"
  },
  delimiters: {
    desc: "DVM Only - The delimiter-characters as defined in the per-file.",
    type: "string"
  },
  dialogEventItem: {
    desc: "Holds the id of the form item linked to the event (screen-record).",
    type: "number"
  },
  dialogEventType: {
    desc: "Contains the name of the dialog trigger. BeforeField, AfterRow,...",
    type: "string"
  },
  dialogType: {
    desc: "The type name of the controlling dialog.",
    type: "DialogType"
  },
  diameter: {
    desc: "The diameter of the Canvas Item.",
    type: "number"
  },
  dim: {
    desc: "",
    type: "IntBoolean"
  },
  dirty: {
    desc: "DVM Only - The Edit has been used by subdialog.  volatile='1'",
    type: "IntBoolean"
  },
  disabled: {
    desc: "Indicates that the element does not allow any user interaction.",
    type: "IntBoolean"
  },
  dndAccepted: {
    desc: "This Drag can be dropped.",
    type: "IntBoolean"
  },
  dndBuffer: {
    desc: "",
    type: "string"
  },
  dndCanCopy: {
    desc: "",
    type: "IntBoolean"
  },
  dndCanMove: {
    desc: "",
    type: "IntBoolean"
  },
  dndFeedback: {
    desc: "",
    type: "DndFeedback"
  },
  dndIdRef: {
    desc: "",
    type: "number"
  },
  dndMimeTypes: {
    desc: "fgl:in, gdc:out",
    type: "string"
  },
  dndOperation: {
    desc: "",
    type: "DndOperation"
  },
  dndRequiredMimeType: {
    desc: "The required mime type. fgl:out, gdc:in",
    type: "string"
  },
  doubleClick: {
    desc: "Defines the action to be sent by client on a double-click",
    type: "string"
  },
  endX: {
    desc: "The X pos of the ending point of the Canvas Item.",
    type: "number"
  },
  endY: {
    desc: "The Y pos of the ending point of the Canvas Item.",
    type: "number"
  },
  errorLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  exec: {
    desc: "DVM Only - The command to be executed from the 4gl runtime. Specifies a parameter for a RUN command invoked from fglrun when selecting the command.  The invocation of the command is controlled by the fgl runtime.  volatile='1'",
    type: "string"
  },
  expanded: {
    desc: "Child rows visible?",
    type: "IntBoolean"
  },
  expandedColumn: {
    desc: "The name of the column holding the expanded state of a tree node  volatile='1' final='1'",
    type: "string"
  },
  extentDegrees: {
    desc: "The ending angle for the Canvas Arc.",
    type: "number"
  },
  fieldId: {
    desc: "DVM Only - The unique id of this Edit within the Form. The attribute will be used by fglrun to lookup the Edit.  The fieldId attribute is used to lookup a FormField qualified by a record-name.  final='1'",
    type: "number"
  },
  fieldIdRef: {
    desc: "DVM Only - The fieldId attribute of the FormField or Matrix this Link is referencing.",
    type: "number"
  },
  fieldOrder: {
    desc: "DVM Only - Controls the cursor tabbing in INPUT or CONSTRUCT statements.",
    type: "IntBoolean"
  },
  fieldSelection: {
    desc: "Indicates if the field must be selected, even if focus has not changed.",
    type: "number"
  },
  fileName: {
    desc: "DVM Only - This attribute is for debugging only: fileName is the absolute file name of the resource file.",
    type: "string"
  },
  fillColor: {
    desc: "The color used to fill the Canvas Item.",
    type: "string"
  },
  flipped: {
    desc: "Flips COLUMNS into ROWS.",
    type: "IntBoolean"
  },
  focus: {
    desc: "The id of the node having the focus.",
    type: "number"
  },
  fontPitch: {
    desc: "The character width of the font. Required for compatibility.",
    type: "FontPitch"
  },
  formLine: {
    desc: "The top-offset when displaying a FORM. Required for compatibility.",
    type: "number"
  },
  format: {
    desc: "A mask to format the output. Only used for NUMERIC and DATE values.",
    type: "string"
  },
  gridChildrenInParent: {
    desc: "The children items are aligned into the parent grid and not into the current container. This can be used to have an alignment between several Groups.",
    type: "IntBoolean"
  },
  gridHeight: {
    desc: "The height in grid-cells.",
    type: "number"
  },
  gridWidth: {
    desc: "The width in grid-cells.",
    type: "number"
  },
  hasChildren: {
    desc: "Is Node.",
    type: "IntBoolean"
  },
  height: {
    desc: "The visible height of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.",
    type: "string"
  },
  helpNum: {
    desc: "DVM Only - The HELP number value of a MENU-Command clause.",
    type: "number"
  },
  hidden: {
    desc: "Visibility (0=visible,1=hidden by program,2=hidden by user). Runtime handles hidden fields as inactive.",
    type: "number"
  },
  idColumn: {
    desc: "The name of the column holding the tree item id  volatile='1' final='1'",
    type: "string"
  },
  image: {
    desc: "Is the case sensitive name of the file of the icon which should be displayed.",
    type: "string"
  },
  imageCollapsed: {
    desc: "The default image for a collapsed node.  volatile='1' final='1'",
    type: "string"
  },
  imageColumn: {
    desc: "The name of the column holding the image attribute of this TableColumn  volatile='1' final='1'",
    type: "string"
  },
  imageExpanded: {
    desc: "The default image for a expanded node.  volatile='1' final='1'",
    type: "string"
  },
  imageLeaf: {
    desc: "The default image for a leaf.  volatile='1' final='1'",
    type: "string"
  },
  include: {
    desc: "A list of values or ranges.  Will be used to constrain special values when making an input.  &lt;danger&gt;The attribute should be replaced by an Element because of the sub-grammar.&lt;/danger&gt; The list separator is a &lt;code&gt;|&lt;/code&gt;. The separator for the start and end value is &lt;code&gt;:&lt;/code&gt;. The escape character is a backslash.",
    type: "string"
  },
  initializer: {
    desc: "DVM Only - The name of a 4gl function to initialize the item list of this combo box.  volatile='1' final='1'",
    type: "string"
  },
  inputWrap: {
    desc: "DVM Only - Leaving the last field of a INPUT will set the focus to the first field.  Secifies if an INPUT or CONSTRUCT will be termined when leaving the last field if will be continued on the first field (the input cursor wraps). GUI-client implementors can ignore this attribute - the tabbing is controlled by the vm yet.",
    type: "IntBoolean"
  },
  isHotKey: {
    desc: "DVM Only - This has been declared by a COMMAND KEY (key-name).",
    type: "number"
  },
  isNodeColumn: {
    desc: "The name of the column holding the isNode attribute a tree node  volatile='1' final='1'",
    type: "string"
  },
  isNull: {
    desc: "Indicates if the element is NULL.",
    type: "number"
  },
  isPassword: {
    desc: "This is a field with password input.",
    type: "IntBoolean"
  },
  isSystem: {
    desc: "Defines if the element is system or user (used by FunctionCall).",
    type: "IntBoolean"
  },
  isTree: {
    desc: "This table is decorated as tree.  volatile='1' final='1'",
    type: "IntBoolean"
  },
  justify: {
    desc: "Text justification form the element.",
    type: "TextJustify"
  },
  maxLength: {
    desc: "What's the maximum number if characters a user can enter (0 is unlimited).",
    type: "number"
  },
  menuLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  messageLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  minHeight: {
    desc: "minimum height for the form measured in characters.",
    type: "number"
  },
  minWidth: {
    desc: "minimum width for the form measured in characters.",
    type: "number"
  },
  moduleName: {
    desc: "Defines the name of a module.",
    type: "string"
  },
  multiRowSelection: {
    desc: "Table allows multirow selection.",
    type: "IntBoolean"
  },
  name: {
    desc: "The name of this Node. Convenience rule: all Node-objects should have a name attribute with a unique value in the list of siblings. This simplifies the identification of the Node.",
    type: "string"
  },
  noEntry: {
    desc: "Do not enable INPUT from this field. If this flag is set the field will be ignored for making input.",
    type: "IntBoolean"
  },
  nodeIdRef: {
    desc: "The id of a node in the AUI tree.",
    type: "number"
  },
  notEditable: {
    desc: "Use the NOTEDITABLE attribute to deny text modification",
    type: "IntBoolean"
  },
  notNull: {
    desc: "On leave an INPUT the target-variable will be checked to be NOT NULL.",
    type: "IntBoolean"
  },
  numAlign: {
    desc: "Indicates if a field contains a numeric value, for text justification.",
    type: "IntBoolean"
  },
  offset: {
    desc: "The index of the first visible row.",
    type: "number"
  },
  orientation: {
    desc: "Defines the orientation of an element.",
    type: "Orientation"
  },
  pageSize: {
    desc: "The number of usable rows in the visible Array. Is lower than bufferSize.",
    type: "number"
  },
  paramCount: {
    desc: "Defines a number of parameters.",
    type: "number"
  },
  parent: {
    desc: "The id attribute of the parent Menu.",
    type: "number"
  },
  parentIdColumn: {
    desc: "The name of the column holding the tree item parent id  volatile='1' final='1'",
    type: "string"
  },
  picture: {
    desc: "A mask defining which character-classes are allowed on fix input positions. Only used for INPUT.",
    type: "string"
  },
  posX: {
    desc: "The X position of the Node in its container. The leftmost position is 0.",
    type: "number"
  },
  posY: {
    desc: "The Y position of the Node in its container. The topmost position is 0.",
    type: "number"
  },
  procId: {
    desc: "The process identifier of a program (hostname:pid).",
    type: "string"
  },
  procIdParent: {
    desc: "The process identifier of the parent program (hostname:pid).",
    type: "string"
  },
  procIdWaiting: {
    desc: "The process identifier of the waiting parent program (hostname:pid).",
    type: "string"
  },
  program: {
    desc: "The name of a program that will be called to edit TEXT or BYTE values.",
    type: "string"
  },
  promptLine: {
    desc: "Required for compatibility.",
    type: "number"
  },
  queryEditable: {
    desc: "Indicates if the field (combobox) is editable during CONSTRUCT.",
    type: "IntBoolean"
  },
  required: {
    desc: "The user must enter something but can also leave the field empty.",
    type: "IntBoolean"
  },
  returnCount: {
    desc: "Defines a number of returned values.",
    type: "number"
  },
  reverse: {
    desc: "Make reverse colors - if You can.",
    type: "IntBoolean"
  },
  row: {
    desc: "(Tree) Row",
    type: "number"
  },
  runtimeStatus: {
    desc: "Tell the client the status of the runtime, interactive: the runtime waits for a user interaction, processing: the runtime is busy,childstart: the runtime is starting a child application process.",
    type: "RuntimeStatus"
  },
  sample: {
    desc: "A sample of a typical value.",
    type: "string"
  },
  screenRecord: {
    desc: "The name of the attached screen record in INPUT|DISPLAY ARRAY.",
    type: "string"
  },
  scroll: {
    desc: "Required for compatibility.",
    type: "IntBoolean"
  },
  scrollBars: {
    desc: "Defines scrolling and word wrapping.",
    type: "ScrollBars"
  },
  selected: {
    desc: "Object selection indicator (0 = not selected, 1 = selected).",
    type: "IntBoolean"
  },
  selection: {
    desc: "The id attribute of the current MenuAction-child.",
    type: "string"
  },
  shift: {
    desc: "The shift attribute controls up or down shifting if this field is in input mode.",
    type: "Shift"
  },
  size: {
    desc: "The size of the array.",
    type: "number"
  },
  sizePolicy: {
    desc: "how elements grow if content is displayed to them.",
    type: "SizePolicy"
  },
  sortColumn: {
    desc: "The index of the Column, data is ordered by.",
    type: "number"
  },
  sortType: {
    desc: "(none|asc|desc)",
    type: "string"
  },
  spacing: {
    desc: "Defines the spacing between two visible siblings.",
    type: "Spacing"
  },
  splitter: {
    desc: "Children will be separated by a splitter.",
    type: "IntBoolean"
  },
  sqlDbName: {
    desc: "The name of the database used to compile this form.  volatile='1' final='1'",
    type: "string"
  },
  sqlTabName: {
    desc: "The name of the SQL Table this Edit is related to. For debugging only.  volatile='1' final='1'",
    type: "string"
  },
  sqlType: {
    desc: "A SQL-type-name. Will be used for CONSTRUCT.  volatile='1' final='1'",
    type: "string"
  },
  startDegrees: {
    desc: "The starting angle for the Canvas Arc.",
    type: "number"
  },
  startX: {
    desc: "The X pos of the starting point of the Canvas Item.",
    type: "number"
  },
  startY: {
    desc: "The Y pos of the starting point of the Canvas Item.",
    type: "number"
  },
  step: {
    desc: "The step between two marks.",
    type: "number"
  },
  stepX: {
    desc: "The space between two cells (horizontal).",
    type: "number"
  },
  stepY: {
    desc: "The space between two cells (vertical).",
    type: "number"
  },
  stretch: {
    desc: "One of { none x y both } - Indicates if the Image can be streched.",
    type: "Stretch"
  },
  stretchColumns: {
    desc: "STRETCH=X becomes the default for all columns of the table.",
    type: "IntBoolean"
  },
  stretchMin: {
    desc: "When STRETCH=X, defines the minimum widget size",
    type: "number"
  },
  stretchMax: {
    desc: "When STRETCH=X, defines the maximum widget size",
    type: "number"
  },
  style: {
    desc: "The given style of the Node.This is used to centralize attributes in the node.stylename style.",
    type: "string"
  },
  tabIndex: {
    desc: "Sets the order of fields in a form.",
    type: "number"
  },
  tabIndexRt: {
    desc: "The tab index of the field in the current dialog.",
    type: "number"
  },
  tabName: {
    desc: "DVM Only - An identifier to lookup children of this node in the rogram.",
    type: "string"
  },
  tag: {
    desc: "User specific text. Can be added to any node.",
    type: "string"
  },
  targetType: {
    desc: "Type of the target variable associated to this screen field.",
    type: "string"
  },
  text: {
    desc: "Text associated to this Control. he text is typically visible for the user.",
    type: "string"
  },
  thousandsSeparator: {
    desc: "Defines the thousands separator for numbers (used for numeric keypad).",
    type: "string"
  },
  timeout: {
    desc: "After timeout seconds beeing idle this action must be invoked",
    type: "number"
  },
  touched: {
    desc: "DVM Only - The Edit has been touched in the current dialog.  volatile='1'",
    type: "IntBoolean"
  },
  ttyAttr: {
    desc: "TTY attributes (COLOR, REVERSE, UNDERLINE, BOLD) as seen from fglcomp.  volatile='1' final='1'",
    type: "string"
  },
  type: {
    desc: "",
    type: "string"
  },
  uiMode: {
    desc: "Render as close as possible like the text user interface.",
    type: "UIMode"
  },
  underline: {
    desc: "Indicates if the current text is underlined. Required for compatibility.",
    type: "IntBoolean"
  },
  unhidable: {
    desc: "Not hidable.",
    type: "IntBoolean"
  },
  unhidableColumns: {
    desc: "Table columns cannot be hidden.",
    type: "IntBoolean"
  },
  unmovable: {
    desc: "Can't be move. Have sense if at least two columns are unmovable: then the order for these columns is fixed.",
    type: "IntBoolean"
  },
  unmovableColumns: {
    desc: "All columns of this list-view have a fixed position. This attribute disables user to set the order of columns at runtime.",
    type: "IntBoolean"
  },
  unsizable: {
    desc: "Not resizable.",
    type: "IntBoolean"
  },
  unsizableColumns: {
    desc: "Table columns are not resizable.",
    type: "IntBoolean"
  },
  unsortable: {
    desc: "Not sortable.",
    type: "IntBoolean"
  },
  unsortableColumns: {
    desc: "Table columns cannot be used for sort.",
    type: "IntBoolean"
  },
  validate: {
    desc: "volatile='1' final='1'",
    type: "number"
  },
  value: {
    desc: "The current value.",
    type: "string"
  },
  valueChecked: {
    desc: "The value the checkbox holds when checked. The default value is 1.",
    type: "string"
  },
  valueMax: {
    desc: "The upper limit of a range of allowed values.",
    type: "number"
  },
  valueMin: {
    desc: "The lower limit of a range of allowed values.",
    type: "number"
  },
  valueUnchecked: {
    desc: "The value the checkbox holds when unchecked. The default value is 0",
    type: "string"
  },
  verify: {
    desc: "DVM Only - the value must be entered twice by the user.",
    type: "IntBoolean"
  },
  version: {
    desc: "The version of an element (used for example in form version).",
    type: "string"
  },
  visibleId: {
    desc: "Ensure the item with the given id to be visible.",
    type: "number"
  },
  waiting: {
    desc: "DVM Only - The command started in a start menu will be started WITH waitingor not depending on waiting value, defaults to 0, not waiting  volatile='1'",
    type: "number"
  },
  wantFixedPageSize: {
    desc: "The pageSize can't be set interactively. This attribute disables users to resize the listView at runtime.",
    type: "IntBoolean"
  },
  wantReturns: {
    desc: "Indicates that this textEdit will consume return-characters. Return characters will not be used to leave the input.",
    type: "IntBoolean"
  },
  wantTabs: {
    desc: "Indicates that this textEdit will consume tab-characters. Tab characters will not be used to leave this field.",
    type: "IntBoolean"
  },
  width: {
    desc: "The visible width of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.",
    type: "string"
  },
  windowStyle: {
    desc: "Defines the parent window style of a form.",
    type: "string"
  },
  xyList: {
    desc: "A space separated list of coordinates describing the CanvasPolygon.",
    type: "string"
  }
};
;

"use strict";

gbc.constants.debugInfo.auiTreeNodeInfo = {
  "Action": {
    "collapsed": false,
    "color": "#78DBE2"
  },
  "ActionDefault": {
    "collapsed": false,
    "color": "#87A96B"
  },
  "ActionDefaultList": {
    "collapsed": true,
    "color": "#FFA474"
  },
  "Aggregate": {
    "collapsed": false,
    "color": "#FAE7B5"
  },
  "Button": {
    "collapsed": false,
    "color": "#9F8170"
  },
  "ButtonEdit": {
    "collapsed": false,
    "color": "#FD7C6E"
  },
  "Canvas": {
    "collapsed": false,
    "color": "#ACE5EE"
  },
  "CanvasArc": {
    "collapsed": false,
    "color": "#A2A2D0"
  },
  "CanvasCircle": {
    "collapsed": false
  },
  "CanvasLine": {
    "collapsed": false
  },
  "CanvasOval": {
    "collapsed": false
  },
  "CanvasPolygon": {
    "collapsed": false,
    "color": "#DE5D83"
  },
  "CanvasRectangle": {
    "collapsed": false,
    "color": "#B0B7C6"
  },
  "CanvasText": {
    "collapsed": false,
    "color": "#B4674D"
  },
  "CheckBox": {
    "collapsed": false,
    "color": "#FF7F49"
  },
  "ComboBox": {
    "collapsed": false,
    "color": "#1F75FE"
  },
  "Completer": {
    "collapsed": false,
    "color": "#1F75FE"
  },
  "Config": {
    "collapsed": false,
    "color": "#EA7E5D"
  },
  "DateEdit": {
    "collapsed": false,
    "color": "#CB4154"
  },
  "DateTimeEdit": {
    "collapsed": false,
    "color": "#56004C"
  },
  "DefaultActions": {
    "collapsed": false,
    "color": "#1CD3A2"
  },
  "Dialog": {
    "collapsed": false,
    "color": "#1DACD6"
  },
  "DialogEvent": {
    "collapsed": false,
    "color": "#BC5D58"
  },
  "DialogInfo": {
    "collapsed": false,
    "color": "#DD9475"
  },
  "DragDropInfo": {
    "collapsed": false,
    "color": "#9ACEEB"
  },
  "Edit": {
    "collapsed": false,
    "color": "#FDDB6D"
  },
  "FieldInfo": {
    "collapsed": false,
    "color": "#2B6CC4"
  },
  "Folder": {
    "collapsed": false,
    "color": "#6E5160"
  },
  "Form": {
    "collapsed": false,
    "color": "#CEFF1D"
  },
  "FormField": {
    "collapsed": false,
    "color": "#71BC78"
  },
  "FunctionCall": {
    "collapsed": false,
    "color": "#C364C5"
  },
  "FunctionCallParameter": {
    "collapsed": false,
    "color": "#CC6666"
  },
  "Grid": {
    "collapsed": false,
    "color": "#FCD975"
  },
  "Group": {
    "collapsed": false,
    "color": "#A8E4A0"
  },
  "GroupTitle": {
    "collapsed": false,
    "color": "#A8E4A0"
  },
  "HBox": {
    "collapsed": false,
    "color": "#1164B4"
  },
  "HLine": {
    "collapsed": false,
    "color": "#F0E891"
  },
  "IdleAction": {
    "collapsed": false,
    "color": "#FF1DCE"
  },
  "Image": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "ImageFonts": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "ImageFont": {
    "collapsed": false,
    "color": "#CA3767"
  },
  "Item": {
    "collapsed": false,
    "color": "#3BB08F"
  },
  "Label": {
    "collapsed": false,
    "color": "#DADA22"
  },
  "Link": {
    "collapsed": false,
    "color": "#FFBD88"
  },
  "Matrix": {
    "collapsed": false,
    "color": "#F664AF"
  },
  "Menu": {
    "collapsed": false,
    "color": "#AAF0D1"
  },
  "MenuAction": {
    "collapsed": false,
    "color": "#CD4A4C"
  },
  "Message": {
    "collapsed": false,
    "color": "#EDD19C"
  },
  "Page": {
    "collapsed": false,
    "color": "#FF8243"
  },
  "PhantomColumn": {
    "collapsed": false,
    "color": "#C8385A"
  },
  "PhantomEdit": {
    "collapsed": false,
    "color": "#EF98AA"
  },
  "PhantomFormField": {
    "collapsed": false,
    "color": "#1A4876"
  },
  "PhantomMatrix": {
    "collapsed": false,
    "color": "#30BA8F"
  },
  "ProgressBar": {
    "collapsed": false,
    "color": "#C54B8C"
  },
  "Property": {
    "collapsed": false,
    "color": "#1974D2"
  },
  "PropertyArray": {
    "collapsed": false,
    "color": "#FFA343"
  },
  "PropertyDict": {
    "collapsed": false,
    "color": "#BAB86C"
  },
  "RadioGroup": {
    "collapsed": false,
    "color": "#FF7538"
  },
  "RecordView": {
    "collapsed": false,
    "color": "#FF2B2B"
  },
  "Rectangle": {
    "collapsed": false,
    "color": "#F8D568"
  },
  "RowInfo": {
    "collapsed": false,
    "color": "#1CA9C9"
  },
  "RowInfoList": {
    "collapsed": false,
    "color": "#FFCFAB"
  },
  "Screen": {
    "collapsed": false,
    "color": "#FDDDE6"
  },
  "ScrollArea": {
    "collapsed": false,
    "color": "#EFDECD"
  },
  "ScrollGrid": {
    "collapsed": false,
    "color": "#A5694F"
  },
  "Slider": {
    "collapsed": false,
    "color": "#8A795D"
  },
  "SpacerItem": {
    "collapsed": false,
    "color": "#45CEA2"
  },
  "SpinEdit": {
    "collapsed": false,
    "color": "#FB7EFD"
  },
  "Stack": {
    "collapsed": false,
    "color": "#80DAEB"
  },
  "StartMenu": {
    "collapsed": false,
    "color": "#80DAEB"
  },
  "StartMenuCommand": {
    "collapsed": false,
    "color": "#ECEABE"
  },
  "StartMenuGroup": {
    "collapsed": false,
    "color": "#FFCF48"
  },
  "StartMenuSeparator": {
    "collapsed": false,
    "color": "#FD5E53"
  },
  "Style": {
    "collapsed": false,
    "color": "#FAA76C"
  },
  "StyleAttribute": {
    "collapsed": false,
    "color": "#18A7B5"
  },
  "StyleList": {
    "collapsed": true,
    "color": "#EBC7DF"
  },
  "Table": {
    "collapsed": false,
    "color": "#FC89AC"
  },
  "TableAction": {
    "collapsed": false,
    "color": "#FC8900"
  },
  "TableActions": {
    "collapsed": false,
    "color": "#FC00AC"
  },
  "TableColumn": {
    "collapsed": false,
    "color": "#DBD7D2"
  },
  "TextEdit": {
    "collapsed": false,
    "color": "#17806D"
  },
  "TimeEdit": {
    "collapsed": false,
    "color": "#DEAA88"
  },
  "ToolBar": {
    "collapsed": false,
    "color": "#77DDE7"
  },
  "ToolBarItem": {
    "collapsed": false,
    "color": "#FFFF66"
  },
  "ToolBarSeparator": {
    "collapsed": false,
    "color": "#926EAE"
  },
  "TopMenu": {
    "collapsed": false,
    "color": "#324AB2"
  },
  "TopMenuCommand": {
    "collapsed": false,
    "color": "#F75394"
  },
  "TopMenuGroup": {
    "collapsed": false,
    "color": "#FFA089"
  },
  "TopMenuSeparator": {
    "collapsed": false,
    "color": "#8F509D"
  },
  "TreeInfo": {
    "collapsed": false,
    "color": "#A2ADD0"
  },
  "TreeItem": {
    "collapsed": false,
    "color": "#FF43A4"
  },
  "UserInterface": {
    "collapsed": false,
    "color": "#FC6C85"
  },
  "VBox": {
    "collapsed": false,
    "color": "#CDA4DE"
  },
  "Value": {
    "collapsed": false,
    "color": "#FCE883"
  },
  "ValueList": {
    "collapsed": true,
    "color": "#C5E384"
  },
  "WebComponent": {
    "collapsed": false,
    "color": "#FFAE42"
  },
  "Window": {
    "collapsed": false,
    "color": "#CD9575"
  }
};
;

"use strict";

gbc.constants.attributeDefaultValuesByNodeType = {
  ScrollGrid: {
    wantFixedPageSize: 1
  },
  Slider: {
    orientation: "horizontal"
  },
  WebComponent: {
    stretch: "both"
  },
  HBox: {
    orientation: "horizontal"
  }
};
/**
 * AUI attributes default values.
 *
 * @instance attributeDefaultValues
 */
gbc.constants.attributeDefaultValues = {
  acceleratorKey1: "",
  acceleratorKey3: "",
  acceleratorName2: "",
  acceleratorName3: "",
  acceleratorName4: "",
  acceleratorName: "",
  action: "",
  actionActive: 0,
  active: 0,
  aggregateText: "",
  aggregateType: "sum",
  aggregateValue: "",
  anchor: "",
  autoNext: 0,
  autoScale: 0,
  blink: 0,
  bold: 0,
  border: 0,
  bufferSize: 0,
  build: "",
  buttonTextHidden: 0,
  century: "",
  className: "",
  clickedCanvasItemId: 0,
  cloneColumns: 0,
  cloneCount: 0,
  colName: "",
  color: "",
  colorCondition: "",
  columnCount: 1,
  comment: "",
  commentLine: 0,
  commentLineHidden: 0,
  componentType: "",
  compress: 0,
  config: "",
  container: "",
  contextMenu: "yes",
  count: 0,
  currentColumn: 0,
  currentParentRow: 0,
  currentRow: 0,
  currentWindow: 0,
  cursor2: 0,
  cursor: 0,
  dataType: "",
  dbCentury: "",
  dbDate: "",
  decimalSeparator: "",
  defaultValue: "",
  defaultView: "auto",
  delimiters: "",
  dialogEventItem: 0,
  dialogEventType: "",
  dialogType: "Display",
  diameter: 0,
  dim: 0,
  dirty: 0,
  disabled: 0,
  dndAccepted: 0,
  dndBuffer: "",
  dndCanCopy: 0,
  dndCanMove: 0,
  dndFeedback: "insert",
  dndIdRef: 0,
  dndMimeTypes: "",
  dndOperation: "move",
  dndParentIdRef: 0,
  dndRequiredMimeType: "",
  doubleClick: "",
  endX: 0,
  endY: 0,
  errorLine: 0,
  exec: "",
  expanded: 0,
  expandedColumn: "",
  extentDegrees: 0,
  fieldId: "",
  fieldIdRef: 0,
  fieldOrder: 0,
  fieldSelection: 0,
  fileName: "",
  fillColor: "",
  filter: "",
  flipped: 0,
  focus: 0,
  focusOnField: 0,
  fontPitch: "default",
  formLine: 0,
  format: "",
  gridChildrenInParent: 0,
  gridHeight: null,
  gridWidth: null,
  hasChildren: 0,
  height: "",
  helpNum: 0,
  hidden: 0,
  idColumn: "",
  image: "",
  imageCollapsed: "",
  imageColumn: "",
  imageExpanded: "",
  imageLeaf: "",
  include: "",
  initializer: "",
  inputWrap: 0,
  isHotKey: 0,
  isNodeColumn: "",
  isNull: 0,
  isPassword: 0,
  isSystem: 0,
  isTimer: 0,
  isTree: 0,
  justify: "left",
  maxLength: 0,
  media: "",
  mediaAttribute: "{}",
  menuLine: 0,
  messageLine: 0,
  minHeight: 0,
  minWidth: 0,
  moduleName: "",
  multiRowSelection: 0,
  name: "",
  noEntry: 0,
  noFilter: 0,
  nodeIdRef: 0,
  notNull: 0,
  noswipe: 0,
  numAlign: 0,
  offset: 0,
  orientation: "vertical",
  pageSize: 0,
  paramCount: 0,
  parent: 0,
  parentIdColumn: "",
  picture: "",
  placeholder: "",
  posX: 0,
  posY: 0,
  procId: "",
  procIdParent: "",
  procIdWaiting: "",
  program: "",
  promptLine: 0,
  queryEditable: 0,
  required: 0,
  returnCount: 0,
  reverse: 0,
  row: 0,
  runtimeStatus: "interactive",
  sample: "",
  screenRecord: "",
  scroll: 0,
  scrollBars: "vertical",
  selected: 0,
  selection: "",
  shift: "none",
  size: 0,
  sizePolicy: "initial",
  sortColumn: -1,
  sortType: "",
  spacing: "normal",
  split: 0,
  splitter: 0,
  sqlDbName: "",
  sqlTabName: "",
  sqlType: "",
  startDegrees: 0,
  startX: 0,
  startY: 0,
  step: 1,
  stepX: 0,
  stepY: 1,
  stretch: "",
  stretchColumns: 0,
  stretchMin: 0,
  stretchMax: 0,
  style: "",
  tabIndex: 0,
  tabIndexRt: 0,
  tabName: "",
  tag: "",
  targetType: "",
  text: "",
  thousandsSeparator: "",
  timeout: 0,
  touched: 0,
  ttyAttr: "",
  type: "",
  uiMode: "default",
  underline: 0,
  unhidable: 0,
  unhidableColumns: 0,
  unmovable: 0,
  unmovableColumns: 0,
  unsizable: 0,
  unsizableColumns: 0,
  unsortable: 0,
  unsortableColumns: 0,
  validate: 0,
  value: "",
  valueChecked: "1",
  valueMax: null,
  valueMin: null,
  valueUnchecked: "0",
  verify: 0,
  version: "",
  visibleId: -1,
  waiting: 0,
  wantFixedPageSize: 0,
  wantReturns: 0,
  wantTabs: 0,
  width: "",
  windowStyle: "",
  xyList: ""
};
;

"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.baseEvents = {
  applicationAdded: "g_applicationAdded",
  applicationRemoved: "g_applicationRemoved",
  childrenNodeCreated: "g_childrenNodeCreated",
  controllerCreated: "g_controllerCreated",
  displayEnd: "g_displayEnd",
  idleChanged: "g_idleChanged",
  nodeCreated: "g_nodeCreated",
  nodeDestroyed: "g_nodeDestroyed",
  ordersManaged: "g_ordersManaged",
  gotRN0: "g_gotRN0"
};

gbc.constants.applicationEvents = {
  startMenuPositionUpdate: "g_startMenuPositionUpdate"
};
;

"use strict";
/**
 * @namespace gbc.constants.network
 */
gbc.constants.network = {
  /**
   * The different headers used by the protocol
   */
  headers: {
    error: "X-FourJs-Error",
    prompt: "X-FourJs-Prompt",
    session: "X-FourJs-Id",
    server: "X-FourJs-Server",
    serverFeatures: "X-FourJs-Server-Features",
    application: "X-FourJs-AppId",
    timeout: "X-FourJs-Timeout",
    webComponent: "X-FourJs-WebComponent",
    newTask: "X-FourJs-NewTask",
    newTaskProcIdParent: "X-FourJs-NewTask-ProcIdParent",
    newTaskWaiting: "X-FourJs-NewTask-Waiting",
    vmReady: "X-FourJs-VmReady",
    closed: "X-FourJs-Closed",
    endUrl: "X-FourJs-End-Url",
    sessionClosed: "X-FourJs-Session-Closed",
    devmode: "X-FourJs-Development",
    message: "X-FourJs-Message",
    contentType: "Content-Type"
  },

  /**
   * Enum RequestType
   * The type of request used in the VM protocol's header
   */
  requestType: {
    AUI: 1,
    Ping: 2,
    Interrupt: 3,
    Close: 4,
    FT: 5
  },
  /**
   * The needed stater response headers
   */
  startHeaders: {
    session: {
      error: "Missing Session ID"
    },
    timeout: {
      error: "Missing Timeout"
    },
    webComponent: {
      prop: "webComponent",
      error: "Missing WebComponent Path"
    }
  },
  sentHeaders: {
    "X-FourJs-Client": "GBC/" + encodeURIComponent(gbc.version) + "-" + gbc.build,
    "X-FourJs-Client-Features": "prompt"
  }
};

/**
 * Array RequestTypeStrings
 * Associate a string to each RequestType. For logging purpose.
 */
gbc.constants.network.requestTypeStrings = Object.swap(gbc.constants.network.requestType);
;

"use strict";

gbc.constants.nodeAttributes = {
  "Action": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "active", "comment", "contextMenu", "context",
    "defaultView", "helpNum", "hidden", "idRef", "image", "name", "tabIndexRt", "tag", "text", "validate"
  ],
  "ActionDefault": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "comment", "contextMenu", "defaultView",
    "idRef", "image", "name", "tag", "text", "validate"
  ],
  "ActionDefaultList": [
    "fileName", "idRef", "name", "tag"
  ],
  "Aggregate": [
    "aggregateText", "aggregateType", "blink", "bold", "color", "colorCondition", "comment", "dim", "fieldIdRef",
    "fontPitch",
    "format", "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse",
    "sample", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "width", "stretchMin", "stretchMax"
  ],
  "Button": [
    "acceleratorName", "actionActive", "actionIdRef", "cloneColumns", "cloneCount", "comment", "disclosureIndicator",
    "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "name", "posX", "posY", "sample", "sizePolicy",
    "stepX",
    "stepY", "stretch", "stretchMin", "style", "tabIndex", "tabIndexRt", "tag", "text", "width"
  ],
  "ButtonEdit": [
    "action", "actionActive", "actionIdRef", "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment",
    "dim", "fontPitch", "format", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "isPassword", "justify",
    "keyboardHint", "maxLength", "name", "notEditable", "picture", "placeholder", "posX", "posY", "program", "reverse", "sample",
    "scroll", "shift",
    "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr", "underline", "verify", "width"
  ],
  "Canvas": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "CanvasArc": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "extentDegrees", "fillColor", "idRef", "name",
    "startDegrees",
    "startX", "startY", "tag"
  ],
  "CanvasCircle": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasLine": [
    "acceleratorKey1", "acceleratorKey3", "comment", "diameter", "endX", "endY", "fillColor", "idRef", "name", "startX",
    "startY", "tag", "width"
  ],
  "CanvasOval": [
    "acceleratorKey1", "acceleratorKey3", "comment", "endX", "endY", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasPolygon": [
    "acceleratorKey1", "acceleratorKey3", "comment", "fillColor", "idRef", "name", "startX", "startY", "tag", "xyList"
  ],
  "CanvasRectangle": [
    "acceleratorKey1", "acceleratorKey3", "comment", "endX", "endY", "fillColor", "idRef", "name", "startX", "startY", "tag"
  ],
  "CanvasText": [
    "acceleratorKey1", "acceleratorKey3", "anchor", "comment", "fillColor", "idRef", "name", "startX", "startY", "tag",
    "text"
  ],
  "CheckBox": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style",
    "tag",
    "text", "ttyAttr", "underline", "valueChecked", "valueUnchecked", "width"
  ],
  "ComboBox": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "initializer", "isPassword", "justify", "name", "placeholder", "posX", "posY", "queryEditable", "reverse", "sample",
    "scroll", "shift",
    "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Completer": [
    "filterMode", "name", "size", "tag"
  ],
  "Config": [
    "idRef", "name", "tag"
  ],
  "DateEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr",
    "underline", "verify",
    "width"
  ],
  "DateTimeEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr",
    "underline", "verify",
    "width"
  ],
  "DefaultActions": [
    "idRef", "name", "tag"
  ],
  "Dialog": [
    "active", "idRef", "name", "tag"
  ],
  "DialogEvent": [
    "dialogEventItem", "dialogEventType", "idRef", "name", "tag"
  ],
  "DialogInfo": [
    "dialogType", "idRef", "name", "tag"
  ],
  "DragDropInfo": [
    "dndAccepted", "dndBuffer", "dndCanCopy", "dndCanMove", "dndFeedback", "dndIdRef", "dndMimeTypes", "dndOperation",
    "dndRequiredMimeType", "idRef", "name", "tag"
  ],
  "Edit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "placeholder",
    "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr",
    "underline", "verify",
    "width"
  ],
  "XEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "placeholder",
    "posX", "posY", "stretchMin", "stretchMax",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width"
  ],
  "FieldInfo": [
    "idRef", "name", "nodeIdRef", "tag", "targetType"
  ],
  "Folder": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "noswipe", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "Form": [
    "blink", "bold", "build", "color", "delimiters", "dim", "formLine", "height", "hidden", "idRef", "image", "isPassword",
    "minHeight", "minWidth", "name", "reverse", "spacing", "sqlDbName", "stretch", "style", "tag", "text", "ttyAttr", "underline", "version",
    "visibleId", "width", "windowStyle"
  ],
  "FormField": [
    "active", "colName", "cursor", "cursor2", "defaultValue", "dialogType", "dirty", "fieldId", "hidden", "idRef", "include",
    "name", "noEntry", "notNull", "numAlign", "required", "screenRecord", "sqlTabName", "sqlType", "tabIndex", "tabIndexRt", "tag",
    "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "value", "varType"
  ],
  "FunctionCall": [
    "idRef", "isSystem", "moduleName", "name", "paramCount", "returnCount", "tag"
  ],
  "FunctionCallParameter": [
    "dataType", "idRef", "isNull", "name", "tag", "value"
  ],
  "Grid": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "Group": [
    "comment", "fontPitch", "gridChildrenInParent", "gridHeight", "gridWidth", "height", "hidden", "idRef", "mediaAttribute", "name", "posX",
    "posY", "sample", "style", "tag", "text", "width"
  ],
  "GroupTitle": [],
  "HBox": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "mediaAttribute", "name", "noswipe", "orientation", "posX",
    "posY",
    "sample", "split",
    "splitter", "style", "tag", "text", "width"
  ],
  "HLine": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "IdleAction": [
    "hidden", "idRef", "name", "tag", "timeout", "isTimer"
  ],
  "Image": [
    "action", "actionActive", "actionIdRef", "autoScale", "blink", "bold", "cloneColumns", "cloneCount", "color",
    "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "image", "isPassword",
    "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "stepX", "stepY", "stretch", "stretchMin", "stretchMax", "style", "tag",
    "text",
    "ttyAttr",
    "underline", "width"
  ],
  "ImageFonts": [],
  "ImageFont": [
    "name", "href"
  ],
  "Item": [
    "idRef", "name", "tag", "text"
  ],
  "Label": [
    "blink", "bold", "cloneColumns", "cloneCount", "color", "colorCondition", "comment", "dim", "fontPitch", "format",
    "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample",
    "sizePolicy", "stepX", "stepY", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Link": [
    "colName", "fieldIdRef", "idRef", "name", "tag"
  ],
  "Matrix": [
    "active", "bufferSize", "colName", "columnCount", "currentRow", "cursor", "cursor2", "defaultValue", "dialogType",
    "dirty",
    "fieldId", "hidden", "idRef", "include", "name", "noEntry", "notNull", "numAlign", "offset", "pageSize", "required",
    "screenRecord",
    "size", "sqlTabName", "sqlType", "stepX", "stepY", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable",
    "unsizable", "unsortable", "varType"
  ],
  "Menu": [
    "active", "comment", "hidden", "idRef", "image", "name", "parent", "posY", "selection", "style", "tag", "text"
  ],
  "MenuAction": [
    "acceleratorName", "acceleratorName2", "acceleratorName3", "acceleratorName4", "active", "comment", "contextMenu", "context",
    "defaultView", "disclosureIndicator", "helpNum", "hidden", "idRef", "image", "isHotKey", "name", "tabIndexRt", "tag", "text",
    "validate"
  ],
  "Message": [
    "blink", "bold", "color", "count", "dim", "gridHeight", "gridWidth", "height", "idRef", "isPassword", "name", "posX",
    "posY", "reverse", "style", "tag", "text", "ttyAttr", "type", "underline", "width"
  ],
  "Page": [
    "action", "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "PhantomColumn": [
    "active", "aggregateText", "aggregateType", "aggregateValue", "colName", "cursor", "cursor2", "defaultValue",
    "dialogType",
    "dirty", "fieldId", "hidden", "idRef", "imageColumn", "include", "name", "noEntry", "notNull", "numAlign", "required",
    "sqlTabName",
    "sqlType", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "varType"
  ],
  "PhantomEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "style", "tag", "text", "ttyAttr", "underline", "verify",
    "width", "stretchMin", "stretchMax"
  ],
  "PhantomFormField": [
    "active", "colName", "cursor", "cursor2", "defaultValue", "dialogType", "dirty", "fieldId", "hidden", "idRef", "include",
    "name", "noEntry", "notNull", "numAlign", "required", "screenRecord", "sqlTabName", "sqlType", "tabIndex", "tabIndexRt", "tag",
    "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "value", "varType"
  ],
  "PhantomMatrix": [
    "active", "bufferSize", "colName", "columnCount", "currentRow", "cursor", "cursor2", "defaultValue", "dialogType",
    "dirty",
    "fieldId", "hidden", "idRef", "include", "name", "noEntry", "notNull", "numAlign", "offset", "pageSize", "required",
    "screenRecord",
    "size", "sqlTabName", "sqlType", "stepX", "stepY", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable",
    "unsizable", "unsortable", "varType"
  ],
  "ProgressBar": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style",
    "tag", "text", "ttyAttr",
    "underline", "valueMax", "valueMin", "width"
  ],
  "Property": [
    "idRef", "name", "value"
  ],
  "PropertyArray": [
    "idRef", "name"
  ],
  "PropertyDict": [
    "idRef", "name"
  ],
  "RadioGroup": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "orientation", "posX", "posY", "reverse", "sample", "sizePolicy", "stretch", "stretchMin",
    "stretchMax",
    "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "RecordView": [
    "idRef", "name", "tabName", "tag"
  ],
  "Rectangle": [
    "color", "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY",
    "sample",
    "style", "tag", "text", "width"
  ],
  "RipGraphic": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "name", "posX", "posY", "sample", "style", "tag", "text",
    "type", "width"
  ],
  "RowInfo": [
    "idRef", "selected"
  ],
  "RowInfoList": [
    "idRef", "name", "tag"
  ],
  "Screen": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "name", "posX", "posY", "sample",
    "style",
    "tag", "text", "width"
  ],
  "ScrollArea": [
    "active", "bufferSize", "currentRow", "gridHeight", "gridWidth", "name", "offset", "pageSize", "posX", "posY", "size",
    "tag"
  ],
  "ScrollGrid": [
    "actionActive", "active", "bufferSize", "comment", "currentRow", "doubleClick", "filter", "noFilter", "fontPitch",
    "gridChildrenInParent", "gridHeight", "gridWidth", "haveRowActions", "height", "hidden", "idRef", "name",
    "offset", "pageSize", "posX", "posY", "sample", "size", "style", "tag", "text", "width", "wantFixedPageSize"
  ],
  "Slider": [
    "blink", "bold", "color", "colorCondition", "comment", "dim", "fontPitch", "gridHeight", "gridWidth", "height", "hidden",
    "idRef", "isPassword", "justify", "name", "orientation", "posX", "posY", "reverse", "sample", "sizePolicy", "stretch", "stretchMin",
    "stretchMax", "step", "style",
    "tag",
    "text", "ttyAttr", "underline", "valueMax", "valueMin", "width"
  ],
  "SpacerItem": [
    "idRef", "name", "tag"
  ],
  "SpinEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "step", "stretch", "stretchMin", "stretchMax", "style", "tag", "text",
    "ttyAttr", "underline",
    "valueMax",
    "valueMin", "verify", "width"
  ],
  "Stack": [
    "posX", "posY", "width", "height", "gridWidth", "gridHeight", "hidden", "fontPitch", "sample",
    "style", "text", "comment", "name", "tag"
  ],
  "StartMenu": [
    "fileName", "idRef", "name", "tag", "text"
  ],
  "StartMenuCommand": [
    "comment", "disabled", "exec", "hidden", "idRef", "image", "name", "tag", "text", "waiting"
  ],
  "StartMenuGroup": [
    "disabled", "hidden", "idRef", "image", "name", "tag", "text"
  ],
  "StartMenuSeparator": [
    "idRef", "name", "tag"
  ],
  "Style": [
    "idRef", "name", "tag"
  ],
  "StyleAttribute": [
    "idRef", "name", "tag", "value"
  ],
  "StyleList": [
    "fileName", "idRef", "name", "tag"
  ],
  "Table": [
    "actionActive", "actionIdRef", "active", "aggregateText", "bufferSize", "comment", "currentColumn", "currentRow",
    "dialogType", "doubleClick", "expandedColumn", "flipped", "filter", "noFilter", "focusOnField", "fontPitch",
    "gridHeight", "gridWidth", "haveRowActions", "height", "hidden", "stretch", "stretchColumns",
    "idColumn", "idRef", "imageCollapsed", "imageExpanded", "imageLeaf", "isNodeColumn", "isTree", "multiRowSelection",
    "name", "offset", "pageSize", "parentIdColumn", "posX", "posY", "sample", "size", "sortColumn", "sortType",
    "style", "tabName", "tag", "text", "unhidableColumns", "unmovableColumns", "unsizableColumns", "unsortableColumns",
    "wantFixedPageSize", "width"
  ],
  "TableAction": [
    "actionIdRef", "active", "hidden", "idRef", "image", "name", "rowBound", "text"
  ],
  "TableActions": [
    "active", "accessoryType", "detailAction", "idRef"
  ],
  "TableColumn": [
    "active", "aggregateText", "aggregateType", "aggregateValue", "colName", "cursor", "cursor2", "defaultValue",
    "dialogType",
    "dirty", "fieldId", "hidden", "idRef", "imageColumn", "include", "name", "noEntry", "notNull", "numAlign", "required",
    "sqlTabName",
    "sqlType", "tabIndex", "tabIndexRt", "tag", "text", "touched", "unhidable", "unmovable", "unsizable", "unsortable", "varType"
  ],
  "TextEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "compress", "dim", "fontPitch", "format",
    "gridHeight", "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "notEditable",
    "picture",
    "posX", "posY", "program", "reverse", "sample", "scroll", "scrollBars", "shift", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style",
    "tag", "text",
    "ttyAttr", "underline", "verify", "wantReturns", "wantTabs", "width",
  ],
  "TimeEdit": [
    "autoNext", "blink", "bold", "century", "color", "colorCondition", "comment", "dim", "fontPitch", "format", "gridHeight",
    "gridWidth", "height", "hidden", "idRef", "isPassword", "justify", "keyboardHint", "maxLength", "name", "picture", "posX", "posY",
    "program", "reverse", "sample", "scroll", "shift", "sizePolicy", "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr",
    "underline", "verify",
    "width"
  ],
  "ToolBar": [
    "buttonTextHidden", "fileName", "idRef", "name", "style", "tag"
  ],
  "ToolBarAutoItems": [
    "style", "hidden", "content", "name", "tag", "mediaAttribute"
  ],
  "ToolBarItem": [
    "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "ToolBarSeparator": [
    "hidden", "idRef", "name", "style", "tag"
  ],
  "TopMenu": [
    "fileName", "idRef", "name", "style", "tag"
  ],
  "TopMenuAutoCommands": [
    "style", "hidden", "content", "name", "tag", "mediaAttribute"
  ],
  "TopMenuCommand": [
    "acceleratorName", "actionActive", "actionIdRef", "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "TopMenuGroup": [
    "comment", "hidden", "idRef", "image", "name", "style", "tag", "text"
  ],
  "TopMenuSeparator": [
    "hidden", "idRef", "name", "style", "tag"
  ],
  "TreeInfo": [
    "currentParentRow", "hasChildren", "idRef"
  ],
  "TreeItem": [
    "expanded", "hasChildren", "idRef", "row"
  ],
  "UserInterface": [
    "charLengthSemantics", "clickedCanvasItemId", "commentLine", "commentLineHidden", "container", "currentWindow", "dbCentury", "dbDate",
    "decimalSeparator", "errorLine", "fieldOrder", "fieldSelection", "focus", "formLine", "height", "idRef", "image", "inputWrap", "media",
    "menuLine", "messageLine", "name", "procId", "procIdParent", "procIdWaiting", "promptLine", "runtimeStatus", "tag", "text",
    "thousandsSeparator", "type", "uiMode", "width"
  ],
  "VBox": [
    "comment", "fontPitch", "gridHeight", "gridWidth", "height", "hidden", "idRef", "mediaAttribute", "name", "noswipe", "orientation", "posX",
    "posY",
    "sample", "split",
    "splitter", "style", "tag", "text", "width"
  ],
  "Value": [
    "blink", "bold", "color", "dim", "idRef", "image", "isPassword", "name", "reverse", "tag", "ttyAttr", "underline",
    "value"
  ],
  "ValueList": [
    "idRef", "name", "tag"
  ],
  "WebComponent": [
    "blink", "bold", "color", "colorCondition", "comment", "componentType", "dim", "fontPitch", "gridHeight", "gridWidth",
    "height", "hidden", "idRef", "isPassword", "justify", "name", "posX", "posY", "reverse", "sample", "scrollBars", "sizePolicy",
    "stretch", "stretchMin", "stretchMax", "style", "tag", "text", "ttyAttr", "underline", "width"
  ],
  "Window": [
    "blink", "bold", "border", "color", "commentLine", "commentLineHidden", "dim", "errorLine", "formLine", "gridHeight",
    "gridWidth", "height", "idRef", "image", "isPassword", "menuLine", "messageLine", "name", "parent", "posX", "posY", "promptLine",
    "reverse", "style", "tag", "text", "ttyAttr", "underline", "width", "windowType"
  ]
};
;

"use strict";

gbc.constants.style = {
  /**
   * The mapping between 4st value and HEX value
   */
  colorMap: {
    green: "#008000",
    darkOlive: "#505000",
    lightTeal: "#33cccc",
    lightOrange: "#ffcc00",
    lightMagenta: "#ffc0ff",
    darkTeal: "#005050",
    lightRed: "#ff8080",
    darkYellow: "#aaaa00",
    lightYellow: "#ffffe0",
    window: "Window",
    windowText: "WindowText",
    buttonFace: "ButtonFace",
    buttonText: "ButtonText",
    highLight: "Highlight",
    highLightText: "HighlightText",
    infoBackground: "InfoBackground",
    infoText: "InfoText",
    grayText: "GrayText",
    appWorkSpace: "AppWorkspace",
    background: "Background",
    systemalternatebackground: "#eeeeee"
  },

  /**
   * The mapping between 4st fontWeight value and CSS
   */
  fontWeightMap: {
    light: "100",
    normal: "400",
    "demi-bold": "600",
    bold: "700",
    black: "900"
  }
};
;

"use strict";

modulum('Event',
  function(context, cls) {
    /**
     * Creates an Event object given a type
     * A property bag used in eventing system
     * @class Event
     * @memberOf classes
     * @publicdoc Base
     */
    cls.Event = context.oo.Class( /** @lends classes.Event.prototype */ {
      __name: "Event",
      cancel: false,
      type: null,
      /**
       * @constructs
       * @param {string} type the event type : actionEvent, configureEvent, keyEvent, functionCallEvent, dragDropEvent, or rowSelectionEvent
       */
      constructor: function(type) {
        this.type = type;
      }
    });
  });
;

"use strict";

/**
 * @typedef {Function} Hook
 * @param {classes.Event} event event object
 * @param {Object} src event emitter
 * @param {...any} additional data
 */
/**
 * @typedef {Function} HandleRegistration
 */

modulum('EventListener', ['Event'],
  function(context, cls) {
    //// debug list unregistered listeners
    //  window.reged = {};
    /**
     * A base class to support eventing
     * @class EventListener
     * @memberOf classes
     * @publicdoc Base
     */
    cls.EventListener = context.oo.Class(function() {
      return /** @lends classes.EventListener.prototype */ {
        /**
         * Literal class name.
         * @type {string}
         * @protected
         */
        __name: "EventListener",

        /**
         * Registered events
         * @type {Map.<string, Array<function>>}
         * @protected
         */
        _events: null,

        /**
         * Handlers for asynchronous calls
         * @type Object[]
         * @protected
         */
        _asyncHandlers: null,

        /**
         * Indicates if object has been destroyed
         * @type {boolean}
         * @protected
         */
        _destroyed: false,

        /**
         * @constructs
         */
        constructor: function() {
          this._events = new Map();
          this._asyncHandlers = [];
        },

        /**
         * Destroy the object and free memory
         * @param {boolean} [forceDestroy] force destroy (must not be delayed)
         */
        destroy: function(forceDestroy) {
          if (!this._destroyed && this._events) {
            this._destroyed = true;
            this._events.clear();
            this._events = null;
            this._clearAllAsyncCalls();
            this._asyncHandlers = null;
          } else {
            context.LogService.warn("Trying to destroy a destroyed Object " + this.__name);
          }
        },

        /**
         * Returns if the node is destroyed
         * @return {boolean} true if node is destroyed
         * @publicdoc
         */
        isDestroyed: function() {
          return this._destroyed;
        },

        /**
         * Emit an event
         * @param {string} type event type to emit
         * @param {...*} args - arguments (excluding type) will be set in event.data
         * @publicdoc
         */
        emit: function(type, ...args) {
          if (this._events) {
            const handlers = this._events.get(type);
            if (handlers && handlers.length) {
              const event = new cls.Event(type);
              event.data = [...args];
              const list = handlers.slice();
              for (const handler of list) {
                if (handler && !event.cancel) {
                  handler.call(this, event, this, ...args);
                }
              }
            }
          }
        },

        /**
         * Registers a handler for this event type
         * @param {string} type - event type (e.g. "attribute changed")
         * @param {function} handler - handler to trigger when the event type is emitted
         * @param {boolean=} once - if true, will only fire once
         * @returns {HandleRegistration} a registration handle (for unbind purpose)
         * @publicdoc
         */
        when: function(type, handler, once) {
          if (this._destroyed) {
            context.LogService.warn("EventListener - Trying to register an event from a destroyed Object: " + type);
            return Function.noop;
          }
          let handlers = this._events.get(type);
          if (!handlers) {
            handlers = [];
            this._events.set(type, handlers);
          }
          let hdlr = handler;
          if (once) {
            hdlr = function(event, src, ...args) {
              this._off(type, hdlr);
              handler.call(this, event, src, ...args);
            }.bind(this);
          }
          handlers.push(hdlr);
          return this._off.bind(this, type, hdlr);
        },

        /**
         * Checks if an event handler has been registered for the given type
         * @param {string} type - event type
         * @return {boolean} true if an event handler has been registered for the given type, false otherwise
         */
        hasEventListeners: function(type) {
          if (this._events) {
            const handlers = this._events.get(type);
            return Boolean(handlers) && handlers.length;
          }
          return false;
        },

        /**
         * Removes an event
         * @param {string} type event type to remove
         * @param {function} handler - event handler id
         * @private
         */
        _off: function(type, handler) {
          //// debug list unregistered listeners
          // if (window.reged[type] && window.reged[type][this.__name]) {
          //   window.reged[type][this.__name]--;
          //   if (!window.reged[type][this.__name]) {
          //     delete window.reged[type][this.__name];
          //   }
          //   if (!Object.keys(window.reged[type]).length) {
          //     delete window.reged[type];
          //
          //   }
          // } else {
          //   console.warn("could not _off event", type, this.__name);
          // }
          if (!this._destroyed) {
            const handlers = this._events.get(type);
            if (handlers) {
              const pos = handlers.indexOf(handler);
              if (pos === -1) {
                gbc.error("We are trying to destroy the wrong event listener ! Please check " + this.__name + " " + type +
                  " event listener bindings and definitions in the project and customizations");
              } else {
                handlers.splice(pos, 1);
                if (handlers.length === 0) {
                  this._events.delete(type);
                }
              }
            } else {
              gbc.error(this.__name + " " + type +
                " event listener has already been destroyed previously. We shouldn't try to remove it again. Please check references and calls of this event listener."
              );
            }
          }
        },

        /**
         * Create a handler of timeout
         * @param {function} callback - function to execute after given time
         * @param {number} time - time in ms before execution
         * @return {?number} - handler
         * @protected
         */
        _registerTimeout: function(callback, time) {
          if (!this._asyncHandlers) {
            return null;
          }
          const timeout = {
            type: "timeout"
          };
          this._asyncHandlers.push(timeout);
          const id = window.setTimeout(function() {
            this._asyncHandlers.remove(timeout);
            callback();
          }.bind(this), time);
          timeout.id = id;
          return id;
        },

        /**
         * Create a handler for requestAnimationFrame
         * @param {function} callback - function to execute after the animation frame
         * @return {number} - handler
         * @protected
         */
        _registerAnimationFrame: function(callback) {
          const requestAnimationFrame = {
            type: "requestAnimationFrame"
          };
          this._asyncHandlers.push(requestAnimationFrame);
          const id = window.requestAnimationFrame(function() {
            this._asyncHandlers.remove(requestAnimationFrame);
            callback();
          }.bind(this));
          requestAnimationFrame.id = id;

          return id;
        },

        _clearTimeout: function(id) {
          if (this._asyncHandlers) {
            this._asyncHandlers.removeMatching(function(handler) {
              return handler.type === "timeout" && handler.id === id;
            });
          }
          window.clearTimeout(id);
        },

        _clearAnimationFrame: function(id) {
          if (this._asyncHandlers) {
            this._asyncHandlers.removeMatching(function(handler) {
              return handler.type === "requestAnimationFrame" && handler.id === id;
            });
          }
          window.cancelAnimationFrame(id);
        },

        /**
         * Clear all asynchronous calls
         * @private
         */
        _clearAllAsyncCalls: function() {
          if (this._asyncHandlers && this._asyncHandlers.length > 0) {
            this._asyncHandlers.forEach(function(handler) {
              if (handler.type === "timeout") {
                window.clearTimeout(handler.id);
              }
              if (handler.type === "requestAnimationFrame") {
                window.cancelAnimationFrame(handler.id);
              }
            });
            this._asyncHandlers = [];
          }
        },
      };
    });
  });
;

"use strict";

modulum('BrowserWindowsService', ['InitService'],
  function(context, cls) {

    /**
     * Service that manages links between browser windows used by sessions
     * @namespace gbc.BrowserWindowsService
     * @gbcService
     * @publicdoc
     */
    context.BrowserWindowsService = context.oo.StaticClass( /** @lends gbc.BrowserWindowsService */ {
      __name: "BrowserWindowsService",

      _eventListener: null,

      /**
       * Initialize the session Service
       */
      init: function() {
        this._eventListener = new cls.EventListener();
        window.addEventListener("multiWindowUnloadRoot", () => {
          window.close();
        });
      },

      /**
       * @returns {Window}
       */
      isRootWindow: function() {
        return window._multiWindowData.isRoot;
      },

      /**
       * @returns {gbc}
       */
      getRootGbc: function() {
        let rootWindow = window._multiWindowData.rootWindow;
        return rootWindow && rootWindow.gbc;
      },

      /**
       * @returns {classes.VMSession}
       */
      getRootSession: function() {
        let rootGbc = this.getRootGbc();
        return rootGbc && rootGbc.SessionService.getCurrent();
      },

      /**
       * @returns {gbc}
       */
      getParentGbc: function() {

      },

      /**
       * @returns {classes.VMSession}
       */
      getParentSession: function() {
        let parentWindow = window._multiWindowData.parentWindow;
        let parentGbc = parentWindow && parentWindow.gbc;
        return parentGbc && parentGbc.SessionService.getCurrent();
      },

      /**
       *
       * @returns {number}
       */
      countChildWindows: function(filter = (w) => true) {
        return window._multiWindowData.directChildren.filter(filter).length;
      },

      /**
       *
       */
      closeAllChildren: function() {
        if (this.isRootWindow()) {
          let children = window._multiWindowData.directChildren;
          while (children.length) {
            const w = children.pop();
            w.__desactivateEndingPopup = true;
          }
        }
      }
    });
    context.InitService.register(context.BrowserWindowsService);
  });
;

"use strict";

modulum('ClipboardService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.ClipboardService
     * @gbcService
     */
    context.ClipboardService = context.oo.StaticClass( /** @lends gbc.ClipboardService */ {
      __name: "ClipboardService",

      /**
       * Text in the clipboard
       * @type {string}
       */
      _txtInClipboard: '',

      /**
       *  Init ClipboardService
       */
      init: function(enable) {
        if (!enable) {
          enable = true;
        }
        document.body.on('paste.Clipboard', this._handlePaste.bind(this));
        document.body.on('copy.Clipboard', this._handleCopy.bind(this));
        document.body.on('cut.Clipboard', this._handleCut.bind(this));

        this._api = enable && navigator.clipboard;
        if (!this._api) {
          context.LogService.warn("Clipboard API is not available on your device");
        }
      },

      /**
       * If you don't want to use the browser's Clipboard API, call this method
       */
      disableApi: function() {
        this._api = false;
      },

      /**
       * Handler when pasting
       * @param {ClipboardEvent} event
       * @private
       */
      _handlePaste: function(event) {
        context.LogService.clipboard.log("Paste event");

        if (!this._canProcessEvent()) {
          return;
        }

        const targetElement = event.target;

        // Get pasted data via clipboard API
        const clipboardData = event.clipboardData || window.clipboardData;
        const pastedData = clipboardData.getData('Text');

        // search widget from dom event
        let widget = gbc.WidgetService.getWidgetFromElement(targetElement);
        // if a widget is found
        if (widget) {

          // Only if client can access to clipboard api
          if (this.canPaste()) {
            // Paste command for waiting vm
            context.SessionService.getCurrent().getCurrentApplication().scheduler.clipboardPasteCommand(pastedData, widget);
            // Cancel the native paste
            event.preventDefault();
          }
        }
      },

      /**
       * Handler called when copy event
       * @param {ClipboardEvent} event
       * @private
       */
      _handleCopy: function(event) {
        context.LogService.clipboard.log("Copy event");

        const targetElement = event.target;
        // search widget from dom event
        let widget = gbc.WidgetService.getWidgetFromElement(targetElement);
        // if a widget is found
        if (widget && navigator.clipboard && navigator.clipboard.readText) {
          if (widget.isInTable()) {
            widget = widget.getTableWidgetBase();
          }
          // Get pasted data via clipboard API
          navigator.clipboard.readText().then(function(text) {
            const copiedText = widget.manageClipboardCopy(text);
            navigator.clipboard.writeText(copiedText);
          });
        }
      },

      /**
       * Handler called when cut event
       * @param {ClipboardEvent} event
       * @private
       */
      _handleCut: function(event) {
        context.LogService.clipboard.log("Cut event");

        const targetElement = event.target;
        // search widget from dom event
        let widget = gbc.WidgetService.getWidgetFromElement(targetElement);
        // if a widget is found
        if (widget && navigator.clipboard && navigator.clipboard.readText) {
          // Get cut data via clipboard API
          const selection = document.getSelection();

          // Paste command for waiting vm
          context.SessionService.getCurrent().getCurrentApplication().scheduler.clipboardCutCommand(selection, widget);

          // Cancel the native cut
          event.preventDefault();
        }
      },

      /**
       * Clear content of clipboard
       */
      clear: async function() {
        context.LogService.clipboard.log("Clear clipboard");

        if (!this.isApiAvailable()) {
          return false;
        }
        try {
          await navigator.clipboard.writeText("");
          return true;
        } catch (e) {
          return false;
        }
      },

      /**
       * Get the content of the clipboard
       */
      get: async function() {
        if (!this.isApiAvailable()) {
          return "";
        }
        try {
          const data = await navigator.clipboard.readText();
          context.LogService.clipboard.log(`Get clipboard value : ${data}`);
          return data;
        } catch (e) {
          return "";
        }
      },

      /**
       * Set the content of the clipboard
       * @param text
       * @param callback
       * @param error
       */
      set: function(text, callback, error) {
        const clipboardApi = navigator.clipboard;
        if (clipboardApi) {
          this.getClipboardData().then(callback).catch(error);
        }
      },

      /**
       * True if the service can handle the Paste command
       * @return {boolean}
       */
      canPaste: function() {
        return navigator.clipboard && navigator.clipboard.readText;
      },

      /**
       * Paste content of clipboard in the given widget
       * @param widget
       */
      pasteToWidget: async function(widget) {
        if (this.isApiAvailable()) {
          const text = await this.get();
          context.SessionService.getCurrent().getCurrentApplication().scheduler.clipboardPasteCommand(text, widget);
          return true;
        }
        return false;
      },

      /**
       * Copy content of the widget to the clipboard
       * @param widget
       * @param {string|boolean} forcedValue
       * @param {Boolean} ignoreSelection
       */
      copyFromWidget: async function(widget, forcedValue, ignoreSelection) {
        let copyData = forcedValue ? forcedValue : await widget.manageClipboardCopy(widget.getClipboardValue(ignoreSelection));

        if (this.isApiAvailable()) {
          context.LogService.clipboard.log(`Set clipboard from widget COPY ${widget._auiName}`);
          await this.setClipboardData(copyData);
        }
        // find another way to get clipboard
        else if (window.clipboardData && window.clipboardData.setData) {
          // IE specific code path to prevent textarea being shown while dialog is visible.
          window.clipboardData.setData("Text", copyData);
        } else if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
          const textarea = document.createElement("textarea");
          if (copyData === "") {
            copyData = " "; // use space string to clean clipboard else it does nothing
          }
          textarea.textContent = copyData;
          textarea.style.position = "fixed"; // Prevent scrolling to bottom of page in MS Edge.
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy"); // Security exception may be thrown by some browsers
            //useModalWindow = !ret;
          } catch (ex) {
            console.warn("Copy to clipboard failed.", ex);
          } finally {
            document.body.removeChild(textarea);
          }
        }
      },

      /**
       * Copy content of the widget to the clipboard
       * @param widget
       */
      cutFromWidget: async function(widget) {
        if (this.isApiAvailable()) {

          const selection = document.getSelection();
          context.SessionService.getCurrent().getCurrentApplication().scheduler.clipboardCutCommand(selection, widget);
        }
      },

      /**
       * Check if clipboard API is available
       * @return {boolean}
       */
      isApiAvailable: function() {
        if (!this._api) {
          context.LogService.clipboard.warn(`Clipboard api not available: fallback mode`);
        }
        return !!this._api;
      },

      /**
       * @return {boolean} false if the application is waiting in background
       * @private
       */
      _canProcessEvent: function() {
        const curSession = context.SessionService.getCurrent();
        const application = curSession && curSession.getCurrentApplication();

        if (application) {
          return application.canProcessEvent();
        }

        return true;
      },

      /**
       * Get the clipboard content
       * @returns {Promise<String>}
       */
      getClipboardData: function() {
        // TODO review this, a "get" function must not change object variable
        this._txtInClipboard = '';

        return new Promise(function(resolve, reject) {
          try {
            if (!this.canPaste()) {
              resolve(this._txtInClipboard);
              return;
            }

            navigator.clipboard.readText().then(function(txt) {
              this._txtInClipboard = txt;
              resolve(this._txtInClipboard);
            }.bind(this));

          } catch (error) {
            reject(error);
          }

        }.bind(this));
      },

      /**
       * Set the clipboard content
       * @returns {Promise<boolean>}
       */
      setClipboardData: async function(textToSet) {
        if (textToSet === null) {
          return false;
        }

        if (this.isApiAvailable()) {
          try {
            await navigator.clipboard.writeText(textToSet);
            context.LogService.clipboard.log(`Set clipboard data: ${textToSet}`);
            return true;
          } catch (e) {
            return false;
          }
        } else {
          //try with modal instead?
          await this._copyToUsingModal(textToSet);
          return true;
        }
      },

      /**
       * add text to the current clipboard content
       */
      addToClipboardData: async function(textToAdd) {
        if (!this.isApiAvailable()) {
          return false;
        }
        try {
          const currentText = await navigator.clipboard.readText();
          await navigator.clipboard.writeText(currentText + textToAdd);
          context.LogService.clipboard.log(`Add data to existing clipboard. New clipboard : ${currentText + textToAdd}`);
          return true;
        } catch (e) {
          return false;
        }
      },

      /**
       * True if the clipboard is empty. Must be called after getClipboardData to retrieve the clipboard data;
       * @returns {boolean}
       */
      isClipboardEmpty: function() {
        return !this._txtInClipboard || this._txtInClipboard.length === 0;
      },

      /** Use modal window with a textarea to copy to clipboard
       *
       * @param text text to copy
       * @param focusElement if !== null after copy the focus will be set on this element
       */
      _copyToUsingModal: async function(text, focusElement) {
        context.LogService.clipboard.warn(`API not available. Set clipboard manually`);
        return new Promise((resolve, _) => {
          // Create a modal with text to copy manually
          const modal = cls.WidgetFactory.createWidget("Modal", {
            appHash: gbc.systemAppId
          });

          modal._gbcSystemModal();
          modal.copyOk = false;

          modal.setClosable(true, true, true);

          const title = cls.WidgetFactory.createWidget("Label", {
            appHash: gbc.systemAppId
          });
          title.setValue(i18next.t("gwc.clipboard.title"));

          const textarea = document.createElement("textarea");
          textarea.textContent = text;
          textarea.readOnly = true;
          textarea.rows = 10;
          textarea.style.width = "100%";

          // Ctrl-C to close the modal
          textarea.on('keydown.ClipboardService', function(event) {
            const char = String.fromCharCode(event.which || event.keyCode); // select all
            if (char.toLowerCase() === 'c' && (event.ctrlKey === true || event.metaKey === true)) {
              // destroy modal in a requestAnimationFrame to be sure browser has the time to do "copy"
              window.requestAnimationFrame(function() {
                modal.copyOk = true;
                modal.hide();
              }.bind(this));
            }
          }.bind(this));
          modal.getElement().querySelector(".mt-dialog-content").addClasses("mt-field", "gbc_TextEditWidget");
          modal.setHeader(title.getElement());
          modal.setContent(textarea);

          document.body.appendChild(modal.getElement());

          textarea.domFocus();

          modal.onClose(function() { // on close focus element and call callback function
            title.destroy();
            modal.destroy();

            textarea.off('keydown.ClipboardService');
            resolve();
            if (focusElement) {
              focusElement.domFocus();
            }

          }.bind(this), true);

          modal.show();
          textarea.select();
        });
      },

      /**
       * Get the current selected text
       * @returns {string}
       */
      getSelection: function() {
        if (window.getSelection) {
          try {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.value) {
              // firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=85686
              return activeElement.value.substring(activeElement.selectionStart, activeElement.selectionEnd);
            } else {
              return window.getSelection().toString();
            }
          } catch (e) {
            console.warn("unable to get the selected text");
          }
        }

        return '';
      }

    });
    context.InitService.register(context.ClipboardService);
  });
;

"use strict";

modulum('DebugAuiController',
  function(context, cls) {

    /**
     * @class DebugAuiController
     * @memberOf classes
     */
    cls.DebugAuiController = context.oo.Class(function() {
      return /** @lends classes.DebugAuiController.prototype */ {
        __name: "DebugAuiController",
        $static: {
          defaultTreeViewItemTemplate: {
            color: "#000000",
            collapsed: false
          },
          highlightAui: 'highlightAui'
        },
        /** @type {classes.MonitorDebugTreeWidget} */
        _treeWidget: null,
        _nodeWidget: null,
        _layoutWidget: null,
        /** @type classes.NodeBase */
        _lastRootNode: null,
        auiSerial: null,
        _currentSelectedNode: null,

        /**
         * Initializer of the controller
         */
        constructor: function() {
          this._treeWidget = cls.WidgetFactory.createWidget("MonitorDebugTree", {
            appHash: gbc.systemAppId
          });
        },

        /**
         * Destroy the controller properly
         */
        destroy: function() {
          if (this._layoutWidget) {
            this._layoutWidget.destroy();
          }
          if (this._nodeWidget) {
            this._nodeWidget.destroy();
          }
          this._treeWidget.destroy();
          this._treeWidget = null;
        },

        /**
         * Get the Debug widget
         * @return {classes.MonitorDebugTreeWidget|null}
         */
        getWidget: function() {
          return this._treeWidget;
        },

        /**
         * Create the node info widget
         * @param {number} id of the node
         * @return {*|HTMLElement}
         */
        _createNodeInfo: function(id) {
          this._nodeWidget = cls.WidgetFactory.createWidget("MonitorDebugNodeInfo", {
            appHash: gbc.systemAppId
          });
          this._displayProperties(this._nodeWidget.getPropertiesContainer(), id);
          return this._nodeWidget.getElement();
        },

        /**
         * Create the layout info widget
         * @param id
         * @return {*|HTMLElement}
         * @private
         */
        _createLayoutInfo: function(id) {
          this._layoutWidget = cls.WidgetFactory.createWidget("MonitorDebugLayoutInfo", {
            appHash: gbc.systemAppId
          });
          this._displayLayout(this._layoutWidget, id);
          return this._layoutWidget.getElement();
        },

        /**
         * Create the subtree item of a given node
         * @param node
         * @return {*|classes.WidgetBase}
         * @private
         */
        _createSub: function(node) {
          const widget = cls.WidgetFactory.createWidget("MonitorDebugTreeItem", {
            appHash: gbc.systemAppId
          });
          let label = node._tag;
          if (node.attribute("name")) {
            label += " (" + node.attribute("name") + ")";
          } else if (node.attribute("value")) {
            const value = node.attribute("value");
            label += " (" + (value.length > 16 ? value.substr(0, 16) + "\u2026" : value) + ")";
          }
          widget.setLabel(label);
          widget.setIdRef(node._id);
          widget.setIconColor((context.constants.debugInfo.auiTreeNodeInfo[node._tag] || cls.DebugAuiController
              .defaultTreeViewItemTemplate)
            .color);
          widget.setCollapsed((context.constants.debugInfo.auiTreeNodeInfo[node._tag] || cls.DebugAuiController
              .defaultTreeViewItemTemplate)
            .collapsed);
          widget.when(gbc.constants.widgetEvents.click, this.showNode.bind(this, node));
          return widget;
        },

        /**
         * Show the node in the tree and in the app
         * @param node
         * @param forceHighlight
         */
        showNode: function(node, forceHighlight) {
          forceHighlight = typeof forceHighlight !== "undefined" ? forceHighlight : false;
          this._currentSelectedNode = node;
          if (forceHighlight) {
            const event = new CustomEvent(cls.DebugAuiController.highlightAui, {
              bubbles: true,
              cancelable: false
            });
            event.auiNodeId = node._id;
            window.dispatchEvent(event);
          }
          this._treeWidget.setSelectedItem(node._id);
          this._treeWidget.setNodeDebugContent(this._createNodeInfo(node._id));
          this._treeWidget.setLayoutInfoContent(this._createLayoutInfo(node._id));
        },

        /**
         * Update the AUI debugger
         * @param {classes.NodeBase} node - node
         */
        refreshDebugAui: function(node) {
          context.styler.bufferize();
          if (node?.getApplication()) {
            this.auiSerial = node.getApplication().getNode(0).auiSerial;
            this._lastRootNode = node;
            this._treeWidget.setFocusedWidget(node.attribute("focus"));

            const subs = function(w, children) {
              for (let i = 0; i < children.length; i++) {
                const widget = this._createSub(children[i]);
                w.addChildWidget(widget);
                subs(widget, children[i].getChildren());
              }
            }.bind(this);
            const rootWidget = this._createSub(node);
            subs(rootWidget, node.getChildren());

            this._treeWidget.empty();
            this._treeWidget.addChildWidget(rootWidget);
            context.styler.flush();
            if (this._currentSelectedNode) {
              this.showNode(this._currentSelectedNode, false);
            }
          } else {
            this._treeWidget.empty();
            if (this._nodeWidget) {
              this._nodeWidget.destroy();
            }
            if (this._layoutWidget) {
              this._layoutWidget.destroy();
            }
          }
        },

        /**
         * Display the layout information of the widget
         * @param {classes.MonitorDebugLayoutInfoWidget} widget - widget concerned
         * @param {number} refId - IdRef of the linked node
         */
        _displayLayout: function(widget, refId) {
          const app = this._lastRootNode.getApplication();
          const omNode = app.getNode(refId);
          if (omNode) {
            const w = omNode.getController() && omNode.getController().getWidget();
            const layoutInfo = w && w.getLayoutInformation();
            if (layoutInfo) {
              widget.setLayoutEngineName(w.getLayoutEngine() && w.getLayoutEngine().__name);
              widget.setPosX(layoutInfo ? layoutInfo.getGridX() : "???");
              widget.setPosY(layoutInfo ? layoutInfo.getGridY() : "???");
              widget.setGridWidth(layoutInfo ? layoutInfo.getGridWidth() : "???");
              widget.setGridHeight(layoutInfo ? layoutInfo.getGridHeight() : "???");
              widget.setWidth(layoutInfo ? layoutInfo.getPreferred().getWidth() : "???");
              widget.setHeight(layoutInfo ? layoutInfo.getPreferred().getHeight() : "???");
              widget.setMeasuredHasSize(layoutInfo ? layoutInfo.getMeasured().hasSize() : "???");
              widget.setMeasuredWidth(layoutInfo ? layoutInfo.getMeasured().getWidth() : "???");
              widget.setMeasuredHeight(layoutInfo ? layoutInfo.getMeasured().getHeight() : "???");
              widget.setMinimalHasSize(layoutInfo ? layoutInfo.getMinimal().hasSize() : "???");
              widget.setMinimalWidth(layoutInfo ? layoutInfo.getMinimal().getWidth() : "???");
              widget.setMinimalHeight(layoutInfo ? layoutInfo.getMinimal().getHeight() : "???");
              widget.setMaximalHasSize(layoutInfo ? layoutInfo.getMaximal().hasSize() : "???");
              widget.setMaximalWidth(layoutInfo ? layoutInfo.getMaximal().getWidth() : "???");
              widget.setMaximalHeight(layoutInfo ? layoutInfo.getMaximal().getHeight() : "???");
              widget.setAvailableHasSize(layoutInfo ? layoutInfo.getAvailable().hasSize() : "???");
              widget.setAvailableWidth(layoutInfo ? layoutInfo.getAvailable().getWidth() : "???");
              widget.setAvailableHeight(layoutInfo ? layoutInfo.getAvailable().getHeight() : "???");
              widget.setAllocatedHasSize(layoutInfo ? layoutInfo.getAllocated().hasSize() : "???");
              widget.setAllocatedWidth(layoutInfo ? layoutInfo.getAllocated().getWidth() : "???");
              widget.setAllocatedHeight(layoutInfo ? layoutInfo.getAllocated().getHeight() : "???");
              widget.setPreferredHasSize(layoutInfo ? layoutInfo.getPreferred().hasSize() : "???");
              widget.setPreferredWidth(layoutInfo ? layoutInfo.getPreferred().getWidth() : "???");
              widget.setPreferredHeight(layoutInfo ? layoutInfo.getPreferred().getHeight() : "???");
              widget.setDecoratingHasSize(layoutInfo ? layoutInfo.getDecorating().hasSize() : "???");
              widget.setDecoratingWidth(layoutInfo ? layoutInfo.getDecorating().getWidth() : "???");
              widget.setDecoratingHeight(layoutInfo ? layoutInfo.getDecorating().getHeight() : "???");
              widget.setDecoratingoffsetHasSize(layoutInfo ? layoutInfo.getDecoratingOffset().hasSize() : "???");
              widget.setDecoratingoffsetWidth(layoutInfo ? layoutInfo.getDecoratingOffset().getWidth() : "???");
              widget.setDecoratingoffsetHeight(layoutInfo ? layoutInfo.getDecoratingOffset().getHeight() : "???");
              widget.setStretchX(layoutInfo ? layoutInfo.getStretched().getX(true) : "???");
              widget.setStretchY(layoutInfo ? layoutInfo.getStretched().getY(true) : "???");
              widget.setChildrenStretchX(layoutInfo ? layoutInfo.isChildrenXStretched() : "???");
              widget.setChildrenStretchY(layoutInfo ? layoutInfo.isChildrenYStretched() : "???");
              widget.setInvalidatedMeasure(layoutInfo ? w._layoutEngine._invalidatedMeasure : "???");
              widget.setInvalidatedAllocatedSpace(layoutInfo ? w._layoutEngine._invalidatedAllocatedSpace : "???");
            } else {
              widget.setNoLayout();
            }
          }
        },

        /**
         * Display the properties of the node
         * @param propertyContainer
         * @param refId
         * @private
         */
        _displayProperties: function(propertyContainer, refId) {
          const app = this._lastRootNode.getApplication();
          const omNode = app && app.getNode(refId);
          if (omNode) {
            const values = {};
            const categories = {};
            context.constants.nodeAttributes[omNode._tag].forEach(function(property) {
              values[property] = null;
              const cat = categories[context.constants.debugInfo.attributeCategory[property]] || [];
              cat.push(property);
              categories[context.constants.debugInfo.attributeCategory[property]] = cat.sort();
            });
            Object.keys(omNode._attributes).forEach(function(key) {
              values[key] = omNode._attributes[key];
            });

            const cats = document.createDocumentFragment();

            Object.keys(categories).sort().forEach(function(category) {
              const hidden = Boolean(gbc.DebugService.auiview['.cat_' + category]);
              const cat = document.createElement("tr"),
                catText = document.createElement("td");
              cat.setAttribute("onclick", "gbc.DebugService.catClicked('" + category + "');");
              catText.setAttribute("colspan", "5");
              catText.addClass("category");
              catText.textContent = category;
              cat.appendChild(catText);
              cats.appendChild(cat);

              const pties = categories[category],
                len = pties.length;
              let i = 0;
              for (; i < len; i++) {
                const property = pties[i],
                  defaultValue = cls.NodeHelper.getAttributeDefaultValue(omNode.tag, property);
                const pty = document.createElement("tr");
                let info = document.createElement("td");
                pty.addClasses("property", "cat_" + category);
                if (omNode._attributesSetByVM[property]) {
                  pty.addClass("changed");
                }
                if (hidden) {
                  pty.addClass("hidden");
                }
                info.textContent = "&nbsp;";
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = property;
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = (values[property] === null) ? defaultValue : values[property];
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = property === "value" ? values[property] : ("" + values[property]).replace(new RegExp("\\s",
                  "g"), "_");
                pty.appendChild(info);
                info = document.createElement("td");
                info.textContent = defaultValue;
                pty.appendChild(info);

                cats.appendChild(pty);
              }
            });

            propertyContainer.empty();
            propertyContainer.appendChild(cats);
          }
        }
      };
    });
  });
;

"use strict";

modulum('DebugService', ['InitService'],
  function(context, cls) {

    /**
     * Debug Service
     * @namespace gbc.DebugService
     * @gbcService
     */
    context.DebugService = context.oo.StaticClass(function() {
      return /** @lends gbc.DebugService */ {
        __name: "DebugService",
        /** @type Window */
        _monitorWindow: null,
        /**
         * @type classes.MonitorWidget
         */
        _widget: null,

        /**
         * @type classes.DebugAuiController
         */
        _debugAuiController: null,
        auiview: null,
        _isDebugWindow: false,
        /**
         * @type classes.EventListener
         */
        _eventListener: null,

        _debugUis: null,
        _active: false,
        _disabled: false,

        _highlightElement: null,
        _highlightTimer: null,
        _highlightDisplayTime: null,

        _gridHighlightColors: null,

        _nodeToShow: null,
        _persistentDebugGrid: false,

        _orderManagedEvent: null,

        _canCounterServer: false,
        /**
         * Check if the current page is a debug monitor
         * @return {boolean} - true if it's the debug monitor, false otherwise
         * @private
         */
        _isMonitor: function() {
          return Boolean(context.UrlService.currentUrl().getQueryStringObject().monitor);
        },

        /**
         * Init service method. should be called only once.
         */
        init: function() {
          this._debugUis = [];
          this._eventListener = new cls.EventListener();
          this._highlightDisplayTime = 2000;
          // Set default style of debug grid highlight
          this._gridHighlightColors = {
            color1: "rgba(255,100,0,0.2)",
            color2: "rgba(255,0,0,0.2)"
          };

          if (this._isMonitor()) {
            this.auiview = {};
            this._isDebugWindow = true;
            this._widget = cls.WidgetFactory.createWidget("Monitor", {
              appHash: gbc.systemAppId
            });
            document.body.appendChild(this._widget.getElement());
            this._debugAuiController = new cls.DebugAuiController();
            this._widget.addChildWidget(this._debugAuiController.getWidget());

            window.setTimeout(function() {
              // Getting correct gbc's instance to inspect
              const rootGbc = window._multiWindowData.parentWindow?.gbc || context.BrowserWindowsService.getRootGbc(),
                session = rootGbc.SessionService.getCurrent(),
                app = session?.getCurrentApplication();
              if (app) {
                this._debugAuiController.refreshDebugAui(app.getNode(0));
                rootGbc.DebugService.attach(window);

                // Refresh debug window at each order
                this._onAppOrdersManaged(app, function() {
                  this._debugAuiController.refreshDebugAui(app.getNode(0));
                }.bind(this));
              }
            }.bind(this), 100);
          } else {
            if (context.__wrapper.isNative()) {
              context.__wrapper.on(context.__wrapper.events.DEBUGNODE, function(event, src, nodeId) {
                this.onHighlightAuiNode({
                  auiNodeId: nodeId
                });
              }.bind(this));
            }
          }
          this.whenActivationChanged(function(event, src, active) {
            if (active) {
              document.body.addClass("gbc_DebugMode");
              if (window.isURLParameterEnabled(window.location.search, "debugcounter")) {
                this.tryCounterServer();
              }
            }
          }.bind(this));
        },

        /**
         * Handler called once application has switched
         */
        onApplicationSwitch: function() {
          if (this._monitorWindow) {
            const debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
            const app = gbc.SessionService.getCurrent().getCurrentApplication();

            // Refresh debug window at each order
            this._onAppOrdersManaged(app, function() {
              debugAuiController.refreshDebugAui(app.getNode(0));
            }.bind(this));

            debugAuiController.refreshDebugAui(app.getNode(0));
            this.attach(this._monitorWindow);
          }
          this.hideHighlightAui();

        },

        /**
         * @return {boolean}
         */
        isMonitorWindow: function() {
          return this._isDebugWindow;
        },

        /**
         * Destroy the service
         */
        destroy: function() {
          if (this._highlightTimer) {
            window.clearTimeout(this._highlightTimer);
            this._highlightTimer = null;
          }
          if (this._monitorWindow) {
            this._monitorWindow.close();
          }
          if (this._orderManagedEvent) {
            this._orderManagedEvent(); //unbind events
          }
        },

        /**
         * Show the Debug window with the AUI tree
         * @param {Number} [auiId] the aimed node id
         */
        show: function(auiId) {
          if (!this._monitorWindow) {
            if (context.__wrapper.isNative()) {
              context.__wrapper.showDebugger(
                context.__wrapper.param(Object.isNumber(auiId) ? auiId : -1, context.SessionService.getCurrent().getCurrentApplication()));
            } else {
              const url = context.UrlService.currentUrl();
              window.open(url.removeQueryString("app").addQueryString("monitor", true).toString());
            }
          } else {
            const uiNode = context.SessionService.getCurrent().getCurrentApplication().getNode(0);
            const debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
            if (uiNode.auiSerial !== debugAuiController.auiSerial) {
              debugAuiController.refreshDebugAui(uiNode);
            }
            this._monitorWindow.focus();
          }
        },

        /**
         *
         * @param monitorWindow
         */
        attach: function(monitorWindow) {
          if (this._monitorWindow !== monitorWindow) {
            this._monitorWindow = monitorWindow;
            this._monitorWindow.document.title = "GBC Debug tools";
            this._monitorWindow.onunload = function() {
              this._monitorWindow = null;
            }.bind(this);
            //persistent Debug Grid
            this._monitorWindow.document.querySelector("#debugGrid").on("change.persistentDebugGrid", function(event) {
              gbc.DebugService.setPersistentDebugGrid(event.target.checked);
            }.bind(this));
            if (this._nodeToShow !== null) {
              this._monitorWindow.gbc.DebugService._debugAuiController.showNode(this._nodeToShow);
              this._nodeToShow = null;
            } else {
              this._monitorWindow.gbc.DebugService._debugAuiController.showNode(window.gbcNode(0));
            }
            this._monitorWindow.addEventListener(context.classes.DebugAuiController.highlightAui, this.onHighlightAuiNode.bind(
              this));
          }
        },

        /**
         * Enable/disable the persistent Debug grid
         * @param status {boolean} - true to enable, false otherwise
         */
        setPersistentDebugGrid: function(status) {
          this._persistentDebugGrid = status;
          if (!status && this._highlightElement) {
            document.body.removeChild(this._highlightElement);
            this._highlightTimer = null;
            this._highlightElement = null;
          }
        },

        /**
         * Define timeout before hiding debug highlight
         * @param time {number} - time to keep debug highlight on screen (in ms) - default: 2000ms
         */
        setHighlightDisplayTime: function(time) {
          this._highlightDisplayTime = time;
        },

        /**
         *
         * @param widget
         */
        registerDebugUi: function(widget) {
          if (this._debugUis.indexOf(widget) < 0) {
            this._debugUis.push(widget);
          }
          widget.activate(this._active);
        },

        /**
         *
         * @param widget
         */
        unregisterDebugUi: function(widget) {
          if (this._debugUis.indexOf(widget) >= 0) {
            this._debugUis.remove(widget);
          }
        },

        /**
         *
         * @param hook
         * @return {*|HandleRegistration}
         */
        whenActivationChanged: function(hook) {
          return this._eventListener.when("debugActivationChanged", hook);
        },

        /**
         * This override the disabled mode
         */
        enable: function() {
          this._disabled = false;
        },

        /**
         *
         */
        disable: function() {
          this._disabled = true;
        },

        /**
         * Activate the Debug service
         * @param {?Boolean} force - true to override the url parameters
         */
        activate: function(force) {
          if (force) {
            this.enable();
          }
          if (!this._active && !this._disabled) {
            this._active = true;
            for (const element of this._debugUis) {
              element.activate(this._active);
            }
            context.classes.DebugHelper.activateDebugHelpers();
            this._registerDebugContextMenu();
            document.body.addClass("gbc_DebugMode");
            this._eventListener.emit("debugActivationChanged", true);
          }
        },

        /**
         *
         * @private
         */
        _registerDebugContextMenu: function() {
          if (!this._isMonitor() && !this.__debugContextMenuRegistered) {
            this.__debugContextMenuRegistered = true;
            window.addEventListener('contextmenu', function(event) {
              const modKey = window.navigator.platform.indexOf('Mac') === 0 ? event.metaKey : event.ctrlKey;
              if (modKey && !event.shiftKey && !event.altKey) {
                const auiNode = window.gbcNode(event.target);
                if (auiNode) {
                  this.show(auiNode.getId());
                  if (this._monitorWindow) {
                    const uiNode = auiNode.getApplication().getNode(0);
                    const debugAuiController = this._monitorWindow.gbc.DebugService._debugAuiController;
                    if (uiNode.auiSerial !== debugAuiController.auiSerial) {
                      debugAuiController.refreshDebugAui(uiNode);
                    }
                    this._monitorWindow.gbc.DebugService._debugAuiController.showNode(auiNode);
                  } else {
                    this._nodeToShow = auiNode;
                  }
                  event.preventCancelableDefault();
                }
              }
            }.bind(this));
          }
        },

        /**
         * Handler called once received orders from the VM
         * @param app - vm application
         * @param callback - hook called once orders are received
         * @private
         */
        _onAppOrdersManaged: function(app, callback) {
          if (this._orderManagedEvent) {
            this._orderManagedEvent();
          }
          this._orderManagedEvent = app.dvm.onOrdersManaged(function() {
            callback();
          }.bind(this));
        },

        /**
         *
         * @return {boolean}
         */
        isActive: function() {
          return this._active;
        },

        /**
         * Hide the highlight layer
         */
        hideHighlightAui: function() {
          if (this._highlightElement) {
            this._highlightElement.addClass("hidden");
          }
        },

        /**
         * Handler called when an element is clicked in AUI tree
         * @param event
         */
        onHighlightAuiNode: function(event) {
          const currentSession = gbc.SessionService.getCurrent();
          const currentApp = currentSession && currentSession.getCurrentApplication();
          if (currentApp) {
            let node = currentApp.getNode(event.auiNodeId);
            if (node.getTag() === 'TreeItem') {
              let table = node;
              while (table.getTag() !== 'Table') {
                table = table.getParentNode();
              }
              const valueIndex = node.attribute('row');
              if (valueIndex === -1) {
                return;
              }
              node = table.getFirstChild('TableColumn').getFirstChild('ValueList').getChildren()[valueIndex];
            }
            let widget = null;
            while (!widget) {
              const ctrl = node.getController();
              if (ctrl) {
                widget = ctrl.getWidget();
              }
              node = node.getParentNode();
            }

            if (this._highlightElement) {
              window.clearTimeout(this._highlightTimer);
              document.body.removeChild(this._highlightElement);
              this._highlightElement = null;
            }

            if (widget._layoutEngine) {
              if (widget._layoutEngine instanceof cls.GridLayoutEngine) {
                this._highlightElement = this.createGridHighlightElement(widget);
              } else if (widget._layoutEngine instanceof cls.DBoxLayoutEngine) {
                this._highlightElement = this.createDBoxHighlightElement(widget);
              }
            }
            if (!this._highlightElement) {
              this._highlightElement = this.createDefaultHighlightElement(widget);
            }

            document.body.appendChild(this._highlightElement);
            if (!this._persistentDebugGrid) {
              this._highlightTimer = window.setTimeout(function() {
                document.body.removeChild(this._highlightElement);
                this._highlightTimer = null;
                this._highlightElement = null;
              }.bind(this), this._highlightDisplayTime);
            }
          }
        },

        /*
         * Change style properties for grid highlight element
         * @param {Object} - style object with backgroundColor and border css
         */
        setGridHighlightColor: function(color1, color2) {
          this._gridHighlightColors = {
            color1,
            color2
          };
        },

        /**
         * Will create an element used to highlight a widget
         * @param widget
         * @return {HTMLElement}
         */
        createDefaultHighlightElement: function(widget) {
          const widgetRect = widget.getElement().getBoundingClientRect();
          const element = document.createElement("div");
          element.style.position = 'fixed';
          element.style.backgroundColor = "rgba(255,0,0,0.5)";
          element.style.border = "1px solid red";
          element.style.zIndex = 999999;
          element.style.top = widgetRect.top + "px";
          element.style.left = widgetRect.left + "px";
          element.style.width = widgetRect.width + "px";
          element.style.height = widgetRect.height + "px";

          document.body.off("keydown.debugLayer");
          document.body.on("keydown.debugLayer", function(event) {
            // Hide debug layer on shift key down
            if (event.shiftKey) {
              element.style.zIndex = -5000;
              this._rebuildDebugLayer = true;
            }
          }.bind(this));

          document.body.off("keyup.debugLayer");
          document.body.on("keyup.debugLayer", function(event) {
            // Rebuild debug layer on shift key up
            if (this._rebuildDebugLayer) {
              this._rebuildDebugLayer = false;
              this.onHighlightAuiNode({
                auiNodeId: widget._auiTag
              });
            }
          }.bind(this));

          // Rebuild debug layer on each layout
          const currentSession = gbc.SessionService.getCurrent();
          const currentApp = currentSession && currentSession.getCurrentApplication();
          if (currentApp) {
            currentApp.layout.afterLayout(this.onHighlightAuiNode.bind(this, {
              auiNodeId: widget._auiTag
            }), true);
          }

          return element;
        },

        /**
         * Will create an element used to highlight a grid widget
         * @param widget
         * @return {HTMLElement}
         */
        createGridHighlightElement: function(widget) {
          const widgetRect = widget.getElement().getBoundingClientRect();
          const element = this.createDefaultHighlightElement(widget);
          element.style.backgroundColor = "";
          element.addClass("persistentDebugGrid");

          const decorating = {
            offsetLeft: widget.getLayoutInformation().getDecoratingOffset().getWidth(true),
            offsetTop: widget.getLayoutInformation().getDecoratingOffset().getHeight(true),
            width: widget.getLayoutInformation().getDecorating().getWidth(true),
            height: widget.getLayoutInformation().getDecorating().getHeight(true)
          };
          const dimensionElementsList = [
            widget._layoutEngine._xspace.dimensionManager.dimensionElements,
            widget._layoutEngine._yspace.dimensionManager.dimensionElements
          ];

          const xSpace = document.createElement("div");
          xSpace.addClass("xSpace");
          const ySpace = document.createElement("div");
          ySpace.addClass("ySpace");

          for (let i = 0; i < dimensionElementsList.length; ++i) {
            const dimensionElements = dimensionElementsList[i];
            let total = 0;
            for (let j = 0; j < dimensionElements.length; ++j) {
              const dimensionElement = dimensionElements[j];
              const bandSize = dimensionElement.getSize(true, true);
              const band = document.createElement("div");
              band.style.position = 'absolute';
              band.style.backgroundColor = j % 2 ? this._gridHighlightColors.color1 : this._gridHighlightColors.colors;
              band.addClass("element");
              if (i === 0) { // X
                band.style.top = 0 + (decorating.offsetTop - 15) + "px";
                band.style.left = total + decorating.offsetLeft + "px";
                band.style.width = bandSize + "px";
                band.style.height = widgetRect.height - decorating.height + 30 + "px";
                xSpace.append(band);
              } else { // Y
                band.style.top = total + decorating.offsetTop + "px";
                band.style.left = 0 + (decorating.offsetLeft - 10) + "px";
                band.style.width = widgetRect.width - decorating.width + 20 + "px";
                band.style.height = bandSize + "px";
                ySpace.append(band);
              }
              total += bandSize;
              band.setAttribute("title", dimensionElement.toString());
            }
          }

          element.appendChild(ySpace);
          element.appendChild(xSpace);

          const widgets = widget._layoutEngine._registeredWidgets;
          const slots = widget._layoutEngine._registeredSlots;
          for (let i = 0; i < widgets.length; ++i) {
            const childWidget = widgets[i];
            const slotX = slots[childWidget.getUniqueIdentifier()].x;
            const slotY = slots[childWidget.getUniqueIdentifier()].y;
            const childWidgetRect = childWidget.getElement().getBoundingClientRect();
            const childRectElement = document.createElement("div");
            childRectElement.addClass("slot");
            childRectElement.style.position = 'fixed';
            childRectElement.style.border = "1px solid red";
            childRectElement.style.top = childWidgetRect.top + "px";
            childRectElement.style.left = childWidgetRect.left + "px";
            childRectElement.style.width = childWidgetRect.width + "px";
            childRectElement.style.height = childWidgetRect.height + "px";
            childRectElement.setAttribute("title", slotX.toString() + "\n--------\n" + slotY.toString());
            element.appendChild(childRectElement);
          }
          return element;
        },

        /**
         * Will create an element used to highlight a DBox widget
         * @param widget
         * @return {HTMLElement}
         */
        createDBoxHighlightElement: function(widget) {
          const widgetRect = widget.getElement().getBoundingClientRect();
          const element = this.createDefaultHighlightElement(widget);

          element.style.backgroundColor = "";

          const children = widget.getChildren();
          let total = 0;
          for (let i = 0; i < children.length; ++i) {
            const bandSize = widget._layoutEngine._getAllocatedSize(children[i]);
            const band = document.createElement("div");
            band.style.position = 'absolute';
            band.style.backgroundColor = i % 2 ? "rgba(255,100,0,0.5)" : "rgba(255,0,0,0.5)";
            if (widget._layoutEngine instanceof cls.HBoxLayoutEngine) {
              band.style.top = 0;
              band.style.left = total + "px";
              band.style.width = bandSize + "px";
              band.style.height = widgetRect.height + "px";
            } else {
              band.style.top = total + "px";
              band.style.left = 0;
              band.style.width = widgetRect.width + "px";
              band.style.height = bandSize + "px";
            }
            total += bandSize;
            element.appendChild(band);
          }

          return element;
        },

        /**
         *
         * @param catName
         * @param noToggle
         */
        catClicked: function(catName, noToggle) {
          if (!noToggle) {
            this.auiview['.cat_' + catName] = !this.auiview['.cat_' + catName];
          }
          const elements = document.body.getElementsByClassName('cat_' + catName);
          let i = 0;
          const len = elements.length;
          for (; i < len; i++) {
            elements[i].toggleClass("hidden", Boolean(this.auiview['.cat_' + catName]));
          }
        },

        tryCounterServer: function() {
          try {
            fetch("http://localhost:9999/")
              .then(function() {
                this._canCounterServer = true;
              }.bind(this))
              .catch(function() {
                this._canCounterServer = false;
              }.bind(this));

          } catch (e) {
            this._canCounterServer = false;
          }
        },

        count: function(name) {
          if (this._canCounterServer) {
            try {
              fetch("http://localhost:9999/var/increment/" + name).catch();
            } catch (e) {
              //
            }
          }
        }
      };
    });
    context.InitService.register(context.DebugService);
  });
;

"use strict";

modulum('DndService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.DndService
     * @gbcService
     */
    context.DndService = context.oo.StaticClass( /** @lends gbc.DndService */ {
      __name: "DndService",

      tableStartDragNode: null,
      tableCurrentDragNode: null,
      valueStartDragNode: null,
      dragDropInfoNode: null,
      dragOverValueNode: null,
      firstDragEnterSent: false,
      dragOverTreeItemNode: null,
      dndAccepted: false,

      init: function() {},

      /**
       * DragStart handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragStart: function(tableNode, valueNode, evt) {

        this.firstDragEnterSent = false;
        this.tableStartDragNode = tableNode;
        this.valueStartDragNode = valueNode;

        const events = [];

        // Send currentRow to VM
        const localStartDragRowIndex = valueNode.getParentNode().getChildren().indexOf(valueNode);
        const startDragRowIndex = tableNode.attribute("offset") + localStartDragRowIndex;
        events.push(new cls.VMConfigureEvent(tableNode.getId(), {
          currentRow: startDragRowIndex
        }));

        // Send row selection extension if mrs is enabled
        if (tableNode.attribute("multiRowSelection") === 1) {
          const startDragRowIndexIsSelected = (tableNode.getChildren("RowInfoList")[0].getChildren()[localStartDragRowIndex]
            .attribute(
              "selected") === 1);
          if (startDragRowIndexIsSelected === false) {
            events.push(new cls.VMRowSelectionEvent(tableNode.getId(), {
              startIndex: startDragRowIndex,
              endIndex: startDragRowIndex,
              selectionMode: "set"
            }));
          }
        }

        // Send dragStart event to VM
        events.push(new cls.VMDragDropEvent(this.tableStartDragNode.getId(), {
          dndEventType: "dragStart"
        }));
        this.tableStartDragNode.getApplication().scheduler.eventVMCommand(events, this.tableStartDragNode);
      },

      /**
       * DragLeave handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragLeave: function(tableNode, valueNode, evt) {
        // no need all is done in onDragOver function
      },

      /**
       * DragEnter handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragEnter: function(tableNode, valueNode, evt) {
        // no need all is done in onDragOver function
      },

      /**
       * DragOver handler
       * @param tableNode
       * @param valueNode
       * @param evt
       */
      onDragOver: function(tableNode, valueNode, evt) {

        if (!this.dragDropInfoNode || !valueNode) {
          return;
        }

        this._showHideDropIndicator(this.dragOverValueNode, false);

        if (this.dragDropInfoNode.attribute("dndAccepted") === 1 && this.firstDragEnterSent) {
          evt.preventCancelableDefault();
        }

        const valueListNode = valueNode.getParentNode();
        const tableColumnNode = valueListNode.getParentNode();
        const indexValue = valueListNode.getChildren().indexOf(valueNode);
        const isTreeView = tableColumnNode.getParentNode().getController().getWidget().isTreeView();
        let treeItemParentNode = null;
        if (isTreeView) {
          const mousePositionTop = evt.offsetY;

          treeItemParentNode = tableNode.getChildren("TreeInfo")[0].findNodeWithAttribute('TreeItem', 'row', indexValue);
          if (treeItemParentNode && mousePositionTop < 6) { // if mouse position is between two tree items
            treeItemParentNode = treeItemParentNode.getAncestor("TreeItem");
          }
        }

        this._showHideDropIndicator(valueNode, true, treeItemParentNode);

        if (this.dragOverValueNode !== valueNode || this.dragOverTreeItemNode !== treeItemParentNode) {

          let event = null;
          if (this.tableCurrentDragNode !== tableNode) {

            if (this.tableCurrentDragNode !== null) {
              // Send dragLeave event to VM
              event = new cls.VMDragDropEvent(this.tableCurrentDragNode.getId(), {
                dndEventType: "dragLeave"
              });
              this.tableStartDragNode.getApplication().scheduler.eventVMCommand(event, this.tableStartDragNode);
            }

            this.tableCurrentDragNode = tableNode;

            event = new cls.VMDragDropEvent(tableNode.getId(), {
              dndEventType: "dragEnter",
              dndMimeTypes: this.dragDropInfoNode.attribute("dndMimeTypes"),
              dndOperation: "move"
            });
            tableNode.getApplication().scheduler.eventVMCommand(event, tableNode);
            this.firstDragEnterSent = true;
          } else {

            this.dragOverValueNode = valueNode;
            this.dragOverTreeItemNode = treeItemParentNode;

            if (this.firstDragEnterSent === false) {
              return; // don't send drag over if drag enter has not been sent before
            }

            if (valueNode === this.valueStartDragNode) {
              return; // don't send drag over event to the node which start the drag
            }

            const tableSize = tableNode.attribute("size");
            if (indexValue >= tableSize && this.dragDropInfoNode.attribute("dndFeedback") === "select") {
              return; // don't send drag over event to a node > tableSize if feedback is select
            }

            let dndOperation = this.dragDropInfoNode.attribute("dndOperation");
            dndOperation = dndOperation === "" ? "move" : dndOperation;

            if (isTreeView === false) {
              event = new cls.VMDragDropEvent(valueNode.getId(), {
                dndEventType: "dragOver",
                dndOperation: dndOperation
              });
            } else {
              event = new cls.VMDragDropEvent(valueNode.getId(), {
                dndEventType: "dragOver",
                dndOperation: dndOperation,
                dndParentIdRef: treeItemParentNode ? treeItemParentNode.getId() : -1
              });
            }
            this.tableStartDragNode.getApplication().scheduler.eventVMCommand(event, valueNode);
          }
        }

      },

      /**
       * DragEnd handler
       */
      onDragEnd: function() {
        let dndOperation = "";
        if (this.dragDropInfoNode) {
          dndOperation = this.dragDropInfoNode.attribute("dndOperation");
        }
        dndOperation = dndOperation === "" ? "move" : dndOperation;

        // Send dragFinished event to VM
        const event = new cls.VMDragDropEvent(this.tableStartDragNode.getId(), {
          dndEventType: "dragFinished",
          dndOperation: dndOperation
        });
        this.tableStartDragNode.getApplication().scheduler.eventVMCommand(event, this.tableStartDragNode);

        this._showHideDropIndicator(this.dragOverValueNode, false);

        this.tableCurrentDragNode = null;
        this.tableStartDragNode = null;
        this.valueStartDragNode = null;
        this.dragOverValueNode = null;
        this.firstDragEnterSent = false;
        this.dragOverTreeItemNode = null;
      },

      /**
       * Drop handler
       * @param valueNode
       */
      onDrop: function(valueNode) {

        if (!this.dragDropInfoNode || !valueNode) {
          return;
        }

        this._showHideDropIndicator(valueNode, false);

        // Send drop event to VM
        const event = new cls.VMDragDropEvent(valueNode.getId(), {
          dndEventType: "drop",
          dndBuffer: this.dragDropInfoNode.attribute("dndBuffer")

        });
        valueNode.getApplication().scheduler.eventVMCommand(event, valueNode);
      },

      /**
       * Show or hide drop indicator
       * @param {classes.NodeBase} valueNode valueNode to find the row
       * @param {boolean} show if true show indicator, else hide it
       * @param {classes.NodeBase} [overTreeItem] draw over treeitem indicator
       * @private
       */
      _showHideDropIndicator: function(valueNode, show, overTreeItem) {
        if (!valueNode) {
          return;
        }

        const valueListNode = valueNode.getParentNode();
        const tableNode = valueListNode.getParentNode().getParentNode();
        const indexInValueList = valueListNode.getChildren().indexOf(valueNode);
        let parentTreeValueRow = -1;
        if (overTreeItem) {
          parentTreeValueRow = overTreeItem.attribute("row");
        }

        // Draw line to visualize where the drop will be done
        const columns = tableNode.getChildren("TableColumn");
        for (const c of columns) {
          const valueList = c.getChildren()[1];
          if (valueList) {
            const w = valueList.getChildren()[indexInValueList].getController().getWidget();
            if (w) {
              const element = w.getParentWidget().getElement();

              element
                .removeClass("dropIndicatorInsert")
                .removeClass("dropIndicatorSelect")
                .removeClass("dropIndicatorInsertAfter");

              if (show && this.dndAccepted && this.firstDragEnterSent) {
                const dndFeedback = this.dragDropInfoNode.attribute("dndFeedback");
                if (overTreeItem && indexInValueList === parentTreeValueRow) {
                  element.addClass("dropIndicatorSelect");
                } else if (dndFeedback === "insert") {
                  element.addClass("dropIndicatorInsert");
                } else if (dndFeedback === "select") {
                  element.addClass("dropIndicatorSelect");
                } else if (dndFeedback === "insert_after") {
                  element.addClass("dropIndicatorInsertAfter");
                }
              }
            }
          }
        }
      }

    });
    context.InitService.register(context.DndService);
  });
;

"use strict";

modulum('ForegroundBackgroundService', ['InitService'],
  function(context, cls) {

    /**
     * Foreground Background Service to handle foreground & background modes in browser with the corresponding predefined actions
     * @namespace gbc.ForegroundBackgroundService
     * @gbcService
     */
    context.ForegroundBackgroundService = context.oo.StaticClass( /** @lends gbc.ForegroundBackgroundService */ {
      __name: "ForegroundBackgroundService",

      /**
       * Handle to watch document visibility changes.
       * @type {HandleRegistration}
       */
      _visibilityChangeHandler: null,

      /**
       * Initialize the service
       */
      init: function() {
        this._visibilityChangeHandler = context.InitService.when(
          context.constants.widgetEvents.visibilityChange,
          this._onVisibilityChangeCommand.bind(this)
        );
      },

      /**
       * Generates enterbackground/enterforeground commands in scheduler depending on document visibility
       * @private
       */
      _onVisibilityChangeCommand: function() {
        const app = context.SessionService.getCurrent() && context.SessionService.getCurrent().getCurrentApplication();
        if (app) {
          if (document.hidden) {
            // document.hidden is similar to document.visibilityState to listen to browser inactive/active tabs (historically named Page API)
            if (!context.NativeService.hasActiveNativeAction("enterbackground")) {
              // Do not send enterbackground command if it is already sent by NativeService (UR)
              app.scheduler.enterBackgroundCommand();
            }
          } else {
            if (!context.NativeService.hasActiveNativeAction("enterforeground")) {
              // Do not send enterforeground command if it is already sent by NativeService (UR)
              app.scheduler.enterForegroundCommand();
            }
          }
        }
      },

      /**
       * @inheritDoc
       */
      destroy: function() {
        if (this._visibilityChangeHandler) {
          this._visibilityChangeHandler();
          this._visibilityChangeHandler = null;
        }
      },
    });
    context.InitService.register(context.ForegroundBackgroundService);
  });
;

"use strict";

modulum('FrontCallService.modules.localStorage', ['FrontCallService'],
  function(context, cls) {

    /**
     * Local storage module to store variables into browser's local storage
     * @instance localStorage
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.localStorage = /** @lends gbc.FrontCallService.modules.localStorage */ {

      /**
       * Set an item in browser's local storage
       * @param {string} key of the item
       * @param {*} value of the item
       * @returns {Array} empty
       */
      setItem: function(key, value) {
        if (!key) {
          this.parametersError();
          return [];
        }
        try {
          let content = context.LocalSettingsService.read('userLocalStorage');
          if (!content) {
            content = {};
          }
          content[key] = value;
          context.LocalSettingsService.write('userLocalStorage', content);
        } catch (ex) {
          this.runtimeError('Could not setItem in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get an item from browser's local storage
       * @param {string} key identifier of the item to get
       * @returns {*}
       */
      getItem: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        const content = context.LocalSettingsService.read('userLocalStorage');
        return (content && content[key]) ? [content[key]] : [];
      },

      /**
       * Remove an item in browser's local storage
       * @param {string} key identifier of the item to remove
       * @returns {Array} empty
       */
      removeItem: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        try {
          let content = context.LocalSettingsService.read('userLocalStorage');
          if (content) {
            delete content[key];
          } else {
            content = {};
          }
          context.LocalSettingsService.write('userLocalStorage', content);
        } catch (ex) {
          this.runtimeError('Could not removeItem in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get all the items keys in browser's local storage
       * @returns {string[]}
       */
      keys: function() {
        const content = context.LocalSettingsService.read('userLocalStorage');
        return content ? [JSON.stringify(Object.keys(content))] : [];
      },

      /**
       * Empty the browser's local storage
       * @returns {Array} empty
       */
      clear: function() {
        try {
          context.LocalSettingsService.write('userLocalStorage', {});
        } catch (ex) {
          this.runtimeError('Could not clear in localStorage. Maximum size may be reached.');
        }
        return [];
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.mobile', ['FrontCallService'],
  function(context, cls) {
    /**
     * Private helper function for the photo/video selection mobile frontcalls
     * @param type input type, should be "file"
     * @param accept image or video
     * @param capture null for file selector, environment for primary camera
     */
    const manageInput = function(type, accept, capture) {
      let input = document.createElement('input');
      input.type = type;
      input.accept = accept;
      if (capture) {
        input.capture = capture;
      }

      input.oncancel = () => {
        this.setReturnValues([null]);
      };
      input.onchange = (e) => {
        var file = e.target.files[0];
        if (file) {
          this.setReturnValues([URL.createObjectURL(file)]);
        } else {
          this.setReturnValues([null]);
        }
      };

      if (!window.browserInfo.isSafari) {
        input.click();
      } else {
        // setTimeout at 0ms to wait until the JS event stack is cleared and has processed the previous input init code
        // https://stackoverflow.com/a/779785
        setTimeout(() => {
          input.click();
        });
        setTimeout(() => {
          // empty timeout that makes "capture" type work
        }, 3000);
      }
    };

    /**
     * Mobile module to store variables into browser's sessions
     * @instance mobile
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.mobile = /** @lends gbc.FrontCallService.modules.mobile */ {

      /**
       * Invokes the mobile device's contact list to select a contact
       * Only available on chrome Android
       * Returns the vCard of the contact
       */
      chooseContact: async function() {
        if (!navigator.contacts) {
          this.runtimeError("This browser does not support chooseContact");
          return;
        }

        try {
          const contactProperties = ["name", "email", "tel", "address"];
          const contact = await navigator.contacts.select(contactProperties);
          if (!contact || !contact[0]) {
            this.setReturnValues([null]);
            return;
          }

          const [firstContact] = contact;
          const {
            name = "", address = "", tel = "", email = ""
          } = firstContact;

          const vCard =
            `BEGIN:VCARD\n` +
            `VERSION:4.0\n` +
            `FN:${name};\n` +
            `TEL;TYPE=voice;VALUE=uri:tel:${tel}\n` +
            `ADR;LABEL=${address}\n` +
            `EMAIL:${email}\n` +
            `END:VCARD\n`;
          this.setReturnValues([vCard]);
        } catch (ex) {
          this.runtimeError(ex);
        }
      },

      /**
       * Invokes the device's default mail app
       * Returns ok if the app was opened, failed otherwise
       */
      composeMail: function(to, subject, content, cc = "", bcc = "", attachments = null) {
        const statusOK = "ok";
        const statusFAILED = "failed";

        if (!to || !subject || !content) {
          this.parametersError("Missing parameter");
          return;
        }

        if (attachments) {
          this.parametersError("Attachments are not supported by GBC frontcalls");
          return;
        }

        try {
          window.open(`mailto:${to}?cc=${cc}&bcc=${bcc}&subject=${subject}&body=${content}`);
        } catch (e) {
          this.setReturnValues([`${statusFAILED}: ${e}`]);

          return;
        }
        this.setReturnValues([statusOK]);
      },

      /**
       * Invokes the device's default messaging app
       * Returns ok if the app was opened, failed otherwise
       */
      composeSMS: function(recipients, content) {
        const statusOK = "ok";
        const statusFAILED = "failed";

        if (!recipients || !content) {
          this.parametersError("Missing parameter");
          return;
        }

        try {
          window.location = `sms:+${recipients};?&body=${content}`;
        } catch (e) {
          this.setReturnValues([statusFAILED]);
          return;
        }
        return [statusOK];
      },

      /**
       * On Android, checks for the specific type of connection, otherwise checks for online/offline status
       * Returns the type of connection
       */
      connectivity: function() {
        const statusNONE = "NONE";
        const statusWIFI = "WIFI";
        const statusETHERNET = "Ethernet";
        const statusMOBILE = "MobileNetwork";
        const statusUNDEFINED = "Undefined Network";

        if (!navigator.connection) {
          // Check for any kind of connection
          if (navigator.onLine) {
            this.setReturnValues([statusUNDEFINED]);
            return;
          }
          this.setReturnValues([statusNONE]);
          return;
        }

        if (typeof navigator.connection.type === "undefined") {
          this.setReturnValues([statusUNDEFINED]);
          return;
        }

        if (navigator.connection.type === "cellular") {
          return this.setReturnValues([statusMOBILE]);
        }
        if (navigator.connection.type === "ethernet") {
          return this.setReturnValues([statusETHERNET]);
        }
        if (navigator.connection.type === "wifi") {
          return this.setReturnValues([statusWIFI]);
        }

        if (navigator.onLine) {
          this.setReturnValues([statusUNDEFINED]);
          return;
        }

        return this.setReturnValues([statusNONE]);
      },

      /**
       * Checks that the content is in the foreground
       * Returns true if the page content is at least partially visible (foreground tab of a non minimized window)
       */
      isForeground: function() {
        try {
          this.setReturnValues([document.visibilityState === "visible"]);
        } catch (e) {
          this.runtimeError("This browser does not support visibility check");
        }
      },

      /**
       * Opens a BarcodeScanner widget to scan any barcode with the device's primary camera
       * Returns two strings: first string for barcode's data, second string for barcode's type
       */
      scanBarCode: async function() {
        if (!("BarcodeDetector" in window)) {
          this.runtimeError("This browser does not support barcode detection");
          return;
        }
        const app = this.getAnchorNode().getApplication();
        this._barcodeScannerWidget = cls.WidgetFactory.createWidget("BarcodeScanner", {
          appHash: app.applicationHash
        });
        app.layout.afterLayout(() => {
          this._barcodeScannerWidget.resizeHandler();
        });
        app.getUI().getWidget().getElement().appendChild(this._barcodeScannerWidget.getElement());
        try {
          await this._barcodeScannerWidget.show();
        } catch (error) {
          this.runtimeError("Error starting stream: " + error);
          return;
        }
        this._barcodeScannerWidget.onClose(() => {
          this.setReturnValues([null, "cancelled"]);
        });
        this._barcodeScannerWidget.detectBarcode((data) => {
          if (data) {
            this.setReturnValues([data.rawValue, data.format.toUpperCase()]);
          } else {
            this.setReturnValues([null, "cancelled"]);
          }
        });
      },

      /**
       * Opens the device's gallery (mobile) or file explorer (desktop) to select an image
       * Returns the blob URL to the selected photo
       */
      choosePhoto: function() {
        manageInput.call(this, 'file', 'image/*');
      },

      /**
       * Opens the device's gallery or file explorer to select a video
       * Returns the blob URL to the selected video
       */
      chooseVideo: function() {
        manageInput.call(this, 'file', 'video/*');
      },

      /**
       * Opens the device's camera (mobile) or file explorer (desktop) to capture an image
       * Returns the blob URL to the captured photo
       */
      takePhoto: function() {
        manageInput.call(this, 'file', 'image/*', 'environment');
      },

      /**
       * Opens the device's camera (mobile) or file explorer (desktop) to capture a video
       * Returns the blob URL to the captured video
       */
      takeVideo: function() {
        manageInput.call(this, 'file', 'video/*', 'environment');
      },

      /**
       * Get Browser's Geolocation
       * Returns status, latitude, longitude
       */
      getGeolocation: function() {
        // See : http://dev.w3.org/geo/api/spec-source.html
        const statusOK = "ok";
        const statusKO = "nok";

        if (!navigator.geolocation) {
          this.runtimeError("This browser does not support geolocalisation");
          return;
        }

        navigator.geolocation.getCurrentPosition(
          function(position) {
            this.setReturnValues([statusOK, position.coords.latitude, position.coords.longitude]);
          }.bind(this),
          function(error) {
            switch (error.code) {
              case error.PERMISSION_DENIED:
                this.setReturnValues([statusKO, 'PERMISSION_DENIED']);
                return;
              case error.POSITION_UNAVAILABLE:
                this.setReturnValues([statusKO, 'POSITION_UNAVAILABLE']);
                return;
              case error.TIMEOUT:
                this.setReturnValues([statusKO, 'TIMEOUT']);
                return;
              default:
                this.setReturnValues([statusKO, 'UNKNOWN_ERROR']);
                return;
            }
          }.bind(this)
        );
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.qa', ['FrontCallService'],
  function(context, cls) {
    /**
     * Frontcall service QA related module
     * @instance qa
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.qa = {

      /**
       * First function to call in a QA environement
       * @return {Array}
       */
      startqa: function() {
        gbc.qaMode = true;
        return [''];
      },

      /**
       * Clean GBC Stored Settings to unsure clean environement
       * @return {Array}
       */
      removestoredsettings: function() {
        window.gbc.StoredSettingsService.reset();
        return [''];
      },

      /**
       * Get an attribute according to its name
       * @param {Number} id of the element
       * @param {String} name of the attribute to get
       * @return {Array}
       */
      getattribute: function(id, name) {
        const element = document.querySelector('[data-aui-id="' + JSON.parse(id).id + '"]');

        if (element) {
          switch (name) {
            case "width":
              return [element.getBoundingClientRect().width];
            case "height":
              return [element.getBoundingClientRect().height];
            case "text":
              const textHolder = element.querySelector(".gbc-label-text-container") ||
                element.querySelector(".gbc_dataContentPlaceholder") || element;
              return [(textHolder.value || textHolder.textContent).trim()];
            case "image":
              const img = element.querySelector("img");
              const cssBg = window.getComputedStyle(element).backgroundImage;
              const urlRegex = /url\("(.*)"\)/.exec(cssBg);
              const url = (urlRegex && urlRegex.length >= 1) ? urlRegex[1] : "";
              return [(img && img.attributes.src.value) ? img.attributes.src.value : url];
            default:
              console.log("getAttribute not supported property:", name);
          }
        }
        console.log("getAttribute", id, name);

        return [''];
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.session', ['FrontCallService'],
  function(context, cls) {
    /**
     * Session module to store variables into browser's sessions
     * @instance session
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.session = /** @lends gbc.FrontCallService.modules.session */ {
      _name: 'session_gwcJS',

      /**
       * Set a variable into browser's sessions
       * @param {string} key identifier of the variable to store
       * @param {*} value of the variable to store
       * @returns {Array}
       */
      setvar: function(key, value) {
        if (!key) {
          this.parametersError();
          return [];
        }
        const sessionObj = context.LocalSettingsService.read(context.FrontCallService.modules.session._name) || {};
        sessionObj[key] = value;
        try {
          context.LocalSettingsService.write(context.FrontCallService.modules.session._name, sessionObj);
        } catch (ex) {
          this.runtimeError('Could not write in localStorage. Maximum size may be reached.');
        }
        return [];
      },

      /**
       * Get a variable from browser's sessions
       * @param {string} key identifier of the item to get
       * @returns {*}
       */
      getvar: function(key) {
        if (!key) {
          this.parametersError();
          return [];
        }
        const sessionObj = context.LocalSettingsService.read(context.FrontCallService.modules.session._name) || {};
        const value = sessionObj[key];
        if (value) {
          return [value];
        } else {
          return [];
        }
      },
    };
  }
);
;

'use strict';

modulum('FrontCallService.modules.standard', ['FrontCallService'],
  function(context, cls) {
    context.TemplateService.registerRawTemplate('FrontCallStandardPlaySound', '<audio></audio>');

    /**
     * Standard module of Frontcall Service
     * @instance standard
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.standard = /** @lends gbc.FrontCallService.modules.standard */ {

      /**
       * Adds to the content of the clipboard
       * @param textToAdd to the current clipboard
       * @returns {?boolean[]}
       */
      cbAdd: async function(textToAdd) {
        if (!textToAdd) {
          this.parametersError();
          return;
        }
        const result = await context.ClipboardService.addToClipboardData(textToAdd);
        this.setReturnValues([result]); // TRUE=success, FALSE=error
      },

      /**
       * Clears the content of the clipboard.
       * @returns {boolean[]} - true if supported and succeed false otherwise
       */
      cbClear: async function() {
        const result = await context.ClipboardService.clear();
        this.setReturnValues([result]); //execution status (TRUE=success, FALSE=error).
      },

      /**
       * Gets the content of the clipboard.
       * @returns {string[]} - content of the clipboard
       */
      cbGet: async function() {
        const textResult = await context.ClipboardService.get();
        this.setReturnValues([textResult]);
      },

      /**
       * Pastes the content of the clipboard to the current field.
       * @returns {boolean[]}
       */
      cbPaste: async function() {
        if (!context.ClipboardService.isApiAvailable()) {
          // Not supported without the Clipboard API
          this.setReturnValues([false]);
        }

        // find focused node to paste content to
        const focusedNode = this.getAnchorNode().getApplication().getFocusedVMNode();
        if (focusedNode && focusedNode.getController() && focusedNode.getController().getWidget()) {
          const focusedWidget = focusedNode.getController().getWidget();
          const pasteResult = await context.ClipboardService.pasteToWidget(focusedWidget);
          this.setReturnValues([pasteResult]);
        }
      },

      /**
       * Set the content of the clipboard.
       * @param text
       * @returns {?boolean[]}
       */
      cbSet: async function(text) {
        if (text === undefined) {
          this.parametersError();
          return;
        }
        const result = await context.ClipboardService.setClipboardData(text);
        this.setReturnValues([result]);
      },

      /**
       * Invokes the device's default mail app
       * Returns ok if the app was opened, failed otherwise
       * (Alias of mobile module's composeMail)
       */
      composeMail: function(to, subject, content, cc = "", bcc = "", attachments = null) {
        context.FrontCallService.modules.mobile.composemail.call(this, to, subject, content, cc, bcc, attachments);
      },

      /**
       * On Android, checks for the specific type of connection, otherwise checks for online/offline status
       * Returns the type of connection
       * (Alias of mobile module's connectivity)
       */
      connectivity: function() {
        context.FrontCallService.modules.mobile.connectivity.call(this);
      },

      /**
       * Executes a command on the front-end platform, with or without waiting.
       * @unsupported
       * @param command
       * @param wait
       * @returns {boolean[]}
       */
      execute: function(command, wait) {
        return [false];
      },

      /**
       * Queries general front-end properties.
       * @param {string} kind of module to call
       * @returns {*}
       */
      feinfo: function(kind) {
        if (kind === undefined) {
          this.parametersError();
          return;
        }
        if (kind.toLowerCase) {
          switch (kind.toLowerCase()) {
            case 'browsername':
              if (window.browserInfo.isFirefox) {
                return ['Firefox'];
              } else if (window.browserInfo.isChrome) {
                return ['Chrome'];
              } else if (window.browserInfo.isIE) {
                return ['Internet Explorer'];
              } else if (window.browserInfo.isEdge) {
                return ['Edge'];
              } else if (window.browserInfo.isOpera) {
                return ['Opera'];
              } else if (window.browserInfo.isSafari) {
                return ['Safari'];
              }
              return ['Unknown'];
              // The code identifying the type of front-end component.
            case 'fename':
              return ['GBC'];
              // Returns "1" if the front-end runs in Active X mode (GDC specific). Unsupported in GBC
            case 'isactivex':
              return [false];
              // Number of screens available on the front-end platform. Always return 1 in GBC
            case 'numscreens':
              return [1];
              // The operating system type where the front-end is running.
            case 'ostype':
              if (navigator.appVersion.indexOf('Win') !== -1) {
                return ['WINDOWS'];
              } else if (navigator.appVersion.indexOf('Android') !== -1) {
                return ['ANDROID'];
              } else if (navigator.appVersion.indexOf('iPhone') !== -1 || navigator.appVersion.indexOf('iPad') !== -1) {
                return ['IOS'];
              } else if (navigator.appVersion.indexOf('Linux') !== -1) {
                return ['LINUX'];
              } else if (navigator.appVersion.indexOf('Mac') !== -1) {
                return ['OSX'];
              }
              return ['Unknown OS Type'];
              // The version of the operating system. Always unknow in GBC.
            case 'osversion':
              return ['Unknown'];
              // Unsupportedin GBC, deprecated in 3.10
            case 'outputmap':
              return [''];
              // Returns the screen pixel density of the front-end platform
            case 'ppi':
              return [window.devicePixelRatio * 96];
              // Returns the screen resolution of the front-end platform
            case 'screenresolution':
              return [(window.devicePixelRatio * screen.width) + 'x' + (window.devicePixelRatio * screen
                .height)]; // taking pixel ratio into account
              // Returns the build platform target code name
            case 'target':
              return ['web'];
              // Returns the current size of the front-end view-port.
            case 'windowsize':
              return [window.document.body.clientWidth + 'x' + window.document.body.clientHeight];
              // Returns the language and territory of the locale
            case 'userpreferredlang':
              return [gbc.StoredSettingsService.getLanguage()];
              // Get browser theme, dark or light
            case 'colorscheme':
              if (window.matchMedia) {
                return (window.matchMedia('(prefers-color-scheme: light)').matches) ? ['light'] : ['dark'];
              }
              return ['light'];
          }
        }
        return [''];
      },

      /**
       * Retrieves a file from the front-end context to the virtual machine context.
       * @param filename
       * @param url
       */
      fgl_getfile: function(filename, url) { // jshint ignore:line
        if (!filename || !url) {
          this.parametersError();
          return;
        }
        const app = this.getAnchorNode().getApplication();
        app.filetransfer.getFile({
            fileTransferUrl: url,
            filename: filename
          }, function() {
            this.setReturnValues([]);
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Transfers a file from the virtual machine context to the front end context.
       * @param url
       * @param filename
       * @returns {?Array}
       */
      fgl_putfile: function(url, filename) { // jshint ignore:line
        if (!url || !filename) {
          this.parametersError();
          return undefined;
        }
        const cdUrl = url + (url.indexOf("?") >= 0 ? "&" : "?") + "ContentDisposition=attachment";
        const node = this.getAnchorNode && this.getAnchorNode(),
          app = node?.getApplication(),
          session = app && app.getSession();
        if (session && session.hasServerFeature("ft-lock-file")) {
          cls.UANetwork.ftLockFile(app, function() {
            window.open(cdUrl, filename);
            this.setReturnValues([]);
          }.bind(this), null, {
            customUrl: cdUrl
          });
        } else {
          window.open(cdUrl, filename);
          return [];
        }
      },

      /**
       * Get Browser's Geolocation
       * Returns status, latitude, longitude
       * (Alias of mobile module's getGeolocation)
       */
      getGeolocation: function() {
        context.FrontCallService.modules.mobile.getgeolocation.call(this);
      },

      /**
       * Returns an environment variable set in the user session on the front end platform.
       * @unsupported
       * @param name
       * @returns {string[]}
       */
      getEnv: function(name) {
        if (name === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Returns the local window manager identifier of the window
       * @unsupported
       * @param auiWindowId
       * @returns {string[]}
       */
      getWindowId: function(auiWindowId) {
        if (auiWindowId === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Checks that the content is in the foreground
       * Returns true if the page content is at least partially visible (foreground tab of a non minimized window)
       * (Alias of mobile module's isForeground)
       */
      isForeground: function() {
        context.FrontCallService.modules.mobile.isforeground.call(this);
      },

      /**
       * Opens a URL with the default URL handler of the front-end.
       * @param {string} url to open
       * @param {string=} mode how to open, if 'replace', will open it in the app window
       * @returns {string[]}
       */
      launchURL: function(url, mode) {
        if (url === undefined) {
          this.parametersError();
          return [''];
        }
        const specialSchemas = ['mailto:', 'news:', 'file:', 'tel:', 'sms:'];
        let replace = (mode === 'replace');

        // Do not open a blank window if it's a redirect url
        if (specialSchemas.some((schema) => url.indexOf(schema) >= 0)) {
          replace = true;
        }
        if (replace) {
          gbc.canShowExitWarning = false;
          window.location = url;
        } else { // 'popup'
          const win = window.open('about:blank');
          if (win) {
            win.document.write('<html><body><a href="' + url +
              '" target="_self">' + i18next.t("gwc.app.noload") + '</a></body></html>');
            win.document.close();
            win.location = url;
          }
        }
        return [];
      },

      /**
       * Unloads a DLL or shared library front call module.
       * @unsupported
       * @param name
       * @returns {*}
       */
      mdClose: function(name) {
        if (name === undefined) {
          this.parametersError();
          return;
        }
        return [-2];
      },

      /**
       * Displays a file dialog window to get a directory path on the local file system.
       * @unsupported
       * @param path
       * @param caption
       * @returns {string[]}
       */
      openDir: function(path, caption) {
        if (path === undefined || caption === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Displays a file dialog window to let the user select a single file path on the local file system.
       * @param path
       * @param fileTypeName
       * @param wildcards
       * @param caption
       */
      openFile: function(path, fileTypeName, wildcards, caption) {
        const app = this.getAnchorNode().getApplication();
        this._filePickerWidget = app.filetransfer.openFile({
            path: path,
            fileTypeName: fileTypeName,
            wildcards: wildcards,
            caption: caption
          }, function(filename) {
            const functionCallNode = this.getAnchorNode();
            if (functionCallNode) {
              this.setReturnValues([filename]);
            } else {
              this.displayErrorMessage(i18next.t('gwc.file.upload.file-already-uploaded'));
            }
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Displays a file dialog window to let the user select a list of file paths on the local file system.
       * @param path
       * @param fileTypeName
       * @param wildcards
       * @param caption
       */
      openFiles: function(path, fileTypeName, wildcards, caption) {
        const app = this.getAnchorNode().getApplication();
        this._filePickerWidget = app.filetransfer.openFiles({
            path: path,
            fileTypeName: fileTypeName,
            wildcards: wildcards,
            caption: caption
          }, function(filenames) {
            const functionCallNode = this.getAnchorNode();
            if (functionCallNode) {
              this.setReturnValues([JSON.stringify(filenames)]);
            } else {
              this.displayErrorMessage(i18next.t('gwc.file.upload.files-already-uploaded'));
            }
          }.bind(this),
          function(msg) {
            this.runtimeError(msg);
          }.bind(this));
      },

      /**
       * Plays the sound file passed as parameter on the front-end platform.
       * @param {string} soundFile source (local or distant)
       * @returns {Array}
       */
      playSound: function(soundFile) {
        if (soundFile === undefined) {
          this.parametersError();
          return undefined;
        }
        const audio = context.TemplateService.renderDOM('FrontCallStandardPlaySound');
        audio.setAttribute('src', soundFile);
        try {
          audio.play();
          return [];
        } catch (err) {
          console.warn(err);
          return [false];
        }
      },

      /**
       * Displays a file dialog window to get a path to save a file on the local file system.
       * @unsupported
       * @param path
       * @param name
       * @param filetype
       * @param caption
       * @returns {string[]}
       */
      saveFile: function(path, name, filetype, caption) {
        if (path === undefined || name === undefined || filetype === undefined || caption === undefined) {
          this.parametersError();
          return undefined;
        }
        return [''];
      },

      /**
       * Override the font used for report generation for the current application.
       * @unsupported
       * @param font
       * @returns {boolean[]}
       */
      setReportFont: function(font) {
        if (font === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },

      /**
       * Override the printer configuration used for report generation for the current application.
       * @unsupported
       * @param printer
       * @returns {boolean[]}
       */
      setReportPrinter: function(printer) {
        if (printer === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },

      /**
       * Defines the base path where web components are located.
       * @deprecated
       * @param path
       * @returns {Array}
       */
      setWebComponentPath: function(path) {
        if (path === undefined) {
          this.parametersError();
          return undefined;
        }
        this.getAnchorNode().getApplication().info().webComponentUsrPath = path;
        return [];
      },

      /**
       * Opens a file on the front-end platform with the program associated to the file extension.
       * @unsupported
       * @param document
       * @param action
       * @returns {boolean[]}
       */
      shellExec: function(document, action) {
        if (document === undefined) {
          this.parametersError();
          return undefined;
        }
        return [false];
      },
      //TODO: append data in the child apps for retrieval upon notificationpushed
      notifyChildren: function(/*data*/) {
        var cnt=0;
        const mwdata=window._multiWindowData;
        if (mwdata) {
          for(var i=0;i<mwdata.directChildren.length;i++) {
            const win=mwdata.directChildren[i];
            if (win.gbc) {
              win.gbc.NativeService.onNativeAction({name:"notificationpushed"});
              cnt++;
            }
          }
        }
        return [cnt];
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.theme', ['FrontCallService'],
  function(context, cls) {

    /**
     * Themes module to manage (activate, list and get) front-end themes
     * @instance theme
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.theme = /** @lends gbc.FrontCallService.modules.theme */ {
      /**
       * Load and activate a given theme by name
       * @param {string} name theme name
       * @returns {Array}
       */
      setTheme: function(name) {
        if (name === undefined) {
          this.parametersError();
          return undefined;
        }

        context.ThemeService.loadTheme(name, function() {
          this.setReturnValues([]);
        }.bind(this), false);
      },

      /**
       * Get the current theme name
       * @return {string} the current theme name
       */
      getCurrentTheme: function() {
        const currentTheme = context.ThemeService.getCurrentTheme();
        return [currentTheme];
      },

      /**
       * List all available themes
       * @return {Array} list of all available themes. One theme is an object composed of attributes 'name', 'title' and 'conditions'
       */
      listThemes: function() {
        const allThemes = context.ThemeService.getAvailableThemes();
        return [allThemes];
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.wci', ['FrontCallService'],
  function(context, cls) {

    /**
     * MDI frontcalls
     * @instance localStorage
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.wci = /** @lends gbc.FrontCallService.modules.wci */ {

      /**
       * Get the number of children of a container.
       * @param {string} containerName window container name
       * @returns {Array} children count
       */
      //http://localhost:6394/ua/r/GBC-2556
      childCount: function(containerName) {
        const session = context.SessionService.getCurrent();
        const appList = session.getNavigationManager().getApplications();
        let res = 0;

        appList.forEach((app) => {
          const container = app.uiNode().attribute("container");
          const type = app.uiNode().attribute("type");

          if (type === "child" && container === containerName) {
            res += 1;
          }
        });

        return [res];
      },

      /**
       * Get the number of child instances for a given program name in the specified container
       * @param {string} containerName window container name
       * @param {string} name program name
       * @returns {Array}
       */
      childInstances: function(containerName, name) {
        const session = context.SessionService.getCurrent();
        const appList = session.getNavigationManager().getApplications();
        let res = 0;

        appList.forEach((app) => {
          const container = app.uiNode().attribute("container");
          const type = app.uiNode().attribute("type");
          const uiName = app.uiNode().attribute("name");

          if (type === "child" && container === containerName && uiName === name) {
            res++;
          }
        });

        return [res];
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService.modules.webcomponent', ['FrontCallService'],
  function(context, cls) {
    /**
     * Service to handle Webcomponent's FrontCalls
     * @instance webcomponent
     * @memberOf gbc.FrontCallService.modules
     */
    context.FrontCallService.modules.webcomponent = /** @lends gbc.FrontCallService.modules.webcomponent */ {

      /**
       * Call a method inside the webcomponent
       */
      call: function() {
        if (arguments.length > 1) {
          const webComponentTarget = arguments[0];
          const functionName = arguments[1];

          const parameters = new Array(arguments.length - 2);
          for (let i = 2; i < arguments.length; ++i) {
            parameters[i - 2] = arguments[i];
          }

          // Once we've managed Orders
          const orderManagedHandle = this.getAnchorNode().getApplication().dvm.onOrdersManaged(function() {
            orderManagedHandle();
            const app = this.getAnchorNode().getApplication();

            //search for the target Node
            const currentWindow = app.getNode(app.uiNode().attribute('currentWindow'));
            const forms = currentWindow.getChildren('Form');
            let currentForm;
            for (let i = forms.length - 1; i >= 0; --i) {
              const form = forms[i];
              if (!form.attribute('hidden')) {
                currentForm = form;
                break;
              }
            }
            if (!currentForm) {
              const componentName = this.getAnchorNode().getChildren()[0].attribute("value");
              this.runtimeError('Can\'t find component: ' + componentName, cls.VMFunctionCallEvent.functionError);
              return;
            }
            const targetNode = currentForm.findNodeWithAttribute('FormField', 'name', webComponentTarget);

            const widget = targetNode.getController().getWidget();

            const process = function(widget, functionName, parameters) {
              let ret = '';
              try {
                const fct = widget._iframeElement.contentWindow[functionName];
                if (typeof(fct) === 'function') {
                  ret = fct.apply(null, parameters);
                } else {
                  this.runtimeError('No function [' + functionName + '] defined in this webcomponent.', cls.VMFunctionCallEvent
                    .unknownFunction);
                  return;
                }
              } catch (e) {
                this.runtimeError(e.message);
                return;
              }
              this.setReturnValues([ret]);
            }.bind(this);

            // If the webcomponent is ready
            if (widget._isReady) {
              process(widget, functionName, parameters);
            } else {
              // Otherwise, we wait that it becomes ready
              const readyHandle = widget.when(context.constants.widgetEvents.ready, function() {
                readyHandle();
                process(widget, functionName, parameters);
              }.bind(this));
            }
          }.bind(this));
        } else {
          this.runtimeError('No webcomponent or function name provided');
        }
      },

      /**
       * Get the frontcall Api version
       * @returns {string[]}
       */
      frontCallAPIVersion: function() {
        return [cls.WebComponentWidget.gICAPIVersion];
      },

      /**
       * Get the window title of the webcomponent
       * @param webComponentTarget
       * @returns {string[]}
       */
      getTitle: function(webComponentTarget) {
        if (webComponentTarget) {
          const targetNode = this.getAnchorNode().getApplication().model.getNodeByAttribute('name', webComponentTarget);
          const domElement = targetNode.getController().getWidget()._iframeElement;
          try {
            return [domElement.contentWindow.document.title];
          } catch (e) {
            this.runtimeError(e.message);
          }
        } else {
          this.runtimeError('No webcomponent name provided');
        }
      }
    };
  }
);
;

"use strict";

modulum('FrontCallService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.FrontCallService
     * @gbcService
     */
    context.FrontCallService = context.oo.StaticClass( /** @lends gbc.FrontCallService */ {
      __name: "FrontCallService",

      /**
       * list of available front call modules
       * @type {Object}
       * */
      modules: {},
      /**
       * currently running front call
       * @type {classes.NodeBase}
       * */
      _functionCallNode: null,

      /** @type {boolean} */
      _functionCallProcessing: false,

      /**
       * Initialize the service
       */
      init: function() {
        const lowerCasedModules = {};
        const moduleNames = Object.keys(this.modules);
        for (const moduleName of moduleNames) {
          const module = this.modules[moduleName];
          const functionNames = Object.keys(module);
          const lowerCasedModule = {};
          lowerCasedModules[moduleName.toLowerCase()] = lowerCasedModule;
          for (const functionName of functionNames) {
            lowerCasedModule[functionName.toLowerCase()] = module[functionName];
          }
        }
        this.modules = lowerCasedModules;
      },

      /**
       * Check if the module exist
       * @param {string} module - name of the frontcall module (i.e: standard, mobile ...)
       * @return {boolean}
       */
      hasModule: function(module) {
        return Boolean(this.modules[module.toLowerCase()]);
      },

      /**
       * Check if module has a frontcall
       * @param {string} module - name of the frontcall module (i.e: standard, mobile ...)
       * @param {string} name - name of the function (i.e: feinfo, openDir, playSound...)
       * @return {boolean} - true if frontcall exist in the module
       */
      hasFrontCall: function(module, name) {
        const moduleItem = this.modules[module.toLowerCase()];
        if (moduleItem) {
          return Boolean(moduleItem[name.toLowerCase()]);
        } else {
          return false;
        }
      },

      /**
       * Check if a functionCall is processing
       * @return {boolean} true if processing, false otherwise
       */
      functionCallIsProcessing: function() {
        return this._functionCallProcessing;
      },

      /**
       * Tell the service that a FrontCall is processing or not
       * @param {boolean} processing - true if processing
       */
      setFunctionCallProcessing: function(processing) {
        this._functionCallProcessing = processing;
      }

    });
    context.InitService.register(context.FrontCallService);
  });
;

"use strict";

modulum('GestureService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {

    /**
     * Touch gesture management service
     * @class GestureService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.GestureService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.GestureService.prototype */ {
        __name: "GestureService",

        /** @type {Boolean} */
        _hasNativeSmoothScroll: false,
        /** @type {classes.WidgetGroupBase|classes.WidgetBase} */
        _widget: null,
        /** @type {HTMLElement} */
        _widgetContainer: null,
        /** @type {Object} */
        _swipeOpts: null,
        /** @type {HTMLElement} */
        _leftArrow: null,
        /** @type {HTMLElement} */
        _rightArrow: null,
        /** @type {HTMLElement} */
        _dots: null,
        /** @type {Number} */
        _lastDirectionSign: 0,
        /** @type {Number} */
        _lastHorizontalScrollPos: 0,
        /** @type {Function} */
        _postponedScroll: null,
        /** @type {Number} */
        _pastCleanedIndex: -1,
        /** @type {Object} */
        _scrollTimerId: null,
        /** @type {Function} */
        _focusHandler: null,
        /** @type {Function} */
        _focusRestoredHandler: null,

        /**
         * Swipe gesture service constructor
         * @param {classes.WidgetGroupBase|classes.WidgetBase} widget
         * @param {Object} swipeOptions
         * @param {Function} swipeOptions.moveCallback : custom function to execute during swipe
         * @param {boolean} swipeOptions.virtualDom : automatically add/remove hidden elements from DOM. False by default.
         * @param {string} swipeOptions.orientation : swipe direction. 'x' for horizontal, 'y' for vertical. Default is 'x'
         * @param {HTMLElement} swipeOptions.container : DOM element on which all events and css are attached. If not specified, we look for widget containerElement and element.
         * @param {boolean} swipeOptions.arrows : display arrows if true. False by default.
         * @param {boolean} swipeOptions.dots : display dots if true. False by default.
         * @param {boolean} swipeOptions.hideScrollbar : hide swipe corresponding scrollbar if true. True by default.
         * @param {boolean} swipeOptions.noSwipe : disable touch gesture if set to true. False by default
         */
        constructor: function(widget, swipeOptions) {
          $super.constructor.call(this);
          this._hasNativeSmoothScroll = this._testSupportsSmoothScroll();
          this._viewPortWidth = window.innerWidth;
          this._widget = widget;
          this._swipeOpts = swipeOptions || {};
          this._widgetContainer = this._swipeOpts.container || widget.getContainerElement() || widget.getElement();

          // defaults options
          if (!this._swipeOpts.orientation) {
            this._swipeOpts.orientation = "x";
          }
          if (typeof this._swipeOpts.hideScrollbar === 'undefined') {
            this._swipeOpts.hideScrollbar = true;
          }

          if (this._swipeOpts.arrows) {
            this.addArrows();
          }
          if (this._swipeOpts.dots) {
            this.addDots();
          }

          this.enableSwipe();

          this._focusRestoredHandler = context.SessionService.getCurrent().getCurrentApplication().focus.when(context.constants.widgetEvents
            .focusRestored, this._onFocusRestored.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.disableSwipe();
          this._swipeOpts = null;
          $super.destroy.call(this);
        },

        /**
         * Disable swipe from the widget
         */
        disableSwipe: function() {
          this.removeTouch();

          this._widgetContainer.off("scroll.swipe");

          this._widgetContainer.removeClass("noswipe");
          this._widgetContainer.removeClass("swipeable");
          this._widget.removeClass("swiping");
          this._widgetContainer.removeClass(this._swipeOpts.orientation);
          this._widgetContainer.removeClass("hidden-scrollbar");

          this.removeArrows();
          this.removeDots();
          this._postponedScroll = null;

        },

        /**
         * Disable touch gestures (swipe only possible via arrows/dots)
         */
        removeTouch: function() {
          this._widgetContainer.addClass("noswipe");
          this._widgetContainer.off("touchstart.swipe");
          this._widgetContainer.off("touchend.swipe");
          this._widgetContainer.off("touchleave.swipe");
        },

        /**
         * Enable touch gestures
         */
        addTouch: function() {
          this._widgetContainer.removeClass("noswipe");
          this._widgetContainer.on("touchstart.swipe", this._onSwipeStart.bind(this));
          const swipeEnd = this._onSwipeEnd.bind(this);
          this._widgetContainer.on("touchend.swipe", swipeEnd);
          this._widgetContainer.on("touchleave.swipe", swipeEnd);
        },

        /**
         * Enable swipe
         * @returns {boolean}
         */
        enableSwipe: function() {
          if (!this._widget) {
            return;
          }

          this._widgetContainer.toggleClass("hidden-scrollbar", this._swipeOpts.orientation);
          this._widgetContainer.addClass(this._swipeOpts.orientation);
          this._widgetContainer.removeClass("visibility-hidden");
          this._widgetContainer.addClass("swipeable");

          this.removeTouch();
          if (!this._swipeOpts.noSwipe) {
            this.addTouch();
          }

          if (this._swipeOpts.virtualDom || this._swipeOpts.moveCallback) {
            this._widgetContainer.on("scroll.swipe", this._onSwipeMove.bind(this, this._swipeOpts.moveCallback));
          }

          return true;
        },

        /**
         * Handler fired on swipe start. Add siblings elements to preview in DOM
         * @private
         */
        _onSwipeStart: function() {
          this._widget.addClass("swiping");
          if (this._pagesInDomTimer && this._swipeOpts.virtualDom) {
            this._clearTimeout(this._pagesInDomTimer);
            this._cleanDom();
          }
          this._widget.emit(context.constants.widgetEvents.swipeStart);
        },

        /**
         * Handler fired during swipe. Update DOM if virtualDom option is on.
         * @param {Function} moveCallback
         * @param {object} evt
         * @private
         */
        _onSwipeMove: function(moveCallback, evt) {
          if (!this._widget.hasClass("swiping")) {
            return;
          }
          let distance = Math.round(this._widgetContainer.scrollLeft - this._lastHorizontalScrollPos);
          if (this._widget.isReversed()) { // manage RTL mode : inverse all
            distance *= -1;
          }
          const directionSign = Math.sign(distance);

          if (this._swipeOpts.virtualDom && directionSign !== this._lastDirectionSign && Math.abs(distance) > 2) {

            this._lastDirectionSign = directionSign;
            this._registerAnimationFrame(function() {
              this._updateDom(directionSign);
            }.bind(this));
          }

          if (moveCallback) {
            moveCallback.call(this._widget, null, distance, directionSign);
          }
        },

        /**
         * Handler fired on swipe end. Clean the DOM to display only current element
         * @private
         */
        _onSwipeEnd: function() {
          this._clearTimeout(this._pagesInDomTimer);

          this._pagesInDomTimer = this._registerTimeout(function() {
            this._widget.removeClass("swiping");
            const index = this._cleanDom();
            this._lastHorizontalScrollPos = this._widgetContainer.scrollLeft;
            this._lastDirectionSign = 0;
            this._widget.emit(context.constants.widgetEvents.swipeEnd, index);
          }.bind(this), 800);
        },

        /**
         * Calculate current index of child element being displayed
         * @returns {number}
         * @private
         */
        _getIndex: function() {
          let scrollRatio = 0;
          if (this._swipeOpts.orientation === "x") {
            scrollRatio = this._widgetContainer.scrollWidth > 0 ?
              Math.abs(this._widgetContainer.scrollLeft) / this._widgetContainer.scrollWidth : 0;
          } else {
            scrollRatio = this._widgetContainer.scrollHeight > 0 ?
              this._widgetContainer.scrollTop / this._widgetContainer.scrollHeight : 0;
          }

          return Math.round(scrollRatio * this._widget.getVisibleChildrenCount());
        },

        /**
         * Update sibling element during swipe process accordingly to current direction
         * @param direction -1 if going to previous sibling element. 1 if going to next sibling element.
         * @private
         */
        _updateDom: function(direction) {
          const index = this._getIndex();

          const next = this._widget.getVisibleChildren()[index + direction];
          const previous = this._widget.getVisibleChildren()[index - direction];
          if (previous && !previous.hasChildWebComponent()) {
            previous.removeFromDom();
          }
          if (next && !next.hasChildWebComponent()) {
            next.addInDom();
          }

        },

        /**
         * Remove siblings elements of the DOM to only display current displayed one
         * @returns {number}
         * @private
         */
        _cleanDom: function(index) {
          this._pagesInDomTimer = null;
          if (this._widgetContainer) {
            index = index >= 0 ? index : this._getIndex();
            if (this._pastCleanedIndex !== index) {

              if (this._swipeOpts.virtualDom) {
                for (let i = 0; i < this._widget.getVisibleChildren().length; i++) {
                  const child = this._widget.getVisibleChildren()[i];
                  if (i === index) {
                    if (!child.hasChildWebComponent()) {
                      child.addInDom();
                    }
                  } else {
                    if (!child.hasChildWebComponent()) {
                      child.removeFromDom();
                    }
                  }
                }
              }

              if (this._swipeOpts.arrows) {
                this._updateArrows(index);
              }
              if (this._swipeOpts.dots) {
                this._updateDots(index);
              }
              this._pastCleanedIndex = index;
            }
          }
          return index;
        },

        /**
         * Focus the corresponding child manually
         * @param {classes.WidgetBase} child
         * @param {Object} opts swipe options
         * @param {boolean} opts.smoothEffect internal app hash
         * @param {boolean} opts.noDelay to remove delayed scroll
         */
        swipeTo: function(child, opts) {
          // 1. check if corresponding child is in dom, otherwise add it
          opts = opts || {};
          if (child) {
            child.addInDom();
          }

          // 2. scroll with/without smooth effect
          const index = this._widget.getVisibleChildren().indexOf(child);

          if (this._postponedScroll) {
            this._postponedScroll = null;
          }
          if (this._scrollTimerId) {
            this._clearTimeout(this._scrollTimerId);
            this._scrollTimerId = null;
          }
          const schedulerService = context.SessionService.getCurrent().getCurrentApplication().scheduler;
          // check if nothing to process before scrolling (and thus focusing)
          if (schedulerService.hasNoCommandToProcess()) {
            if (opts.noDelay === true) {
              this._registerAnimationFrame(function() {
                //Need to wait the next frame to have a correct scrollWidth
                this._scroll(index, opts.smoothEffect);
              }.bind(this));
            } else {
              this._scrollTimerId = this._registerTimeout(function() {
                this._scroll(index, opts.smoothEffect);
              }.bind(this), 100);
            }
          } else {
            this._postponedScroll = this._scroll.bind(this, index, opts.smoothEffect);
          }
        },

        /**
         * Generate a scroll to the specified index
         * @param {Number} index
         * @param {boolean} smoothEffect
         * @returns {cancel}
         * @private
         */
        _scroll: function(index, smoothEffect) {
          if (!this._widgetContainer) {
            return;
          }
          if (this._swipeOpts.arrows) {
            this._updateArrows(index);
          }
          if (this._swipeOpts.dots) {
            this._updateDots(index);
          }
          let left = (this._swipeOpts.orientation === "x" ? this._widgetContainer.scrollWidth : this._widgetContainer.scrollHeight) * (index /
            this._widget.getVisibleChildren().length);
          if (this._widget.isReversed()) { // manage RTL mode
            left *= -1;
          }
          this._widgetContainer.removeClass("visibility-hidden");
          if (this._hasNativeSmoothScroll || !smoothEffect) {
            const scrollParams = {
              [this._swipeOpts.orientation === "x" ? 'left' : 'top']: left
            };
            if (smoothEffect) {
              scrollParams.behavior = 'smooth';
            }
            this._widgetContainer.scrollTo(scrollParams);
          } else { // IOS
            this._smoothScrollPolyfill(this._swipeOpts.orientation === "x" ? 'scrollLeft' : 'scrollTop', left);
          }
        },

        /**
         * Update dom & arrows/dot on focus restored or eventually execute a postponed scroll operation
         * @private
         */
        _onFocusRestored: function(notifier, event) {
          if (this._postponedScroll) {
            this._postponedScroll();
            this._postponedScroll = null;

            this._onFocus(notifier, event);
          }

          if (this._swipeOpts.arrows) {
            this.refreshArrows();
          }

          if (this._swipeOpts.dots) {
            this.refreshDots();
          }
        },
        /**
         * Update dom & arrows/dot on set focus
         * @private
         */
        _onFocus: function(notifier, event) {
          let index = -1;
          if (event && event._focusedNode) {
            let child = event._focusedNode.getController().getWidget();
            while (index === -1 && child) {
              index = this._widget.getVisibleChildren().indexOf(child);
              child = child.getParentWidget();
            }
          }
          this._registerTimeout(this._cleanDom.bind(this, index), 200);
        },

        // NAVIGATION STYLE
        /**
         * Add arrows as helper to swipe
         */
        addArrows: function() {
          this._swipeOpts.arrows = true;

          if (this._leftArrow && this._rightArrow) {
            // arrows already enabled
            return;
          }
          this._leftArrow = document.createElement("div");
          this._rightArrow = document.createElement("div");
          this._leftArrow.addClass("left_arrow");
          this._rightArrow.addClass("right_arrow");
          this._widgetContainer.parentNode.appendChild(this._leftArrow);
          this._widgetContainer.parentNode.appendChild(this._rightArrow);

          // add left/right arrows events
          this._leftArrow.on("click.LeftArrow", this._arrowHandler.bind(this, -1));
          this._rightArrow.on("click.RightArrow", this._arrowHandler.bind(this, 1));

          this._updateArrows(0);

          if (!this._focusHandler) {
            this._focusHandler = this._widget.getUserInterfaceWidget().when(context.constants.widgetEvents
              .splitViewChange, this._onFocus.bind(this));
          }
        },

        /**
         * true if arrows are enabled
         * @returns {boolean}
         */
        hasArrows: function() {
          return this._swipeOpts.arrows;
        },

        /**
         * true if dots are enabled
         * @returns {boolean}
         */
        hasDots: function() {
          return this._swipeOpts.dots;
        },

        /**
         * Remove arrows buttons
         */
        removeArrows: function() {
          this._swipeOpts.arrows = false;
          if (!this._leftArrow && !this._rightArrow) {
            // arrows already disabled
            return;
          }
          this._leftArrow.off("click.LeftArrow");
          this._rightArrow.off("click.RightArrow");
          this._widgetContainer.parentNode.removeChild(this._leftArrow);
          this._widgetContainer.parentNode.removeChild(this._rightArrow);
          this._leftArrow = null;
          this._rightArrow = null;

          if (!this._swipeOpts.dots) {
            if (this._focusRestoredHandler) {
              this._focusRestoredHandler();
              this._focusRestoredHandler = null;
            }
            if (this._focusHandler) {
              this._focusHandler();
              this._focusHandler = null;
            }
          }
        },

        /**
         * Arrows buttons
         * @param {Number} index
         * @private
         */
        _updateArrows: function(index) {
          if (this._leftArrow && this._rightArrow) {
            if (this._widget.getVisibleChildrenCount() === 1) {
              this._leftArrow.addClass("disabled");
              this._rightArrow.addClass("disabled");
            } else if (index <= 0) {
              this._leftArrow.addClass("disabled");
              this._rightArrow.removeClass("disabled");
            } else if (index >= this._widget.getVisibleChildrenCount() - 1) {
              this._rightArrow.addClass("disabled");
              this._leftArrow.removeClass("disabled");
            } else {
              this._rightArrow.removeClass("disabled");
              this._leftArrow.removeClass("disabled");
            }
          }
        },

        /**
         * Navigate to previous/next view
         * @param {Number} inc
         * @private
         */
        _arrowHandler: function(inc) {
          const newIndex = this._getIndex() + inc;
          const child = this._widget.getVisibleChildren()[newIndex];
          if (child) {
            this._onSwipeStart();
            this.swipeTo(child, {
              smoothEffect: true
            });
            this._onSwipeEnd();
          }
        },

        /**
         * Add dots as helper to swipe
         */
        addDots: function() {
          this._swipeOpts.dots = true;

          if (this._dots) {
            // dots already enabled
            return;
          }
          this._dots = document.createElement("div");

          this._dots.addClass("dots");

          this._widgetContainer.parentNode.appendChild(this._dots);

          // add dots events
          for (const element of this._widget.getVisibleChildren()) {
            this._addDot();
          }

          this._updateDots(0);

          if (!this._focusHandler) {
            this._focusHandler = this._widget.getUserInterfaceWidget().when(context.constants.widgetEvents
              .splitViewChange, this._onFocus.bind(this));
          }
        },

        removeDots: function() {
          this._swipeOpts.dots = false;
          if (!this._swipeOpts.arrows) {
            if (this._focusRestoredHandler) {
              this._focusRestoredHandler();
              this._focusRestoredHandler = null;
            }
            if (this._focusHandler) {
              this._focusHandler();
              this._focusHandler = null;
            }
          }

          if (!this._dots) {
            // dots already disabled
            return;
          }
          this._widgetContainer.parentNode.removeChild(this._dots);
          for (const element of this._dots.children) {
            element.off("click.NavigationStyleDot");
          }
          this._dots = null;
        },

        /**
         * Create a dot element and add it in the DOM
         * @private
         */
        _addDot: function() {
          const div = document.createElement("div");
          div.addClass("dot");
          div.on("click.NavigationStyleDot", this._dotHandler.bind(this, this._dots.children.length));
          // add listener
          this._dots.appendChild(div);
        },

        /**
         * Navigate to view corresponding to dot index
         * @param {Number} index
         * @private
         */
        _dotHandler: function(index) {
          const child = this._widget.getVisibleChildren()[index];
          if (child) {
            this._onSwipeStart();
            this.swipeTo(child, {
              smoothEffect: true
            });
            this._onSwipeEnd();
          }
        },

        /**
         * Update current dot status
         * @param {Number} index
         * @private
         */
        _updateDots: function(index) {
          // need to resynchronize dots with childs
          if (this._widget.getVisibleChildrenCount() !== this._dots.children.length) {
            this.removeDots();
            this.addDots();
          }
          if (this._dots) {
            for (let i = 0; i < this._dots.children.length; i++) {
              const dot = this._dots.children[i];
              if (i === index) {
                if (!dot.hasClass("current")) {
                  dot.addClass("current");
                }
              } else {
                dot.removeClass("current");
              }
            }
          }
        },

        /**
         * Test smooth scroll functionality
         * @returns {string|boolean}
         * @private
         */
        _testSupportsSmoothScroll: function() {
          let supports = false;
          try {
            let div = document.createElement('div');
            div.scrollTo({
              top: 0,
              get behavior() {
                supports = true;
                return 'smooth';
              }
            });
          } catch (err) {} // Edge throws an error
          return supports;
        },

        _easingOutQuint: function(x, t, b, c, d) {
          return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },

        _smoothScrollPolyfill: function(key, target) {
          const startTime = Date.now();
          const offset = this._widgetContainer[key];
          const gap = target - offset;
          const duration = 1000;
          let interrupt = false;

          const cancel = function() {
            interrupt = true;
            this._widgetContainer.removeEventListener('wheel', cancel);
            this._widgetContainer.removeEventListener('touchstart', cancel);
          }.bind(this);

          const step = function() {
            const elapsed = Date.now() - startTime;
            const percentage = elapsed / duration;

            if (interrupt) {
              return;
            }

            if (percentage > 1) {
              this._widgetContainer.removeEventListener('wheel', cancel);
              this._widgetContainer.removeEventListener('touchstart', cancel);
              return;
            }

            this._widgetContainer[key] = this._easingOutQuint(0, elapsed, offset, gap, duration);
            window.requestAnimationFrame(step);
          }.bind(this);

          this._widgetContainer.addEventListener('wheel', cancel, {
            passive: true
          });
          this._widgetContainer.addEventListener('touchstart', cancel, {
            passive: true
          });

          step();

          return cancel;
        },

        _smoothHorizontalScrolling: function(e, time, amount, start) {
          const eAmt = amount / 100;
          let curTime = 0;
          let scrollCounter = 0;
          while (curTime <= time) {
            window.setTimeout(this._SHS_B, curTime, e, scrollCounter, eAmt, start);
            curTime += time / 100;
            scrollCounter++;
          }
        },

        _SHS_B: function(e, sc, eAmt, start) {
          e.scrollLeft = (eAmt * sc) + start;
        },

        refreshDots: function() {
          this._updateDots(this._getIndex());
        },

        refreshArrows: function() {
          this._updateArrows(this._getIndex());
        }

      };

    });
    cls.ApplicationServiceFactory.register("Gesture", cls.GestureService);
  });
;

"use strict";

modulum('HostLeftSidebarService', ['InitService', 'HostService', 'DebugService', 'EventListener'],
  function(context, cls) {

    /**
     * GBC Sidebar service
     * @namespace gbc.HostLeftSidebarService
     * @gbcService
     */
    context.HostLeftSidebarService = context.oo.StaticClass( /** @lends gbc.HostLeftSidebarService */ {
      __name: "HostLeftSidebarService",
      /** @type {classes.ApplicationHostSidebarWidget} */
      _sidebar: null,

      /** @type {WeakSet<classes.VMSession>} */
      _sessions: null,

      /** @type {classes.ApplicationHostSidebarBackdropWidget} */
      _sidebarBackdrop: null,

      _tabbedContainerMode: false,

      _enabled: false,
      _visibility: false,
      _visible: false,
      _applicationCount: 0,
      _applicationListVisible: null,

      init: function() {
        this._sessions = new WeakSet();
      },

      preStart: function() {
        this._sidebar = cls.WidgetFactory.createWidget('RSidebar', {
          appHash: gbc.systemAppId
        });
        this._sidebarBackdrop = cls.WidgetFactory.createWidget('ApplicationHostSidebarBackdrop', {
          appHash: gbc.systemAppId
        });
        const hostWidget = context.HostService.getApplicationHostWidget(),
          hostElement = hostWidget.getElement();
        hostElement.prependChild(this._sidebar.getElement());
        hostElement.appendChild(this._sidebarBackdrop.getElement());
        this._sidebar.setParentWidget(hostWidget);
        this._sidebarBackdrop.setParentWidget(hostWidget);
        this._sidebar.onDisplayChanged(() =>
          context.HostService.updateDisplay());
        this._sidebar.when(context.constants.widgetEvents.toggleClick, () => gbc.HostLeftSidebarService.hideSidebar());
        this._sidebarBackdrop.onClick(() => {
          gbc.HostLeftSidebarService.hideSidebar();
          gbc.HostLeftSidebarService.showTopMenu(false);
        });
      },

      destroy: function() {
        this._sessions = null;
        this._sidebar.destroy();
        this._sidebarBackdrop.destroy();
      },

      /**
       *
       * @return {classes.ApplicationHostSidebarWidget}
       */
      getSidebar: function() {
        return this._sidebar;
      },

      setTitle: function(title) {
        this._sidebar.setTitleText(title);
      },

      setContent: function(content) {
        this._sidebar.setSidebarContent(content);
      },

      getSidebarWidth: function() {
        if (this._sidebar && !this._sidebar.isUnavailable() && this._sidebar.isAlwaysVisible()) {
          return this._sidebar.getCurrentSize();
        }
        return 0;
      },

      setTabbedContainerMode: function(tabbedMode) {
        this._tabbedContainerMode = tabbedMode;
        if (tabbedMode) {
          this.hideSidebar();
          this.showAppList(false);
          this.showSettings(false);
          this.showTitle(false);
          window.document.querySelector(":root").style.setProperty('--applistWidth', 0);
        }
      },

      showSidebar: function() {
        let status = this._sidebar.setDisplayed(true);
        this._sidebarBackdrop.setDisplayed(status);
        //Save it to the stored settings
        gbc.StoredSettingsService.setSideBarVisible(false); // force false, we don't want topmenu
      },

      hideSidebar: function() {
        let status = this._sidebar.setDisplayed(false);
        this._sidebarBackdrop.setDisplayed(status);
        //Save it to the stored settings
        gbc.StoredSettingsService.setSideBarVisible(status);
      },

      toggleSidebar: function() {
        if (this._sidebar.isDisplayed()) {
          this.hideSidebar();
        } else {
          this.showSidebar();
        }
        return this._sidebar.isDisplayed();
      },

      enableSidebar: function(enable) {
        this._enabled = Boolean(enable);
      },

      // Show Hide methods on sidebar
      showTitle: function(show) {
        show = this._tabbedContainerMode ? false : show;
        this._sidebar.showTitle(show);
      },
      showAppList: function(show) {
        show = this._tabbedContainerMode ? false : show;
        this._sidebar.showAppList(show);
        this.showSettings(show);
      },
      /**
       * Set Applist mode (for 4ST api)
       * @param {String} visible could be 'yes', 'no' or 'auto'
       */
      setApplicationListVisible: function(visible) {
        visible = visible ? visible : 'auto';
        if (!this._applicationListVisible) { // if not set yet set it, else ignore
          this._applicationListVisible = visible;
        }
        this._sidebar.setApplicationListVisible(this._applicationListVisible, this._applicationCount);

      },
      showTopMenu: function(show) {
        this._sidebar.showTopMenu(show);
        if (!show && window.isMobile()) {
          this._sidebar.setAppListWidth(0);
        }
        if (show) {
          this.showSidebar();
          if (window.isMobile()) {
            const themeSideBarSize = parseInt(gbc.ThemeService.getValue("theme-sidebar-default-width"), 10);
            this._sidebar.setAppListWidth(themeSideBarSize);
          }
        } else {
          this.hideSidebar();
          if (window.isMobile()) {
            this._sidebar.setAppListWidth(0);
          }
        }
      },
      renderAppTopMenu: function(appHash) {
        this._sidebar.renderAppTopMenu(appHash);
      },
      showSettings: function(show) {
        show = this._tabbedContainerMode ? false : show;
        this._sidebar.showSettings(show);
      },

      setHasTopMenu: function(hasTopMenu, inSidebar) {
        gbc.HostService.getApplicationHostWidget().toggleClass("has-topmenu-sidebar", hasTopMenu && inSidebar);
      },
      hasTopMenu: function() {
        return gbc.HostService.getApplicationHostWidget().hasClass("has-topmenu-sidebar");
      },
      // Only in mobile case
      toggleTopMenu: function() {
        if (this.hasTopMenu()) {
          this.showTopMenu(true);
        }
        if (this._applicationCount > 1) {
          const themeSideBarSize = !this._sidebar.isExpanded() ? gbc.ThemeService.getValue("theme-sidebar-default-width") : gbc.ThemeService
            .getValue("theme-sidebar-max-width");
          this._sidebar.setAppListWidth(parseInt(themeSideBarSize, 10), true);
        }
      },

      _updateApplicationListVisibility: function() {
        if (context.SessionService.getCurrent().isInTabbedContainerMode()) {
          this._visible = false; // no sidebar in tabbed Container
        } else if (this._applicationListVisible === 'auto') {
          this._visible = this._applicationCount > 1;
        } else if (typeof(this._visibility) === "boolean") {
          this._visible = this._visibility;
        }

        if (this._visible) {
          const themeSideBarSize = !this._sidebar.isExpanded() ? gbc.ThemeService.getValue("theme-sidebar-default-width") : gbc.ThemeService
            .getValue("theme-sidebar-max-width");
          this._sidebar.setAppListWidth(themeSideBarSize);
        } else {
          this._sidebar.setAppListWidth(0);
        }

      },

      updateApplicationCount: function(count) {
        this._applicationCount += count;
        this._updateApplicationListVisibility();
        this.showTopMenu(false); // if number of app changes, hide topmenu
        if (this._applicationCount <= 1) {
          this.showAppList(false);
        }
      },

      /**
       * Get number of current running app
       * @return {number}
       */
      getApplicationCount: function() {
        return this._applicationCount;
      },

      /**
       *
       * @param {classes.VMSession} session
       */
      addSession: function(session) {
        if (this._sessions.has(session)) {
          return;
        }

        this._sidebar.getApplist().addChildWidget(session.getNavigationManager().getWidget());
        this._sessions.add(session);
      },

      /**
       *
       * @param {classes.VMSession} session
       */
      removeSession: function(session) {
        if (this._sessions.has(session)) {
          this._sidebar.removeChildWidget(session.getNavigationManager().getWidget());
          this._sessions.delete(session);
        }
      },

      /**
       * Create link to the topmenu and the responsive one
       * @param {classes.TopMenuWidget} menuWidget
       */
      addResponsiveMenu: function(menuWidget) {
        this._sidebar.setSidebarTopMenu(menuWidget);
      },

      /**
       * Get the responsive menu associated to topmenu
       * @return {classes.RSidebarTopMenuWidget}
       */
      getResponsiveMenu: function() {
        return this._sidebar.getSidebarTopMenu();
      },

      setApplicationListVisibility: function(visibility) {
        // only if changed
        if (this._visibility !== visibility) {
          this._visibility = visibility;
          this._updateApplicationListVisibility();
        }
      },

      setWindowListVisibility: function(visibility) {
        context.SessionService.getCurrent().getNavigationManager().getChromeBarTitleWidget().setListingVisibility(visibility);
      }
    });
    context.InitService.register(context.HostLeftSidebarService);
  });
;

"use strict";

modulum('HostService', ['InitService', 'DebugService', 'EventListener'],
  function(context, cls) {

    /**
     * Main service which init global gbc listeners
     * @namespace gbc.HostService
     * @gbcService
     */
    context.HostService = context.oo.StaticClass( /** @lends gbc.HostService */ {
      __name: "HostService",

      currentWindowChanged: "currentWindowChanged",

      /** @type classes.MainContainerWidget */
      _widget: null,
      /** @type classes.LogPlayerWidget */
      _logPlayer: null,
      /** @type String */
      _defaultTitle: "",
      /** @type classes.ApplicationHostWidget */
      _applicationHostWidget: null,
      /** @type classes.WindowNode */
      _currentWindowNode: null,
      /** @type classes.EventListener */
      _eventListener: null,
      /** @type HTMLElement */
      _dropDownContainer: null,
      /** @type HTMLElement */
      _fontPreloader: null,
      /** @type Array **/
      _windowStack: null,
      /** @type String */
      _currentMediaSize: null,
      /**
       * @type {HandleRegistration}
       */
      _browserResizeHandler: null,

      /** @type Object **/
      _hostSize: null,

      /** @type String **/
      _windowState: null,

      _tabbedHostInfo: null,
      /**
       * @type {WeakMap<classes.WindowWidget, classes.WindowNode>}
       */
      _widgetToNodeWindows: null,
      _closeButtonsInfo: null,

      init: function() {
        this._eventListener = new cls.EventListener();
        this._windowStack = [];
        this._widgetToNodeWindows = new WeakMap();
        this._closeButtonsInfo = {};

        const existingOnError = window.onerror;
        window.onerror = function(msg, file, line, col, error) {
          if (existingOnError) {
            existingOnError(msg, file, line, col, error);
          }
          context.HostService._eventListener.emit('error', error, msg, file, line, col);
          return false;
        };

        // Device orientation handler
        window.addEventListener("orientationchange", function() {
          if (window.isIOS()) {
            const viewportSelector = document.querySelector("meta[name=viewport]");
            if (viewportSelector) {
              const content = viewportSelector.getAttribute("content");
              //GMI-911: temporarily limiting the zoom to 1.0 to avoid
              //scaling too large on orientation change
              viewportSelector.setAttribute("content", `${content}, maximum-scale=1.0`);
              // Using setTimeout since iOS doesn't seem to relayout everytime there is a rotation change.
              // No events are sent to the VM, nor layout executed
              window.setTimeout(() => {
                //reset to zoomable after a while
                viewportSelector.setAttribute("content", content);
              }, 90);
            }
          }
          if (window.isMobile) {
            this._eventListener.emit("orientationChange.Host");
          }
        }.bind(this));

        // Keep track of host size on resize
        this._hostSize = {
          width: 0,
          height: 0
        };

        // Window Resize handler
        window.addEventListener("resize", function() {
          let screenSizeChanged = {
            width: this._hostSize.width !== window.document.body.offsetWidth,
            height: this._hostSize.height !== window.document.body.offsetHeight
          };
          this._hostSize = {
            width: window.document.body.offsetWidth,
            height: window.document.body.offsetHeight,
          };
          // emit new size and changes in host size
          this._eventListener.emit("resize.Host", window.document.body.offsetWidth, window.document.body.offsetHeight, screenSizeChanged);
        }.bind(this));

        // Let know the VM when the screen is resized
        this.onScreenResize(function() {
          const mediaString = context.ThemeService.getMediaString();
          if (mediaString !== this._currentMediaSize) {
            if (gbc.SessionService.getCurrent() && !gbc.SessionService.getCurrent().isEmpty()) {
              let event = new cls.VMConfigureEvent(0, {
                media: context.ThemeService.getMediaString()
              });
              this._currentMediaSize = mediaString;
              gbc.SessionService.getCurrent().getApplications().forEach((app) => {
                let focusNode = app.getFocusedVMNode();
                if (focusNode && focusNode.getCurrentValueNode) {
                  focusNode = focusNode.getCurrentValueNode();
                }

                const controller = focusNode ? focusNode.getController() : null;
                const newVmFocusWidget = controller ? controller.getWidget() : null;

                if (newVmFocusWidget && newVmFocusWidget.getValue) {
                  controller.sendWidgetCursors();
                  controller.sendWidgetValue(newVmFocusWidget.getValue());
                }

                app.scheduler.eventVMCommand(event, app.getNode(0));
                gbc.LogService.ui.log("resize", context.ThemeService.getMediaString());
              });
            }
          }
        }.debounce(250).bind(this));

        this.onScreenResize(() => this.updateDisplay());
      },

      destroy: function() {
        if (this._browserResizeHandler) {
          this._browserResizeHandler();
          this._browserResizeHandler = null;
        }
      },

      isLogPlayerRequested: function() {
        return window.isURLParameterEnabled("logplayer");
      },

      preStart: function() {
        if (!context.DebugService.isMonitorWindow()) {
          this._widget = cls.WidgetFactory.createWidget("MainContainer", {
            appHash: gbc.systemAppId
          });
          if (this.isLogPlayerRequested()) {
            this._logPlayer = cls.WidgetFactory.createWidget("LogPlayer", {
              appHash: gbc.systemAppId
            });
            this._logPlayer.addChildWidget(this._widget);
          }
          window.requestAnimationFrame(function() {
            const w = this._logPlayer ? this._logPlayer : this._widget;
            document.body.appendChild(w.getElement());
            if (this.isLogPlayerRequested()) {
              context.HostLeftSidebarService.enableSidebar(true);
            }
          }.bind(this));
          this._defaultTitle = document.title;
          this._applicationHostWidget = cls.WidgetFactory.createWidget("ApplicationHost", {
            appHash: gbc.systemAppId
          });
          this._widget.addChildWidget(this._applicationHostWidget);

          // create drop down container
          if (!this._dropDownContainer) {
            // TODO rename gbc_DropDownContainerWidget to gbc_DropDownContainer (this is not a widget)
            this._dropDownContainer = document.createElement("div");
            this._dropDownContainer.addClasses("gbc_DropDownContainerWidget", "hidden");
            document.body.appendChild(this._dropDownContainer);
          }
          // preload mono font
          if (!this._fontPreloader) {
            this._fontPreloader = document.createElement("span");
            this._fontPreloader.textContent = "M";
            this._fontPreloader.addClasses("gbc_MonoFontPreloader");
            document.body.appendChild(this._fontPreloader);
          }
          context.HostLeftSidebarService.preStart();
        }
      },
      getWidget: function() {
        return this._widget;
      },

      /**
       *
       * @returns {classes.ApplicationHostWidget}
       */
      getApplicationHostWidget: function() {
        return this._applicationHostWidget;
      },

      getLogPlayer: function() {
        return this._logPlayer;
      },

      start: function() {
        const params = context.UrlService.currentUrl().getQueryStringObject();
        if (window.gbcWrapper.protocolType !== "direct" && (params.app || context.bootstrapInfo.appName)) {
          context.SessionService.startApplication(params.app || context.bootstrapInfo.appName);
        } else {
          this.displayNoSession();
        }
      },
      displaySession: function() {
        this._applicationHostWidget.getLauncher().setHidden(true);
      },
      displayNoSession: function() {
        this._applicationHostWidget.getLauncher().setHidden(false);
      },
      whenError: function(cb) {
        this._eventListener.when('error', cb);
      },
      /**
       *
       * @param {number?} appHash
       * @returns {classes.WindowNode}
       */
      getCurrentWindowNode: function(appHash) {
        if (typeof appHash === "number" && appHash >= 0) {
          return context.SessionService.getCurrent().getApplicationByHash(appHash).getCurrentWindow();
        }
        return this._currentWindowNode;
      },
      /**
       * @param {number?} appHash
       * @returns {classes.WindowWidget}
       */
      getCurrentWindowWidget: function(appHash) {
        const windowNode = this.getCurrentWindowNode(appHash);
        return windowNode && windowNode.getWidget();
      },
      /**
       */
      unsetCurrentWindowNode: function() {
        this._currentWindowNode = null;
      },

      /**
       * Defines the initial state of the window (UR only).
       * @param {String} state - state of the window
       */
      setWindowState: function(state) {
        this._windowState = state;
      },
      /**
       * Get the state of the window as defined in the 4ST
       * @return {String}
       */
      getWindowState: function() {
        return this._windowState || "normal";
      },

      /**
       * get info about the current available closebutton if any
       * @return {*}
       * @private
       */
      _getCurrentWindowCloseButtonInfo: function() {
        let result = null;
        const windowNode = this.getCurrentWindowNode(),
          windowWidget = windowNode && windowNode.getWidget();
        if (windowWidget) {
          const uiWidget = windowWidget.getUserInterfaceWidget && windowWidget.getUserInterfaceWidget(),
            app = uiWidget && uiWidget.getParentWidget();
          if (app && app._tabbedPage) {
            if (this._tabbedHostInfo) {
              result = this.getCloseButtonInfo(this._tabbedHostInfo.node);
            }
          } else {
            result = this.getCloseButtonInfo(windowNode);
          }
        }
        return result;
      },

      /**
       * do a click if possible on the current available closebutton if any
       */
      tryCloseButtonClick: function() {
        const closeInfo = this._getCurrentWindowCloseButtonInfo();
        if (closeInfo && closeInfo.closeWidget) {
          closeInfo.closeWidget.manageMouseClick();
        }
      },
      /**
       *
       * @param {Hook} hook
       * @return {HandleRegistration}
       */
      onCurrentWindowChange: function(hook) {
        return this._eventListener.when(this.currentWindowChanged, hook);
      },

      syncCurrentWindow: function() {
        const session = context.SessionService.getCurrent(),
          app = session && session.getCurrentApplication();
        if (app && app.getUI()) {
          const appUI = app.getUI();
          appUI.syncCurrentWindow();
        }
      },

      updateDisplay: function() {
        if (this._applicationHostWidget) {
          const session = context.SessionService.getCurrent();
          let app = session && session.getCurrentApplication();
          if (session && session.isInTabbedContainerMode()) {
            app = session.displayChanged();
          }
          if (app && app.scheduler) {
            app.scheduler.layoutCommand({
              resize: true
            });

            let ui = app.getUI();
            let appWidget = ui && ui.getWidget();
            let uiWidget = appWidget && appWidget.getUserInterfaceWidget();
            let chromeBar = uiWidget && uiWidget.getChromeBarWidget();

            if (chromeBar) {
              chromeBar.refresh();
            }
          }
        }
      },

      /**
       * - Manage switch of window in the DOM depending on whether they are modal or not and having WebComponent or not.
       * - Display/hide topmenu & toolbars of active/inactive windows.
       * - Set window title
       * @param {classes.WindowNode} windowToDisplay
       */
      setDisplayedWindowNode: function(windowToDisplay) {
        this.updateDisplay();
        const session = context.SessionService.getCurrent();
        if (session) {
          if (windowToDisplay) {
            const
              app = session && session.getCurrentApplication(),
              currentWindowWidget = this._currentWindowNode && this._currentWindowNode.getWidget(),
              currentWindowUIWidget = currentWindowWidget && currentWindowWidget.getUserInterfaceWidget(),
              appUIWidget = app && app.getUI() && app.getUI().getWidget(),
              tabbedPage = appUIWidget && appUIWidget._tabbedPage,
              windowToDisplayWidget = windowToDisplay.getWidget(),
              windowToDisplayIsModal = windowToDisplayWidget && windowToDisplayWidget.isModal,
              windowToDisplayUIWidget = windowToDisplayWidget && windowToDisplayWidget.getUserInterfaceWidget(),
              switchingApplication = !this._currentWindowNode || (windowToDisplayUIWidget !== currentWindowUIWidget),
              areInSameApplication = appUIWidget === windowToDisplayUIWidget,
              windowToDisplayHasWebComponent = windowToDisplayWidget && windowToDisplayWidget.hasChildWebComponent(),
              windowToDisplayElement = windowToDisplayWidget && windowToDisplayWidget.getElement(),
              windowToDisplayUIContainerElement = windowToDisplayUIWidget.getContainerElement(),
              windowText = windowToDisplayWidget ? (windowToDisplayWidget.getText() || windowToDisplayUIWidget.getText()) : "",
              windowIcon = windowToDisplayWidget ? (windowToDisplayWidget.getImage() || windowToDisplayUIWidget.getImage()) : "";
            let
              previousWindow = windowToDisplayUIWidget._activeWindow,
              previousWindowWidget = previousWindow && previousWindow.getWidget(),
              previousWindowIsModal = previousWindowWidget && previousWindowWidget.isModal,
              previousWindowHasWebComponent = previousWindowWidget && previousWindowWidget.hasChildWebComponent();

            // If new window is a modal, we don't remove/insert it in DOM. Modal is fully managed by WindowTypeVMBehavior
            session.getNavigationManager().freezeWindow(this._currentWindowNode, windowToDisplayIsModal);
            // determine if in current application a switch of window occured
            // if only a switch of application occured without change of window in current app, we do nothing (application management done by SessionWidget did all the job)

            if (switchingApplication) {
              context.DebugService.onApplicationSwitch();
            }
            // TODO what happens when previousWindow === win ?
            // if app window changed and new active window isn't a modal, we add it to DOM
            if (switchingApplication || !windowToDisplayIsModal) {
              // WebComponent Management
              if (previousWindowHasWebComponent || windowToDisplayHasWebComponent) {
                // if window to remove has a webcomponent, just send it far away out of view, without removing it
                if (previousWindowHasWebComponent) {
                  previousWindowWidget.addClass("gbc_out_of_view");
                  if (!windowToDisplayHasWebComponent && windowToDisplayUIContainerElement) {
                    windowToDisplayUIContainerElement.appendChild(windowToDisplayElement);
                  }
                } else {
                  if (previousWindowWidget) {
                    previousWindowWidget.getElement().remove();
                  }
                }
                // if window to be displayed has a webcomponent, just put it back in the view
                if (windowToDisplayHasWebComponent) {
                  windowToDisplayWidget.removeClass("gbc_out_of_view");
                  if (!windowToDisplayElement.parentNode) {
                    windowToDisplayUIContainerElement.appendChild(windowToDisplayElement);
                  }
                }
                // if neither previous and new window has WebComponent
              } else if (windowToDisplayUIWidget) {
                // TODO when previousWindow === win
                // TODO window is removed and immediately added to DOM this useless
                // TODO and activate signal is sent whereas it should not
                if (windowToDisplayUIContainerElement) {
                  // if previous window wasn't a modal neither, we can safely remove it from DOM
                  if (previousWindowWidget && !previousWindowIsModal) {
                    previousWindowWidget.getElement().remove();
                  }
                  if (!windowToDisplayHasWebComponent && (!windowToDisplayElement.parentElement ||
                      (windowToDisplayElement.parentElement.lastChild !== windowToDisplayElement))) {
                    windowToDisplayUIContainerElement.appendChild(windowToDisplayElement);
                  }
                }
                // send activate signal to inform elements that window is append to DOM
                windowToDisplayUIWidget.activate(windowToDisplayWidget);
              }
            } else if (windowToDisplayIsModal) {
              const childrenWin = windowToDisplayUIWidget.getChildren();
              let nonModalPrevWin = null;
              let winIndex = childrenWin.indexOf(windowToDisplayWidget);
              const parentId = windowToDisplay.getParentWindowId();

              // Get the previous non-modal window to display it
              for (winIndex; winIndex >= 0; winIndex--) {
                nonModalPrevWin = childrenWin[winIndex - 1];
                if (nonModalPrevWin && !nonModalPrevWin.isModal && nonModalPrevWin._auiTag === parentId) {
                  break;
                }
              }
              if (nonModalPrevWin && (nonModalPrevWin.hasChildWebComponent && !nonModalPrevWin.hasChildWebComponent())) {
                if (nonModalPrevWin !== previousWindow && !windowToDisplayUIContainerElement.contains(nonModalPrevWin.getElement())) {
                  windowToDisplayUIContainerElement.appendChild(nonModalPrevWin.getElement());
                }
                nonModalPrevWin._forceVisible = true;
              }
            }
            if (!previousWindow || previousWindow.isDestroyed()) {
              previousWindow = this.getPreviousWindowOfStack(windowToDisplay);
            }
            previousWindowWidget = previousWindow && previousWindow.getWidget();
            previousWindowIsModal = previousWindowWidget && previousWindowWidget.isModal;
            // hide topmenu/toolbar of previous windows if none previous and new window are modal. In that case, topmenu/toolbar container is shared
            if (previousWindowWidget && !previousWindowIsModal && windowToDisplay && !windowToDisplayIsModal) {
              if (previousWindowWidget._activeTopMenuWidget) {
                previousWindowWidget._activeTopMenuWidget.setHidden(true);
              }
            }

            //Manage the top menu of the background window for modal window
            if (previousWindowWidget && previousWindowIsModal && previousWindow.getParentWindowId() > 0) {
              const parentOfWindowToDisplayAsModal = windowToDisplay.getParentNodeWhenModal(),
                parentWidgetOfWindowToDisplayAsModal = parentOfWindowToDisplayAsModal && parentOfWindowToDisplayAsModal.getWidget(),
                parentOfPreviousWindowAsModal = previousWindow.getParentNodeWhenModal(),
                parentWidgetOfPreviousWindowAsModal = parentOfPreviousWindowAsModal && parentOfPreviousWindowAsModal.getWidget();
              if (parentWidgetOfPreviousWindowAsModal && parentWidgetOfPreviousWindowAsModal._activeTopMenuWidget) {
                parentWidgetOfPreviousWindowAsModal._activeTopMenuWidget.setHidden(true);
              }
              if (parentWidgetOfWindowToDisplayAsModal && parentWidgetOfWindowToDisplayAsModal._activeTopMenuWidget) {
                parentWidgetOfWindowToDisplayAsModal._activeTopMenuWidget.setHidden(false);
                if (windowToDisplayIsModal && previousWindow &&
                  (previousWindow !== parentOfWindowToDisplayAsModal) && previousWindowWidget._activeTopMenuWidget) {
                  previousWindowWidget._activeTopMenuWidget.setHidden(true);
                }
              }
            }

            if (windowToDisplayWidget) {
              // display topmenu/toolbar of new current window
              if (windowToDisplayWidget._activeTopMenuWidget) {
                windowToDisplayWidget._activeTopMenuWidget.setHidden(false);
              }
              if (windowToDisplayWidget._toolBarWidget) {
                windowToDisplayWidget._toolBarWidget.setHidden(false);
              }
            }

            this._currentWindowNode = windowToDisplay;
            const windowToDisplayApplication = windowToDisplay && windowToDisplay.getApplication();
            if (windowToDisplayApplication) {
              windowToDisplayApplication.setCurrentWindow(windowToDisplay);
            }
            windowToDisplayUIWidget._activeWindow = windowToDisplay.isDestroyed() ? null : windowToDisplay;

            session.getNavigationManager().unfreezeWindow(this._currentWindowNode);

            if (windowToDisplayWidget) {
              const chromebar = windowToDisplayWidget.getParentWidget().getChromeBarWidget();
              if (chromebar) {
                chromebar.setLinkedWindow(windowToDisplayWidget);
              }

              // if we switched application we need to invalidate allocated space
              if (previousWindow && switchingApplication) {
                windowToDisplayWidget.getLayoutEngine().invalidateAllocatedSpace();
              }
              // set current window title (icon + text) as application host menu title
              if (areInSameApplication && !switchingApplication && tabbedPage) {
                if (!windowToDisplayWidget.isModal) {
                  tabbedPage.setText(windowText);
                  tabbedPage.setImage(windowIcon);
                }
              }
              if (!app || (!tabbedPage && !windowToDisplayWidget.isModal)) {
                session.getNavigationManager().setCurrentWindow(windowToDisplay);
                //A                this.setCurrentTitle(windowText);
                //A                this.setCurrentIcon(windowIcon);
              }
            }
            if (switchingApplication || windowToDisplay !== previousWindow) {
              this._eventListener.emit(this.currentWindowChanged, windowToDisplayWidget);
            }
            // need to refresh current application layout for potential background dynamic VM update
            if (app) {
              if (app.dvm) {
                app.dvm.updateProcessingStatus();
              }
              app.scheduler.layoutCommand();
              app.scheduler.restoreFocusCommand(true);
            }
          }
          session.getNavigationManager().updateItemsStatuses(this._currentWindowNode);
        }
      },

      unsetDisplayedWindowNode: function() {
        this.setDisplayedWindowNode(null);
      },

      /**
       * Define the current app title to display
       * @param {string} title - text to display in top bar
       * @param {classes.Application} app -
       */
      setDocumentTitle: function(title, app) {
        if (document.title !== title && app) {
          document.title = title ? title : this._defaultTitle;
          context.__wrapper.nativeCall(context.__wrapper.param({
            name: "windowTitle",
            args: {
              "title": document.title
            }
          }, app));
        }
      },

      /**
       * Define the current icon for this app
       * @param {string} img - the icon url for current app
       * @param {string} appIcon - the global icon url
       */
      setCurrentIcon: function(img, appIcon) {
        const app = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
        const uiWidget = app && app.model.getNode(0) && app.model.getNode(0).getWidget();
        if (uiWidget && uiWidget.getChromeBarWidget()) {
          uiWidget.getChromeBarWidget().setIcon(img, appIcon);
        }
      },

      /**
       * @param {classes.WindowNode} windowNode
       */
      getCloseButtonInfo: function(windowNode) {
        const app = windowNode && windowNode.getApplication(),
          appHash = app && app.applicationHash,
          windowWidget = windowNode && windowNode.getWidget(),
          windowUuid = windowWidget && windowWidget.getUniqueIdentifier();
        return windowNode && this._closeButtonsInfo[appHash] && this._closeButtonsInfo[appHash][windowUuid];
      },
      /**
       *
       * @param {classes.WindowNode} windowNode
       */
      setTabbedHost: function(windowNode) {
        const windowWidget = windowNode && windowNode.getWidget();
        this._tabbedHostInfo = {
          node: windowNode,
          widget: windowWidget,
          appHash: windowWidget._appHash,
          windowId: windowWidget.getUniqueIdentifier()
        };
      },
      /**
       *
       * @param {classes.WindowNode} windowNode
       * @param {classes.WidgetBase} widget
       * @param {Object} opts
       */
      registerClosableWindow: function(windowNode, widget, opts) {
        const app = windowNode && windowNode.getApplication(),
          appHash = app && app.applicationHash,
          windowWidget = widget || windowNode && windowNode.getWidget(),
          windowUuid = windowWidget && windowWidget.getUniqueIdentifier();
        // Add a window to the stack
        if (this._windowStack.indexOf(windowNode) < 0) {
          this._windowStack.push(windowNode);
        }
        if (windowNode && this._closeButtonsInfo[appHash] && this._closeButtonsInfo[appHash][windowUuid]) {
          this.unregisterClosableWindow(windowNode, true);
        }
        this._widgetToNodeWindows.set(windowWidget, windowNode);
        const perAppInfo = this._closeButtonsInfo[appHash] = this._closeButtonsInfo[appHash] || {};
        const closeInfo = perAppInfo[windowUuid] = perAppInfo[windowUuid] || {};

        // Tabbed host with different window (hosted window)
        if (this._tabbedHostInfo && this._tabbedHostInfo.appHash !== appHash) {
          if (opts && opts.chromeBar) {

            opts.chromeBar.setHidden(true);
          }
          closeInfo.closeWidget = cls.WidgetFactory.createWidget("TabbedApplicationClose", {
            appHash: gbc.systemAppId
          });
          closeInfo.closeClickHandler = closeInfo.closeWidget.onClick(windowWidget._emitClose.bind(windowWidget));

          const session = context.SessionService.getCurrent(),
            application = session && session.getApplicationByHash(appHash),
            applicationWidget = application && application.getUI() && application.getUI().getWidget(),
            actionsElement = applicationWidget && applicationWidget._tabbedPage && applicationWidget._tabbedPage.getTitleWidget()
            .getActionsContainerElement();
          this.setClosableWindowActionProcessing(windowWidget, application.isProcessing());
          if (actionsElement) {
            actionsElement.appendChild(closeInfo.closeWidget.getElement());
          }

          // Tabbed host with a window (host window)
        } else if (this._tabbedHostInfo && this._tabbedHostInfo.appHash === appHash) {
          //  if chromebar
          if (opts && opts.chromeBar) {
            closeInfo.closeWidget = opts.chromeBar.getGbcMenuItem("close");
            closeInfo.closeWidget.setLinkedWindow(windowWidget);
          }
        } else {
          // default case
          //  if chromebar
          if (opts && opts.chromeBar) {
            closeInfo.closeWidget = opts.chromeBar.getGbcMenuItem("close");
            if (!closeInfo.closeWidget.isHidden()) {
              closeInfo.closeWidget.setLinkedWindow(windowWidget);
            }
          }
        }
      },

      unregisterClosableWindow: function(windowNode, noHostDelete) {
        const app = windowNode && windowNode.getApplication(),
          appHash = app && app.applicationHash,
          windowWidget = windowNode && windowNode.getWidget(),
          windowUuid = windowWidget && windowWidget.getUniqueIdentifier();
        this._widgetToNodeWindows.delete(windowWidget);
        // Remove window from the stack
        if (this._windowStack.indexOf(windowNode) >= 0) {
          this._windowStack.splice(this._windowStack.indexOf(windowNode), 1);
        }
        const closeInfo = this.getCloseButtonInfo(windowNode);
        if (closeInfo.closeWidget.isInstanceOf(cls.ChromeBarItemCloseWidget)) {
          closeInfo.closeWidget.setLinkedWindow(null); // Should restore old linked window
          if (!noHostDelete && this._tabbedHostInfo && this._tabbedHostInfo.windowId === windowUuid) {
            delete this._tabbedHostInfo;
          }
        } else {
          if (closeInfo && closeInfo.closeWidget && !closeInfo.closeWidget.isDestroyed()) {
            closeInfo.closeWidget.getElement().remove();
            if (closeInfo.closeClickHandler) {
              closeInfo.closeClickHandler();
              closeInfo.closeClickHandler = null;
            }
            closeInfo.closeWidget.destroy();
            closeInfo.closeWidget = null;
            delete this._closeButtonsInfo[appHash][windowUuid];
            if (!Object.keys(this._closeButtonsInfo[appHash]).length) {
              delete this._closeButtonsInfo[appHash];
            }
            if (!noHostDelete && this._tabbedHostInfo && this._tabbedHostInfo.windowId === windowUuid) {
              delete this._tabbedHostInfo;
            }
          }
        }
      },
      setClosableWindowActionActive: function(windowWidget, active, winNode) {
        const windowNode = this._widgetToNodeWindows.get(windowWidget) || winNode;
        const closeInfo = this.getCloseButtonInfo(windowNode);
        if (closeInfo && closeInfo.closeWidget) {
          closeInfo.closeWidget.setActive(active, windowWidget);
        }
      },
      setClosableWindowActionHidden: function(windowWidget, hidden) {
        const windowNode = this._widgetToNodeWindows.get(windowWidget);
        const closeInfo = this.getCloseButtonInfo(windowNode);
        if (closeInfo && closeInfo.closeWidget && windowWidget.isClosable()) {
          closeInfo.closeWidget.setHidden(hidden, windowWidget);
        }
      },
      setClosableWindowActionProcessing: function(windowWidget, processing) {
        const windowNode = this._widgetToNodeWindows.get(windowWidget);
        const closeInfo = this.getCloseButtonInfo(windowNode);
        if (closeInfo && closeInfo.closeWidget && closeInfo.closeWidget._setProcessingStyle) {
          closeInfo.closeWidget._setProcessingStyle(processing);
        }
      },

      /**
       * Handler when the screen orientation changed
       * @param {function} callback - method to call once screen orientation changes
       * @note mobile only
       */
      onOrientationChange: function(callback) {
        return this._eventListener.when("orientationChange.Host", callback.bind(this));
      },

      /**
       * Handler when the screen size changed
       * @param {function} callback - method to call once screen size changes
       */
      onScreenResize: function(callback) {
        return this._eventListener.when("resize.Host", callback.bind(this));
      },

      /**
       * Check if current gbc is running as UR
       * @return {Boolean} - true if native, false otherwise
       */
      isUR: function() {
        return gbc.__wrapper.isNative();
      },

      /**
       *
       * @param {classes.WindowWidget} windowToDisplay
       */
      getPreviousWindowOfStack: function(windowToDisplay) {
        let newIndex = this._windowStack.indexOf(windowToDisplay) - 1;
        newIndex = newIndex >= 0 ? newIndex : 0;
        return this._windowStack[newIndex];
      }
    });
    context.InitService.register(context.HostService);
  });
;

"use strict";

modulum('LocalSettingsService', ['InitService'],
  function(context, cls) {

    /**
     * GBC local settings (local storage) service
     * @namespace gbc.LocalSettingsService
     * @gbcService
     */
    context.LocalSettingsService = context.oo.StaticClass( /** @lends gbc.LocalSettingsService */ {
      __name: "LocalSettingsService",
      _eventListener: null,
      _quotaExceededError: false,

      init: function() {
        this._eventListener = new cls.EventListener();
        if (!localStorage) {
          console.error("localStorage is not enabled, you might experience some errors");
        }
      },

      read: function(id) {
        if (localStorage) {
          return JSON.parse(localStorage.getItem(id));
        } else {
          return false;
        }
      },

      write: function(id, contents) {
        try {
          localStorage.setItem(id, JSON.stringify(contents));
        } catch (e) {
          if (e.name === "QuotaExceededError") {
            console.error(e);
            this._quotaExceededError = true;
            this._eventListener.emit("QuotaExceededError");
          }
        }
      },
      remove: function(id) {
        localStorage.removeItem(id);
      },
      keys: function() {
        return Object.keys(localStorage);
      },
      clear: function() {
        localStorage.clear();
      }
    });
    context.InitService.register(context.LocalSettingsService);
  });
;

"use strict";

modulum('StoredSettingsService', ['InitService', 'LocalSettingsService'],
  function(context, cls) {

    /**
     * Stored Settings Service to handle clientside specific configurations
     * @class gbc.StoredSettingsService
     * @gbcService
     */
    gbc.StoredSettingsService = context.oo.Singleton( /** @lends gbc.StoredSettingsService */ {
      __name: "StoredSettingsService",

      /**
       * NameSpace for Stored App Settings to avoid conflict
       */
      _storedSettingsAppName: "storedSettings_gwcJS",

      /**
       * NameSpace for layout settings
       */
      _storedSettingsLayoutDataName: "storedSettingsLayout_gwcJS",

      /**
       * Copy of browser stored app settings
       * @type {Object}
       */
      _storedSettings: null,

      /**
       * Copy of browser stored layout settings
       * @type {Object}
       */
      _storedLayoutSettings: null,

      /**
       * Flag to define if stored settings are enabled or not
       * @type {boolean}
       */
      _storedSettingsEnable: true,

      /**
       * Keep track of disabled tables in an array
       * @type {Array}
       */
      _disabledTables: [],

      /**
       * Keep track of disabled tables
       */
      _disabledWindows: [],

      /**
       * Updated forms name
       * @type {Set<string>}
       */
      _updatedForms: null,

      _eventListener: new cls.EventListener(),

      /**
       * Should be called once
       */
      init: function() {
        this._storedSettings = context.LocalSettingsService.read(this._storedSettingsAppName);
        this._updatedForms = new Set();

        if (!this._storedSettings) {
          try {
            context.LocalSettingsService.write(this._storedSettingsAppName, {});
            context.LocalSettingsService.write(this._storedSettingsLayoutDataName, {});
            this._storedSettings = {};
            this._storedLayoutSettings = {};
          } catch (e) {
            this._storedSettingsEnable = false;
          }
        } else {
          this._storedLayoutSettings = context.LocalSettingsService.read(this._storedSettingsLayoutDataName);
        }

        context.InitService.when(gbc.constants.widgetEvents.onBeforeUnload, function() {
          if (context.SessionService.getCurrent() &&
            context.SessionService.getCurrent().isInBrowserMultiPageMode() &&
            !context.SessionService.getCurrent().isMasterBrowserPage()
          ) {
            return;
          }
          this.sync();
        }.bind(this));
      },

      moveLayoutSettings: function() {
        if (!this._storedLayoutSettings) {
          let settings = context.LocalSettingsService.read(this._storedSettingsLayoutDataName);

          if (!settings) {
            settings = this._storedSettings;
          } else {
            this._storedLayoutSettings = settings;
            return;
          }

          if (!settings) {
            settings = context.LocalSettingsService.read(this._storedSettingsAppName);
          }

          if (settings && settings.gwc && settings.gwc.forms) {
            this._storedLayoutSettings = {
              gwc: {
                forms: settings.gwc.forms
              }
            };
          } else {
            this._storedLayoutSettings = {
              gwc: {}
            };
          }

          this.writeLayoutData(this._storedLayoutSettings);
          this.syncLayout();
        }
      },

      /**
       * Access to a local copy of stored data or browser's one if local copy is empty
       * @returns {Object}
       */
      readSettingsData: function() {
        return this._storedSettings || context.LocalSettingsService.read(this._storedSettingsAppName);
      },

      /**
       * Access to a local copy of layout stored data or browser's one if local copy is empty
       * @returns {Object}
       */
      readLayoutData: function() {
        let session = context.SessionService.getCurrent();
        if (session && (session.isInBrowserMultiPageMode() || !session.isMasterBrowserPage())) {
          this._storedLayoutSettings = context.LocalSettingsService.read(this._storedSettingsLayoutDataName);
          return this._storedLayoutSettings;
        }

        this._storedLayoutSettings = this._storedLayoutSettings || context.LocalSettingsService.read(this._storedSettingsLayoutDataName);
        return this._storedLayoutSettings;
      },

      /**
       * Write the local copy of stored App data
       * @param object
       */
      writeSettingsData: function(object) {
        this._storedSettings = object;
      },

      /**
       * Write the local copy of stored layout data
       * @param object
       */
      writeLayoutData: function(object) {
        this._storedLayoutSettings = object;
        let session = context.SessionService.getCurrent();
        if (session && (session.isInBrowserMultiPageMode() || !session.isMasterBrowserPage())) {
          context.LocalSettingsService.write(this._storedSettingsLayoutDataName, this._storedLayoutSettings);
        }
      },

      /**
       * Synchronize the App temporary stored settings to the browser'storage
       * @note Keep in mind that calling this many times will lower performances
       */
      syncApp: function() {
        context.LocalSettingsService.write(this._storedSettingsAppName, this._storedSettings);
      },

      /**
       * Synchronize the Layout temporary stored settings to the browser'storage
       * @note Keep in mind that calling this many times will lower performances
       */
      syncLayout: function() {
        let session = context.SessionService.getCurrent();
        if (session && (session.isInBrowserMultiPageMode() || !session.isMasterBrowserPage())) {
          context.LocalSettingsService.write(this._storedSettingsLayoutDataName,
            this._extend(true, context.LocalSettingsService.read(this._storedSettingsLayoutDataName),
              this._keepUpdatedForms(this._storedLayoutSettings)));
        } else {
          context.LocalSettingsService.write(this._storedSettingsLayoutDataName, this._storedLayoutSettings);
        }
      },

      /**
       * Synchronize all the temporary stored settings to the browser'storage
       * @note Keep in mind that calling this many times will lower performances
       */
      sync: function() {
        context.LocalSettingsService.write(this._storedSettingsAppName, this._storedSettings);
        this.syncLayout();
      },

      /**
       * Return a tree with only the updated forms
       * @private
       */
      _keepUpdatedForms: function() {
        if (!this._storedLayoutSettings.gwc || !this._storedLayoutSettings.gwc.forms) {
          return {};
        }

        const keys = Object.keys(this._storedLayoutSettings.gwc.forms);
        const res = {
          gwc: {
            forms: {}
          }
        };

        keys.forEach(function(key) {
          if (this._updatedForms.has(key)) {
            res.gwc.forms[key] = this._storedLayoutSettings.gwc.forms[key];
          }
        }.bind(this));

        return res;
      },

      /**
       *
       * @param deep
       * @param oldSettings
       * @param newSettings
       * @returns {{}}
       * @private
       */
      _extend: function(deep, oldSettings, newSettings) {
        // Variables
        const extended = {};

        // Merge the object into the extended object
        const merge = (obj) => {
          for (let prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
              if (Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                if (!deep && Object.getOwnPropertyNames(obj[prop]).length === 0) {
                  delete extended[prop];
                } else {
                  extended[prop] = this._extend(deep, extended[prop], obj[prop]);
                }
              } else {
                extended[prop] = obj[prop];
              }
            }
          }
        };

        merge(oldSettings);
        merge(newSettings);

        return extended;
      },

      /**
       * Write the stored Settings in Local Storage of the browser
       * /!\ you should not call this function directly, it will break the stored settings
       * @param {boolean} isLayoutData
       * @param {object|string} newSettings
       * @param {boolean} [deep]
       * @private
       */
      _update: function(isLayoutData, newSettings, deep = true) {

        // Pass in the objects to merge as arguments.
        // For a deep extend, set the first argument to `true`.

        const oldSettings = isLayoutData ? this.readLayoutData() : this.readSettingsData();

        const finalSettings = this._extend(deep, oldSettings, newSettings);
        if (isLayoutData) {
          this.writeLayoutData(finalSettings);
        } else {
          this.writeSettingsData(finalSettings);
        }
      },

      /**
       * Will create an object according to the accessor key given
       * @param key {string} accessor to the setting
       * @param leafValue
       * @returns {{}}
       * @private
       */
      _buildTree: function(key, leafValue) {
        const obj = {};
        const splittedKey = key.split('.');
        const splicedKey = key.split('.');
        let newKey = '';

        //Create branch
        if (splittedKey.length > 1) {
          for (let i = 0; splittedKey.length > 0; i++) {
            if (!obj.hasOwnProperty(splittedKey[i])) {
              newKey = splicedKey.splice(i + 1).join('.');
              if (newKey.length > 0) {
                obj[splittedKey[i]] = this._buildTree(newKey, leafValue);
              } else {
                break;
              }
            } else {
              break;
            }
          }
        } else { //create Leaf
          obj[key] = leafValue === 0 ? 0 : leafValue || false;
        }
        return obj;
      },

      /**
       * Helper to get a cookie by name
       * @param name {string}
       * @returns {*}
       * @private
       */
      _getCookie: function(name) {
        const match = document.cookie.match(new RegExp(name + '=([^;]+)'));
        if (match) {
          return match[1];
        }
      },

      /**
       * Check if table/window has been disabled by 4ST style
       * @param key {string} accessor to stored ressource
       * @returns {boolean}
       * @private
       */
      _isForcedDefault: function(key) {
        //Check if form disabled
        const formName = key.replace('gwc.forms.', '').split('.')[0];
        //Check if table disabled
        const tableName = key.replace('gwc.forms.' + formName + '.tables.', '').split('.')[0];

        return (this._disabledWindows.indexOf(formName) >= 0 || this._disabledTables.indexOf(tableName) >= 0);
      },

      /**
       * Choose to use or not Stored Settings
       * @param {boolean} state is Enable?
       */
      enable: function(state) {
        this._storedSettingsEnable = state;
        this._update(false, {
          'storedSettingDisabled': !state
        }, false);
      },

      /**
       * Check if StoredSettings are enabled or not
       * @returns {boolean}
       */
      areEnabled: function() {
        const allStored = this.readSettingsData();
        if (allStored === null) {
          return false;
        }
        /* jshint ignore:start */
        if (allStored.hasOwnProperty('storedSettingDisabled')) {
          this._storedSettingsEnable = !allStored.storedSettingDisabled;
        }
        /* jshint ignore:end */
        return this._storedSettingsEnable;
      },

      /**
       * Disable stored Settings of a given window
       * @param winName
       * @param disable
       */
      disableWindowStoredSettings: function(winName, disable) {
        if (!disable) {
          const index = this._disabledWindows.indexOf(winName);
          if (index >= 0) {
            this._disabledWindows.splice(index, 1);
          }
        } else {
          this._disabledWindows.push(winName);
        }
      },

      /**
       * Disable stored Settings of a given table
       * @param tableName
       * @param disable
       */
      disableTableStoredSettings: function(tableName, disable) {
        if (!disable) {
          const index = this._disabledTables.indexOf(tableName);
          if (index >= 0) {
            this._disabledTables.splice(index, 1);
          }
        } else {
          this._disabledTables.push(tableName);
        }
      },

      /**
       * Reset and erase all stored settings
       */
      reset: function() {
        this.writeSettingsData({});
        this.writeLayoutData({});
        this._eventListener.emit('storedSettingsReset');
      },

      /**
       * Reset and erase a specific stored settings
       * @param key {?string} key to remove from stored settings
       */
      removeSettings: function(key) {
        this.setSettings(key, {}, true); //true to replace
      },

      /**
       * Get a stored setting by its key accessor (i.e: gwc.app.something)
       * @param {string} key
       * @returns {*}
       */
      getSettings: function(key) {
        let settings = key.startsWith("gwc.forms.") ? this.readLayoutData() : this.readSettingsData();
        const keys = key.split('.');
        if (this.areEnabled() && !this._isForcedDefault(key)) {
          for (const element of keys) {
            if (settings.hasOwnProperty(element)) {
              settings = settings[element];
            } else {
              settings = null;
              break;
            }
          }
          return typeof(settings) === 'undefined' ? null : settings;
        } else {
          return null;
        }

      },

      /**
       * Store a setting, create the accessor path if non-existing
       * @param {string} key accessor to the setting
       * @param {*} settings
       * @param {boolean} [replace]
       * @returns {boolean} true if success / false otherwise
       */
      setSettings: function(key, settings, replace = false) {
        if (this.areEnabled() && !this._isForcedDefault(key)) {
          const isLayoutSettings = key.startsWith("gwc.forms.");

          const match = key.match(/^(gwc\.forms\.)(\w*)(\..*)$/);
          if (match) {
            this._updatedForms.add(match[2]);
          }

          //get Settings first
          let existingSetting = this.getSettings(key);

          //If existing : update values
          if (!existingSetting) {
            const tree = this._buildTree(key);
            this._update(isLayoutSettings, tree);
          }

          existingSetting = settings;
          const allStored = this._goDown(key, existingSetting);
          this._update(isLayoutSettings, allStored, !replace);
          return true;
        } else {
          return false;
        }
      },

      /**
       * Used to be recursive
       * @param key
       * @param settings
       * @returns {*|{}}
       * @private
       */
      _goDown: function(key, settings) {
        return this._buildTree(key, settings);
      },

      //Sidebar related functions
      /**
       * Store the sidebar status: visible / hiiden
       * @param visible {bool}
       */
      setSideBarVisible: function(visible) {
        this.setSettings('gwc.app.sidebar.visible', visible);
      },

      /**
       * Check if sideBar is visible
       * @returns {bool}
       */
      isSideBarVisible: function() {
        return this.getSettings('gwc.app.sidebar.visible');
      },

      /**
       * Store the sidebar width
       * @param width {number}
       */
      setSideBarwidth: function(width) {
        this.setSettings('gwc.app.sidebar.width', width);
      },

      /**
       * Get the sidebar width
       * @returns {number}
       */
      getSideBarwidth: function() {
        return this.getSettings('gwc.app.sidebar.width');
      },

      //Language related functions
      /**
       * Manually set the language of the interface
       * @param locale {string} should be something like "en-US" or "fr-FR"
       */
      setLanguage: function(locale) {
        this.setSettings('gwc.app.locale', locale);
        gbc.I18NService.setLng(locale);
      },

      /**
       * Get the language set
       * @returns {string} locale
       */
      getLanguage: function() {
        let locale = this.getSettings('gwc.app.locale');
        if (!locale) {
          locale = this._getCookie('lang');
        }
        return locale;
      },

      //Log level related functions
      /**
       * store the log level
       * @param loglevel {string}
       */
      setLoglevel: function(loglevel) {
        this.setSettings('gwc.app.loglevel', loglevel);
      },

      /**
       * Get the log level
       * @returns {string} loglevel
       */
      getLoglevel: function() {
        return this.getSettings('gwc.app.loglevel') || 'none';
      },

      //Log types related functions
      /**
       * store the log types
       * @param logtypes {string}
       */
      setLogtypes: function(logtypes) {
        this.setSettings('gwc.app.logtypes', JSON.stringify(logtypes));
      },

      /**
       * Get the log types
       * @returns {string} logtypes
       */
      getLogtypes: function() {
        return JSON.parse(this.getSettings('gwc.app.logtypes') || "null");
      },

      //Splitter related functions
      /**
       * Define a splitter according to parameters
       * @param formName
       * @param identifier
       * @param splitInfo
       */
      setSplitter: function(formName, identifier, splitInfo) {
        const selector = 'gwc.forms.' + formName + '.layoutContainer.' + identifier;
        this.setSettings(selector, splitInfo);
      },

      /**
       * Get Splitter info
       * @param formName
       * @param identifier
       * @returns {*}
       */
      getSplitter: function(formName, identifier) {
        const selector = 'gwc.forms.' + formName + '.layoutContainer.' + identifier;
        return this.getSettings(selector);
      },

      //Collapsible group related functions
      /**
       * Define a group collapsed state according to parameters
       * @param {string} formName
       * @param {string} identifier
       * @param {boolean} collapsedInfo
       */
      setGroupCollapsedState: function(formName, identifier, collapsedInfo) {
        const selector = 'gwc.forms.' + formName + '.groupCollapsed.' + identifier;
        this.setSettings(selector, collapsedInfo);
      },

      /**
       * Get group collapsed state
       * @param {string} formName
       * @param {string} identifier
       * @returns {boolean}
       */
      getGroupCollapsedState: function(formName, identifier) {
        const selector = 'gwc.forms.' + formName + '.groupCollapsed.' + identifier;
        return this.getSettings(selector);
      },

      /**
       * Handling a callback on reset storedSettings
       * @param hook
       * @returns {*|HandleRegistration}
       */
      whenReset: function(hook) {
        return this._eventListener.when('storedSettingsReset', hook);
      }
    });
    context.InitService.register(context.StoredSettingsService);
  });
;

"use strict";

modulum('TopmenuService', ['InitService', 'DebugService', 'EventListener'],
  function(context, cls) {

    /**
     * Service used to synchronise topmenus across windows and sidebar
     * @namespace gbc.TopmenuService
     * @gbcService
     */
    context.TopmenuService = context.oo.StaticClass( /** @lends gbc.TopmenuService */ {
      __name: "TopmenuService",

      _topmenuList: null,
      _responsiveMenu: null,

      init: function() {
        this._topmenuList = [];
      },

      /**
       * Add a topmenu to the handled tm of this service
       * @param {classes.TopMenuWidget} topmenu - tm to add
       */
      addTopMenu: function(topmenu) {
        this._topmenuList.push(topmenu);
      },

      /**
       * Remove a topmenu from the handled tm of this service
       * - used to avoid memory leaks
       * @param {classes.TopMenuWidget} topmenu - tm to delete
       */
      removeTopmenu: function(topmenu) {
        const idx = this._topmenuList.indexOf(topmenu);
        this._topmenuList.splice(idx, 1);
      },

      /**
       * Get all TopMenus of an app
       * @param {Number} appHash - appHash to get topmenus of
       * @return {Array} an array of topmenus
       */
      getAppTopMenus: function(appHash) {
        return this._topmenuList.filter(tm => tm._appHash === appHash);
      },

      /**
       * Sync TopMenus for given app
       *  - will display the topmenu where it should be
       * @param {Number} appHash - app Hash of app to display
       */
      syncTopMenus: function(appHash) {
        const appTM = this.getAppTopMenus(appHash);
        const session = gbc.SessionService.getCurrent();
        const currentWindow = session.getCurrentApplication().getCurrentWindow();

        // Sync only if currentWindow
        if (currentWindow) {

          appTM.forEach((tm, index) => {
            // show Global Topmenu or TopmMenu in current window
            let visible = tm.isGlobal() || tm.getParentWidget() === currentWindow.getWidget();
            let hidden = !visible;

            // if next Topmenu in list is in modal
            if (index + 1 < appTM.length && appTM[index + 1].getWindowWidget()) { // ensure window widget exist in case of startmenu
              // This next topmenu has a modal window as parent, and we are displaying it: show the current TopMenu
              if (appTM[index + 1].getWindowWidget().isModal && currentWindow.isModal()) {
                hidden = false;
              }
            }

            tm.render({
              hidden
            });
          });

          gbc.HostLeftSidebarService.renderAppTopMenu(appHash);
        }
      },

    });
    context.InitService.register(context.TopmenuService);
  });
;

"use strict";

modulum('I18NService', ['InitService'],
  function(context, cls) {

    /**
     * Localization Service to translate the app
     * @namespace gbc.I18NService
     * @gbcService
     * @publicdoc
     */
    context.I18NService = context.oo.StaticClass( /** @lends gbc.I18NService */ {
      __name: 'I18NService',
      _init: false,

      /**
       * Language to use if not defined by user or browser
       * @type {string}
       */
      _fallBackLng: 'en-US',

      /**
       * Event listener object
       * @type {classes.EventListener}
       */
      _eventListener: new cls.EventListener(), //used to listen when i18next is ready

      /**
       * Event name once I18N is ready
       */
      _i18nReady: 'i18nReady',
      change: 'change',

      /**
       * Flag to determine if service is ready or not
       * @type {boolean}
       */
      isReady: false,

      /**
       * Init service method. should be called only once.
       */
      init: function() {
        window.i18next
          .use(window.i18nextBrowserLanguageDetector)
          .init({
            fallbackLng: this._getNormalizedLanguage(),
            resources: window.gbcLocales,
            detection: {
              lookupQuerystring: 'setLng',
              lookupCookie: 'lang',
              caches: ['cookie']
            }
          }, this._onReady.bind(this));
      },

      /**
       * Set the language of the app
       * @param locale {string} language code to set (e.g. en_US, fr_FR ...)
       * @publicdoc
       */
      setLng: function(locale) {
        window.i18next.changeLanguage(this._getNormalizedLanguage(locale)[0]);
        this._eventListener.emit(this.change);
      },

      whenLangChange: function(hook) {
        return this._eventListener.when(this.change, hook);
      },

      /**
       * Translate a widget with i18n data
       * @param {classes.WidgetBase} widget Widget to translate
       * @publicdoc
       */
      translate: function(widget) {
        if (this.isReady) {
          widget.translate();
        } else {
          return this._eventListener.when(this._i18nReady, widget.translate.bind(widget));
        }
        return null;
      },

      /**
       * Get all available translations with locales id
       * @returns {Array} - array of locales id
       * @publicdoc
       */
      getAllLng: function() {
        return Object.keys(window.gbcLocales).map(function(key) {
          if (key !== 'undefined') {
            return {
              'locale': key,
              'language': window.i18next.exists('gwc.lngName', {
                lng: key,
                fallbackLng: 'undef'
              }) ? window.i18next.t('gwc.lngName', {
                lng: key
              }) : key
            };
          }
        });
      },

      /**
       * Ready Handler
       * @private
       */
      _onReady: function() {
        this._checkLanguageCompatibility();
        const storedLng = gbc.StoredSettingsService.getLanguage();
        const cookieLng = gbc.StoredSettingsService._getCookie('lang');
        const language = cookieLng || storedLng || this._fallBackLng;
        document.querySelector("html").setAttribute("lang", language.substring(0, 2));
        // Emit I18n ready
        this._eventListener.emit(this._i18nReady);
        this.isReady = true;
      },

      /**
       * Try to find the closest language as defined by browser
       * @private
       */
      _checkLanguageCompatibility: function() {
        const storedLng = gbc.StoredSettingsService.getLanguage();
        const cookieLng = gbc.StoredSettingsService._getCookie('lang');
        const language = cookieLng || storedLng || this._fallBackLng;

        if (language && !window.gbcLocales[language]) {
          const allLngKeys = Object.keys(window.gbcLocales);
          for (const element of allLngKeys) {
            if (language.startsWith(element.substring(0, 2))) {
              this.setLng(element);
              gbc.StoredSettingsService.setSettings('gwc.app.locale', element);
              break;
            }
          }
        }
      },

      /**
       * Helper to get the browser current language
       * @returns {string} - locale id
       * @public
       */
      getBrowserLanguage: function() {
        return navigator.language || navigator.userLanguage;
      },

      /**
       * Get the normalized locale according to the parameter
       * Will do its best to identify an existing locale
       * @param {string} [locale] - initial str to test, if undef, will take browser language, or fallback one: en-US
       * @return {Array} list of usable locales as fallback (i.e: ["fr-FR","en-US"]) this list allways contain at least one item
       * @private
       */
      _getNormalizedLanguage: function(locale) {
        locale = typeof locale === "undefined" ? false : locale;
        const fallback = locale || this.getBrowserLanguage() || this._fallBackLng;
        const availableLC = Object.keys(window.gbcLocales);
        const fallbackLanguageList = [];
        const localeRegex = /^([a-z]{2})[-_]?([A-Z0-9]*)/;
        let r = null;
        const fallbackR = localeRegex.exec(fallback); // try to match fallback on standardized locale format

        if (fallbackR) {
          for (const element of availableLC) {
            r = localeRegex.exec(element);
            // Check perfect match (i.e 'es-ES'), then taking care of lang without region (i.e 'es-419', 'es_AR' will take only 'es' into account)
            if (element.indexOf(fallback) === 0 || r[1] === fallbackR[1]) {
              if (element === locale) { // add it at begining of the array if the locale match
                fallbackLanguageList.unshift(element);
              } else { // add it at the end of the array
                fallbackLanguageList.push(element);
              }

            }
          }
        }
        // Use en-US as default if nothing found
        if (fallbackLanguageList.indexOf(this._fallBackLng) === -1) {
          fallbackLanguageList.push(this._fallBackLng);
        }
        return fallbackLanguageList;
      },

    });
    context.InitService.register(context.I18NService);
  });
;

"use strict";

modulum('InitService',
  function(context, cls) {

    /**
     * Root Service
     * @namespace gbc.InitService
     * @gbcService
     */
    context.InitService = context.oo.StaticClass( /** @lends gbc.InitService */ {
      __name: "InitService",
      _builtinActionDefaultsKeys: ['enter', 'esc', 'f3', 'ctrl+f3', 'f4', 'f1', 'alt+f4', 'ctrl+f', 'ctrl+g', 'tab', 'shift+tab',
        'down', 'up', 'home', 'end', 'pageup', 'pagedown', 'ctrl+tab', 'ctrl+shift+tab'
      ],

      _services: [],
      _onVisibilityChangeHandler: null,
      _eventListener: new cls.EventListener(),

      create: function(auiData, app, forUnit) {
        app = app || context.MockService.fakeApplication(forUnit);
        const treeModificationTrack = new cls.TreeModificationTracker();
        const node = gbc.classes.NodeFactory.createRecursive(null, auiData, app, treeModificationTrack);
        node.createController();
        return node;
      },
      register: function(service) {
        this._services.push(service);
      },
      /**
       * Fallback method bound on body to manage accelerators when focused unfortunately moved to body
       * @param {domEvent} event - body keydown event
       * @private
       */
      onKeyFallback: function(event) {
        if (document.activeElement.tagName === "BODY") {

          const currentApp = context.SessionService.getCurrent() && context.SessionService.getCurrent().getCurrentApplication();
          if (currentApp && currentApp.keyboard) {

            const appWidget = currentApp.getUI().getWidget();
            if (appWidget) {
              const uiWidget = appWidget._uiWidget;
              if (uiWidget && !uiWidget._destroyed) {
                // 1. Refocus UserInterface widget
                uiWidget.setFocus();
                // 2. Using KeyboardApplicationService logic, we process the key
                currentApp.keyboard._onKeyDown(event);
              }
            }
          }
        }
      },
      initServices: function() {
        this._onVisibilityChangeHandler = function() {
          this.emit(context.constants.widgetEvents.visibilityChange);
        }.bind(this);
        document.addEventListener("visibilitychange", this._onVisibilityChangeHandler);

        for (const element of this._services) {
          element.init();
        }
        context.__wrapper.emit(context.__wrapper.events.SERVICESREADY);
      },
      /**
       * unique identifiers increments storage
       */
      _uniqueId: {
        asString: 0,
        asNumber: 0
      },

      destroy: function() {
        document.removeEventListener("visibilitychange", this._onVisibilityChangeHandler);
        if (context.SessionService.getCurrent()) {
          const currentApp = context.SessionService.getCurrent().getCurrentApplication();
          if (currentApp) {
            currentApp.close();
          }
        }
      },

      /**
       * Get a unique identifier (an auto increment number)
       * @return {number}
       */
      uniqueId: function() {
        return ++this._uniqueId.asNumber;
      },

      /**
       * Get a unique identifier as string (based on an auto increment number)
       * @return {string} a unique identifier as string
       */
      uniqueIdAsString: function() {
        return "" + (++this._uniqueId.asString);
      },

      emit: function(eventName) {
        this._eventListener.emit(eventName);
      },
      when: function(eventName, hook) {
        return this._eventListener.when(eventName, hook);
      }

    });
  });
;

"use strict";

modulum('LayoutInvalidationService',
  function(context, cls) {

    /**
     * Layout Invalidation Service to manage layout invalidations
     * @namespace gbc.LayoutInvalidationService
     * @gbcService
     */
    context.LayoutInvalidationService = context.oo.StaticClass( /** @lends gbc.LayoutInvalidationService */ {
      __name: "LayoutInvalidationService",

      /**
       * next invalidation timestamp
       * @type {number}
       */
      _nextInvalidation: 2,

      /**
       * get next layout timestamp
       * @return {number} the next layout timestamp
       */
      nextInvalidation: function() {
        return this._nextInvalidation++;
      },

      getInitialInvalidation: function() {
        return Number.POSITIVE_INFINITY;
      }
    });
  });
;

"use strict";

modulum('BufferedConsoleLogProvider', ['LogProviderBase', 'ConsoleLogProvider'],
  function(context, cls) {

    /**
     * @class BufferedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.BufferedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, function($super) {
      return /** @lends classes.BufferedConsoleLogProvider.prototype */ {
        __name: "BufferedConsoleLogProvider",
        throttle: 100,
        buffer: null,
        console: null,
        currentLevel: "none",
        constructor: function() {
          $super.constructor.call(this);
          this.buffer = [];
          this.console = new cls.ConsoleLogProvider();
        },
        flush: function(force) {
          if (this.buffer.length) {
            if (force || this.buffer.length >= this.throttle) {
              this.console.getLogger()[this.currentLevel](this.buffer.join("\n"));
              this.buffer.length = 0;
            }
          }
        },
        getLogger: function() {
          const result = {};
          const levels = context.LogService.levels;
          for (const element of levels) {
            const item = element;
            result[item] = this._loggerMethod.bind(this, item);
          }
          return result;
        },
        _loggerMethod: function(level, arg) {
          if (level !== "all") {
            this.flush(this.currentLevel !== level);
            this.currentLevel = level;
            this.buffer.push(arg);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * @class ConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.ConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.ConsoleLogProvider.prototype */ {
      __name: "ConsoleLogProvider",
      getLogger: function() {
        return window.console;
      }
    });
  });
;

"use strict";

modulum('KeyboardPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all keyboard logs
     * @class KeyboardPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.KeyboardPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "KeyboardPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            const t = new Date().getTime();
            const args = Array.prototype.slice.call(arguments);
            const bufferedKey = args[1];
            const eventKey = args[2];

            const keyMatch = args[0].match(/(Delayed|onKeyDown|processKey).*: (.*)/);

            const entry = {
              provider: prefix.replace(/\s/g, ''), // Change [KEYBOARD   ] to [KEYBOARD]
              t: t,
              type: keyMatch ? keyMatch[1] : "unknown",
              bufferedKey: bufferedKey,
              eventKey: eventKey
            };
            context.LogService.record(entry);
          }
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('LoggerBase', ['LogService'],
  function(context, cls) {
    const abstractLoggerMethods = {};
    for (let levelId = 1; levelId < context.LogService.levels.length; levelId++) {
      abstractLoggerMethods[context.LogService.levels[levelId]] = Function.noop;
    }
    cls.AbstractLogger = context.oo.Class(abstractLoggerMethods);

    /**
     * @class LoggerBase
     * @memberOf classes
     */
    cls.LoggerBase = context.oo.Class(abstractLoggerMethods);
  });
;

"use strict";

modulum('LogProviderBase',
  function(context, cls) {

    /**
     * @class LogProviderBase
     * @memberOf classes
     */
    cls.LogProviderBase = context.oo.Class( /** @lends classes.LogProviderBase.prototype */ {
      __name: "LogProviderBase",

      /** @type {boolean} */
      _enabled: false,

      /**
       * Get the logger with all necessary methods
       * @return {Object|null}
       */
      getLogger: function() {
        throw new Error("LogProvider is abstract. Implement it to log.");
      },

      /**
       * Activate this logProvider
       * @param {Boolean} enable - true to enable, false otherwise
       */
      enable: function(enable) {
        this._enabled = enable;
      },

      /**
       * Check if this logProvider is enabled
       * @return {boolean} true if enabled, false otherwise
       */
      isEnabled: function() {
        return this._enabled;
      }
    });
  });
;

"use strict";

modulum('LogService', ['InitService', 'ConsoleLogProvider', 'StoredSettingsService'],
  function(context, cls) {

    /**
     * GBC log service
     * @namespace gbc.LogService
     * @gbcService
     */
    context.LogService = context.oo.StaticClass( /** @lends gbc.LogService */ {
      __name: "LogService",
      /**
       * @type {string}
       */
      _currentLevel: "none",
      /**
       * @type {string[]}
       */
      levels: ["all", "debug", "log", "info", "warn", "error"],
      /**
       * @type {Object<string, classes.LogProviderBase>}
       */
      _providers: {
        _default: new cls.ConsoleLogProvider()
      },
      /**
       * @type {Array<string>}
       */
      _activeLoggers: null,
      /**
       * @type {Object<string, string>}
       */
      _labels: {},

      /** @type {Boolean} **/
      _enableRecording: false,
      /** @type {Object} **/
      _recordingsHeaders: null,
      /** @type {Array<Object>} **/
      _recordings: null,
      /** @type {Object} **/
      _recordingsImages: null,

      /**
       * initialize service
       */
      init: function() {
        this._currentLevel = context.StoredSettingsService.getLoglevel();
        this._activeLoggers = context.StoredSettingsService.getLogtypes();
        this.changeLevel(this._currentLevel, true);

        this.enableRecording(window.isURLParameterEnabled(window.location.search,
          "recordgbclog")); // QueryString  ?recordGbcLog=1  will enable this
        gbc.DebugService.whenActivationChanged(function() {
          if (gbc.LogService.isRecordingEnabled()) {
            gbc.LogService._recordingsHeaders.gbcInfos.debugMode = gbc.DebugService.isActive();
          }
        });
      },

      /**
       *
       * @param {string} level
       * @return {number}
       * @private
       */
      _intLevel: function(level) {
        return this.levels.indexOf(level);
      },

      /**
       *
       * @return {string}
       */
      getCurrentLevel: function() {
        return this._currentLevel;
      },

      /**
       * @param {string} newLevel
       * @param {boolean} force
       */
      changeLevel: function(newLevel, force) {
        const intlevel = this._intLevel(this._currentLevel);
        const intnewlevel = this._intLevel(newLevel);
        if (force || (intnewlevel !== intlevel)) {
          this._currentLevel = newLevel;
          const p = Object.keys(this._providers);
          for (const element of p) {
            this._prepareLogger(element, this._isActive(element || "_default") ? intnewlevel : -1);
          }
        }
      },

      /**
       * @param {classes.LogProviderBase} provider
       * @param {string|Array<string>} type
       * @param {string} [label]
       */
      registerLogProvider: function(provider, type, label) {
        const types = (Array.isArray(type) ? type : [type]);
        for (const element of types) {
          if (label) {
            this._labels[element || "_default"] = label;
          }
          this._providers[element || "_default"] = provider;
          this._prepareLogger(element || "_default", this._isActive(element || "_default") ? this._intLevel(this._currentLevel) :
            -1);
        }
      },

      /**
       *
       * @param {string} type
       * @param {number} intnewlevel
       * @private
       */
      _prepareLogger: function(type, intnewlevel) {
        let target = this;
        if (type !== "_default") {
          this[type] = {};
          target = this[type];
        }
        for (let i = 1; i < this.levels.length; i++) {
          const levelName = this.levels[i];
          if (intnewlevel < 0 || intnewlevel > i) {
            target[levelName] = this._getLogMethod(type, "record");
          } else {
            target[levelName] = this._getLogMethod(type, levelName);
          }
        }
      },

      /**
       *
       * @param {string} type
       * @return {boolean}
       * @private
       */
      _isActive: function(type) {
        return !this._activeLoggers || this._activeLoggers.indexOf(type) >= 0;
      },

      /**
       *
       * @param {string} logType
       * @param {string} level
       * @return {Function}
       * @private
       */
      _getLogMethod: function(logType, level) {
        const provider = this._providers[logType] || this._providers._default;
        const recordEnabled = this.isRecordingEnabled();
        return function() {
          if (provider.isEnabled()) {
            if (level !== "record") {
              provider.getLogger()[level].apply(provider.getLogger(), arguments);
              // If Record is enabled, use record method of the logger
              if (recordEnabled && provider.getLogger().record) {
                provider.getLogger().record.apply(provider.getLogger(), arguments);
              }
            } else {
              if (recordEnabled && provider.getLogger().record) {
                provider.getLogger().record.apply(provider.getLogger(), arguments);
              }
            }
          }
          // Not enabled: record anyway if enabled
          else if (recordEnabled && provider.getLogger().record) {
            provider.getLogger().record.apply(provider.getLogger(), arguments);
          }
        };
      },
      debug: function() {
        console.debug.apply(console, arguments);
      },
      log: function() {
        console.log.apply(console, arguments);
      },
      info: function() {
        console.info.apply(console, arguments);
      },
      warn: function() {
        console.warn.apply(console, arguments);
      },
      error: function() {
        console.error.apply(console, arguments);
      },

      /**
       * @return {Array<{name:string, label:string}>}
       */
      getTypes: function() {
        return Object.keys(this._providers).map(function(k) {
          return {
            name: k,
            label: this._labels[k] || k
          };
        }.bind(this));
      },

      /**
       * @return {Array<string>}
       */
      getActiveLogTypes: function() {
        return this._activeLoggers;
      },

      /**
       * @param {string} type
       */
      toggleType: function(type) {
        if (!this._activeLoggers) {
          this._activeLoggers = Object.keys(this._providers);
        }
        if (this._activeLoggers.indexOf(type) >= 0) {
          this._activeLoggers.remove(type);
        } else {
          this._activeLoggers.push(type);
        }
        this._prepareLogger(type || "_default", this._isActive(type || "_default") ? this._intLevel(this._currentLevel) : -1);
      },

      /**
       * Activate the providers
       * @param {Boolean} enable - true to enable the providers, false otherwise
       */
      enableProviders: function(enable) {
        const providers = Object.keys(this._providers);
        for (const element of providers) {
          this._providers[element].enable(enable);
        }
      },

      checkMemoryLogs: function(clearObject) {
        // Ensure last recorded log has been saved
        const memoryLogs = gbc.LocalSettingsService.read("logPlayer");
        if (memoryLogs) {
          if (!window.isURLParameterEnabled("qainfo")) {
            const useMemoryLog = window.confirm(i18next.t('gwc.logPlayer.unsavedConfirm'));
            if (useMemoryLog) {
              this._recordingsHeaders = memoryLogs.headers;
              this._recordings = memoryLogs.log;
              this.download("recovered_" + memoryLogs.filename);
              if (typeof clearObject !== 'undefined') {
                this.clearLog(clearObject);
              }
            }
            gbc.LocalSettingsService.write("logPlayer", null);
          } else {
            gbc.error("Existing log!");
            gbc.LocalSettingsService.write("logPlayer", null);
          }
        }
      },
      /**
       * Activate recording of GBClog
       * @param {boolean} enabled - true to enable the recording
       */
      enableRecording: function(enabled) {
        if (enabled) {
          this._recordings = [];
          this._enableRecording = enabled;

          this.checkMemoryLogs();

          const winRect = window.document.body.getBoundingClientRect();
          // Save useful information
          this._recordingsHeaders = {
            logType: "gbcLog",
            runDate: new Date(),
            gbcInfos: {
              version: gbc.version,
              build: gbc.build,
              platformName: window.gbcWrapper.platformName,
              protocolType: window.gbcWrapper.protocolType,
              activeTheme: gbc.ThemeService.getCurrentTheme(),
              availableThemes: gbc.ThemeService.getAvailableThemes(),
              isSideBarVisible: gbc.StoredSettingsService.isSideBarVisible(),
              sideBarSize: gbc.StoredSettingsService.getSideBarwidth() || parseInt(gbc.ThemeService.getValue(
                "theme-sidebar-default-width"), 10),
              debugMode: gbc.DebugService.isActive()
            },
            browserInfos: {
              userAgent: window.navigator.userAgent,
              os: navigator.platform,
              activeLanguage: navigator.language,
              availableLanguages: navigator.languages,
              dimension: {
                width: parseInt(winRect.width, 10),
                height: parseInt(winRect.height, 10),
              },
              url: window.location.href
            },
            themeVariables: gbc.ThemeService._currentVariables,
            storedSettings: gbc.StoredSettingsService._storedSettings,
            logs: []
          };
          // end of headers
          this._recordingsImages = {}; // init image list

          gbc.InitService.when(gbc.constants.widgetEvents.onBeforeUnload, function() {
            const session = gbc.SessionService.getCurrent();
            const filename = session.getAppId() + "-" + session.getSessionId().substring(0, 8) + ".gbclog";
            // If there is an un-saved log, store it into the memory before leaving
            if (this._recordingsHeaders.logType) {
              gbc.LocalSettingsService.write("logPlayer", {
                headers: this._recordingsHeaders,
                log: this._recordings,
                filename: filename
              });
            }
          }.bind(this));
        }
      },

      /**
       * Check if recording is enabled on this session
       * @return {boolean} true if enabled, false otherwise
       */
      isRecordingEnabled: function() {
        return this._enableRecording;
      },

      /**
       * Add an entry to the record
       * @param {Object} entry
       */
      record: function(entry) {
        if (!Object.isNumber(entry.appId)) {
          const session = gbc.SessionService.getCurrent();
          const app = session && session.getCurrentApplication();
          if (app) {
            entry.appId = app.applicationHash;
          }
        }
        this._recordings.push(entry);
      },

      /**
       * Map image to its base64 equivalent
       * @param imgWidget
       * @param {Boolean} usePlaceholder - true to use a generated placeHolder
       */
      addImage: function(imgWidget, usePlaceholder) {
        console.log("Image: add it with placeholder", usePlaceholder);
        if (usePlaceholder) {
          const size = imgWidget.getNaturalDimension(),
            width = size.width,
            height = size.height,
            backgroundColor = '#bbdefb',
            fontColor = '#000000',
            canvas = document.createElement('canvas');

          /* set canvas stage */
          canvas.id = "placeholder";
          canvas.width = width;
          canvas.height = height;

          /* set canvas stage */
          canvas.id = "placeholder";
          canvas.width = width;
          canvas.height = height;

          /* add content */
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = backgroundColor;
          ctx.fillRect(0, 0, width, height);

          ctx.fillStyle = fontColor;
          ctx.font = '16px Courier';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 4;
          ctx.strokeStyle = "#FF0000";
          // Drow cross
          ctx.beginPath();
          ctx.moveTo(0, 2);
          ctx.lineTo(canvas.width, canvas.height - 2);
          ctx.moveTo(0, canvas.height - 2);
          ctx.lineTo(canvas.width + 2, 0);
          ctx.strokeRect(0, 0, canvas.width, canvas.height);
          ctx.lineWidth = 2;
          //ctx.fillText($0.alt, (width / 2), (height / 2) + height/3)
          ctx.stroke();
          ctx.closePath();

          /* convert to image base64 */
          this._recordingsImages[imgWidget.getValue()] = canvas.toDataURL('image/png');
        } else {
          // Use real image encoded to base64 (take more space in output file)
          window.toDataURL(
            imgWidget.getValue(),
            function(dataUrl) {
              this._recordingsImages[imgWidget.getValue()] = dataUrl;
            }.bind(this),
            "image/png"
          );
        }

      },

      /**
       * Get the last record
       * @return {Object} last recorded entry
       */
      getLastRecord: function() {
        return this._recordings[this._recordings.length - 1];
      },

      /**
       * Function to download data to a file
       * @param {String?} filename - give a name to the file to download (if no name, generate it)
       * @return {boolean}
       */
      download: function(filename) {
        if (!this.isRecordingEnabled()) {
          console.warn(i18next.t("gwc.logPlayer.notEnabled"));
          return false;
        }

        const session = gbc.SessionService.getCurrent();
        filename = filename ? filename : (session.getAppId() + "-" + session.getSessionId().substring(0, 8) + (window.isURLParameterEnabled(
            window.location.search,
            "withrealimages") ?
          "_realImages" : "") + ".gbclog");

        const type = "json";
        const logContent = this.getLogContent();

        const file = new Blob([logContent], {
          type: type
        });
        if (window.navigator.msSaveOrOpenBlob) { // IE10+
          window.navigator.msSaveOrOpenBlob(file, filename);
        } else { // Others
          const a = document.createElement("a"),
            url = URL.createObjectURL(file);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 0);
        }
      },

      /**
       * Get JSON stringified content of the log
       * @param {string} [format] - choose output format (json or string(default))
       * @return {string} content
       */
      getLogContent: function(format) {
        format = typeof format === "string" ? format : "string";
        this._recordingsHeaders.logs = this._recordings;
        this._recordingsHeaders.images = this._recordingsImages;
        return format === "string" ? JSON.stringify(this._recordingsHeaders, null, 2) : this._recordingsHeaders;
      },

      /**
       * Clear the log from memory
       * @param {Object} clearObject
       * @param {Boolean} clearObject.header - clear the log header
       * @param {Boolean} clearObject.images - clear the images records
       * @param {Boolean} clearObject.clearContent - clear the log content
       */
      clearLog: function(clearObject) {
        gbc.LocalSettingsService.write("logPlayer", null);
        if (!clearObject) {
          this._recordingsHeaders = {};
          this._recordingsImages = {};
          this._recordings = [];
        } else {
          if (clearObject.header) {
            this._recordingsHeaders = {};
          }
          if (clearObject.images) {
            this._recordingsImages = {};
          }
          if (clearObject.clearContent) {
            this._recordings = [];
          }
        }
      }

    });
    context.InitService.register(context.LogService);
  });
;

"use strict";

modulum('MousePrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all mouse logs
     * @class MousePrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.MousePrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "MousePrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            const args = Array.prototype.slice.call(arguments);
            const logStr = args[0];
            const mouse = logStr.match(/(onClick|onRightClick)/);
            const t = new Date().getTime();

            if (mouse) {
              const evt = args[1];
              const closestNode = args[1].target.closest("gbc_WidgetBase");
              const itemId = args[1].target.id || closestNode ? closestNode.getAttribute("data-aui-name") : null;
              const auiId = closestNode ? closestNode.getAttribute("data-aui-id") : null;

              const entry = {
                provider: prefix.replace(/\s/g, ''),
                t: t,
                itemId: itemId,
                itemElement: args[1].target.outerHTML,
                auiId: auiId,
                clientX: evt.clientX,
                clientY: evt.clientY,
                rightClick: mouse[1] === "onRightClick",
              };

              context.LogService.record(entry);
            }
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('NetworkPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all Network logs
     * @class NetworkPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.NetworkPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "NetworkPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            const args = Array.prototype.slice.call(arguments);
            const logStr = args.join(" ");
            const isRequest = logStr.indexOf("HTTP REQUEST") >= 0;
            const isResponse = logStr.indexOf("HTTP RESPONSE") >= 0;
            const t = new Date().getTime();

            if (isRequest || isResponse) {
              const urlInfo = args[1].match(
                /(\w*).*(?:POST|GET).*?\/ua\/(\w+)\/([a-f0-9]*)[^?]*\??(?:appId=(\d*)&pageId=(\d*))?/);
              const appId = urlInfo ? parseInt(urlInfo[5]) : context.LogService.getLastRecord().appId;
              const pageId = urlInfo ? parseInt(urlInfo[6]) : context.LogService.getLastRecord().pageId;
              const uaType = urlInfo ? urlInfo[3] : "unknown";
              const entry = {
                provider: prefix.replace(/\s/g, ''),
                t: t,
                httpType: args[0].trim(),
                httpMethod: urlInfo && urlInfo[2],
                uaType: uaType,
                uaDetails: urlInfo && urlInfo[1],
                type: args[1].trim(),
                data: args[2] && ("" + args[2]).trim()
              };

              if (uaType === "sua") {
                entry.appId = appId;
                entry.pageId = pageId;
              }

              context.LogService.record(entry);
            }
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('NoLogProvider', ['LogService', 'LogProviderBase'],
  function(context, cls) {

    const noLog = {};
    const levels = context.LogService.levels;
    for (const item of levels) {
      noLog[item] = Function.noop;
    }
    /**
     * @class NoLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.NoLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.NoLogProvider.prototype */ {
      __name: "NoLogProvider",

      getLogger: function() {
        return noLog;
      }
    });
  });
;

"use strict";

modulum('PrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * @class PrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.PrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "PrefixedConsoleLogProvider",
      _logger: null,

      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            const args = Array.prototype.slice.call(arguments);
            const logStr = args.join(" ");
            const t = new Date().getTime();

            const entry = {
              provider: prefix.replace(/\s/g, ''),
              t: t,
              log: logStr
            };
            context.LogService.record(entry);
          }
        };
      },
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('SWPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all Network logs
     * @class SWPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.SWPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "SWPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('UiPrefixedConsoleLogProvider', ['LogProviderBase'],
  function(context, cls) {

    /**
     * Console log provider to handle all UI logs
     * @class UiPrefixedConsoleLogProvider
     * @memberOf classes
     * @extends classes.LogProviderBase
     */
    cls.UiPrefixedConsoleLogProvider = context.oo.Class(cls.LogProviderBase, /** @lends classes.PrefixedConsoleLogProvider.prototype */ {
      __name: "UiPrefixedConsoleLogProvider",
      _logger: null,

      /**
       * @inheritDoc
       */
      constructor: function(prefix, prefixStyle) {
        const _prefix = (prefixStyle ? "%c" : "") + prefix;
        this._logger = {
          debug: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.debug.apply(console, args);
          },
          log: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.log.apply(console, args);
          },
          info: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.info.apply(console, args);
          },
          warn: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.warn.apply(console, args);
          },
          error: function() {
            const args = Array.prototype.slice.apply(arguments);
            if (prefixStyle) {
              args.unshift(prefixStyle);
            }
            args.unshift(_prefix);
            console.error.apply(console, args);
          },
          record: function() {
            const args = Array.prototype.slice.call(arguments);
            const logStr = args[0];
            const t = new Date().getTime();
            const name = args[2];
            const type = logStr.match(/\w*/);

            const data = {};
            if (args[3]) {
              if (name === "ContextMenuWidget") {
                data.x = args[3].x;
                data.auiTag = args[3]._auiTag;
                data.parentName = args[3].getParentWidget().__name;
              }
              if (name === "ImageWidget") {
                const imgWidget = args[3];
                data.size = imgWidget.getLayoutInformation().getMeasured();
                data.auiTag = imgWidget._auiTag;

                const qs = context.UrlService.currentUrl().getQueryStringObject();
                const useRealImage = Boolean(qs.withRealImages); // QueryString  &withRealImages=1  will enable this

                context.LogService.addImage(imgWidget, !useRealImage); // add image for easy mapping
              }
            }

            const entry = {
              provider: prefix.replace(/\s/g, ''), // Change [UI      ] to [UI]
              t: t,
              type: type[0].toLowerCase(),
              status: args[1],
              name: name,
              data: data
            };

            context.LogService.record(entry);
          },
        };
      },

      /**
       * @inheritDoc
       */
      getLogger: function() {
        return this._logger;
      }
    });
  });
;

"use strict";

modulum('LogPlayerService',
  function(context, cls) {

    /**
     * Log Player Service to centralize log playing logic used in LogPlayerWidget and in UR Log Player
     * @namespace gbc.LogPlayerService
     * @gbcService
     */
    context.LogPlayerService = context.oo.StaticClass( /** @lends gbc.LogPlayerService */ {
      __name: "LogPlayerService",

      /**
       * @type {Map<number, Map<number, classes.VMApplication>>}
       */
      _fakeSessions: null,

      _appStack: null,
      /**
       * Get the mock application registered with a session id and an application id
       * @param {number} sessionId
       * @param {number} appId
       * @param {number} procId
       * @param {boolean} dontCreate
       * @returns {classes.VMApplication}
       */
      getApplication: function(sessionId, appId, procId, dontCreate) {
        if (!this._fakeSessions) {
          this._fakeSessions = new Map();
        }
        if (!this._appStack) {
          this._appStack = [];
        }
        if (!this._fakeSessions.has(sessionId)) {
          this._fakeSessions.set(sessionId, new Map());
        }
        if (appId === null) {
          appId = procId;
        }
        const fakeSession = this._fakeSessions.get(sessionId);
        if (!fakeSession.has(appId) && !dontCreate) {
          const app = window.gbc.MockService.fakeApplication(false, appId, procId);
          app.setRunning(true);
          app.info().procId = procId;
          app.procId = procId;
          app.info().webComponent = window.location.origin +
            window.location.pathname.replace(/\/[^\/]+$/, "/") +
            context.ThemeService.getResource("webcomponents");
          fakeSession.set(appId, app);

          this._appStack.push(app);
          app.dvm.when(context.constants.baseEvents.gotRN0, () => {
            window.requestAnimationFrame(() => {
              let session = app.getSession();
              app.stop();
              let appIndex = this._appStack.indexOf(app);
              if (appIndex >= 0) {
                let nextApp = this._appStack[appIndex - 1];
                this._appStack.splice(appIndex, 1);
                if (!nextApp) {
                  nextApp = this._appStack[this._appStack.length - 1];
                }
                if (nextApp) {
                  nextApp.getSession().getWidget().setCurrentWidget(nextApp.getUI().getWidget());
                }
              }
              if (session && session.getApplications() && !session.getApplications().length) {
                session.destroy();
              }
            });
          });
        }
        return fakeSession.get(appId);
      },

      /**
       * Set a given app visible
       * @param {classes.VMApplication} app- application to set visible
       */
      setVisibleApplication: function(app) {
        const session = app.getSession();
        if (session) {
          session.getWidget().setCurrentWidget(app.getUI().getWidget());
        }
      },

      /**
       * Unregister a mock application
       * @param sessionId
       * @param appId
       */
      removeApplication: function(sessionId, appId) {
        if (!this._fakeSessions) {
          this._fakeSessions = new Map();
        }
        const session = this._fakeSessions.get(sessionId);
        if (session) {
          session.delete(appId);
          if (!session.size) {
            this._fakeSessions.delete(sessionId);
          }
        }
      },

      /**
       * Clean all applications/session
       */
      cleanApplications: function() {
        if (this._fakeSessions) {
          this._fakeSessions.clear();
        }
      },

      /**
       * Replace resource reference with mock ones
       * @param {string} order
       * @param {Object?} imageMap
       * @returns {string}
       */
      mockOrderResources: function(order, imageMap) {
        const imgMock = context.ThemeService.getResource("img/logo.png"),
          ttfMock = context.ThemeService.getResource("fonts/materialdesignicons-webfont.ttf");

        const imgReplacer = function(tpl, data) {
          return tpl.toString().replace(/([^"]+\.(?:png|jpg|gif|svg))(?:\?[^\\"]+)?/g, function(id) {
            return data && data[id] || imgMock;
          });
        };

        order = imgReplacer(order, imageMap);

        return order.replace(/"[^"]+\.ttf\?[^"]+"/g, "\"" + ttfMock + "\"") // Fonts
          .replace(/componentType "[^"]+"/g, "componentType \"empty\""); // webcomponents
      }
    });
  });
;

"use strict";

modulum('MockService', ['InitService'],
  function(context, cls) {

    /**
     * QA AUI less GBC service creator
     * @namespace gbc.MockService
     * @gbcService
     */
    context.MockService = context.oo.StaticClass( /** @lends gbc.MockService */ {
      __name: "MockService",
      _i: 0,
      _init: false,
      init: function() {},

      fakeApplication: function(forUnit, appId, procId) {
        procId = procId || forUnit ? ("fake:" + (this._i++)) : null;

        if (!this._init) {
          this._init = true;
          context.LogService.registerLogProvider(new cls.BufferedConsoleLogProvider(), null);
          gbc.start();
        }
        let currentSession = context.SessionService.getCurrent();
        if (forUnit) {
          if (currentSession) {
            currentSession.destroy(true);
            currentSession = null;
          }

          // Force ListView to be Table for unit tests
          if (window.isMobile()) {
            window.gbc.ThemeService.setValue("theme-table-default-widget", "table");
          }
        }
        const params = {
          mode: "no"
        };
        let newApp = null;
        if (!currentSession) {
          newApp = context.SessionService.startApplication(appId || "fake", params, procId).getCurrentApplication();
          newApp.getSession()._sessionId = "00000000000000000000000000000000";
        } else {
          currentSession.start(appId || "fake", params);
          newApp = currentSession.getCurrentApplication();
        }
        newApp.applicationInfo.connectionInfo = {
          procId: procId || appId || "fake"
        };
        newApp.applicationInfo.procId = procId || appId || "fake";
        if (procId) {
          context.SessionService.getCurrent().getNavigationManager().updateApplicationInformation(newApp);
        }
        newApp.applicationInfo.ignoreFrontcallModules = ["webcomponent"];
        return newApp;
      }
    });
    context.InitService.register(context.MockService);
  });
;

"use strict";

modulum('MouseService', ['InitService'],
  function(context, cls) {

    /**
     * Mouse events Service
     * @namespace gbc.MouseService
     * @gbcService
     */
    context.MouseService = context.oo.StaticClass( /** @lends gbc.MouseService */ {
      __name: "MouseService",

      /**
       *  Init mouse service
       */
      init: function() {
        document.body.on("mousedown.MouseService", this._onMouseDown.bind(this));
        document.body.on("mouseup.MouseService", this._onMouseUp.bind(this));
        document.body.on("click.MouseService", this._onClick.bind(this));
        document.body.on("contextmenu.MouseService", this._onRightClick.bind(this));
        document.body.on("dblclick.MouseService", this._onDblClick.bind(this));
      },

      /**
       * Save the mouse position after a domEvent
       * @param {MouseEvent} domEvent - dom event that trigger the request
       * @param {Element} targetElement - target element to use as reference when getting cursors
       */
      saveMousePosition: function(domEvent, targetElement) {
        if ((!domEvent.clientX || domEvent.clientX < 0) && (!domEvent.clientY || domEvent.clientY < 0)) {
          const rect = targetElement.getBoundingClientRect();
          context.WidgetService.cursorX = rect.left;
          context.WidgetService.cursorY = rect.top;
        } else {
          let marginLeft = 0;
          let marginTop = 0;
          // if target element is in another body context look for cursors using target element position as reference
          if (document.body !== domEvent.currentTarget) {
            const pos = targetElement.getBoundingClientRect();
            marginLeft = pos.x;
            marginTop = pos.y;
          }
          context.WidgetService.cursorX = marginLeft + domEvent.clientX;
          context.WidgetService.cursorY = marginTop + domEvent.clientY;
        }
      },

      /**
       * Mouse down handler bound on body element. Catch all mouse down events and propagate it to the corresponding widget.
       * @param event
       * @param targetElement - mouse down target element. If not specified we find it from event object
       * @private
       */
      _onMouseDown: function(event, targetElement) {
        context.LogService.mouse.log("onMouseDown event : ", event);

        targetElement = targetElement || event.target;

        this.saveMousePosition(event, targetElement);

        // search widget from dom event
        const widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        if (widget && !this._canProcessEvent(widget)) {
          return false;
        }

        // if a widget is found
        if (widget) {

          let bubbles = widget.manageMouseDown(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            const widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            let parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              const parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                bubbles = parentWidget.manageMouseDown(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Mouse up handler bound on body element. Catch all mouse up events and propagate it to the corresponding widget.
       * @param event
       * @param targetElement - mouse up target element. If not specified we find it from event object
       * @private
       */
      _onMouseUp: function(event, targetElement) {
        context.LogService.mouse.log("onMouseUp event : ", event);

        targetElement = targetElement || event.target;

        this.saveMousePosition(event, targetElement);

        // search widget from dom event
        const widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        if (widget && !this._canProcessEvent(widget)) {
          return false;
        }

        // if a widget is found
        if (widget) {

          let bubbles = widget.manageMouseUp(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            const widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            let parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              const parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                bubbles = parentWidget.manageMouseUp(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Click handler bound on body element. Catch all click events and propagate it to the corresponding widget.
       * @param event
       * @param targetElement - click target element. If not specified we find it from event object
       * @param {boolean} delayedClick - true if onClick is executed from a delayed click command
       * @private
       */
      _onClick: function(event, targetElement, delayedClick = false) {
        // onClick can raise during a GBC reload. In that case just ignore it.
        if (!context.LogService.mouse) {
          return;
        }
        context.LogService.mouse.log("onClick event : ", event);

        targetElement = targetElement || event.target;

        this.saveMousePosition(event, targetElement);

        // if overlay is visible, we hide displayed dropdowns and prevent default click events behaviors
        if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOfDropDown(targetElement)) {
          cls.DropDownWidget.hideAll();
          return false;
        }

        // search widget from dom event
        let widget = gbc.WidgetService.getWidgetFromElement(targetElement);
        // if no widget found, but we clicked inside a widget dropdown, get this dropdown
        if (!widget && cls.DropDownWidget.hasAnyVisible() && cls.DropDownWidget.isChildOfDropDown(targetElement)) {
          widget = cls.DropDownWidget.getActiveDropDowns().last();
        }

        if (widget?.getAUIWidget && widget.getAUIWidget()) {
          // If the command widget is in sidebar, close it
          let sideBarTopmenu = widget.getParentWidget(cls.RSidebarTopMenuWidget);
          if (sideBarTopmenu) {
            context.HostLeftSidebarService.showTopMenu(false);
            sideBarTopmenu.emit("close");
          }

          //If it is a virtual widget send the mouse event to the real one
          widget = widget.getAUIWidget();
        }

        if (widget && !widget.acceptEventWhenWindowInactive() && !this._canProcessEvent(widget)) {
          return false;
        }

        // if a widget is found
        if (widget) {

          // if widget doesn't have aui identifier then directly execute manageMouseClick of the widget and do not delay the command (no vm interaction needed)
          if (!delayedClick && widget.getAuiLinkedUniqueIdentifier()) {
            const curSession = context.SessionService.getCurrent();
            const app = curSession && curSession.getCurrentApplication();
            if (app && !app.scheduler.hasNoCommandToProcess()) {

              // if widget is interruptable directly execute manageMouseClick no delayedMouseClick
              if (!widget.isInterruptable()) {
                app.scheduler.delayedMouseClickCommand(widget, event);
                return false;
              }
            }
          }

          let bubbles = widget.manageMouseClick(event);
          if (widget.isInTable()) { // if widget is in a table emit tableClick event
            widget.emit(context.constants.widgetEvents.tableClick, event);
          }

          // bubble event to parent *DOM* widget
          if (bubbles) {
            const widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            let parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              const parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {

                bubbles = parentWidget.manageMouseClick(event);
                if (widget.isInTable()) { // if widget is in a table emit tableClick event
                  parentWidget.emit(context.constants.widgetEvents.tableClick, event);
                }
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Click handler bound on body element. Catch all rightclick events and propagate it to the corresponding widget.
       * @param event
       * @param targetElement - right click target element. If not specified we find it from event object
       * @private
       */
      _onRightClick: function(event, targetElement) {
        context.LogService.mouse.log("onRightClick event : ", event);

        targetElement = targetElement || event.target;

        this.saveMousePosition(event, targetElement);

        // if overlay is visible, we hide displayed dropdowns and prevent default click events behaviors
        if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOfDropDown(targetElement)) {
          cls.DropDownWidget.hideAll();
          //Restore the focus to the current widget
          const application = context.SessionService.getCurrent().getCurrentApplication();
          if (application) {
            const node = application.getFocusedVMNodeAndValue(true);
            const ctrl = node.getController();
            if (ctrl) {
              ctrl.setFocus();
            }
          }
          event.preventCancelableDefault();
          return false;
        }

        // search widget from dom event
        const widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        if (widget && !this._canProcessEvent(widget)) {
          return false;
        }

        // if a widget is found
        if (widget) {
          // todo check if scheduler is processing similar to onclick
          let bubbles = widget.manageMouseRightClick(event);
          if (widget.isInTable()) { // if widget is in a table emit tableClick event
            widget.emit(context.constants.widgetEvents.tableClick, event);
          }

          // bubble event to parent *DOM* widget
          if (bubbles) {
            const widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            let parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              const parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                bubbles = parentWidget.manageMouseRightClick(event);
                if (widget.isInTable()) { // if widget is in a table emit tableClick event
                  parentWidget.emit(context.constants.widgetEvents.tableClick, event);
                }
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * Click handler bound on body element. Catch all dblclick events and propagate it to the corresponding widget.
       * @param event
       * @param targetElement - double click target element. If not specified we find it from event object
       * @private
       */
      _onDblClick: function(event, targetElement) {
        context.LogService.mouse.log("onDblClick event : ", event);

        targetElement = targetElement || event.target;

        // search widget from dom event
        const widget = gbc.WidgetService.getWidgetFromElement(targetElement);

        if (widget && !this._canProcessEvent(widget)) {
          return false;
        }

        // if a widget is found
        if (widget) {

          let bubbles = widget.manageMouseDblClick(event);

          // bubble event to parent *DOM* widget
          if (bubbles) {
            const widgetElement = targetElement.elementOrParent("gbc_WidgetBase");
            let parentWidgetElement = widgetElement.parent("gbc_WidgetBase");
            while (parentWidgetElement && bubbles) {
              const parentWidget = gbc.WidgetService.getWidgetFromElement(parentWidgetElement);
              if (parentWidget) {
                // todo check if scheduler is processing similar to onclick
                bubbles = parentWidget.manageMouseDblClick(event);
              }
              parentWidgetElement = parentWidgetElement.parent("gbc_WidgetBase");
            }
          }
        }
      },

      /**
       * @param {classes.WidgetBase} widget
       * @return {boolean} false if the application is waiting in background
       * @private
       */
      _canProcessEvent: function(widget) {
        const curSession = context.SessionService.getCurrent();
        const application = curSession && curSession.getApplicationByIdentifier(widget.getApplicationIdentifier());

        if (application) {
          return application.canProcessEvent();
        }

        return true;
      }

    });
    context.InitService.register(context.MouseService);
  });
;

"use strict";

modulum('NativeService',
  function(context, cls) {

    /**
     * Native Service to interact with native in UR mode
     * @namespace gbc.NativeService
     * @gbcService
     */
    context.NativeService = context.oo.StaticClass( /** @lends gbc.NativeService */ {
      __name: "NativeService",

      _activeNativeAction: {},

      /**
       *
       * @param {{name:string, args:Array}} data
       */
      onNativeAction: function(data) {
        if (data) {
          const app = context.SessionService.getCurrent().getCurrentApplication();
          this._activeNativeAction[data.name] = true;
          switch (data.name) {
            case "notificationpushed":
              app.scheduler.nativeNotificationPushedCommand();
              break;
            case "notificationselected":
              app.scheduler.nativeNotificationSelectedCommand();
              break;
            case "cordovacallback":
              app.scheduler.nativeCordovaCallbackCommand();
              break;
            case "back":
              app.scheduler.nativeBackCommand(data.args);
              break;
            case "close":
              app.scheduler.nativeCloseCommand();
              break;
            case "enterbackground":
              app.scheduler.enterBackgroundCommand();
              break;
            case "enterforeground":
              app.scheduler.enterForegroundCommand();
              break;
            default:
              // Fallback: trigger action as called
              const actionService = app.getActionApplicationService();
              let actionNode = actionService.getAction(data.name);
              if (actionNode) {
                app.scheduler.actionVMCommand(actionNode, {});
              }
              break;
          }
        }
      },

      /**
       * Returns true if native action name has been executed at least once during application cycle lifetime
       * @param {string} actionName
       * @returns {boolean}
       */
      hasActiveNativeAction: function(actionName) {
        if (!this._activeNativeAction) {
          return false;
        }
        return !!this._activeNativeAction[actionName];
      },

      /**
       * Destroy handler
       * @param data
       */
      onDestroyEvent: function(data) {
        const session = context.SessionService.getCurrent(),
          app = session.getApplicationByProcId(data.procId);
        app.fail(data.content.message);
      },

      /**
       * Native End handler
       * @param {Object} data - contains everything requested to End the app
       */
      onNativeEnd: function(data) {
        const {
          content: {
            message
          },
          procId
        } = data;

        // Get App with ProcId
        const session = context.SessionService.getCurrent(),
          app = session?.getApplicationByProcId(procId);
        // Stop app with message
        app?.stop(message);
      },

      /**
       * Widget coordinates query handler
       * @param {*} data
       */
      onQuery: function(data) {
        const app = context.SessionService.getCurrent().getCurrentApplication();
        const result = {
          queryId: data.queryId
        };
        switch (data.queryId) {
          case "getWidgetCoordinates":
            const node = app.model.getNode(data.id),
              rect = node.getWidget().getElement().getBoundingClientRect();
            result.x = rect.left + rect.width / 2;
            result.y = rect.top + rect.height / 2;
            break;
          default:
            break;
        }
        context.__wrapper.queryResult(context.__wrapper.param(result, app));
      },

      /**
       * @inheritDoc
       */
      destroy: function() {
        this._activeNativeAction = null;
      },
    });
  });
;

"use strict";

modulum('NavigationService', ['InitService'],
  function(context, cls) {

    /**
     * Service that manages navigation
     * @namespace gbc.NavigationService
     * @gbcService
     * @publicdoc
     */
    context.NavigationService = context.oo.StaticClass( /** @lends gbc.NavigationService */ {
      __name: "NavigationService",

      /**
       * @type {classes.EventListener}
       */
      _eventListener: null,
      _handlerRegistered: false,
      _newRootApplicationEvent: "gbc.NavigationService.newRootApplication",

      /**
       * Initialize the navigation Service
       */
      init: function() {
        this._eventListener = new cls.EventListener();

        window.requestAnimationFrame(() => {
          gbc.HostService.onCurrentWindowChange(this._registerHandler.bind(this));
        });
      },

      /**
       * Register the new Application internal handler
       * @private
       */
      _registerHandler: function() {
        if (this._handlerRegistered) {
          return;
        }

        this._handlerRegistered = true;
        const navigationManager = gbc.SessionService.getCurrent().getNavigationManager();

        navigationManager.when(context.constants.VMSessionNavigationManagerEvents
          .addSessionSidebarApplicationStackItem,
          (event) => {
            let application = event.data[0];
            this._eventListener.emit(this._newRootApplicationEvent, application);
          });
      },

      /**
       * Run the new application
       * @param {string} applicationId appId defined in the XCF file
       * @param onFailure callback in case of failure
       */
      newRootApplication: function(applicationId, onFailure) {
        let application = gbc.SessionService.getCurrent().getCurrentApplication();
        application.protocolInterface.runApplication(application, applicationId, onFailure);
      },

      /**
       * Event raised when a new application is created. Callback syntax: fn(application)
       * @param {function} callback function syntaxe: fn(VMApplication)
       * @return {HandleRegistration}
       */
      onNewRootApplication: function(callback) {
        return this._eventListener.when(this._newRootApplicationEvent, function(event) {
          callback(event.data[0]);
        });
      },

      /**
       * Get all the root applications
       * @return {classes.VMApplication[]}
       */
      getRootApplicationList: function() {
        const res = new Set();
        const navigationManager = gbc.SessionService.getCurrent().getNavigationManager();
        const appList = navigationManager.getApplications();

        appList.forEach((app) => {
          res.add(navigationManager.getRootWaitingApplication(app));
        });

        return Array.from(res);
      },

      /**
       * Get the current root application
       * @return {classes.VMApplication}
       */
      getCurrentRootApplication: function() {
        const session = gbc.SessionService.getCurrent();
        const navigationManager = session.getNavigationManager();

        return navigationManager.getRootWaitingApplication(session.getCurrentApplication());
      },

      /**
       * Show the active window of the application
       * @param {classes.VMApplication} application
       */
      setForegroundApplication: function(application) {
        application.getSession().getNavigationManager().goBackToLastActiveWindow(application);
      },

      /**
       * Close the current application
       */
      closeApplication: function() {
        gbc.SessionService.getCurrent().getCurrentApplication().close();
      },

    });

    context.InitService.register(context.NavigationService);
  });
;

"use strict";

/**
 * See modulum import at the end of the file
 */
const AuiProtocolParser = (function() {
  // jshint ignore:start

  /*
   * Generated by PEG.js 0.9.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  function peg$parse(input) {
    const options = arguments.length > 1 ? arguments[1] : {},
      parser = this,

      peg$FAILED = {},

      peg$startRuleFunctions = {
        start: peg$parsestart
      };
    let peg$startRuleFunction = peg$parsestart;
    const peg$c0 = function(cnx) {
        return [cnx];
      },
      peg$c1 = function(attrs) {
        return {
          type: "meta",
          verb: "Connection",
          attributes: attrs
        };
      },
      peg$c2 = {
        type: "other",
        description: "OM Order"
      },
      peg$c3 = function(idGroup, list) {
        return {
          type: "om",
          id: idGroup,
          operations: list,
          header: null
        };
      },
      peg$c4 = function(bytes, idGroup, list) {
        return {
          type: "om",
          id: idGroup,
          operations: list,
          header: bytes
        };
      },
      peg$c5 = {
        type: "any",
        description: "any character"
      },
      peg$c6 = function(cmd) {
        return cmd;
      },
      peg$c7 = {
        type: "other",
        description: "OM command"
      },
      peg$c8 = {
        type: "other",
        description: "Add node"
      },
      peg$c9 = function(parentId, n) {
        return {
          type: "add",
          parent: parentId,
          node: n
        };
      },
      peg$c10 = {
        type: "other",
        description: "Update node"
      },
      peg$c11 = function(id, attrs) {
        return {
          type: "update",
          id: id,
          attributes: attrs
        };
      },
      peg$c12 = {
        type: "other",
        description: "RemoveNode"
      },
      peg$c13 = function(id) {
        return {
          type: "remove",
          id: id
        };
      },
      peg$c14 = function(attrs) {
        const result = {},
          len = attrs.length;
        for (let i = 0; i < len; i++) {
          result[attrs[i].name] = attrs[i].value;
        }
        return result;
      },
      peg$c15 = "value",
      peg$c16 = {
        type: "literal",
        value: "value",
        description: "\"value\""
      },
      peg$c17 = function(chars) {
        return {
          name: "value",
          value: chars.join("")
        };
      },
      peg$c18 = "valueChecked",
      peg$c19 = {
        type: "literal",
        value: "valueChecked",
        description: "\"valueChecked\""
      },
      peg$c20 = function(chars) {
        return {
          name: "valueChecked",
          value: chars.join("")
        };
      },
      peg$c21 = "valueUnchecked",
      peg$c22 = {
        type: "literal",
        value: "valueUnchecked",
        description: "\"valueUnchecked\""
      },
      peg$c23 = function(chars) {
        return {
          name: "valueUnchecked",
          value: chars.join("")
        };
      },
      peg$c24 = "name",
      peg$c25 = {
        type: "literal",
        value: "name",
        description: "\"name\""
      },
      peg$c26 = function(chars) {
        return {
          name: "name",
          value: chars.join("")
        };
      },
      peg$c27 = "comment",
      peg$c28 = {
        type: "literal",
        value: "comment",
        description: "\"comment\""
      },
      peg$c29 = function(chars) {
        return {
          name: "comment",
          value: chars.join("")
        };
      },
      peg$c30 = "text",
      peg$c31 = {
        type: "literal",
        value: "text",
        description: "\"text\""
      },
      peg$c32 = function(chars) {
        return {
          name: "text",
          value: chars.join("")
        };
      },
      peg$c33 = "style",
      peg$c34 = {
        type: "literal",
        value: "style",
        description: "\"style\""
      },
      peg$c35 = function(chars) {
        return {
          name: "style",
          value: chars.join("")
        };
      },
      peg$c36 = "aggregateValue",
      peg$c37 = {
        type: "literal",
        value: "aggregateValue",
        description: "\"aggregateValue\""
      },
      peg$c38 = function(chars) {
        return {
          name: "aggregateValue",
          value: chars.join("")
        };
      },
      peg$c39 = "aggregateText",
      peg$c40 = {
        type: "literal",
        value: "aggregateText",
        description: "\"aggregateText\""
      },
      peg$c41 = function(chars) {
        return {
          name: "aggregateText",
          value: chars.join("")
        };
      },
      peg$c42 = "acceleratorName",
      peg$c43 = {
        type: "literal",
        value: "acceleratorName",
        description: "\"acceleratorName\""
      },
      peg$c44 = function(chars) {
        return {
          name: "acceleratorName",
          value: chars.join("")
        };
      },
      peg$c45 = "acceleratorName2",
      peg$c46 = {
        type: "literal",
        value: "acceleratorName2",
        description: "\"acceleratorName2\""
      },
      peg$c47 = function(chars) {
        return {
          name: "acceleratorName2",
          value: chars.join("")
        };
      },
      peg$c48 = "acceleratorName3",
      peg$c49 = {
        type: "literal",
        value: "acceleratorName3",
        description: "\"acceleratorName3\""
      },
      peg$c50 = function(chars) {
        return {
          name: "acceleratorName3",
          value: chars.join("")
        };
      },
      peg$c51 = "acceleratorName4",
      peg$c52 = {
        type: "literal",
        value: "acceleratorName4",
        description: "\"acceleratorName4\""
      },
      peg$c53 = function(chars) {
        return {
          name: "acceleratorName4",
          value: chars.join("")
        };
      },
      peg$c54 = "acceleratorKey1",
      peg$c55 = {
        type: "literal",
        value: "acceleratorKey1",
        description: "\"acceleratorKey1\""
      },
      peg$c56 = function(chars) {
        return {
          name: "acceleratorKey1",
          value: chars.join("")
        };
      },
      peg$c57 = "acceleratorKey3",
      peg$c58 = {
        type: "literal",
        value: "acceleratorKey3",
        description: "\"acceleratorKey3\""
      },
      peg$c59 = function(chars) {
        return {
          name: "acceleratorKey3",
          value: chars.join("")
        };
      },
      peg$c60 = function(name, value) {
        return {
          name: name,
          value: value
        };
      },
      peg$c61 = function(n) {
        return n;
      },
      peg$c62 = function(nodeType, nodeId, attrs, children) {
        return {
          id: nodeId,
          type: nodeType,
          attributes: attrs,
          children: children
        };
      },
      peg$c63 = {
        type: "other",
        description: "needed space"
      },
      peg$c64 = /^[ \t\r\n]/,
      peg$c65 = {
        type: "class",
        value: "[ \\t\\r\\n]",
        description: "[ \\t\\r\\n]"
      },
      peg$c66 = {
        type: "other",
        description: "optional space"
      },
      peg$c67 = "meta",
      peg$c68 = {
        type: "literal",
        value: "meta",
        description: "\"meta\""
      },
      peg$c69 = "Connection",
      peg$c70 = {
        type: "literal",
        value: "Connection",
        description: "\"Connection\""
      },
      peg$c71 = "om",
      peg$c72 = {
        type: "literal",
        value: "om",
        description: "\"om\""
      },
      peg$c73 = "an",
      peg$c74 = {
        type: "literal",
        value: "an",
        description: "\"an\""
      },
      peg$c75 = "un",
      peg$c76 = {
        type: "literal",
        value: "un",
        description: "\"un\""
      },
      peg$c77 = "rn",
      peg$c78 = {
        type: "literal",
        value: "rn",
        description: "\"rn\""
      },
      peg$c79 = "{",
      peg$c80 = {
        type: "literal",
        value: "{",
        description: "\"{\""
      },
      peg$c81 = "}",
      peg$c82 = {
        type: "literal",
        value: "}",
        description: "\"}\""
      },
      peg$c83 = /^[0-9]/,
      peg$c84 = {
        type: "class",
        value: "[0-9]",
        description: "[0-9]"
      },
      peg$c85 = function(digits) {
        return parseInt(digits.join(""), 10);
      },
      peg$c86 = function(num) {
        const res = parseFloat(num);
        if (Number.isNaN(res)) {
          return num;
        } else {
          return res;
        }
      },
      peg$c87 = function(integer) {
        if (integer.length > 16) {
          return integer;
        } else {
          return parseInt(integer, 10);
        }
      },
      peg$c88 = function(chars) {
        return chars.join("");
      },
      peg$c89 = "0",
      peg$c90 = {
        type: "literal",
        value: "0",
        description: "\"0\""
      },
      peg$c91 = function() {
        return 0;
      },
      peg$c92 = "-",
      peg$c93 = {
        type: "literal",
        value: "-",
        description: "\"-\""
      },
      peg$c94 = /^[1-9]/,
      peg$c95 = {
        type: "class",
        value: "[1-9]",
        description: "[1-9]"
      },
      peg$c96 = function(sign, firstdigit, digits) {
        return (sign ? "-" : "") + firstdigit + digits.join("");
      },
      peg$c97 = ".",
      peg$c98 = {
        type: "literal",
        value: ".",
        description: "\".\""
      },
      peg$c99 = function(sign, digits, decimals) {
        return (sign ? "-" : "") + digits.join("") + "." + decimals.join("");
      },
      peg$c100 = function() {
        return "";
      },
      peg$c101 = "\"",
      peg$c102 = {
        type: "literal",
        value: "\"",
        description: "\"\\\"\""
      },
      peg$c103 = "\\",
      peg$c104 = {
        type: "literal",
        value: "\\",
        description: "\"\\\\\""
      },
      peg$c105 = "/",
      peg$c106 = {
        type: "literal",
        value: "/",
        description: "\"/\""
      },
      peg$c107 = "b",
      peg$c108 = {
        type: "literal",
        value: "b",
        description: "\"b\""
      },
      peg$c109 = function() {
        return "\b";
      },
      peg$c110 = "f",
      peg$c111 = {
        type: "literal",
        value: "f",
        description: "\"f\""
      },
      peg$c112 = function() {
        return "\f";
      },
      peg$c113 = "n",
      peg$c114 = {
        type: "literal",
        value: "n",
        description: "\"n\""
      },
      peg$c115 = function() {
        return "\n";
      },
      peg$c116 = "u",
      peg$c117 = {
        type: "literal",
        value: "u",
        description: "\"u\""
      },
      peg$c118 = function(digits) {
        return String.fromCharCode(parseInt(digits, 16));
      },
      peg$c119 = function(sequence) {
        return sequence;
      },
      peg$c120 = /^[\t\r -!#-[\]-\uFFFF]/,
      peg$c121 = {
        type: "class",
        value: "[\\t\\r\\x20-\\x21\\x23-\\x5B\\x5D-\\uFFFF]",
        description: "[\\t\\r\\x20-\\x21\\x23-\\x5B\\x5D-\\uFFFF]"
      },
      peg$c122 = /^[\x01-\x08\x0B-\f\x0E-\x1F]/,
      peg$c123 = {
        type: "class",
        value: "[\\x01-\\x08\\x0B-\\x0C\\x0E-\\x1F]",
        description: "[\\x01-\\x08\\x0B-\\x0C\\x0E-\\x1F]"
      },
      peg$c124 = /^[0-9a-fA-F]/,
      peg$c125 = {
        type: "class",
        value: "[0-9a-fA-F]",
        description: "[0-9a-fA-F]"
      },
      peg$c126 = "wip.",
      peg$c127 = {
        type: "literal",
        value: "wip.",
        description: "\"wip.\""
      },
      peg$c128 = function(prefix, w) {
        return prefix + w;
      },
      peg$c129 = function(c) {
        return c.join("");
      },
      peg$c130 = /^[A-Za-z]/,
      peg$c131 = {
        type: "class",
        value: "[A-Za-z]",
        description: "[A-Za-z]"
      },
      peg$c132 = /^[_]/,
      peg$c133 = {
        type: "class",
        value: "[_]",
        description: "[_]"
      };
    let peg$currPos = 0,
      peg$savedPos = 0;
    const peg$posDetailsCache = [{
      line: 1,
      column: 1,
      seenCR: false
    }];
    let peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,

      peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{
          type: "other",
          description: description
        }],
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function error(message) {
      throw peg$buildException(
        message,
        null,
        input.substring(peg$savedPos, peg$currPos),
        peg$computeLocation(peg$savedPos, peg$currPos)
      );
    }

    function peg$computePosDetails(pos) {
      let details = peg$posDetailsCache[pos],
        p, ch;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column,
          seenCR: details.seenCR
        };

        while (p < pos) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      const startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, found, location) {
      function cleanupExpected(expected) {
        let i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }

          return s
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\f/g, '\\f')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return '\\x0' + hex(ch);
            })
            .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return '\\x' + hex(ch);
            })
            .replace(/[\u0100-\u0FFF]/g, function(ch) {
              return '\\u0' + hex(ch);
            })
            .replace(/[\u1000-\uFFFF]/g, function(ch) {
              return '\\u' + hex(ch);
            });
        }

        const expectedDescs = new Array(expected.length);
        let expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ?
          expectedDescs.slice(0, -1).join(", ") +
          " or " +
          expectedDescs[expected.length - 1] :
          expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new peg$SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      let s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseconnection();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseorders();
      }

      return s0;
    }

    function peg$parseconnection() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMETA();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCONNECTION();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseLBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseattributes();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseRBRACE();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c1(s8);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseorders() {
      let s0, s1;

      s0 = [];
      s1 = peg$parseorder();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseorder();
      }

      return s0;
    }

    function peg$parseorder() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOM();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseINTEGER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseLBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsecommandList();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseRBRACE();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c3(s4, s8);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsebytesHeader();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseOM();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse__();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseINTEGER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parse_();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseLBRACE();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parsecommandList();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseRBRACE();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parse_();
                              if (s12 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c4(s2, s5, s9);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c2);
        }
      }

      return s0;
    }

    function peg$parsebytesHeader() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      if (input.length > peg$currPos) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c5);
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c5);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c5);
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c5);
              }
            }
            if (s4 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c5);
                }
              }
              if (s5 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c5);
                  }
                }
                if (s6 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c5);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c5);
                      }
                    }
                    if (s8 !== peg$FAILED) {
                      if (input.length > peg$currPos) {
                        s9 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c5);
                        }
                      }
                      if (s9 !== peg$FAILED) {
                        s1 = [s1, s2, s3, s4, s5, s6, s7, s8, s9];
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecommandList() {
      let s0, s1;

      s0 = [];
      s1 = peg$parsecommandItem();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsecommandItem();
      }

      return s0;
    }

    function peg$parsecommandItem() {
      let s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLBRACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsecommand();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsecommand() {
      let s0, s1;

      peg$silentFails++;
      s0 = peg$parseaddnode();
      if (s0 === peg$FAILED) {
        s0 = peg$parseupdatenode();
        if (s0 === peg$FAILED) {
          s0 = peg$parseremovenode();
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c7);
        }
      }

      return s0;
    }

    function peg$parseaddnode() {
      let s0, s1, s2, s3, s4, s5, s6, s7;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseAN();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseINTEGER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsenode();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c9(s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c8);
        }
      }

      return s0;
    }

    function peg$parseupdatenode() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseUN();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseINTEGER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseLBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseattributes();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseRBRACE();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c11(s4, s8);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c10);
        }
      }

      return s0;
    }

    function peg$parseremovenode() {
      let s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseRN();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseINTEGER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c13(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c12);
        }
      }

      return s0;
    }

    function peg$parseattributes() {
      let s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseattribute();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseattribute();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c14(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseattribute() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLBRACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c15) {
              s4 = peg$c15;
              peg$currPos += 5;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c16);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsequotation_mark();
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseschar();
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parseschar();
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsequotation_mark();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseRBRACE();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c17(s7);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLBRACE();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.substr(peg$currPos, 12) === peg$c18) {
                s4 = peg$c18;
                peg$currPos += 12;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse__();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsequotation_mark();
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    s8 = peg$parseschar();
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseschar();
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsequotation_mark();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parse_();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseRBRACE();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parse_();
                            if (s11 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c20(s7);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLBRACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 14) === peg$c21) {
                  s4 = peg$c21;
                  peg$currPos += 14;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c22);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse__();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsequotation_mark();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseschar();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseschar();
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parsequotation_mark();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parse_();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseRBRACE();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c23(s7);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLBRACE();
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c24) {
                    s4 = peg$c24;
                    peg$currPos += 4;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c25);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse__();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsequotation_mark();
                      if (s6 !== peg$FAILED) {
                        s7 = [];
                        s8 = peg$parseschar();
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          s8 = peg$parseschar();
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parsequotation_mark();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parse_();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$parseRBRACE();
                              if (s10 !== peg$FAILED) {
                                s11 = peg$parse_();
                                if (s11 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c26(s7);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLBRACE();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();
                  if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c27) {
                      s4 = peg$c27;
                      peg$currPos += 7;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c28);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parse__();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsequotation_mark();
                        if (s6 !== peg$FAILED) {
                          s7 = [];
                          s8 = peg$parseschar();
                          while (s8 !== peg$FAILED) {
                            s7.push(s8);
                            s8 = peg$parseschar();
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsequotation_mark();
                            if (s8 !== peg$FAILED) {
                              s9 = peg$parse_();
                              if (s9 !== peg$FAILED) {
                                s10 = peg$parseRBRACE();
                                if (s10 !== peg$FAILED) {
                                  s11 = peg$parse_();
                                  if (s11 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c29(s7);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseLBRACE();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parse_();
                    if (s3 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c30) {
                        s4 = peg$c30;
                        peg$currPos += 4;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c31);
                        }
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parse__();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parsequotation_mark();
                          if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$parseschar();
                            while (s8 !== peg$FAILED) {
                              s7.push(s8);
                              s8 = peg$parseschar();
                            }
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parsequotation_mark();
                              if (s8 !== peg$FAILED) {
                                s9 = peg$parse_();
                                if (s9 !== peg$FAILED) {
                                  s10 = peg$parseRBRACE();
                                  if (s10 !== peg$FAILED) {
                                    s11 = peg$parse_();
                                    if (s11 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c32(s7);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parse_();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parseLBRACE();
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parse_();
                      if (s3 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c33) {
                          s4 = peg$c33;
                          peg$currPos += 5;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c34);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parse__();
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parsequotation_mark();
                            if (s6 !== peg$FAILED) {
                              s7 = [];
                              s8 = peg$parseschar();
                              while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$parseschar();
                              }
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parsequotation_mark();
                                if (s8 !== peg$FAILED) {
                                  s9 = peg$parse_();
                                  if (s9 !== peg$FAILED) {
                                    s10 = peg$parseRBRACE();
                                    if (s10 !== peg$FAILED) {
                                      s11 = peg$parse_();
                                      if (s11 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c35(s7);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parseLBRACE();
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parse_();
                        if (s3 !== peg$FAILED) {
                          if (input.substr(peg$currPos, 14) === peg$c36) {
                            s4 = peg$c36;
                            peg$currPos += 14;
                          } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c37);
                            }
                          }
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parse__();
                            if (s5 !== peg$FAILED) {
                              s6 = peg$parsequotation_mark();
                              if (s6 !== peg$FAILED) {
                                s7 = [];
                                s8 = peg$parseschar();
                                while (s8 !== peg$FAILED) {
                                  s7.push(s8);
                                  s8 = peg$parseschar();
                                }
                                if (s7 !== peg$FAILED) {
                                  s8 = peg$parsequotation_mark();
                                  if (s8 !== peg$FAILED) {
                                    s9 = peg$parse_();
                                    if (s9 !== peg$FAILED) {
                                      s10 = peg$parseRBRACE();
                                      if (s10 !== peg$FAILED) {
                                        s11 = peg$parse_();
                                        if (s11 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c38(s7);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parse_();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parseLBRACE();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parse_();
                          if (s3 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 13) === peg$c39) {
                              s4 = peg$c39;
                              peg$currPos += 13;
                            } else {
                              s4 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c40);
                              }
                            }
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parse__();
                              if (s5 !== peg$FAILED) {
                                s6 = peg$parsequotation_mark();
                                if (s6 !== peg$FAILED) {
                                  s7 = [];
                                  s8 = peg$parseschar();
                                  while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$parseschar();
                                  }
                                  if (s7 !== peg$FAILED) {
                                    s8 = peg$parsequotation_mark();
                                    if (s8 !== peg$FAILED) {
                                      s9 = peg$parse_();
                                      if (s9 !== peg$FAILED) {
                                        s10 = peg$parseRBRACE();
                                        if (s10 !== peg$FAILED) {
                                          s11 = peg$parse_();
                                          if (s11 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c41(s7);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parse_();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parseLBRACE();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parse_();
                            if (s3 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 15) === peg$c42) {
                                s4 = peg$c42;
                                peg$currPos += 15;
                              } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c43);
                                }
                              }
                              if (s4 !== peg$FAILED) {
                                s5 = peg$parse__();
                                if (s5 !== peg$FAILED) {
                                  s6 = peg$parsequotation_mark();
                                  if (s6 !== peg$FAILED) {
                                    s7 = [];
                                    s8 = peg$parseschar();
                                    while (s8 !== peg$FAILED) {
                                      s7.push(s8);
                                      s8 = peg$parseschar();
                                    }
                                    if (s7 !== peg$FAILED) {
                                      s8 = peg$parsequotation_mark();
                                      if (s8 !== peg$FAILED) {
                                        s9 = peg$parse_();
                                        if (s9 !== peg$FAILED) {
                                          s10 = peg$parseRBRACE();
                                          if (s10 !== peg$FAILED) {
                                            s11 = peg$parse_();
                                            if (s11 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c44(s7);
                                              s0 = s1;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parse_();
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parseLBRACE();
                            if (s2 !== peg$FAILED) {
                              s3 = peg$parse_();
                              if (s3 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 16) === peg$c45) {
                                  s4 = peg$c45;
                                  peg$currPos += 16;
                                } else {
                                  s4 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c46);
                                  }
                                }
                                if (s4 !== peg$FAILED) {
                                  s5 = peg$parse__();
                                  if (s5 !== peg$FAILED) {
                                    s6 = peg$parsequotation_mark();
                                    if (s6 !== peg$FAILED) {
                                      s7 = [];
                                      s8 = peg$parseschar();
                                      while (s8 !== peg$FAILED) {
                                        s7.push(s8);
                                        s8 = peg$parseschar();
                                      }
                                      if (s7 !== peg$FAILED) {
                                        s8 = peg$parsequotation_mark();
                                        if (s8 !== peg$FAILED) {
                                          s9 = peg$parse_();
                                          if (s9 !== peg$FAILED) {
                                            s10 = peg$parseRBRACE();
                                            if (s10 !== peg$FAILED) {
                                              s11 = peg$parse_();
                                              if (s11 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c47(s7);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parse_();
                            if (s1 !== peg$FAILED) {
                              s2 = peg$parseLBRACE();
                              if (s2 !== peg$FAILED) {
                                s3 = peg$parse_();
                                if (s3 !== peg$FAILED) {
                                  if (input.substr(peg$currPos, 16) === peg$c48) {
                                    s4 = peg$c48;
                                    peg$currPos += 16;
                                  } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c49);
                                    }
                                  }
                                  if (s4 !== peg$FAILED) {
                                    s5 = peg$parse__();
                                    if (s5 !== peg$FAILED) {
                                      s6 = peg$parsequotation_mark();
                                      if (s6 !== peg$FAILED) {
                                        s7 = [];
                                        s8 = peg$parseschar();
                                        while (s8 !== peg$FAILED) {
                                          s7.push(s8);
                                          s8 = peg$parseschar();
                                        }
                                        if (s7 !== peg$FAILED) {
                                          s8 = peg$parsequotation_mark();
                                          if (s8 !== peg$FAILED) {
                                            s9 = peg$parse_();
                                            if (s9 !== peg$FAILED) {
                                              s10 = peg$parseRBRACE();
                                              if (s10 !== peg$FAILED) {
                                                s11 = peg$parse_();
                                                if (s11 !== peg$FAILED) {
                                                  peg$savedPos = s0;
                                                  s1 = peg$c50(s7);
                                                  s0 = s1;
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$parse_();
                              if (s1 !== peg$FAILED) {
                                s2 = peg$parseLBRACE();
                                if (s2 !== peg$FAILED) {
                                  s3 = peg$parse_();
                                  if (s3 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 16) === peg$c51) {
                                      s4 = peg$c51;
                                      peg$currPos += 16;
                                    } else {
                                      s4 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c52);
                                      }
                                    }
                                    if (s4 !== peg$FAILED) {
                                      s5 = peg$parse__();
                                      if (s5 !== peg$FAILED) {
                                        s6 = peg$parsequotation_mark();
                                        if (s6 !== peg$FAILED) {
                                          s7 = [];
                                          s8 = peg$parseschar();
                                          while (s8 !== peg$FAILED) {
                                            s7.push(s8);
                                            s8 = peg$parseschar();
                                          }
                                          if (s7 !== peg$FAILED) {
                                            s8 = peg$parsequotation_mark();
                                            if (s8 !== peg$FAILED) {
                                              s9 = peg$parse_();
                                              if (s9 !== peg$FAILED) {
                                                s10 = peg$parseRBRACE();
                                                if (s10 !== peg$FAILED) {
                                                  s11 = peg$parse_();
                                                  if (s11 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c53(s7);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parse_();
                                if (s1 !== peg$FAILED) {
                                  s2 = peg$parseLBRACE();
                                  if (s2 !== peg$FAILED) {
                                    s3 = peg$parse_();
                                    if (s3 !== peg$FAILED) {
                                      if (input.substr(peg$currPos, 15) === peg$c54) {
                                        s4 = peg$c54;
                                        peg$currPos += 15;
                                      } else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c55);
                                        }
                                      }
                                      if (s4 !== peg$FAILED) {
                                        s5 = peg$parse__();
                                        if (s5 !== peg$FAILED) {
                                          s6 = peg$parsequotation_mark();
                                          if (s6 !== peg$FAILED) {
                                            s7 = [];
                                            s8 = peg$parseschar();
                                            while (s8 !== peg$FAILED) {
                                              s7.push(s8);
                                              s8 = peg$parseschar();
                                            }
                                            if (s7 !== peg$FAILED) {
                                              s8 = peg$parsequotation_mark();
                                              if (s8 !== peg$FAILED) {
                                                s9 = peg$parse_();
                                                if (s9 !== peg$FAILED) {
                                                  s10 = peg$parseRBRACE();
                                                  if (s10 !== peg$FAILED) {
                                                    s11 = peg$parse_();
                                                    if (s11 !== peg$FAILED) {
                                                      peg$savedPos = s0;
                                                      s1 = peg$c56(s7);
                                                      s0 = s1;
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$parse_();
                                  if (s1 !== peg$FAILED) {
                                    s2 = peg$parseLBRACE();
                                    if (s2 !== peg$FAILED) {
                                      s3 = peg$parse_();
                                      if (s3 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 15) === peg$c57) {
                                          s4 = peg$c57;
                                          peg$currPos += 15;
                                        } else {
                                          s4 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c58);
                                          }
                                        }
                                        if (s4 !== peg$FAILED) {
                                          s5 = peg$parse__();
                                          if (s5 !== peg$FAILED) {
                                            s6 = peg$parsequotation_mark();
                                            if (s6 !== peg$FAILED) {
                                              s7 = [];
                                              s8 = peg$parseschar();
                                              while (s8 !== peg$FAILED) {
                                                s7.push(s8);
                                                s8 = peg$parseschar();
                                              }
                                              if (s7 !== peg$FAILED) {
                                                s8 = peg$parsequotation_mark();
                                                if (s8 !== peg$FAILED) {
                                                  s9 = peg$parse_();
                                                  if (s9 !== peg$FAILED) {
                                                    s10 = peg$parseRBRACE();
                                                    if (s10 !== peg$FAILED) {
                                                      s11 = peg$parse_();
                                                      if (s11 !== peg$FAILED) {
                                                        peg$savedPos = s0;
                                                        s1 = peg$c59(s7);
                                                        s0 = s1;
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parse_();
                                    if (s1 !== peg$FAILED) {
                                      s2 = peg$parseLBRACE();
                                      if (s2 !== peg$FAILED) {
                                        s3 = peg$parse_();
                                        if (s3 !== peg$FAILED) {
                                          s4 = peg$parseIDENT();
                                          if (s4 !== peg$FAILED) {
                                            s5 = peg$parse__();
                                            if (s5 !== peg$FAILED) {
                                              s6 = peg$parseVALUE();
                                              if (s6 !== peg$FAILED) {
                                                s7 = peg$parse_();
                                                if (s7 !== peg$FAILED) {
                                                  s8 = peg$parseRBRACE();
                                                  if (s8 !== peg$FAILED) {
                                                    s9 = peg$parse_();
                                                    if (s9 !== peg$FAILED) {
                                                      peg$savedPos = s0;
                                                      s1 = peg$c60(s4, s6);
                                                      s0 = s1;
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsechildnodes() {
      let s0, s1;

      s0 = [];
      s1 = peg$parsenodeItem();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsenodeItem();
      }

      return s0;
    }

    function peg$parsenodeItem() {
      let s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseLBRACE();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsenode();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c61(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsenode() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIDENT();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseINTEGER();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseLBRACE();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseattributes();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseRBRACE();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parse_();
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseLBRACE();
                            if (s12 !== peg$FAILED) {
                              s13 = peg$parse_();
                              if (s13 !== peg$FAILED) {
                                s14 = peg$parsechildnodes();
                                if (s14 !== peg$FAILED) {
                                  s15 = peg$parse_();
                                  if (s15 !== peg$FAILED) {
                                    s16 = peg$parseRBRACE();
                                    if (s16 !== peg$FAILED) {
                                      s17 = peg$parse_();
                                      if (s17 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c62(s2, s4, s8, s14);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parse__() {
      let s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c64.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c65);
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c64.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c63);
        }
      }

      return s0;
    }

    function peg$parse_() {
      let s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c64.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c65);
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c64.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c65);
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        if (peg$silentFails === 0) {
          peg$fail(peg$c66);
        }
      }

      return s0;
    }

    function peg$parseMETA() {
      let s0;

      if (input.substr(peg$currPos, 4) === peg$c67) {
        s0 = peg$c67;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c68);
        }
      }

      return s0;
    }

    function peg$parseCONNECTION() {
      let s0;

      if (input.substr(peg$currPos, 10) === peg$c69) {
        s0 = peg$c69;
        peg$currPos += 10;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c70);
        }
      }

      return s0;
    }

    function peg$parseOM() {
      let s0;

      if (input.substr(peg$currPos, 2) === peg$c71) {
        s0 = peg$c71;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }

      return s0;
    }

    function peg$parseAN() {
      let s0;

      if (input.substr(peg$currPos, 2) === peg$c73) {
        s0 = peg$c73;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c74);
        }
      }

      return s0;
    }

    function peg$parseUN() {
      let s0;

      if (input.substr(peg$currPos, 2) === peg$c75) {
        s0 = peg$c75;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c76);
        }
      }

      return s0;
    }

    function peg$parseRN() {
      let s0;

      if (input.substr(peg$currPos, 2) === peg$c77) {
        s0 = peg$c77;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c78);
        }
      }

      return s0;
    }

    function peg$parseLBRACE() {
      let s0;

      if (input.charCodeAt(peg$currPos) === 123) {
        s0 = peg$c79;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c80);
        }
      }

      return s0;
    }

    function peg$parseRBRACE() {
      let s0;

      if (input.charCodeAt(peg$currPos) === 125) {
        s0 = peg$c81;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c82);
        }
      }

      return s0;
    }

    function peg$parseINTEGER() {
      let s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c83.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c84);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c83.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseVALUE() {
      let s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsequotation_mark();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseNUMBER();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsequotation_mark();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c86(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsequotation_mark();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseINT();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsequotation_mark();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c87(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsequotation_mark();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseschar();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseschar();
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsequotation_mark();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c88(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseINT() {
      let s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 48) {
        s1 = peg$c89;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c90);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c91();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c92;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c93);
          }
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        if (s1 !== peg$FAILED) {
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c83.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c83.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c96(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseNUMBER() {
      let s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c92;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c93);
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c83.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c83.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s3 = peg$c97;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c83.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c83.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c99(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseschar() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parseignored();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c100();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseunescaped();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseescape();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s2 = peg$c101;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c102);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 92) {
                s2 = peg$c103;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 47) {
                  s2 = peg$c105;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c106);
                  }
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 98) {
                    s3 = peg$c107;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c108);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c109();
                  }
                  s2 = s3;
                  if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 102) {
                      s3 = peg$c110;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c112();
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 110) {
                        s3 = peg$c113;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c114);
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c115();
                      }
                      s2 = s3;
                      if (s2 === peg$FAILED) {
                        s2 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 117) {
                          s3 = peg$c116;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c117);
                          }
                        }
                        if (s3 !== peg$FAILED) {
                          s4 = peg$currPos;
                          s5 = peg$currPos;
                          s6 = peg$parseHEXDIG();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseHEXDIG();
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parseHEXDIG();
                              if (s8 !== peg$FAILED) {
                                s9 = peg$parseHEXDIG();
                                if (s9 !== peg$FAILED) {
                                  s6 = [s6, s7, s8, s9];
                                  s5 = s6;
                                } else {
                                  peg$currPos = s5;
                                  s5 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s5;
                              s5 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                          }
                          if (s5 !== peg$FAILED) {
                            s4 = input.substring(s4, peg$currPos);
                          } else {
                            s4 = s5;
                          }
                          if (s4 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c118(s4);
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c119(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseescape() {
      let s0;

      if (input.charCodeAt(peg$currPos) === 92) {
        s0 = peg$c103;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c104);
        }
      }

      return s0;
    }

    function peg$parsequotation_mark() {
      let s0;

      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c101;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c102);
        }
      }

      return s0;
    }

    function peg$parseunescaped() {
      let s0;

      if (peg$c120.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c121);
        }
      }

      return s0;
    }

    function peg$parseignored() {
      let s0;

      if (peg$c122.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c123);
        }
      }

      return s0;
    }

    function peg$parseDIGIT() {
      let s0;

      if (peg$c83.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c84);
        }
      }

      return s0;
    }

    function peg$parseHEXDIG() {
      let s0;

      if (peg$c124.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c125);
        }
      }

      return s0;
    }

    function peg$parseIDENT() {
      let s0, s1, s2;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c126) {
        s1 = peg$c126;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c127);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseWORD();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c128(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseWORD();
      }

      return s0;
    }

    function peg$parseWORD() {
      let s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseCHAR();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseCHAR();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c129(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseCHAR() {
      let s0;

      if (peg$c130.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c131);
        }
      }
      if (s0 === peg$FAILED) {
        if (peg$c83.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c84);
          }
        }
        if (s0 === peg$FAILED) {
          if (peg$c132.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c133);
            }
          }
        }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({
          type: "end",
          description: "end of input"
        });
      }

      throw peg$buildException(
        null,
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length ?
        peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) :
        peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
  // jshint ignore:end

})();

try {
  // Using Modulum
  modulum("AuiProtocolParser", (context) => {
    context.AuiProtocolParser = AuiProtocolParser;
  });
} catch (err) {
  (() => {})();
}
;

"use strict";

modulum("AuiProtocolReader",
  function(context, cls) {
    /**
     * @class AuiProtocolReader
     * @memberOf classes
     */
    cls.AuiProtocolReader = context.oo.StaticClass(
      /** @lends classes.AuiProtocolReader */
      {
        __name: "AuiProtocolReader",
        translate: function(obj) {
          return context.AuiProtocolParser.parse(obj);
        }
      });
  });
;

"use strict";

modulum("AuiProtocolWriter",
  function(context, cls) {
    const auiTreeCode = "\x01";
    const escapeSpecials = function(text) {
      if (Object.isString(text)) {
        return text.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/"/g, "\\\"");
      } else {
        return text;
      }
    };
    /** @ignore */
    const stringifiers = {
      /** @ignore */
      om: function(obj, application) {
        const result = [];
        if (application.info().wrapper) {
          result.push(cls.AuiProtocolWriter.translate(obj.orders, application));
        } else {
          result.push("event _om ", obj.order, "{}{", cls.AuiProtocolWriter.translate(obj.orders, application), "}\n");
        }
        //noinspection JSDeprecatedSymbols
        const sendString = result.join("");
        let finalString = sendString;
        if (application.encapsulation) {
          const size = sendString.getBytesCount();
          const encodedSize = Number.encodeInteger(size);
          finalString = encodedSize + encodedSize + auiTreeCode + sendString;
        }
        return finalString;
      },
      /** @ignore */
      meta: function(obj) {
        const result = [];
        result.push("meta ", obj.verb, "{", stringifiers.attributes(obj.attributes), "}\n");
        return result.join("");
      },
      /** @ignore */
      functionCallEvent: function(obj) {
        const result = [];
        const datatypes = {
          "string": "STRING",
          "object": "RECORD",
          "array": "ARRAY"
        };
        result.push("{FunctionCallEvent 0{{result \"", obj.status, "\"}");
        if (obj.message) {
          result.push("{errorMessage \"" + escapeSpecials(obj.message) + "\"}");
        }
        result.push("}");
        if (Array.isArray(obj.values)) {
          result.push("{");
          for (let i = 0; i < obj.values.length; i++) {
            const value = obj.values[i];
            result.push("{FunctionCallReturn " + i + "{");
            const valtype = Object.prototype.toString.call(value) === '[object Array]' ? "array" : typeof value;
            if (datatypes[valtype]) {
              result.push("{dataType \"" + datatypes[typeof value] + "\"}");
            }
            if (value === null || value === undefined || value.length <= 0) {
              result.push("{isNull \"1\"}{value \"0\"}");
            } else if (Object.isBoolean(value)) {
              result.push("{isNull \"0\"}{value \"" + (value ? "1" : "0") + "\"}");
            } else {
              result.push("{isNull \"0\"}{value \"" + escapeSpecials(value.toString()) + "\"}");
            }
            result.push("}{}}");
          }
          result.push("}");
        }
        result.push("}");
        return result.join("");
      },
      /** @ignore */
      configureEvent: function(obj) {
        const result = [];
        result.push("{ConfigureEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      keyEvent: function(obj) {
        const result = [];
        result.push("{KeyEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      actionEvent: function(obj) {
        const result = [];
        result.push("{ActionEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      rowSelectionEvent: function(obj) {
        const result = [];
        result.push("{RowSelectionEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      dragDropEvent: function(obj) {
        const result = [];
        result.push("{DragDropEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      attributes: function(attributeList) {
        const string = [];
        const keys = Object.keys(attributeList);
        for (let i = 0; i < keys.length; i++) {
          string.push("{", keys[i], " \"", escapeSpecials(attributeList[keys[i]]), "\"", "}");
        }
        return string.join("");
      },
      /** @ignore */
      destroyEvent: function(obj) {
        const result = [];
        result.push("{DestroyEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },
      /** @ignore */
      logEvent: function(obj) {
        const result = [];
        result.push("{LogEvent 0{", stringifiers.attributes(obj.attributes), "}}");
        return result.join("");
      },

      /** @ignore */
      _default: function(obj) {
        context.LogService.info("no aui protocol implementation for " + obj.type, obj);
        return "";
      }
    };
    /**
     * @namespace classes.AuiProtocolWriter
     */
    cls.AuiProtocolWriter = context.oo.StaticClass(
      /** @lends classes.AuiProtocolWriter */
      {
        __name: "AuiProtocolWriter",
        /**
         *
         * @param obj
         * @param application
         * @return {string}
         */
        translate: function(obj, application) {
          return (Array.isArray(obj) ? obj : [obj]).map(function(item) {
            return (stringifiers[item.type] || stringifiers._default)(item, application);
          }).join("");

        }
      });
  });
;

"use strict";

modulum("ProtocolInterface",
  function(context, cls) {
    /**
     * Base class for protocol interface.
     * @class ProtocolInterface
     * @memberOf classes
     */
    cls.ProtocolInterface = context.oo.Class(
      /** @lends classes.ProtocolInterface.prototype */
      {
        __name: "ProtocolInterface",
        isAlive: function() {
          return false;
        },
        trackPrompt: function() {
          return false;
        },
        getNetworkDelay: function() {
          return 0;
        }
      });
  });
;

"use strict";

(
  function(context, cls) {

    /**
     * Direct protocol interface. manages the full protocol as a state machine
     * @class DirectInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.DirectInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.DirectInterface.prototype */ {
        __name: "DirectInterface",
        /**
         * @type {classes.VMApplication}
         */
        application: null,
        /**
         * The Direct protocol is managed by Finite State Machine
         * @see https://github.com/jakesgordon/javascript-state-machine
         */
        directProtocol: null,
        _incomingData: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 0,
        onFirstGuiReady: null,
        /** @type {window.gbcWrapper} */
        _wrapper: null,
        _wrapperReceiveHandler: null,
        /**
         * @constructs
         * @param application
         */
        constructor: function(application) {
          this.application = application;

          this._incomingData = [];
          this.onFirstGuiReady = [];
          this.eventQueue = [];
          this._wrapper = application.info().wrapper;
          const directInterface = this;
          const directProtocol = this.directProtocol = context.StateMachine.create(
            /** @lends classes.DirectInterface#directProtocol */
            {
              /**
               * the general error handler
               */
              error: function(eventName, from, to, args, errorCode, errorMessage) {
                if (application.info()) {
                  application.info().ending = cls.ApplicationEnding.notok("" + errorCode + ". " + errorMessage);
                } else {
                  gbc.error("" + errorCode + ". " + errorMessage);
                }
              },
              initial: "Start",
              /**
               * the different events of the state machine
               * @see the directStates constant
               */
              events: context.constants.network.directStates,
              callbacks: {
                /**
                 * whenever we leave a state
                 */
                onleavestate: function(action, from, to) {
                  context.LogService.networkProtocol.log(`{${application.procId}}`, "PROTOCOL", from, " -> [", action, "] -> ", to);
                },
                onleaveStart: function(event, from, to, ending) {
                  directInterface.read(function(data) {
                    cls.DirectInitialAUI.run(data, application, function() {
                      window.setTimeout(function() {
                        application.setRunning(true);
                        directProtocol.transition();
                      }, 10);
                    });
                  });
                  return context.StateMachine.ASYNC;
                },
                onenterRecvInitialAUI: function() {
                  if (application.isProcessing()) {
                    directProtocol.waitForMoreInitialAUI();
                  } else {
                    directProtocol.guiMode();
                  }
                },
                onenterSendEmpty: function() {
                  directProtocol.getMoreOrder();
                },
                onleaveSendEmpty: function() {
                  if (!directInterface.application.hasError && !directInterface.application.ending) {
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                onenterRecvOrder: function() {
                  if (application.isProcessing()) {
                    directProtocol.waitForMoreOrder();
                  } else {
                    directProtocol.guiMode();
                  }
                },
                onenterGUI: function() {
                  if (directInterface.application.ending) {
                    if (directProtocol.transition) {
                      directProtocol.transition.cancel();
                    }
                    directProtocol.waitForEnd();
                  } else {
                    if (directInterface.onFirstGuiReady) {
                      const callbacks = directInterface.onFirstGuiReady;
                      directInterface.onFirstGuiReady = null;
                      while (callbacks.length) {
                        callbacks.splice(0, 1)[0]();
                      }
                    }

                    directInterface.eventInterval = window.setInterval(function() {
                      if (directInterface.eventQueue.length) {
                        directInterface.application.setProcessing();
                        window.setTimeout(function() {
                          directProtocol.sendOrder();
                        }, 10);
                        if (directInterface.eventInterval !== null) {
                          window.clearInterval(directInterface.eventInterval);
                          directInterface.eventInterval = null;
                        }
                      }
                    }, directInterface.eventIntervalTimeout);
                  }
                },
                onleaveGUI: function() {
                  if (directInterface.eventInterval !== null) {
                    window.clearInterval(directInterface.eventInterval);
                    directInterface.eventInterval = null;
                  }
                },
                onenterSendOrder: function() {
                  directProtocol.getOrderAnswer();
                },
                onleaveSendOrder: function(event, from, to) {
                  if (to !== "ApplicationEnd") {
                    let orders = [];
                    let evt = null;
                    // not send all events but only until first with directFire
                    while (directInterface.eventQueue.length > 0) {
                      evt = directInterface.eventQueue.shift();
                      orders.push(evt);
                      if (evt.directFire) {
                        break;
                      }
                    }

                    cls.DirectSendOrders.run(orders.flatten(), application, directInterface);
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                onenterReadOrder: function() {
                  directProtocol.getOrderAnswer();
                },
                onleaveReadOrder: function(event, from, to) {
                  if (to !== "ApplicationEnd") {
                    directInterface.read(function(data) {
                      cls.DirectRecvOrder.run(data, application, function() {
                        directProtocol.transition();
                      });
                    });
                    return StateMachine.ASYNC;
                  }
                },
                /**
                 * when the application ends, we wait for a confirmation close
                 */
                onenterApplicationEnding: function() {
                  directProtocol.endApp();
                },
                onenterApplicationEnd: function() {
                  application.stop();
                }
              }
            });
        },
        start: function() {
          this._wrapperReceiveHandler = this._wrapper.on(this._wrapper.events.RECEIVE, (event, src, data) => {
            if (this._wrapper.protocolVersion && this._wrapper.protocolVersion >= 2) {
              if (data.procId === this.application.info().procId) {
                this._onReceive(event, src, data.content);
              }
            } else {
              this._onReceive(event, src, data);
            }
          });
          this._wrapper.URReady(context.__wrapper.param({
            UCName: "GBC",
            UCVersion: gbc.version,
            mobileUI: context.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0,
            media: gbc.ThemeService.getMediaString(),
            icon: context.ThemeService.getResource("img/gbc_logo.ico")
          }, this.application));
          this.directProtocol.start();
        },

        stop: function(message) {
          const data = cls.AuiProtocolWriter.translate({
              type: "om",
              order: this.application.info().auiOrder++,
              orders: [new cls.VMDestroyEvent(-3, message)]
            }, this.application),
            options = {};
          this.application.model.logFireEvent(data);
          this.write(data, options);
        },

        event: function(events, noTimer = true) {
          if (events) {
            if (this.application && !this.application.ending) {
              // detect short time when we are going to send a request to the VM, but we didn't send yet
              this.application.pendingRequest = true;
              this.eventQueue.push(events);
              this.eventQueue[this.eventQueue.length - 1].directFire = true;

              if (this.eventInterval !== null) {
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              }

              if (noTimer) {
                this._manageEvents();
              } else {
                this.eventInterval = window.setInterval(this._manageEvents.bind(this), this.eventIntervalTimeout);
              }
            } else {
              if (this.eventInterval !== null) {
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              }
            }
          }
        },
        /**
         * @returns {number} the delay in ms between network requests
         */
        getNetworkDelay: function() {
          return this._networkDelay;
        },
        /**
         * @param {number} delay the delay in ms between network requests
         */
        setNetworkDelay: function(delay) {
          this._networkDelay = delay;
        },
        _manageEvents: function() {
          if (this.application) {
            this.application.pendingRequest = false;
            if (this.application.isIdle() && this.directProtocol.can("sendOrder")) {
              if (this.eventQueue.length) {
                this.application.setProcessing();
                if (this._networkDelay > 0) {
                  window.setTimeout(this.directProtocol.sendOrder.bind(this.directProtocol), this._networkDelay);
                } else {
                  this.directProtocol.sendOrder();
                }
                if (this.eventInterval !== null) {
                  window.clearInterval(this.eventInterval);
                  this.eventInterval = null;
                }
              } else {
                if (this.eventInterval !== null) {
                  window.clearInterval(this.eventInterval);
                  this.eventInterval = null;
                }
              }
            }
          } else {
            if (this.eventInterval !== null) {
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
            }
          }
        },
        newTask: function() {
          this._wrapper.childStart(context.__wrapper.param(null, this.application));
        },
        waitForApplicationInNewWindow: function(onSuccess, onFailure) {
          onSuccess();
        },
        interrupt: function() {
          this._wrapper.interrupt(context.__wrapper.param(null, this.application));
        },
        close: function() {
          this._wrapper.close(context.__wrapper.param(null, this.application));
        },
        destroy: function() {
          if (this._wrapperReceiveHandler) {
            this._wrapperReceiveHandler();
          }
          if (this.eventInterval !== null) {
            window.clearInterval(this.eventInterval);
            this.eventInterval = null;
          }
          let param = context.__wrapper.param(null, this.application);
          this.application = null;
          this.eventQueue = null;
          this._wrapper.close(param);
          this.directProtocol = null;
        },

        read: function(cb) {
          if (this._incomingData.length) {
            // don't use requestAnimationFrame because of background webview behavior
            window.setTimeout(function() {
              cb(this._incomingData.shift());
            }.bind(this), 0);
          } else {
            setTimeout(function() {
              this.read(cb);
            }.bind(this), 10);
          }
        },
        write: function(data, options) {
          context.LogService.networkProtocol.log(`{${this.application.procId}} ⇑ UR REQUEST\n`, "-> NATIVE SEND", data);
          this._wrapper.send(context.__wrapper.param(data, this.application), options);
        },
        _onReceive: function(event, src, data) {
          context.LogService.networkProtocol.log(`{${this.application.procId}} ⇓ HTTP RESPONSE\n`, "<- NATIVE RECEIVE", data);
          this._incomingData.push(data);
          if (!this.application.isProcessing()) {
            if (!this.directProtocol.transition) {
              this.directProtocol.readOrder();
            } else {
              // if pending transition delay the readOrder
              window.setTimeout(() => {
                if (this.directProtocol) {
                  this.directProtocol.readOrder();
                }
              }, 50);

            }
          }
        },

        /**
         * Check if the protocol has still some data to process
         * @returns {boolean} - true if data still exist in the queue
         */
        hasIncomingData: function() {
          return this._incomingData.length > 0;
        }

      };
    });

  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class DirectInitialAUI
     * @memberOf classes
     */
    cls.DirectInitialAUI = context.oo.StaticClass(
      /** @lends classes.DirectInitialAUI */
      {
        run: function(data, application, callback) {
          application.model.logDvm(data);
          application.dvm.manageAuiOrders(data, callback);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class DirectRecvOrder
     * @memberOf classes
     */
    cls.DirectRecvOrder = context.oo.StaticClass(
      /** @lends classes.DirectRecvOrder */
      {
        run: function(data, application, callback) {
          if (data) {
            application.model.logDvm(data);
            application.dvm.manageAuiOrders(data, callback);
          } else {
            callback();
          }
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class DirectSendOrders
     * @memberOf classes
     */
    cls.DirectSendOrders = context.oo.StaticClass(
      /** @lends classes.DirectSendOrders */
      {
        run: function(orders, application, directInterface) {
          const data = cls.AuiProtocolWriter.translate({
            type: "om",
            order: application.info().auiOrder++,
            orders: orders
          }, application);
          let options = {};
          if (orders.find(function(item) {
              return item.noUserActivity;
            })) {
            options = {
              userActivity: "no"
            };
          }
          application.model.logFireEvent(data);
          directInterface.write(data, options);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  /**
   * @param {gbc} context
   */
  function(context) {
    context.constants.network.directStates = [{
      name: "run",
      from: "none",
      to: "Start"
    }, {
      name: "start",
      from: "Start",
      to: "RecvInitialAUI"
    }, {
      name: "waitForMoreInitialAUI",
      from: "RecvInitialAUI",
      to: "SendEmpty"
    }, {
      name: "getMoreOrder",
      from: "SendEmpty",
      to: "RecvOrder"
    }, {
      name: "guiMode",
      from: ["RecvInitialAUI", "RecvOrder"],
      to: "GUI"
    }, {
      name: "sendOrder",
      from: "GUI",
      to: "SendOrder"
    }, {
      name: "readOrder",
      from: "GUI",
      to: "ReadOrder"
    }, {
      name: "getOrderAnswer",
      from: ["SendOrder", "ReadOrder"],
      to: "RecvOrder"
    }, {
      name: "waitForMoreOrder",
      from: "RecvOrder",
      to: "SendEmpty"
    }, {
      name: "waitForEnd",
      from: ["ApplicationEnding", "GUI", "SendHandShake"],
      to: "ApplicationEnding"
    }, {
      name: "endApp",
      from: ["SendStart", "SendStartTask", "SendHandShake", "GUI", "SendEmpty", "SendOrder", "ApplicationEnding"],
      to: "ApplicationEnd"
    }];
  })(gbc);
;

"use strict";

(
  function(context, cls) {

    /**
     *
     * @class NoInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.NoInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.NoInterface.prototype */ {
        __name: "NoInterface",
        application: null,
        uaProtocol: null,
        ping: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 300,
        onFirstGuiReady: null,
        applicationEnding: null,
        taskCount: 0,
        _eventListener: null,
        /**
         * @constructs
         * @param application
         */
        constructor: function(application) {
          this.eventQueue = [];
          this._eventListener = new cls.EventListener();
        },
        start: function() {},
        event: function(events) {
          if (events) {
            if (!Array.isArray(events)) {
              events = [events];
            }
            this.eventQueue = this.eventQueue.concat(events);
            window.clearInterval(this.eventInterval);

            this.eventInterval = window.setInterval(function() {
              if (this.eventQueue.length) {
                this._eventListener.emit("events", this.eventQueue);
                window.clearInterval(this.eventInterval);
              } else {
                window.clearInterval(this.eventInterval);
              }
            }.bind(this), this.eventIntervalTimeout);
          } else {
            window.clearInterval(this.eventInterval);
          }
        },
        newTask: function() {},
        interrupt: function() {},
        close: function() {},
        destroy: function() {},
        waitForApplicationInNewWindow: function(onSuccess, onFailure) {
          onSuccess();
        },

        /**
         * Returns the queued events and clears the event list.
         * @returns {object[]} list of events to send to the VM
         */
        fetchEvents: function() {
          const events = this.eventQueue;
          this.eventQueue = [];
          return events;
        },
        onEvents: function(hook) {
          return this._eventListener.when("events", hook);
        }
      };
    });

  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * populates the headers from the response object
     * @memberOf UAInterface
     * @private
     * @param jqXHR the $.ajax jqXHR response
     * @returns {Object} a map of gbc aware headers
     * @ignore
     */
    const getHeaders = function(jqXHR) {
      const result = {};
      const keys = Object.keys(context.constants.network.headers);
      for (let k = 0; k < keys.length; k++) {
        const headerName = context.constants.network.headers[keys[k]];
        result[keys[k]] = jqXHR.getResponseHeader(headerName);
      }

      if (result.message) {
        let message = result.message;
        try {
          //base64 utf-8 to string like '["message1", "message2"]'
          const decodedMessage = decodeURIComponent(window.escape(atob(message))),
            messageArray = JSON.parse(decodedMessage),
            messageString = messageArray.length > 0 ? messageArray.join("\n") : message; // join with newline
          result.message = decodeURIComponent(messageString);
        } catch (ex) {
          result.message = message;
        }
      }

      return result;
    };
    /**
     *
     * @param session
     * @param taskId
     * @param taskProcIdParent
     * @param taskWaiting
     * @param callback
     * @ignore
     */
    const runNewTask = function(session, taskId, taskProcIdParent, taskWaiting, callback = () => {}) {
      window.setTimeout(() => {
        const sessionInstance = (session instanceof cls.VMSession) ? session : context.SessionService.getSession(session);
        if (sessionInstance) {
          sessionInstance.startSubTask(taskId, taskProcIdParent, taskWaiting, callback);
        }
      }, 10);
    };

    /**
     * manages special headers from sever whenever a response is received
     * @memberOf UAInterface
     * @private
     * @param args the arguments of the $.ajax callback (data, status, jqXHR)
     * @param uaProtocol the uaProtocol instance
     * @param {classes.VMApplication} application
     * @param onSuccess the callback in case of success
     * @param {?boolean} fromNewTask
     * @ignore
     */
    const canRun = function(args, uaProtocol, application, onSuccess, fromNewTask) {
      if (!application) {
        if (uaProtocol.transition) {
          uaProtocol.transition.cancel();
        }
      } else {
        if (application.info() && application.info().ending) {
          application.setError();
          if (uaProtocol.transition) {
            uaProtocol.transition.cancel();
          }
          uaProtocol.headerError();
        } else {
          const headers = getHeaders(args[2]);
          if (headers.message && !Boolean(headers.sessionClosed)) {
            application.message.gasAdminMessage(headers.message, true); //true to notify all win in session
          }
          if (headers.serverFeatures) {
            application.getSession().addServerFeatures((headers.serverFeatures || "").split(","));
          }
          if (headers.endUrl) {
            application.getSession().setEndUrl(headers.endUrl);
          }
          if (headers.sessionClosed) {
            //Rules defined in GBC-3937
            //X-FourJs-Session-Closed=true and an X-FourJs-Error ==> standard end page and display error message
            if (headers.error) {
              application.info().ending = cls.ApplicationEnding.notok(headers.error);
              application.getSession().setEndUrl(null); //No redirect even if an EndURL is defined
            } else if (headers.message) {
              //X-FourJs-Session-Closed=true and an X-FourJs-Message ==> standard end page and display error message
              application.info().ending = cls.ApplicationEnding.notok(headers.message);
            }

            application.getSession().closeSession();
            return;
          }
          if (fromNewTask && !headers.newTask) {
            application.getSession().waitedForNewTask();
          }
          if (headers.devmode === "true") {
            context.DebugService.activate();
          }
          if (headers.webComponent) {
            context.WebComponentService.setWebcomponentUrl(headers.webComponent);
          }
          if (headers.error) {
            application.setError();
            if (uaProtocol.transition) {
              uaProtocol.transition.cancel();
            }
            uaProtocol.headerError(headers.error);
          } else if (headers.closed) {
            if (uaProtocol.transition) {
              uaProtocol.transition.cancel();
            }
            application.setEnding();
            uaProtocol.endApp(headers.closed);
          } else if (headers.newTask) {
            runNewTask(application.getSession(), headers.newTask, headers.newTaskProcIdParent, headers.newTaskWaiting === "true", function() {
              onSuccess(args[0], headers);
            });
          } else if (headers.contentType === "text/html") {
            window.__desactivateEndingPopup = true;
            window.location.reload();
          } else {
            onSuccess(args[0], headers);
          }
          if (!application.hasError && !application.ending) {
            application.getSession().displayLogPrompt(headers.prompt);
          }
        }
      }
    };
    /**
     * UAProxy protocol interface. manages the full protocol as a state machine
     * @class UAInterface
     * @memberOf classes
     * @extends classes.ProtocolInterface
     */
    cls.UAInterface = context.oo.Class({
      base: cls.ProtocolInterface
    }, function() {
      return /** @lends classes.UAInterface.prototype */ {
        __name: "UAInterface",
        sessionId: null,
        /** @type classes.VMApplication */
        application: null,
        uaProtocol: null,
        ping: null,
        eventQueue: null,
        eventInterval: null,
        eventIntervalTimeout: 0,
        _networkDelay: 0,
        onFirstGuiReady: null,
        applicationEnding: null,
        taskCount: 0,

        /**
         * @constructs
         * @param {classes.VMApplication} application
         */
        constructor: function(application) {
          this.application = application;
          this.sessionId = application.getSession().getIdentifier();
          this.onFirstGuiReady = [];
          this.eventQueue = [];
          const uaInterface = this;
          /**
           * The ua protocol is managed by Finite State Machine
           * @memberOf UAInterface
           * @see https://github.com/jakesgordon/javascript-state-machine
           */
          const uaProtocol = this.uaProtocol = context.StateMachine.create({
            /**
             * the general error handler
             * @ignore
             */
            error: function(eventName, from, to, args, errorCode, errorMessage, e) {
              console.error(eventName, from, to, args, errorCode, errorMessage);
              context.error(errorMessage, e, application);
              if (!application.ended) {
                const appInfo = application.info();
                if (appInfo) {
                  appInfo.ending = cls.ApplicationEnding.notok("" + errorCode + ". " + errorMessage);
                } else {
                  gbc.error("UA protocol error: [" + eventName + ", " + from + ", " + to + ", " + args + ", " + errorCode + ", " +
                    errorMessage + "]");
                }
              }
            },
            /**
             * the different events of the state machine
             * @see the uaStates constant
             * @ignore
             */
            events: context.constants.network.uaStates,
            callbacks: /** @ignore */ {
              /**
               * whenever we leave a state
               * @ignore
               */
              onleavestate: function(action, from, to) {
                context.LogService.networkProtocol.log("STATE MACHINE(", application.applicationHash, ")", from,
                  " -> [", action, "] -> ", to);

              },
              /**
               * leave sendStart state
               * * if data is defined, it is either true if the app is closing, or an error message
               * * else we read the returning connection string
               * @ignore
               */
              onleaveSendStart: function(event, from, to, data) {
                if (!application.info().ending && !data) {
                  cls[application.info().task ? "UAStartupTask" : "UAStartup"].run(application, function(arg1, arg2, arg3, arg4,
                    arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UAConnectionString.run(data, headers, application);
                        uaProtocol.transition();
                      });
                  });
                  return context.StateMachine.ASYNC;
                }
              },
              /**
               * leave sendStartTask state (new task)
               * * if data is defined, it is either true if the app is closing, or an error message
               * * else we read the returning connection string
               * @ignore
               */
              onleaveSendStartTask: function(event, from, to, data) {
                if (!application.info().ending && !data) {
                  cls.UAStartupTask.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UAConnectionString.run(data, headers, application);
                        uaProtocol.transition();
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /**
               * When the connection string is ok, we send handshake to the server
               * @ignore
               */
              onenterRecvConnectionString: function() {
                uaProtocol.handShake();
              },
              /**
               * As we send handshake to the server, we ask for the initial aui tree
               * @ignore
               */
              onenterSendHandShake: function() {
                if (!application.info().ending) {
                  uaInterface.isRunning = true;
                  application.setProcessing();
                  uaProtocol.getInitialAUI();
                } else {
                  uaProtocol.headerError(";");
                }
              },
              /** @ignore */
              onleaveSendHandShake: function(event, from, to, ending) {
                if (!ending) {
                  if (uaInterface.application.ending) {
                    if (event !== "waitForEnd") {
                      if (uaProtocol.transition) {
                        uaProtocol.transition.cancel();
                      }
                      uaProtocol.waitForEnd();
                    }
                  } else {
                    cls.UAHandShake.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                      canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                        function(data, headers) {
                          cls.UAInitialAUI.run(data, headers, application, function() {
                            application.setRunning(true);
                            uaProtocol.transition();
                          });
                        });
                    });
                    return StateMachine.ASYNC;
                  }
                }
              },
              /** @ignore */
              onenterRecvInitialAUI: function() {
                if (application.isProcessing()) {
                  uaProtocol.waitForMoreInitialAUI();
                } else {
                  uaProtocol.guiMode();
                }
              },
              /** @ignore */
              onenterSendEmpty: function() {
                uaProtocol.getMoreOrder();
              },
              /** @ignore */
              onleaveSendEmpty: function() {
                if (!uaInterface.application.hasError && !uaInterface.application.ending) {
                  cls.UASendEmpty.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          uaProtocol.transition();
                        });
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /** @ignore */
              onenterRecvOrder: function() {
                if (application.isProcessing()) {
                  uaProtocol.waitForMoreOrder();
                } else {
                  uaProtocol.guiMode();
                }
              },
              /** @ignore */
              onenterGUI: function() {
                if (!uaInterface.application) {
                  uaProtocol.transition.cancel();
                  return;
                }
                if (uaInterface.application.ending) {
                  if (uaProtocol.transition) {
                    uaProtocol.transition.cancel();
                  }
                  uaProtocol.waitForEnd();
                } else {
                  if (uaInterface.onFirstGuiReady) {
                    const callbacks = uaInterface.onFirstGuiReady;
                    uaInterface.onFirstGuiReady = null;
                    while (callbacks.length) {
                      callbacks.splice(0, 1)[0]();
                    }
                  }
                  uaInterface.ping = window.setTimeout(function() {
                    uaProtocol.ping();
                  }, application.info().pingTimeout);

                  /** @ignore */
                  const localManageEvents = function() {
                    if (uaInterface.eventQueue && uaInterface.eventQueue.length) {
                      if (uaInterface.application.isIdle() && uaProtocol.can("sendOrder")) {
                        uaInterface.application.setProcessing();
                        uaProtocol.sendOrder();
                        if (uaInterface.eventInterval !== null) {
                          window.clearInterval(uaInterface.eventInterval);
                          uaInterface.eventInterval = null;
                        }
                      }
                    }
                  };
                  if (uaInterface.eventQueue && uaInterface.eventQueue.length) {
                    if (uaInterface.eventInterval === null) {
                      // TODO GBC-2925 can we remove this timer ?
                      uaInterface.eventInterval = window.setInterval(localManageEvents.bind(uaInterface), uaInterface
                        .eventIntervalTimeout);
                    }
                  }
                }
              },
              /** @ignore */
              onleaveGUI: function() {
                window.clearTimeout(uaInterface.ping);
                if (uaInterface.eventInterval !== null) {
                  window.clearInterval(uaInterface.eventInterval);
                  uaInterface.eventInterval = null;
                }
              },
              /** @ignore */
              onenterSendOrder: function(event, from, to, count) {
                uaProtocol.getOrderAnswer();
              },
              /** @ignore */
              onleaveSendOrder: function(event, from, to) {
                if (to !== "ApplicationEnd" && to !== "HeaderError") {
                  let orders = [];
                  let evt = null;
                  // not send all events but only until first with directFire
                  while (uaInterface.eventQueue.length > 0) {
                    evt = uaInterface.eventQueue.shift();
                    orders.push(evt);
                    if (evt.directFire) {
                      break;
                    }
                  }

                  orders = orders.flatten();
                  let httpOptions = null;
                  if (orders.find(function(item) {
                      return item.noUserActivity;
                    })) {
                    httpOptions = {
                      headers: {
                        "X-FourJs-User-Activity": "no"
                      }
                    };
                  }
                  cls.UASendOrders.run(orders, application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
                    arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          uaProtocol.transition();
                        });
                      });
                  }, httpOptions);
                  return StateMachine.ASYNC;
                }
              },
              /**
               * the ping doesn't take care of the answer (apart from the headers)
               * @ignore
               */
              onenterPing: function() {
                cls.UAPing.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                  canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                    function() {
                      // no need to manage ping answer
                    });
                });
                uaProtocol.pingSent();
              },
              /**
               * when the application ends, we wait for a confirmation close
               * @ignore
               */
              onenterApplicationEnding: function(event, from, to) {
                uaProtocol.endApp(from === "SendHandShake");
              },
              /**
               * until we  the application ends, we wait for a confirmation close
               * @ignore
               */
              onleaveApplicationEnding: function(event, from, to, closed) {
                if (!closed && !uaInterface.application.hasError) {
                  cls.UASendEndingEmpty.run(application, function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
                    canRun([arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9], uaProtocol, uaInterface.application,
                      function(data, headers) {
                        cls.UARecvOrder.run(data, headers, application, function() {
                          if (application.ending) {
                            uaProtocol.transition();
                          } else {
                            uaProtocol.transition.cancel();
                            window.setTimeout(function() {
                              uaProtocol.waitForEnd();
                            }, 1000);
                          }
                        });
                      });
                  });
                  return StateMachine.ASYNC;
                }
              },
              /** @ignore */
              onenterHeaderError: function(event, from, to, msg) {
                const appInfo = application.info();
                if (appInfo) {
                  if (msg && msg.indexOf("Auto Logout") === 0) {
                    appInfo.ending = cls.ApplicationEnding.autoLogout(msg);
                  } else {
                    appInfo.ending = application.info().ending || cls.ApplicationEnding.uaProxy(msg);
                  }
                } else {
                  gbc.error("UA protocol onenterHeaderError: [" + event + ", " + from + ", " + to + ", " + msg + "]");
                }
                uaProtocol.endApp();
              },
              /** @ignore */
              onenterApplicationEnd: function() {
                const session = application.getSession();
                const applicationInfo = application.info();
                if (applicationInfo) {
                  applicationInfo.ending = applicationInfo.ending || cls.ApplicationEnding.ok;
                }
                application.stop();
                if (session) {
                  const nextApp = session.getCurrentApplication();
                  if (nextApp) {
                    session.getWidget().setCurrentWidget(nextApp.getUI().getWidget());
                  }
                }
              }
            }
          });
          uaProtocol.start();
        },
        start: function() {
          this.uaProtocol.getConnectionString();
        },
        event: function(events, noTimer = true) {
          if (events) {
            if (this.application && !this.application.ending) {
              // detect short time when we are going to send a request to the VM, but we didn't send yet
              this.application.pendingRequest = true;
              this.eventQueue.push(events);
              this.eventQueue[this.eventQueue.length - 1].directFire = true;

              if (this.eventInterval !== null) {
                window.clearInterval(this.eventInterval);
                this.eventInterval = null;
              }
              if (noTimer) {
                this._manageEvents();
              } else {
                this.eventInterval = window.setInterval(this._manageEvents.bind(this), this.eventIntervalTimeout);
              }
            } else {
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
            }
          }
        },
        /**
         * @returns {number} the delay in ms between network requests
         */
        getNetworkDelay: function() {
          return this._networkDelay;
        },
        /**
         * @param {number} delay the delay in ms between network requests
         */
        setNetworkDelay: function(delay) {
          this._networkDelay = delay;
        },
        _manageEvents: function() {
          if (this.application) {
            this.application.pendingRequest = false;
            if (this.application.isIdle() && this.uaProtocol.can("sendOrder")) {
              if (this.eventQueue.length) {
                this.application.setProcessing();
                if (this._networkDelay > 0) {
                  window.setTimeout(this.uaProtocol.sendOrder.bind(this.uaProtocol), this._networkDelay);
                } else {
                  this.uaProtocol.sendOrder();
                }
                if (this.eventInterval !== null) {
                  window.clearInterval(this.eventInterval);
                  this.eventInterval = null;
                }
              } else {
                if (this.eventInterval !== null) {
                  window.clearInterval(this.eventInterval);
                  this.eventInterval = null;
                }
              }
            }
          } else {
            if (this.eventInterval !== null) {
              window.clearInterval(this.eventInterval);
              this.eventInterval = null;
            }
          }
        },
        newTask: function() {
          let session = this.application;
          if (this.application) {
            session = this.application.getSession();
          } else {
            session = context.SessionService.getCurrent();
          }
          session.waitingForNewTask();
          const uaProtocol = this.uaProtocol;
          cls.UANetwork.newTask(this.application || session, function(...args) {
            if (this.application) {
              canRun(args, uaProtocol, this.application, () => {}, true);
            } else {
              const headers = getHeaders(args[2]);
              if (headers.newTask) {
                runNewTask(this.sessionId, headers.newTask, headers.newTaskProcIdParent, headers.newTaskWaiting === "true");
              } else {
                session.waitedForNewTask();
              }
            }
          }.bind(this));
        },
        interrupt: function() {
          cls.UANetwork.interrupt(this.application);
        },
        close: function() {
          if (this.application.info().session) {
            // if we sent a session ua/close there is no need to send app ua/close
            if (!this.application.info().sessionIsClosing) {
              cls.UANetwork.close(this.application);
            }
            if (this.uaProtocol.transition) {
              this.uaProtocol.transition.cancel();
            }
            this.uaProtocol.waitForEnd();
          }
        },
        closeSession: function() {
          if (this.application.info().session) {
            this.application.info().sessionIsClosing = true;
            cls.UANetwork.closeSession(this.application);
          }
        },
        /**
         * Stop the protocol by sending a DestroyEvent
         * @param {String} message - reason of stop request
         */
        stop: function(message) {
          this.application.scheduler.emptyCommandsQueue(); // cancel all command and send only the destroyEvent
          const event = new cls.VMDestroyEvent(-3, message); // -3 = bad AUI (see spec in VM DestroyEvent.js)
          this.application.scheduler.eventVMCommand(event);
        },
        destroy: function() {
          window.clearTimeout(this.ping);
          window.clearInterval(this.eventInterval);
          this.eventInterval = null;
          this.application = null;
          this.eventQueue = null;
          this.uaProtocol = null;
        },
        isAlive: function() {
          return Boolean(this.uaProtocol);
        },
        trackPrompt: function() {
          const session = this.application && this.application.getSession();
          if (session && !session._isTrackingPrompt) {
            session._isTrackingPrompt = true;
            cls.UANetwork.trackPrompt(this.application, function(arg1, arg2, arg3) {
              const headers = getHeaders(arg3),
                session = this.application && this.application.getSession();
              if (session) {
                if (headers.sessionClosed) {
                  session.closeSession();
                }
                session._isTrackingPrompt = false;
                session.displayLogPrompt(headers.prompt);
              }
            }.bind(this));
          }
        },

        waitForApplicationInNewWindow: function(onSuccess, onFailure) {
          let app = this.application,
            session = app.getSession();
          session._addWaitingApplication(app);
          cls.UANetwork.waitTask(app, (response, none, jqXhr) => {
            const headers = getHeaders(jqXhr);
            if (headers.vmReady) {
              session._removeWaitingApplication(app);
              const win = cls.WindowHelper.openWindow(cls.UANetwork.newApp(app, null, null, {
                noQueryString: true
              }), true);
              window.setTimeout(() => {
                session._registerChildWindow(win);
                onSuccess();
              }, 0);
            } else {
              if (app.info().ending) {
                onFailure();
              } else if (!headers.closed) {
                window.setTimeout(() => this.waitForApplicationInNewWindow(onSuccess, onFailure), 0);
              } else {
                onFailure();
              }
            }
          });
        },
        /**
         * Run without waiting application define with the xcfAppId
         * @param {classes.VMApplication} application
         * @param {string} xcfAppId
         * @param onFailure callback in case of failure
         */
        runApplication: function(application, xcfAppId, onFailure) {
          const uaProtocol = this.uaProtocol;
          cls.UANetwork.runApplication(application, function(...args) {
            const xhr = args[2];
            if (xhr.status >= 400) {
              if (onFailure) {
                onFailure(xcfAppId, args[0], xhr.status);
              }
            } else {
              canRun(args, uaProtocol, application, () => {
                application.newTask();
              }, false);
            }
          }.bind(this), null, {
            xcfAppId: xcfAppId
          });
        }

      };
    });

  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * Standardized queries to access ua proxy
     * @namepace classes.UANetwork
     */
    cls.UANetwork = context.oo.StaticClass(function() {

      const passableQueryString = ["qainfo", "responsive", "noquitpopup", "debugmode", "setlng",
        "ur_platform_type", "ur_platform_name", "ur_protocol_type", "contextmenu", "mobileui", "browsermultipage", "serviceworker", "json"
      ];

      const httpQueries = /** @lends classes.UANetwork */ {
        /**
         * send start query
         * /ua/r?frontEndId1=...&frontEndId2=...
         */
        start: {
          verb: "GET",
          action: "r",
          /** @ignore */
          uriPart: function(application) {
            const info = application.info();
            let parts = [info.appId, "?Bootstrap=done"].join("");
            const keys = Object.keys(info.urlParameters),
              len = keys.length;
            for (let i = 0; i < len; i++) {
              const key = keys[i],
                id = "&" + key + "=";
              const args = info.urlParameters[key];
              if (args) {
                parts += id + (Array.isArray(args) ? args : [args]).join(id);
              }
            }
            return parts;
          }
        },

        /**
         * send wait new task
         * /ua/sua/session_id?appId=...
         */
        waitTask: {
          verb: "GET",
          action: "wait",
          /** @ignore */
          uriPart: function(application) {
            const info = application.info();
            return [info.session, "?appId=", (info.app || 0)].join("");
          }
        },

        /**
         * send start new task
         * /ua/sua/session_id?appId=...&pageId=1
         * post data : empty
         */
        runTask: {
          verb: "POST",
          action: "sua",
          /** @ignore */
          uriPart: function(application) {
            const info = application.info();
            if (info.app === application._session.__lastNewtaskRun) {
              return null;
            } else {
              application._session.__lastNewtaskRun = info.app;
            }
            return [info.session, "?appId=", (info.app || 0), "&pageId=1"].join("");
          }
        },

        /**
         * Get url for new task in new window
         * /ua/sua/session_id?appId=...
         */
        newApp: {
          urlOnly: true,
          action: "sua",
          /** @ignore */
          uriPart: function(application, httpOptions) {
            const info = application.info();
            const keys = Object.keys(info.urlParameters),
              len = keys.length,
              parts = [info.session, "?appId=", (info.app || 0)];
            for (let i = 0; i < len; i++) {
              const key = keys[i],
                lowerKey = key.toLocaleLowerCase(),
                id = "&" + key + "=";
              if (key !== "appId") {
                if (!httpOptions || !httpOptions.noQueryString || passableQueryString.indexOf(lowerKey) >= 0) {
                  const args = info.urlParameters[key];
                  if (args) {
                    parts.push(id + (Array.isArray(args) ? args : [args]).join(id));
                  }
                }
              }
            }
            if (gbc.queryStringTheme === gbc.ThemeService.getCurrentTheme()) {
              parts.push("&theme=" + gbc.queryStringTheme);
            }
            return parts.join("");
          }
        },

        /**
         * send aui order(s)
         * /ua/sua/session_id?appId=...&pageId=...
         * post data : aui order(s)
         */
        auiOrder: {
          verb: "POST",
          action: "sua",
          appId: true,
          pageId: true
        },

        /**
         * send empty request
         * /ua/sua/session_id?appId=...&pageId=...
         * post data : empty
         */
        empty: {
          verb: "POST",
          action: "sua",
          appId: true,
          pageId: true
        },

        /**
         * send ping
         * /ua/ping/session_id?appId=...
         * post data : empty
         */
        ping: {
          verb: "POST",
          appId: true
        },

        /**
         * track prompt
         * /ua/sua/session_id
         */
        trackPrompt: {
          verb: "POST",
          action: "sua"
        },

        /**
         * run without waiting a appId in
         * /ua/start/session_id/xcfAppId
         */
        runApplication: {
          verb: "GET",
          action: "start",
          /** @ignore */
          uriPart: function(application, httpOptions) {
            const info = application.info();
            return [info.session, httpOptions.xcfAppId].join("/");
          }

        },

        /**
         * send interrupt
         * /ua/interrupt/session_id?appId=...
         * post data : empty
         */
        interrupt: {
          verb: "POST",
          appId: true
        },

        /**
         * send close
         * /ua/close/session_id?appId=...
         * post data : empty
         */
        close: {
          verb: "POST",
          appId: true
        },

        /**
         * send close
         * /ua/close/session_id
         * post data : empty
         */
        closeSession: {
          action: "close",
          verb: "POST"
        },

        /**
         * send new task query
         * /ua/newtask/session_id
         */
        newTask: {
          verb: "POST",
          action: "newtask",
          sequence: true
        },

        /**
         * ft-lock-file
         */
        ftLockFile: {
          verb: "GET",
          customUrl: true,
          headers: {
            "X-FourJs-LockFile": true
          }
        }
      };
      const methods = {};
      const preparedMethod = {};

      const querySend = function(query, application, prepared, callback, data, httpOptions) {
        const logMessage = [query, prepared.verb, prepared.url].join(" : ");
        context.LogService.networkProtocol.log("HTTP REQUEST\n", logMessage, data);
        let themeValue = gbc.ThemeService.getValue("theme-network-retry-on-error");
        const httpRetriedErrors = themeValue instanceof Array ? themeValue.slice() :
          themeValue.split(" ").map(x => parseInt(x)).filter(x => !isNaN(x));
        themeValue = gbc.ThemeService.getValue("theme-network-retry-timeout");
        let httpRetries = themeValue instanceof Array ? themeValue.slice() :
          themeValue.split(" ").map(x => parseInt(x)).filter(x => !isNaN(x));

        if (window.isURLParameterEnabled("serviceworker")) {
          // use old way for start connection or meta send
          const isMeta = data && data.indexOf("meta") === 0;
          const isNewTask = query === "newTask" || query === "runTask";

          if (query !== "start" && !isMeta) {
            try {
              const {
                application,
                ...fetchDetail
              } = prepared;
              gbc.sendMessage({
                action: "querySend",
                query,
                fetchDetail,
                data
              });
              return;
            } catch (err) {
              Function.noop();
              // can't use Service Worker, use old way
            }
          }
        }

        const xhr = new XMLHttpRequest();
        xhr.withCredentials = prepared.withCredentials;
        xhr.query = query;
        xhr.open(prepared.verb, prepared.url, true);
        const headers = Object.keys(prepared.headers);
        for (const element of headers) {
          xhr.setRequestHeader(element, prepared.headers[element]);
        }
        if (httpOptions && httpOptions.headers) {
          const keys = Object.keys(httpOptions.headers);
          for (const element of keys) {
            xhr.setRequestHeader(element, httpOptions.headers[element]);
          }
        }
        const invalid = false;
        const _retryCurrentRequest = () => {
          const timeout = httpRetries.shift() * 1000;
          xhr.abort();
          window.setTimeout(() => {
            xhr.open(prepared.verb, prepared.url, true);
            xhr.send((data ? data : null));
          }, timeout);
        };

        // "load" event triggered when the request is complete (even if HTTP status is like 400 or 500) and the response is fully downloaded
        xhr.onload = function(invalid, appInfo, logMessage, xhrEvent) {
          if (!invalid) {
            context.LogService.networkProtocol.log("HTTP RESPONSE\n", logMessage, xhrEvent.target.response);
            if (callback) {
              callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
            }
          }
        }.bind(null, invalid, prepared.appInfo, logMessage);
        if (!prepared.ignoreResponse) {
          xhr.onreadystatechange = function(appInfo, xhrEvent) {
            let error = true;
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (httpRetriedErrors.includes(xhr.status) && (httpRetries.length > 0)) {
                _retryCurrentRequest();
                return;
              }
              if (xhr.query === "runApplication" && xhr.status >= 400) {
                error = false;
              } else if (xhr.status === 404) {
                if (application && application.protocolInterface && application.protocolInterface.isRunning) {
                  appInfo.ending = cls.ApplicationEnding.notok("Session does not exist.");
                } else {
                  appInfo.ending = cls.ApplicationEnding.notFound;
                }
              } else if (xhr.status === 403) {
                appInfo.ending = cls.ApplicationEnding.forbidden;
              } else if (xhr.status >= 400 && xhr.status < 500) {
                appInfo.ending = cls.ApplicationEnding.notok(xhr.responseText);
              } else if (xhr.status >= 500) {
                context.LogService.networkProtocol.log("HTTP RESPONSE", logMessage, xhr.status, xhr.statusText, xhr
                  .responseText);
                if (application && application.protocolInterface && application.protocolInterface.isRunning) {
                  appInfo.ending = cls.ApplicationEnding.notok("Session does not exist.");
                } else {
                  appInfo.ending = cls.ApplicationEnding.notFound;
                }
              } else if (xhr.status !== 200) {
                context.LogService.networkProtocol.log("HTTP RESPONSE", logMessage, xhr.status, xhr.statusText, xhr
                  .responseText);
                error = false;
              } else {
                error = false;
              }
              if (application && error) {
                context.LogService.networkProtocol.log("HTTP REQUEST ERROR", xhr.statusText, xhr.responseText);
                application.error("HTTP", "Network error (" + xhr.statusText + ")", xhr);
                if (callback) {
                  callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
                }
              }
            }
          }.bind(null, prepared.appInfo);

          //"error" event triggered when the request could not be made, e.g. network down.
          xhr.onerror = function(invalid, appInfo, logMessage, xhrEvent, textStatus, errorThrown) {
            if (httpRetries.length > 0) {
              _retryCurrentRequest();
            } else {
              if (!invalid) {
                context.LogService.networkProtocol.log("HTTP REQUEST ERROR", textStatus, errorThrown);
                appInfo.ending = cls.ApplicationEnding.notok("Server unreachable");
                application.error("HTTP", "Network error (" + textStatus + ")", xhrEvent);
                if (callback) {
                  callback.call(null, xhrEvent.target.response, null, xhrEvent.target);
                }
              }
            }
          }.bind(null, invalid, prepared.appInfo, logMessage);
        }
        xhr.send((data ? data : null));
      };

      const createQuery = function(query, info) {
        preparedMethod[query] = function(query, info, application, httpOptions) {
          const appInfo = application.info();
          let url, shouldReturn = false,
            withCredentials = false;
          if (info.customUrl) {
            url = httpOptions && httpOptions.customUrl;
          } else {
            const parts = [appInfo && (appInfo.customUA || appInfo.connector) || "", "/ua/", info.action || query, "/"],
              uriPart = cls.UANetwork._getUriPart(application, info, httpOptions);
            if (!uriPart) {
              shouldReturn = true;
            } else {
              parts.push(uriPart);
              url = parts.join("");
            }
          }
          if (context.ThemeService.getValue("theme-network-use-credentials-headers")) {
            withCredentials = true;
          }
          const headers = {};
          const defaultHeaders = Object.keys(context.constants.network.sentHeaders);
          for (const element of defaultHeaders) {
            headers[element] = context.constants.network.sentHeaders[element];
          }

          headers[context.constants.network.headers.session] = appInfo.session;

          if (info.headers) {
            const ikeys = Object.keys(info.headers);
            for (const element of ikeys) {
              headers[element] = info.headers[element];
            }
          }
          return {
            shouldReturn: shouldReturn,
            withCredentials: withCredentials,
            url: url,
            application: application,
            appInfo: appInfo,
            headers: headers,
            verb: info.verb
          };
        };
        methods[query] = function(query, info, application, callback, data, httpOptions) {
          const prepared = preparedMethod[query](query, info, application, httpOptions);
          if (prepared.shouldReturn) {
            return;
          }
          if (info.urlOnly) {
            return prepared.url;
          }

          querySend(query, application, prepared, callback, data, httpOptions);

        }.bind(null, query, info);
      };
      const queryKeys = Object.keys(httpQueries);
      for (var i = 0; i < queryKeys.length; i++) {
        var query = queryKeys[i];
        const queryInfo = httpQueries[query];
        /**
         * For each sub cited methods, the same signature
         * @param application the current application
         * @param callback the callback in case of success
         * @param data the payload to send
         * @param httpOptions the http request options (like headers) to send
         */
        createQuery(query, queryInfo);
      }
      const result =
        /** @lends classes.UANetwork */
        {
          __name: "UANetwork",
          __sequence: 0,
          _prepared: {},
          querySend: querySend,
          _getUriPart: function(application, info, httpOptions) {
            const appInfo = application.info();
            const uriParts = [];
            // Manage server prefix for cgi
            if (info.uriPart) {
              uriParts.push(info.uriPart(application, httpOptions));
            } else {
              uriParts.push(appInfo.session);
              let queryStarted = false;
              if (info.appId) {
                queryStarted = true;
                uriParts.push("?appId=", appInfo.app || 0);
                if (info.pageId) {
                  uriParts.push("&pageId=", appInfo.page++);
                }
              }
              if (info.sequence) {
                uriParts.push(queryStarted ? "&" : "?", "seq=", this.__sequence++);
              }
            }
            const uriPart = uriParts.join("");
            if (!uriPart) {
              return null;
            }
            return uriPart;
          }
        };

      const keys = Object.keys(methods);
      for (const element of keys) {
        result[element] = methods[element];
        result._prepared[element] = preparedMethod[element].bind(null, element, httpQueries[element]);
      }

      return result;

    });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAConnectionString
     * @memberOf classes
     */
    cls.UAConnectionString = context.oo.StaticClass(
      /** @lends classes.UAConnectionString */
      {

        run: function(data, headers, application) {
          application.model.logDvm(data);
          let appInfo = application && application.info(),
            session = application && application.getSession();
          try {
            if (!appInfo.session || appInfo.task || !session.isMasterBrowserPage()) {
              if (!appInfo.session) {
                const headersKeys = Object.keys(context.constants.network.startHeaders);
                for (const key of headersKeys) {
                  const value = context.constants.network.startHeaders[key];
                  const hvalue = headers[key];
                  if (hvalue === null) {
                    throw value.error;
                  }
                  appInfo[value.prop || key] = hvalue;
                }
                session.setSessionId(appInfo.session);
                appInfo.serverVersion = headers.server;
              }
              const t = appInfo.timeout;
              appInfo.pingTimeout = (t > 1 ? t > 5 ? t - 5 : t - 1 : t) * 1000;

              const vmMessages = cls.AuiProtocolReader.translate(data);

              if (vmMessages.length === 0 || vmMessages.length !== 1 && vmMessages[0].type !== "meta" || vmMessages[0].verb !==
                "Connection") {
                if (!data) {
                  throw new Error("No connectionString received. Ensure your application is compiled and published.");
                } else {
                  throw new Error("Received connectionString bad format : \"" + data + "\"");
                }
              }

              appInfo.connectionInfo = vmMessages[0].attributes;
              session.getNavigationManager().updateApplicationInformation(application);
              gbc.classes.EncodingHelper.setVMEncoding(appInfo.connectionInfo.encoding.toLowerCase());
              application.prepareEmergencyClose();
            }
          } catch (e) {
            const message = "" + e.toString();
            if (appInfo) {
              appInfo.ending = cls.ApplicationEnding.notok(message);
            }
          }
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAHandShake
     * @memberOf classes
     */
    cls.UAHandShake = context.oo.StaticClass(
      /** @lends classes.UAHandShake */
      {
        run: function(application, callback) {
          // Performing the initial hanshake
          const data = cls.AuiProtocolWriter.translate({
            type: "meta",
            verb: "Client",
            attributes: {
              name: "GBC",
              version: context.version,
              encoding: "UTF-8",
              encapsulation: 0,
              filetransfer: 0,
              mobileUI: context.ThemeService.getValue("aui-mobileUI-default") ? 1 : 0,
              media: context.ThemeService.getMediaString(), // could be  'small' (phone), 'medium' (tablet), 'large' (desktop): see FGL-5429
              json: (window.isURLParameterEnabled("json") || context.ThemeService.getValue("aui-json-protocol")) ? 1 : 0
            }
          });
          application.model.logFireEvent(data);
          cls.UANetwork.auiOrder(application, callback, data);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAInitialAUI
     * @memberOf classes
     */
    cls.UAInitialAUI = context.oo.StaticClass(
      /** @lends classes.UAInitialAUI */
      {
        run: function(data, headers, application, callback) {
          application.model.logDvm(data);
          application.dvm.manageAuiOrders(data, callback);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAPing
     * @memberOf classes
     */
    cls.UAPing = context.oo.StaticClass(
      /** @lends classes.UAPing */
      {
        run: function(application, callback) {
          cls.UANetwork.ping(application, callback);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UARecvOrder
     * @memberOf classes
     */
    cls.UARecvOrder = context.oo.StaticClass(
      /** @lends classes.UARecvOrder */
      {
        run: function(data, headers, application, callback) {
          if (data) {
            application.model.logDvm(data);
            application.dvm.manageAuiOrders(data, callback);
          } else {
            if (headers.newTask) {
              application.scheduler.validateLastCommand(true);
            }
            callback();
          }
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UASendEmpty
     * @memberOf classes
     */
    cls.UASendEmpty = context.oo.StaticClass(
      /**@lends classes.UASendEmpty */
      {
        run: function(application, callback) {
          cls.UANetwork.empty(application, callback);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UASendEndingEmpty
     * @memberOf classes
     */
    cls.UASendEndingEmpty = context.oo.StaticClass(
      /** @lends classes.UASendEndingEmpty */
      {
        run: function(application, callback) {
          cls.UANetwork.empty(application, callback);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UASendOrders
     * @memberOf classes
     */
    cls.UASendOrders = context.oo.StaticClass(
      /** @lends classes.UASendOrders */
      {
        run: function(orders, application, callback, httpOptions) {
          for (const element of orders) {
            if (element.lazyResolve) {
              element.lazyResolve();
            }
          }
          const data = cls.AuiProtocolWriter.translate({
            type: "om",
            order: application.info().auiOrder++,
            orders: orders
          }, application);
          application.model.logFireEvent(data);
          cls.UANetwork.auiOrder(application, callback, data, httpOptions);
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAStartup
     * @memberOf classes
     */
    cls.UAStartup = context.oo.StaticClass(
      /** @lends classes.UAStartup */
      {
        run: function(application, callback) {
          const headers = {
            Accept: "application/octet-stream"
          };
          cls.UANetwork.start(application, callback, null, {
            headers: headers
          });
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  function(context, cls) {
    /**
     * @class UAStartupTask
     * @memberOf classes
     */
    cls.UAStartupTask = context.oo.StaticClass(
      /** @lends classes.UAStartupTask */
      {
        run: function(application, callback) {
          const headers = {
            Accept: "application/octet-stream"
          };
          cls.UANetwork.runTask(application, callback, null, {
            headers: headers
          });
        }
      });
  })(gbc, gbc.classes);
;

"use strict";

(
  /**
   * @param {gbc} context
   */
  function(context) {
    context.constants.network.uaStates = [{
      name: "start",
      from: "none",
      to: "SendStart"
    }, {
      name: "startTask",
      from: "none",
      to: "SendStartTask"
    }, {
      name: "getConnectionString",
      from: ["SendStart", "SendStartTask"],
      to: "RecvConnectionString"
    }, {
      name: "handShake",
      from: "RecvConnectionString",
      to: "SendHandShake"
    }, {
      name: "getInitialAUI",
      from: "SendHandShake",
      to: "RecvInitialAUI"
    }, {
      name: "waitForMoreInitialAUI",
      from: "RecvInitialAUI",
      to: "SendEmpty"
    }, {
      name: "getMoreOrder",
      from: "SendEmpty",
      to: "RecvOrder"
    }, {
      name: "guiMode",
      from: ["RecvInitialAUI", "RecvOrder"],
      to: "GUI"
    }, {
      name: "ping",
      from: "GUI",
      to: "Ping"
    }, {
      name: "pingSent",
      from: "Ping",
      to: "GUI"
    }, {
      name: "sendOrder",
      from: "GUI",
      to: "SendOrder"
    }, {
      name: "getOrderAnswer",
      from: "SendOrder",
      to: "RecvOrder"
    }, {
      name: "waitForMoreOrder",
      from: "RecvOrder",
      to: "SendEmpty"
    }, {
      name: "waitForEnd",
      from: ["ApplicationEnding", "GUI", "SendHandShake", "SendEmpty", "SendOrder"],
      to: "ApplicationEnding"
    }, {
      name: "headerError",
      from: ["SendStart", "SendStartTask", "SendHandShake", "SendEmpty", "SendOrder", "GUI", "Ping", "ApplicationEnding"],
      to: "HeaderError"
    }, {
      name: "endApp",
      from: ["HeaderError", "SendStart", "SendStartTask", "SendHandShake", "SendEmpty", "SendOrder", "Ping", "ApplicationEnding"],
      to: "ApplicationEnd"
    }];
  })(gbc);
;

"use strict";

modulum('OverlayService', ['InitService'],
  function(context, cls) {

    /**
     * Service to display or hide an overlay which intercepts all mouse events. Overlay can be invisible or visible (grey)
     * @namespace gbc.OverlayService
     * @gbcService
     * @publicdoc
     */
    context.OverlayService = context.oo.StaticClass( /** @lends gbc.OverlayService */ {
      __name: "OverlayService",

      /**
       * Map which contains all overlay defined during application life
       * @type {Map}
       */
      _overlayList: null,

      /**
       * Initialize the overlay management service
       */
      init: function() {
        this._overlayList = new Map();
      },

      /**
       * Create a new overlay object composed of element and custom flags
       * @returns {{timer: Function, visible: boolean, active: boolean, element: HTMLElement}}
       * @private
       */
      _create: function() {
        const overlayElement = document.createElement("div");
        overlayElement.addClasses("overlay", "hidden");
        return {
          element: overlayElement,
          active: false,
          visible: false,
          timer: null
        };
      },

      /**
       * Get the overlay associated with provided name
       * @param {string} name - overlay identifier
       * @returns {{timer: Function, visible: boolean, active: boolean, element: HTMLElement}} return overlay object
       * @publicdoc
       */
      get: function(name) {
        let overlay = this._overlayList.get(name);
        if (!overlay) { // create new overlay
          overlay = this._create();
          this._overlayList.set(name, overlay);
        }
        return overlay;
      },

      /**
       * Enable global overlay
       * @param {string} name - overlay identifier used to create and manage an associated overlay element
       * @param {HTMLElement} parentContainer - DOM element which contains overlay div. If none we add overlay directly under body
       * @publicdoc
       */
      enable: function(name, parentContainer) {
        const overlay = this.get(name);
        overlay.active = true;
        const containerElement = parentContainer || document.body;
        if (overlay.element.parentNode !== containerElement) {
          containerElement.appendChild(overlay.element);
        }
        overlay.element.removeClass("hidden");
      },

      /**
       * Disable global overlay
       * @param {string} name - overlay identifier
       * @publicdoc
       */
      disable: function(name) {
        const overlay = this.get(name);
        if (overlay.timer) {
          window.clearTimeout(overlay.timer);
          overlay.timer = null;
        }
        overlay.active = false;
        overlay.visible = false;
        overlay.element.addClass("hidden");
        overlay.element.removeClass("greybg");
      },

      /**
       * Define a cursor to put over the given overlay
       * @param {String} name - name of the overlay
       * @param {String} cursor - cursor to put over
       */
      setCursor: function(name, cursor) {
        const overlay = this.get(name);
        overlay.element.style.cursor = cursor;
      },

      /**
       * Makes overlay non-transparent by setting its opacity
       * @param {string} name - overlay identifier
       * @param {boolean} visible - show/hide overlay by updating its transparency
       * @publicdoc
       */
      setOpacity: function(name, visible) {
        const overlay = this.get(name);
        if (overlay.visible !== visible) {
          overlay.visible = visible;
          if (overlay.timer) {
            window.clearTimeout(overlay.timer);
            overlay.timer = null;
          }
          if (overlay.visible) {
            overlay.timer = window.setTimeout(
              function() { // to be sure that class is added after "hidden" class is removed, else css transition doesn't work
                overlay.timer = null;
                overlay.element.addClass("greybg");
              }.bind(this), 300);
          } else {
            overlay.element.removeClass("greybg");
          }
        }
      }
    });
    context.InitService.register(context.OverlayService);
  });
;

"use strict";

modulum('QAService', ['InitService'],
  function(context, cls) {

    /**
     * @namespace gbc.QAService
     */
    context.QAService = context.oo.StaticClass( /** @lends gbc.QAService */ {
      __name: "QAService",

      /** @type {Array} */
      _qaReadyActionWidgets: null,

      _afterLayoutHandler: null,

      _isReady: false,

      /**
       * Initialize the service
       */
      init: function() {
        this._afterLayoutHandlers = {};
      },

      /**
       * Get the afterLayout for the given widget
       * @param {cls.WidgetBase} widget - widget to get handler
       * @returns {*|null}
       * @private
       */
      _getHandlerForWidget: function(widget) {
        return this._afterLayoutHandlers[widget.getUniqueIdentifier()] ? this._afterLayoutHandlers[widget.getUniqueIdentifier()] : null;
      },

      /**
       * Set the afterLayout Handler for the given widget
       * @param {cls.WidgetBase} widget - widget to get handler
       * @param {function} handler
       * @private
       */
      _setHandlerForWidget: function(widget, handler) {
        if (handler) {
          this._afterLayoutHandlers[widget.getUniqueIdentifier()] = handler;
        } else {
          delete(this._afterLayoutHandlers[widget.getUniqueIdentifier()]);
        }
      },

      /**
       * Attach the afterLayout handler to widget
       * @param {cls.WidgetBase} widget - widget to bind
       */
      bindQAReadyButton: function(widget) {
        if (this._getHandlerForWidget(widget)) {
          this._getHandlerForWidget(widget)(); // call to remove handler
        }
        let modelHelper = new cls.ModelHelper(widget); // using ModelHelper to ensure correct current app is used
        this._setHandlerForWidget(widget, modelHelper.getApplication().scheduler.schedulerProcessEndedEvent(() => {
          // event executed once : we release reference because event listener will destroy it
          this._setHandlerForWidget(widget, null);
          widget.emit(context.constants.widgetEvents.click); // auto-click on itself
        }, true));
      },

      /**
       * @param {cls.SchedulerApplicationService} schedulerInstance
       */
      bindToScheduler: function(schedulerInstance) {
        schedulerInstance.schedulerProcessStartedEvent(() => {
          this._isReady = false;
        }, false);

        schedulerInstance.schedulerProcessEndedEvent(() => {
          this._isReady = true;
        }, false);
      },

      /**
       * Check if app is ready for QA
       * By asking the scheduler if there is nothing more to process
       * @return {boolean} - true if ready, false otherwise
       */
      isQAReady: function() {
        return this._isReady;
      },
    });
    context.InitService.register(context.QAService);
  });
;

"use strict";

modulum('CallbackCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Command callback.
     * @class CallbackCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.CallbackCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.CallbackCommand.prototype */ {
        __name: "CallbackCommand",

        /**
         * Function to execute
         * @function
         */
        _callback: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {function} callback
         */
        constructor: function(app, callback) {
          $super.constructor.call(this, app, null);
          this._callback = callback;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          if (this._callback) {
            this._callback();
            return true;
          }
          return false;
        },

      };
    });
  }
);
;

"use strict";

modulum('ClipboardCutCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native back command.
     * @class ClipboardCutCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.ClipboardCutCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.ClipboardCutCommand.prototype */ {
        __name: "ClipboardCutCommand",

        /** @type Selection */
        _selection: null,

        /** @type classes.WidgetBase */
        _widget: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {Selection} selection Selection
         * @param {classes.WidgetBase} widget
         */
        constructor: function(app, selection, widget) {
          $super.constructor.call(this, app, null);
          this._selection = selection;
          this._widget = widget;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          // if widget has not the focus --> no cut
          if (!this._widget || !this._app.hasVMFocus(this._widget)) {
            return false;
          }

          if (this._widget.manageBeforeInput()) {
            this._widget.manageClipboardCut(this._selection);
            this._widget.manageInput();
          }

          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('ClipboardPasteCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native back command.
     * @class ClipboardPasteCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.ClipboardPasteCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.ClipboardPasteCommand.prototype */ {
        __name: "ClipboardPasteCommand",

        /** @type String */
        _textValue: null,

        /** @type classes.WidgetBase */
        _widget: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {String} textValue text to be pasted
         * @param {classes.WidgetBase} widget
         */
        constructor: function(app, textValue, widget) {
          $super.constructor.call(this, app, null);
          this._textValue = textValue;
          this._widget = widget;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          // if widget has not the focus --> no paste
          if (!this._widget || !this._app.hasVMFocus(this._widget)) {
            return false;
          }

          if (this._widget.manageBeforeInput(this._textValue)) {
            this._widget.manageClipboardPaste(this._textValue);
            this._widget.manageInput(this._textValue);
          }

          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('CommandBase',
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Commands base class.
     * @class CommandBase
     * @memberOf classes
     */
    cls.CommandBase = context.oo.Class(function() {
      return /** @lends classes.CommandBase.prototype */ {
        __name: "CommandBase",

        /** @type {boolean} */
        __virtual: true,

        /**
         * Application
         * @type {classes.VMApplication}
         */
        _app: null,

        /**
         * Command timestamp
         * @type {number}
         * */
        _time: 0, // TODO why do we need this ?

        /**
         * linked AUI node
         * @type {classes.NodeBase}
         */
        _node: null,

        /** @type {boolean} */
        _isValueNode: false,

        /** @type {boolean} */
        _executeImmediately: false,

        /** @type {?number} */
        _initialContainerOffset: null,

        /** @type {number} */
        _runAttempts: 0,

        /**
         * Command generated by the execution of this command
         * It can be a command group 
         * @type {classes.CommandBase[]} 
         * @private
         * */
        _inducedCommands: null,

        /**
         * @constructs
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node linked AUI node
         */
        constructor: function(app, node) {
          this._app = app;
          this._time = Date.now();
          this._node = node;
          this._isValueNode = node?.getTag() === "Value";

          // if node is a value, keep offset value of its container
          // necessary to retrieve correct node if offset has changed between creation and execution of this command
          if (this._isValueNode) {
            const offsetContainerNode = node.getAncestorWithAttribute("offset");
            if (offsetContainerNode) {
              this._initialContainerOffset = offsetContainerNode.attribute("offset");
            }
          }
        },

        /**
         * Returns if command must be executed immediately
         * @returns {boolean} true if command must be executed immeadiately
         */
        executeImmediately() {
          return this._executeImmediately;
        },

        /**
         * Returns if command can be executed.
         * @returns {boolean} true if command can be executed
         */
        canBeExecuted: function() {
          return true;
        },

        /**
         * 
         * @returns {boolean} true if command should be retested on next run if failed
         */
        retryIfFailed: function() {
          return false;
        },

        /**
         * Check if this command needs to be sent to the VM before sending another one,
         * @returns {boolean} true if this command needs to be sent to the VM before sending another one, false otherwise
         */
        needsVmSync: function() {
          return false;
        },

        /**
         * Returns if after command executed a refresh layout is needed
         * @returns {boolean} true if refresh layout is needed
         */
        needsRefreshLayout: function() {
          return true;
        },

        /**
         * Execute command
         * @returns {boolean} the command did something ?
         */
        execute: function() {
          return false;
        },

        /**
         * Update the AUI _node because it can have changed between command creation and command execution
         * @returns {boolean} returns if the node has been correctly updated
         */
        updateNode: function() {
          // Check that offset is still the same between creation and before execution of this command
          if (this._isValueNode && this._initialContainerOffset !== null) {
            const valueListNode = this._node.getParentNode();
            const offsetContainerNode = this._node.getAncestorWithAttribute("offset");
            const containerOffset = offsetContainerNode ? offsetContainerNode.attribute("offset") : this._initialContainerOffset;

            const offsetDiff = containerOffset - this._initialContainerOffset;
            // if offset has changed need to retrieve correct value node
            if (offsetDiff !== 0) {
              const wrongIndex = this._node.getIndex("Value");
              const correctIndex = wrongIndex - offsetDiff;
              const valueNodes = valueListNode.getChildren("Value");
              if (correctIndex < valueNodes.length && correctIndex >= 0) {
                this._node = valueNodes[correctIndex];
              } else {
                // current table value nodes don't contain corresponding node anymore (offset update > page size)
                // in that case we should ignore the command
                this._node = null;
                return false;
              }
            }
          }
          return true;
        },

        /**
         * Check if a command is valid and can be executed
         * For example a command on destroyed node is invalid
         * @returns {boolean} true if the command is valid, false otherwise
         */
        checkIntegrity: function() {
          let ok = true;

          if (this._node) {
            // check that the node is not destroyed
            ok = (this._node._destroyed === false);
          }
          return ok;
        },

        /**
         * test if the request has been accepted by the VM
         * @returns {boolean} true if the request has been accepted by the VM, false otherwise
         */
        validate: function() {
          return true;
        },

        /**
         * Cancel a command not yet executed
         */
        cancel: function() {
          context.LogService.scheduler.log("[app" + this._app.applicationHash + "] " + this.__name + " command canceled",
            this);
          this._app.scheduler._removeCommand(this);
        },

        /**
         * Notify the scheduler that the command have failed
         */
        fail: function() {
          this._runAttempts += 1;
          context.LogService.scheduler.log(`[app${this._app.applicationHash}] ${this.__name} command failed.`);
          this._app.scheduler._handleFailedCommand(this);
        },

        /**
         * merges with another command
         * @param {classes.CommandBase} command the command to merge with
         * @returns {boolean} true if merged successfully
         */
        merge: function(command) {
          return false;
        },

        /**
         * Returns if only one command of this type must be added to scheduler queue
         * @return {boolean} true if command must be unique in scheduler queue
         */
        isUnique: function() {
          return false;
        },

        /**
         * get the linked AUI node
         * @returns {classes.NodeBase} the node associated to command
         */
        getNode: function() {
          return this._node;
        },

        /**
         * get the command timestamp
         * @returns {number} the command creation time
         */
        getTime: function() {
          return this._time;
        },

        /**
         * get the command run count. Usefull for commands that have the retryIfFailed() set to true
         * @returns {number} return the command runCount
         */
        getRunAttempts: function() {
          return this._runAttempts;
        },

        /**
         * @returns How many times a command can fail before cancelling it for good
         */
        getMaxRunAttempts: function() {
          return 50;
        },

        /**
         * @returns {classes.CommandBase[]} Getter for the inducedcommands list
         */
        getInducedCommands: function() {
          if (this._inducedCommands === null) {
            this._inducedCommands = [];
          }
          return this._inducedCommands;
        }
      };
    });
  }
);
;

"use strict";

modulum('DelayedKeyCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Delayed key command.
     * @class DelayedKeyCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.DelayedKeyCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.DelayedKeyCommand.prototype */ {
        __name: "DelayedKeyCommand",

        /** @type String */
        _keyString: null,

        /** @type Object */
        _keyEvent: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {String} keyString string corresponding to the key
         * @param {Object} keyEvent keyDown js event
         */
        constructor: function(app, keyString, keyEvent) {
          $super.constructor.call(this, app, null);
          this._keyString = keyString;
          this._keyEvent = keyEvent;
          this._executeImmediately = true;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          let processed = false;
          const focusedVMNode = this._app.getFocusedVMNodeAndValue();
          if (focusedVMNode) {
            const controller = focusedVMNode.getController();
            if (controller) {
              processed = this._app.keyboard.processKey(this._keyString, this._keyEvent, false);
              if (!processed) {
                context.LogService.scheduler.log("DelayedKeyCommand execute function on", controller);
                processed = this._simulateBrowserBehavior(controller);
              }

              this._app.keyboard.executeKeyUp(this._keyString, this._keyEvent);
            }
          }
          return processed;
        },

        /**
         * Try mimic browser behavior on a widget
         * @param {classes.WidgetBase} widget - widget on which we try to execute the key
         * @returns {boolean} true if key has been processed
         */
        simulateBrowserBehaviorOnWidget: function(widget) {
          if (!(widget instanceof cls.FieldWidgetBase)) {
            return false;
          }

          if (!widget.hasInputElement() || !widget.hasCursors() || widget.isReadOnly() || widget.isNotEditable()) {
            return false;
          }

          let consumed = false;
          let value = widget.getValue().toString();
          let keyString = this._keyString;
          const keyEvent = this._keyEvent;
          const cursors = widget.getCursors();

          const ctrlA = window.browserInfo.isSafari ? 'meta+a' : 'ctrl+a';
          if (keyString === 'space') { // needed for IE
            keyString = ' '; // replace "space" by " "
          } else {
            keyString = cls.KeyboardApplicationService.getCharIfComposedKey(keyString, keyEvent);
          }
          if (cls.KeyboardHelper.isChar(keyString)) { // value key
            const firstPart = value.substr(0, cursors.start);
            const secondPart = value.substr(cursors.end);
            value = firstPart + keyString;
            const newCursorPos = value.length;
            value += secondPart;
            cursors.start = cursors.end = newCursorPos;
            consumed = true;
          } else switch (keyString) { // modifier key
            case widget.getStart():
              cursors.start = cursors.start > 0 ? cursors.start - 1 : 0;
              cursors.end = cursors.start;
              consumed = true;
              break;
            case widget.getEnd():
              cursors.start = cursors.end < value.length ? cursors.end + 1 : value.length;
              cursors.end = cursors.start;
              consumed = true;
              break;
            case 'home':
              cursors.start = cursors.end = 0;
              consumed = true;
              break;
            case 'end':
              cursors.start = cursors.end = value.length;
              consumed = true;
              break;
            case 'shift+' + widget.getStart():
              cursors.start = cursors.start > 0 ? cursors.start - 1 : 0;
              consumed = true;
              break;
            case 'shift+' + widget.getEnd():
              cursors.end = cursors.end < value.length ? cursors.end + 1 : value.length;
              consumed = true;
              break;
            case ctrlA:
              cursors.start = 0;
              cursors.end = value.length;
              consumed = true;
              break;
            case 'backspace':
              if (cursors.end > 0 && value) {
                if (cursors.start === cursors.end) {
                  value = value.slice(0, cursors.start - 1) + value.slice(cursors.start);
                  cursors.start = cursors.end = cursors.end - 1;
                } else {
                  value = value.slice(0, cursors.start) + value.slice(cursors.end);
                }
              }
              consumed = true;
              break;
            case 'del':
            case 'delete':
              if (cursors.end > -1 && value) {
                if (cursors.start === cursors.end) {
                  value = value.slice(0, cursors.start) + value.slice(cursors.start + 1);
                } else {
                  value = value.slice(0, cursors.start) + value.slice(cursors.end);
                }
              }
              consumed = true;
              break;
          }

          if (consumed) {
            widget.setValue(value, false);
            widget.setCursors(cursors.start, cursors.end);
            // Because we simulate a key input, we need to call manageInput
            widget.manageInput();
          }

          return consumed;
        },

        /**
         * Try mimic browser behavior on a controller widget
         * @param {classes.ControllerBase} controller - controller on which we try to execute the key
         * @returns {boolean} true if key has been processed
         */
        _simulateBrowserBehavior: function(controller) {
          if (!controller || !controller.getWidget()) {
            return false;
          }

          const widget = controller.getWidget();
          return this.simulateBrowserBehaviorOnWidget(widget);
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('DelayedMouseClickCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Delayed mouse click command.
     * @class DelayedMouseClickCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.DelayedMouseClickCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.DelayedMouseClickCommand.prototype */ {
        __name: "DelayedMouseClickCommand",

        /** @type Object */
        _mouseEvent: null,
        /** @type classes.WidgetBase */
        _widget: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.WidgetBase} widget - widget where we must replay the event
         * @param {Object} mouseEvent mouse js event
         */
        constructor: function(app, widget, mouseEvent) {
          $super.constructor.call(this, app, null);
          this._widget = widget;
          this._mouseEvent = mouseEvent;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          let processed = false;
          if (this._widget) {
            if (this._widget.isDestroyed() === false) {
              context.MouseService._onClick(this._mouseEvent, this._widget.getElement(), true);
              processed = true;
            } else {
              context.LogService.scheduler.log("Widget destroyed : delayed click not executed.", this._widget);
              processed = false;
            }
          }

          return processed;
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('EnterBackgroundCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * EnterBackground command.
     * @class EnterBackgroundCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.EnterBackgroundCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.EnterBackgroundCommand.prototype */ {
        __name: "EnterBackgroundCommand",

        /**
         * @param {classes.VMApplication} app owner
         * @param {String[]} actionList list of actions to execute
         */
        constructor: function(app, actionList) {
          $super.constructor.call(this, app, null);
          this._actionList = actionList;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          // Tell the VM to execute the action
          this._app.action.executeByName("enterbackground");

          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('EnterForegroundCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native Enterforeground command.
     * @class EnterForegroundCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.EnterForegroundCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.EnterForegroundCommand.prototype */ {
        __name: "EnterForegroundCommand",

        /**
         * @param {classes.VMApplication} app owner
         * @param {String[]} actionList list of actions to execute
         */
        constructor: function(app, actionList) {
          $super.constructor.call(this, app, null);
          this._actionList = actionList;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          // Tell the VM to execute the action
          this._app.action.executeByName("enterforeground");
          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('GroupCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Group of commands
     * @class GroupCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.GroupCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.GroupCommand.prototype */ {
        __name: "GroupCommand",

        /** @type {classes.CommandBase[]} */
        _commands: null,

        /** @function */
        _executionFunc: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.CommandBase[]} commands - list of command
         * @param {function} func - execution function, if func() return true all commands are executed else nothing is done
         */
        constructor: function(app, commands, func) {
          $super.constructor.call(this, app, null);
          this._commands = commands;
          this._executionFunc = func;

          this._executeImmediately = true;
        },

        /**
         * Add a command in the group.
         * Last command added is used to know if all commands of the group can be executed
         * @param {classes.CommandBase} cmd - command to be added
         */
        addCommand: function(cmd) {
          if (!this._commands) {
            this._commands = [];
          }
          this._commands.push(cmd);

          this._executionFunc = cmd.canBeExecuted.bind(cmd);
          this.canBeExecuted = cmd.canBeExecuted.bind(cmd);
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          // if one command of the group is false all the group must be rejected
          for (let i = 0; i < this._commands.length; i++) {
            const cmd = this._commands[i];
            if (cmd.checkIntegrity() === false) {
              return false;
            }
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          if (this._executionFunc && this._executionFunc()) {
            while (this._commands.length !== 0) {
              const cmd = this._commands.shift();
              // only last command of a group can require a vm sync
              if (cmd.setNeedsVmSync) {
                cmd.setNeedsVmSync(this._commands.length === 0 && cmd.needsVmSync());
              }
              this._app.scheduler._addCommand(cmd, this._commands.length === 0);
            }
            return true;
          } else {
            return false;
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('LayoutCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Layout command.
     * @class LayoutCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.LayoutCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.LayoutCommand.prototype */ {
        __name: "LayoutCommand",

        /** @type Object */
        _options: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {Object} opts
         */
        constructor: function(app, opts = {}) {
          $super.constructor.call(this, app, null);
          this._options = opts;
          this._executeImmediately = false;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          this._app.layout.refreshLayout(this._options);
          return true;
        },

        /**
         * @inheritDoc
         */
        merge: function(command) {
          if (command instanceof cls.LayoutCommand) {
            const layoutCommand = /** @type classes.LayoutCommand */ command;
            this._options.resize = this._options.resize || layoutCommand._options.resize;
            this._options.noLayout = this._options.noLayout || layoutCommand._options.noLayout;
            return true;
          }
          return false;
        }

      };
    });
  }
);
;

"use strict";

modulum('NativeBackCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native back command.
     * @class NativeBackCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.NativeBackCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.NativeBackCommand.prototype */ {
        __name: "NativeBackCommand",

        /** @type String[] */
        _actionList: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {String[]} actionList list of actions to execute
         */
        constructor: function(app, actionList) {
          $super.constructor.call(this, app, null);
          this._actionList = actionList;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          let found = false,
            list = this._actionList,
            len = list && list.length;
          const actionService = this._app.action;
          for (let i = 0; i < len; i++) {
            if (actionService.getAction(list[i])) {
              found = true;
              const options = {};
              options.sendValue = true; // send value of the current field before execute action
              actionService.executeByName(list[i], null, options);
              break;
            }
          }
          if (!found) {
            context.__wrapper.nativeCall(context.__wrapper.param({
              name: "noBackAction"
            }, this.application));
          }

          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('NativeCloseCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native close command.
     * @class NativeCloseCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.NativeCloseCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.NativeCloseCommand.prototype */ {
        __name: "NativeCloseCommand",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          context.HostService.tryCloseButtonClick();

          return true;
        },

      };
    });
  }
);
;

"use strict";

modulum('NativeCordovaCallbackCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native cordovacallback command.
     * @class NativeCordovaCallbackCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.NativeCordovaCallbackCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.NativeCordovaCallbackCommand.prototype */ {
        __name: "NativeCordovaCallbackCommand",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          $super.execute.call(this);
          const inducedCmd = this._app.action.executeByName("cordovacallback");
          if (inducedCmd === null) {
            return false;
          }
          // TODO review the concept of induced commands, is it really necessary ?
          this.getInducedCommands().push(inducedCmd);
          return this.getInducedCommands().reduce((canBexecuted, cmd) => canBexecuted && cmd.canBeExecuted(), true);
        },

        /**
         * @inheritDoc
         */
        isUnique: function() {
          return true;
        },

        /**
         * @inheritdoc
         */
        retryIfFailed: function() {
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('NativeNotificationPushedCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native notificationpushed command.
     * @class NativeNotificationPushedCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.NativeNotificationPushedCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.NativeNotificationPushedCommand.prototype */ {
        __name: "NativeNotificationPushedCommand",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          $super.execute.call(this);
          const inducedCmd = this._app.action.executeByName("notificationpushed");
          if (inducedCmd === null) {
            return false;
          }
          // TODO review the concept of induced commands, is it really necessary ?
          this.getInducedCommands().push(inducedCmd);
          return this.getInducedCommands().reduce((canBexecuted, cmd) => canBexecuted && cmd.canBeExecuted(), true);
        },

        /**
         * @inheritDoc
         */
        isUnique: function() {
          return true;
        },

        /**
         * @inheritdoc
         */
        retryIfFailed: function() {
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('NativeNotificationSelectedCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Native notificationselected command.
     * @class NativeNotificationPushedCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.NativeNotificationSelectedCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.NativeNotificationPushedCommand.prototype */ {
        __name: "NativeNotificationSelectedCommand",

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app, null);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          $super.execute.call(this);
          const inducedCmd = this._app.action.executeByName("notificationselected");
          if (inducedCmd === null) {
            return false;
          }
          // TODO review the concept of induced commands, is it really necessary ?
          this.getInducedCommands().push(inducedCmd);
          return this.getInducedCommands().reduce((canBeExecuted, cmd) => canBeExecuted && cmd.canBeExecuted(), true);
        },

        /**
         * @inheritDoc
         */
        isUnique: function() {
          return true;
        },

        /**
         * @inheritdoc
         */
        retryIfFailed: function() {
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('OpenDropDownCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Open drop down command.
     * @class OpenDropDownCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.OpenDropDownCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.OpenDropDownCommand.prototype */ {
        __name: "OpenDropDownCommand",

        /**
         * Dropdown widget focus handler
         * @function
         */
        _onWidgetFocusHandler: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node node on which open drop down
         */
        constructor: function(app, node) {
          $super.constructor.call(this, app, node);
          this._executeImmediately = true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._onWidgetFocusHandler) {
            this._onWidgetFocusHandler();
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        execute: function() {

          const focusedVMNode = this._app.getFocusedVMNodeAndValue();

          // open drop down only if node has the focus
          if (focusedVMNode === this._node) {
            const widget = /** @type classes.FieldWidgetBase */ this._node.getWidget();

            // if widget has not yet the focus, wait for focus signal to open drop down
            if (widget.hasFocus()) {
              // need to put this in the afterDomMutator because it must be executed
              // after table setVerticalScroll::doScroll which is done in a afterDomMutator
              widget.afterDomMutator(function() {
                widget.openDropDown();
              }.bind(widget));

            } else {
              if (this._onWidgetFocusHandler) {
                this._onWidgetFocusHandler();
              }
              this._onWidgetFocusHandler = widget.when(context.constants.widgetEvents.focus, widget.openDropDown.bind(widget),
                true);
            }
          }

          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('RestoreFocusCommand', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Restore focus command.
     * Restore the focus at the correct position (according to AUI Tree)
     * @class RestoreFocusCommand
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.RestoreFocusCommand = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.RestoreFocusCommand.prototype */ {
        __name: "RestoreFocusCommand",

        _restoreDOMFocus: false,
        /**
         * @param {classes.VMApplication} app owner
         * @param {boolean} restoreDOMFocus
         */
        constructor: function(app, restoreDOMFocus) {
          $super.constructor.call(this, app, null);
          this._restoreDOMFocus = restoreDOMFocus;
          this._executeImmediately = false;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          this._app.focus.restoreVMFocus(this._restoreDOMFocus);
          return true;
        },

        /**
         * @inheritDoc
         */
        merge: function(command) {
          if (command instanceof cls.RestoreFocusCommand) {
            this._restoreDOMFocus = this._restoreDOMFocus || command._restoreDOMFocus;
            return true;
          }
          return false;
        }

      };
    });
  }
);
;

"use strict";

modulum('ActionVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Command VM action.
     * @class ActionVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.ActionVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.ActionVMCommand.prototype */ {
        __name: "ActionVMCommand",

        /** @type boolean */
        _noUserActivity: false,

        /** @type boolean */
        _dialogTouched: false,

        /** @type null|classes.NodeBase */
        _conflictNode: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node action
         * @param {Object} options - add options
         */
        constructor: function(app, node, options) {
          $super.constructor.call(this, app, node);
          this._noUserActivity = Boolean(options.noUserActivity);
          this._dialogTouched = node && (node.attribute('name') === 'dialogtouched');
          this._actionName = options.actionName;

          this._needsVmSync = true;
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          // If the action has to be executed by its name, retrieve the action name before
          if (this._actionName) {
            this._node = this._app.action.getAction(this._actionName);
            this._actionName = null; // set back to null to avoid searching again for the same action node
          }

          let sendActionEvent = false;

          if (this._node) {
            switch (this._node.getTag()) {
              case "StartMenuCommand":
                sendActionEvent = (this._node.attribute('disabled') !== 1);
                break;
              case "IdleAction":
                sendActionEvent = true;
                break;
              case "ActionDefault":
                sendActionEvent = true;
                break;
              default:
                let parentNode = this._node.getParentNode();
                if (parentNode.getTag() === "TableColumn") {
                  parentNode = parentNode.getParentNode(); // we want the table node
                }
                // Check if action is active
                const hasActionActiveAttr = this._node.isAttributeSetByVM('actionActive');
                const hasActiveAttr = this._node.isAttributeSetByVM('active');
                const hasParentActiveAttr = parentNode && parentNode.isAttributeSetByVM('active');

                let active = false;
                if (hasActionActiveAttr) {
                  active = this._node.attribute('actionActive');
                } else if (hasActiveAttr) {
                  active = this._node.attribute('active');
                }

                if (hasParentActiveAttr && parentNode.attribute('active')) {
                  active = active && parentNode.attribute('active');
                }

                sendActionEvent = active;

                if (sendActionEvent) {
                  // check if any conflict can exist with current action
                  this._conflictNode = this._getConflictNode(this._node);
                }
            }
          }

          return sendActionEvent;
        },

        /**
         * Check if current action can be in conflict with another node action
         * @param node
         * @returns {null|classes.NodeBase}
         * @private
         */
        _getConflictNode: function(node) {
          // image specific
          // if we resolve Image node as having a valid action to send to VM, then flag parent Table/ScrollGris not to send
          if (node.getTag() === "Image" && (node.isInTable() || node.isInScrollGrid())) {
            return node.getAncestor("Table") || node.getAncestor("ScrollGrid");
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        execute: function() {

          if (this.canBeExecuted()) {

            let events = [];
            // for default actions (=any predefined actions) send KeyEvent (VM don't understand Action event on ActionDefault)
            if (this._node && this._node.getTag() === "ActionDefault") {
              const key = cls.ActionApplicationService._localActions[this._node.attribute("name")];
              if (key) {
                events.push(new cls.VMKeyEvent(key));
              }

            } else {
              let actionEvent = new cls.VMActionEvent(this._node.getId());
              actionEvent.noUserActivity = this._noUserActivity;
              events.push(actionEvent);
            }

            if (events.length > 0) {
              // if we send an Action or Key event, check if we are in a PagedScrollGrid
              let focusedNode = this._node.getApplication().getFocusedVMNode();
              let scrollGridNode = focusedNode.getAncestor("ScrollGrid");
              let isPagedScrollGrid = scrollGridNode && scrollGridNode.getController().isPagedScrollGrid();

              if (isPagedScrollGrid) {
                // in a PagedScrollGrid send offset to force VM to not change it,
                // it is only frontend which can change offset
                let offset = focusedNode.attribute('offset');
                events.push(new cls.VMConfigureEvent(focusedNode.getId(), {
                  offset: offset
                }));
              }
            }

            if (events.length > 0) {
              this._vmEvents = events;
            }
          }

          return this._vmEvents && this._vmEvents.length > 0;
        },

      };
    });
  }
);
;

"use strict";

modulum('CommandVMBase', ['CommandBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * VM commands base class.
     * @class CommandVMBase
     * @memberOf classes
     * @extends classes.CommandBase
     */
    cls.CommandVMBase = context.oo.Class(cls.CommandBase, function($super) {
      return /** @lends classes.CommandVMBase.prototype */ {
        __name: "CommandVMBase",

        /** @type boolean */
        __virtual: true,

        /** @type boolean */
        _needsVmSync: false,

        /** @type classes.VMEventBase[] */
        _vmEvents: null,

        /**
         * @constructs
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node linked AUI node
         */
        constructor: function(app, node) {
          $super.constructor.call(this, app, node);
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return this._needsVmSync;
        },

        /** Sets if command needs a synchronisation, if yes scheduler will wait to send next commands until this commands VM responds
         * @param {boolean} b - needs vm sync ?
         */
        setNeedsVmSync: function(b) {
          this._needsVmSync = b;
        },

        /**
         * @inheritDoc
         */
        executeImmediately() {
          return this.needsVmSync();
        },

        /**
         * Returns VM events generated by this command and to be sent to VM
         * @returns {classes.VMEventBase[]}
         */
        getVMEvents() {
          return this._vmEvents;
        }
      };
    });
  }
);
;

"use strict";

modulum('CurrentRowVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * CurrentRow VM command.
     * @class CurrentRowVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.CurrentRowVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.CurrentRowVMCommand.prototype */ {
        $static: /** @lends classes.CurrentRowVMCommand */ {
          /**
           * Compute new row according to an action
           * @param {classes.MatrixNode|classes.TableNode} containerNode
           * @param {string} actionName
           * @param {number} row - Reference current row
           * @param {boolean} [canAddExtraRow] - can add extra row by doing down key after last row
           * @returns {number|null}
           */
          computeNewRowFromAction: function(containerNode, actionName, row, canAddExtraRow) {

            if (!cls.ActionNode.isTableNavigationAction(actionName)) {
              return null;
            }
            const pageSize = containerNode.attribute('pageSize');
            const size = containerNode.attribute('size');

            let newCurrentRow = null;

            if (actionName === 'nextrow') {
              newCurrentRow = cls.CurrentRowVMCommand._computeNewRowFromDelta(containerNode, 1, row);
            } else if (actionName === 'prevrow') {
              newCurrentRow = cls.CurrentRowVMCommand._computeNewRowFromDelta(containerNode, -1, row);
            } else if (actionName === 'nextpage') {
              newCurrentRow = cls.CurrentRowVMCommand._computeNewRowFromDelta(containerNode, pageSize, row);
            } else if (actionName === 'prevpage') {
              newCurrentRow = cls.CurrentRowVMCommand._computeNewRowFromDelta(containerNode, -pageSize, row);
            } else if (actionName === 'firstrow') {
              newCurrentRow = 0;
            } else if (actionName === 'lastrow') {
              newCurrentRow = size - 1;
            }

            // check that new row is in the correct size range [0...size]
            if (newCurrentRow >= size) {
              if (!canAddExtraRow || actionName !== "nextrow") { // only exception is in Input mode when the action is "nextrow"
                newCurrentRow = size - 1;
              }
            } else if (newCurrentRow < 0) {
              newCurrentRow = 0;
            }

            return newCurrentRow;
          },

          /**
           * Compute new row according to a delta value
           * @param {classes.MatrixNode|classes.TableNode} node
           * @param {number} delta
           * @param {number} currentRow - Reference current row
           * @returns {number}
           * @private
           */
          _computeNewRowFromDelta: function(node, delta, currentRow) {

            const size = node.attribute('size');

            const offset = node.attribute('offset');
            const pageSize = node.attribute('pageSize');

            let newCurrentRow = null;

            if (pageSize === 1) {
              newCurrentRow = currentRow + delta;
            } else {
              // handle step = +-/ pageSize behavior (like Explorer)
              if (delta === pageSize) {

                const isVerticalScrollAtEnd = node.getController().getWidget() && node.getController().getWidget().isVerticalScrollAtEnd ?
                  node
                  .getController().getWidget()
                  .isVerticalScrollAtEnd() :
                  false;
                if (offset + pageSize >= size || isVerticalScrollAtEnd) {
                  newCurrentRow = size;
                } else if (currentRow >= offset + pageSize - 1) {
                  //we are on the last row
                  newCurrentRow = currentRow + pageSize;
                } else {
                  //we move to the next page
                  newCurrentRow = offset + pageSize - 1;
                }
              } else if (delta === -(pageSize)) {
                if (currentRow < offset) {
                  newCurrentRow = Math.max(0, currentRow - pageSize + 1);
                } else if (currentRow === offset) {
                  newCurrentRow = offset - pageSize;
                } else {
                  newCurrentRow = offset;
                }
              } else {
                newCurrentRow = currentRow + delta;
              }
            }

            return newCurrentRow;
          }
        },
        __name: "CurrentRowVMCommand",

        /** @type String */
        _actionName: null,

        /** @type {number} */
        _currentRowToValidate: -1,

        /** @type {boolean} */
        _ctrlKey: false,

        /** @type {boolean} */
        _shiftKey: false,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {string} actionName - actionName used to change current row
         * @param {boolean} [ctrlKey] - ctrlKey pressed during command creation
         * @param {boolean} [shiftKey] - shiftKey pressed during command creation
         */
        constructor: function(app, node, actionName, ctrlKey, shiftKey) {
          $super.constructor.call(this, app, node);
          this._actionName = actionName;
          this._ctrlKey = ctrlKey ? ctrlKey : false;
          this._shiftKey = shiftKey ? shiftKey : false;

          this._needsVmSync = true;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const oldCurrentRow = this._node.attribute("currentRow");
          const dialogType = this._node.attribute('dialogType');
          const canAddExtraRow = this._node.getTag() === "Table" && !(dialogType === "Display" || dialogType === "DisplayArray");

          const newCurrentRow = cls.CurrentRowVMCommand.computeNewRowFromAction(this._node, this._actionName, this._node.attribute(
            "currentRow"), canAddExtraRow);
          if (newCurrentRow !== null && (oldCurrentRow !== newCurrentRow)) {
            this._currentRowToValidate = newCurrentRow;
            const events = [];
            // if mrs and one modifier is pressed, we must not send ActionEvent but ConfigureEvent with currentRow
            const forceConfigureEvent = (this._ctrlKey || this._shiftKey) && (this._node.attribute('multiRowSelection') !== 0);
            const actionNode = this._app.action.getAction(this._actionName);
            if (actionNode && !forceConfigureEvent) {
              events.push(new cls.VMActionEvent(actionNode.getId()));
            } else {
              events.push(new cls.VMConfigureEvent(this._node.getId(), {
                currentRow: newCurrentRow
              }));
            }

            // Paged ScrollGrids need to compute the offset in the client to keep it in sync properly
            const scrollGridNode = this._node.getTag() === "ScrollGrid" ? this._node : null;
            if (scrollGridNode && scrollGridNode.getController().isPagedScrollGrid()) {
              let offset = scrollGridNode.attribute('offset');
              const pageSize = scrollGridNode.attribute('pageSize');
              const size = scrollGridNode.attribute('pageSize');
              if (newCurrentRow < offset || newCurrentRow >= offset + pageSize || newCurrentRow > size - pageSize) {
                offset = Math.floor(newCurrentRow / pageSize) * pageSize;
                events.push(new cls.VMConfigureEvent(this._node.getId(), {
                  offset: offset
                }));
              }
            }
            this._vmEvents = events;
          }
          return this._vmEvents && this._vmEvents.length > 0;
        },

        /**
         * @inheritDoc
         */
        validate: function() {
          const currentRow = this._node.attribute('currentRow');
          return this._currentRowToValidate === currentRow;
        },

        /**
         * @returns {classes.NodeBase} the node to be focused
         */
        getNode: function() {
          return this._node;
        },

      };
    });
  }
);
;

"use strict";

modulum('CursorsVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Cursors VM command
     * This class updates the cursors of a widget
     * @class CursorsVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.CursorsVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.CursorsVMCommand.prototype */ {
        __name: "CursorsVMCommand",

        /** @type {?number} */
        _cursor: null,
        /** @type {?number} */
        _cursor2: null,
        /** @type {number} */
        _valueLength: 0,
        /** @type {boolean} */
        _canBeExecuted: true,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node - target node
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} [cursor2] - current ending cursor of the node
         * @param {number} valueLength - node value length
         * @param {boolean} [canBeExecuted] - true if the current command can be executed, false otherwise
         */
        constructor: function(app, node, cursor1, cursor2, valueLength, canBeExecuted) {
          $super.constructor.call(this, app, node);
          this._cursor = cursor1;
          if (cursor2 !== undefined) {
            this._cursor2 = cursor2;
          }
          if (valueLength !== undefined) {
            this._valueLength = valueLength;
          }
          this._canBeExecuted = canBeExecuted;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const ctrl = this._node.getController();
          let event = null;
          if (ctrl) {
            const node = this._node.isInTable() || this._node.isInMatrix() ? this._node.getParentNode().getParentNode() : this._node;
            let vmCursor = node.attribute('cursor');
            if (vmCursor === -1) {
              vmCursor = this._valueLength;
            }
            let vmCursor2 = node.attribute('cursor2');
            if (vmCursor2 === -1) {
              vmCursor2 = this._valueLength;
            }
            const cursorData = {};
            let hasData = false;
            // Sending only modified cursors to the VM.
            if (vmCursor !== this._cursor) {
              cursorData.cursor = this._cursor;
              hasData = true;
            }
            if (hasData || (this._cursor2 !== null && vmCursor2 !== this._cursor2)) {
              cursorData.cursor2 = this._cursor2;
              hasData = true;
            }
            if (hasData) {
              event = new cls.VMConfigureEvent(node.getId(), cursorData);
              this._vmEvents = [event];
            }
          }
          return this._vmEvents && this._vmEvents.length > 0;
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          return this._canBeExecuted;
        }
      };
    });
  }
);
;

"use strict";

modulum('EventVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Event VM command.
     * This class sends an event to the VM.
     * @class EventVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.EventVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.EventVMCommand.prototype */ {
        __name: "EventVMCommand",

        /** @type {classes.VMEventBase} */
        _event: null,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.VMEventBase} event to execute
         * @param {classes.NodeBase} [node] optional used only to check integrity of event
         */
        constructor: function(app, event, node) {
          $super.constructor.call(this, app, node);
          this._event = event;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          if (this._event) {
            this._vmEvents = [this._event];
          }
          return this._vmEvents && this._vmEvents.length > 0;
        },

        /**
         * @inheritDoc
         */
        needsVmSync: function() {
          return this._needsVmSync || (this._event instanceof cls.VMActionEvent || this._event instanceof cls.VMKeyEvent || this
            ._event instanceof cls
            .VMFunctionCallEvent);
        },

      };
    });
  }
);
;

"use strict";

modulum('FocusVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Focus VM comand.
     * @class FocusVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.FocusVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.FocusVMCommand.prototype */ {
        __name: "FocusVMCommand",

        /** @type {number} */
        _cursor: 0,
        /** @type {number} */
        _cursor2: 0,

        /** @type {number} */
        _currentRowToValidate: -1,
        /** @type {number} */
        _currentColumnToValidate: -1,
        /** @type {number} */
        _rowIndex: -1,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node that should have the focus
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} cursor2 - current ending cursor of the node
         * @param {number} rowIndex - hint for row index requested by the focus
         */
        constructor: function(app, node, cursor1, cursor2, rowIndex) {
          $super.constructor.call(this, app, node);
          this._cursor = cursor1 || 0;
          this._cursor2 = cursor2 || 0;
          this._rowIndex = rowIndex;

          this._needsVmSync = true;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const controller = this._node.getController();
          let events = [];
          if (controller) {
            if (this._node.isInTable()) {
              events = this._requestTableCellFocus();
            } else if (this._node.isInMatrix() || this._node.isInScrollGrid()) {
              // if in scrollgrid we should have matrix as direct childs except for static image which are direct child of scrollgrid
              events = this._requestMatrixCellFocus();
            } else if (this._node.getTag() === "Table") {
              events = this._requestTableFocus();
            } else if (this._node.getTag() === "ScrollGrid") {
              events = this._requestScrollGridFocus();
            } else {
              events = this._requestFieldFocus();
            }
          }

          this._vmEvents = events;
          return this._vmEvents.length > 0;
        },

        /**
         * @inheritDoc
         */
        validate: function() {
          const controller = this._node.getController();
          if (!controller) { // controller may be null if it has been destroyed during process
            return false;
          }
          if (this._node.isInTable()) {
            return this._validateTableCellFocus();
          } else if (this._node.isInMatrix() || this._node.isInScrollGrid()) {
            return this._validateMatrixCellFocus();
          } else if (this._node.getTag() === "ScrollGrid") {
            return this._validateScrollGridFocus();
          } else {
            return this._validateFocus();
          }
        },

        /**
         * Request focus on a form field
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestFieldFocus: function() {
          if (this._node.attribute('active') === 0) {
            // Do not request any focus if not active to not cancel selection of text during this operation (needed to CTRL-C)
            // https://agile.strasbourg.4js.com/jira/browse/GBC-669
            return [];
          }
          const ui = this._app.uiNode();

          if (ui.attribute('focus') !== this._node.getId()) {
            // special for webcomp
            const originWidgetNode = this._app.getFocusedVMNode();
            const originWidgetController = originWidgetNode.getController();
            const originWidget = originWidgetController.getWidget();
            if (originWidget && originWidget.flushWebcomponentData) {
              originWidget.flushWebcomponentData();
            }

            const event = new cls.VMConfigureEvent(this._node.getId(), {
              cursor: this._cursor,
              cursor2: this._cursor2
            });
            return [event];
          }
          return [];
        },

        /**
         * Requests the focus on a Table
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestTableFocus: function() {
          const tableNode = this._node;

          // if table is not active or if it has already the focus
          if (tableNode.attribute('active') === 0 || this._app.getFocusedVMNode() === tableNode) {
            return []; // Nothing to do
          }

          // ask focus for first active table column index sorted by tabindex
          let columnIndex = 0;
          const columnNodes = tableNode.getTabIndexSortedChildren('TableColumn');
          for (const col of columnNodes) {
            if (col.attribute('noEntry') === 0 && col.attribute('active') === 1) {
              columnIndex = col.getIndex("TableColumn");
              break;
            }
          }
          const rowIndex = tableNode.attribute("currentRow");

          const event = new cls.VMConfigureEvent(tableNode.getId(), {
            currentColumn: columnIndex,
            currentRow: rowIndex
          });

          return [event];
        },

        /**
         * Requests the focus on a Scrollgrid
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestScrollGridFocus: function() {
          const scrollGridNode = this._node;
          let currentRow = this._rowIndex;
          const vmCurrentRow = scrollGridNode.attribute('currentRow');

          if (currentRow === -1) {
            currentRow = scrollGridNode.getController().getCurrentRow();
          }
          const offset = scrollGridNode.getController().getOffset();
          currentRow = currentRow + offset;
          this._currentRowToValidate = currentRow;

          if (scrollGridNode.attribute('active') === 0) {
            // Restore the focus to its previous location
            return [];
          }
          if (currentRow !== vmCurrentRow || !scrollGridNode.hasVMFocus()) {
            let eventData = {
              currentRow: currentRow,
            };

            let events = [];
            events.push(new cls.VMConfigureEvent(scrollGridNode.getId(), eventData));
            return events;
          }
          return [];
        },

        /**
         * Request focus on a matrix field
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestMatrixCellFocus: function() {
          const containerNode = this._node.isInMatrix() ? this._node.getAncestor("Matrix") : this._node.getAncestor("ScrollGrid");
          const ui = this._app.uiNode();
          // try to retrieve index of node from rowIndex if specified, or using generic method otherwise
          const valueNodeIndex = this._rowIndex > -1 ? this._rowIndex : this._node.getIndex();
          const offset = containerNode.attribute('offset');
          const vmCurrentRow = containerNode.attribute('currentRow');
          const currentRow = valueNodeIndex + offset;
          const isSameCurrentRow = currentRow === vmCurrentRow;

          const dialogType = containerNode.attribute('dialogType');
          // if no dialogtype, then we miss Matrix parent and may be a direct child of ScrollGrid. We consider we are in display.
          const displayDialog = !dialogType || dialogType === "Display" || dialogType === "DisplayArray";

          this._currentRowToValidate = currentRow;
          const scrollGridNode = this._node.getAncestor("ScrollGrid");
          const isPagedScrollGrid = scrollGridNode && scrollGridNode.getController().isPagedScrollGrid();

          if (containerNode.attribute('active') === 0) {
            // Restore the focus to its previous location
            return [];
          }
          if (ui.attribute('focus') !== containerNode.getId() || !isSameCurrentRow) {
            const eventData = {
              currentRow: currentRow,
            };
            if (!displayDialog) {
              eventData.cursor = this._cursor;
              eventData.cursor2 = this._cursor2;
            }

            const events = [];
            events.push(new cls.VMConfigureEvent(containerNode.getId(), eventData));
            if (isPagedScrollGrid) {
              events.push(new cls.VMConfigureEvent(containerNode.getId(), {
                offset: offset
              }));
            }
            return events;
          }
          return [];
        },

        /**
         * Request focus on a table cell
         * @returns {classes.VMEventBase[]} the event to send to the VM.
         * @private
         */
        _requestTableCellFocus: function() {
          const containerNode = this._node.getParentNode().getParentNode();
          const tableNode = containerNode.getParentNode();
          const ui = this._app.uiNode();

          const eventParams = {};
          const valueNodeIndex = this._node.getIndex();
          const offset = tableNode.attribute('offset');
          eventParams.currentRow = valueNodeIndex + offset;

          this._currentRowToValidate = eventParams.currentRow;

          let needFocus = ui.attribute('focus') !== tableNode.getId() ||
            eventParams.currentRow !== tableNode.attribute('currentRow');

          const dialogType = containerNode.attribute('dialogType');
          const displayDialog = dialogType === "Display" || dialogType === "DisplayArray";
          const isActiveColumn = (containerNode.attribute('active') === 1);

          const focusOnField = tableNode.attribute('focusOnField') === 1;
          if (!displayDialog || focusOnField) { // Input, InputArray, Construct or FocusOnField attribute set
            eventParams.currentColumn = containerNode.getIndex('TableColumn');
            needFocus = needFocus || !tableNode.isAttributeSetByVM('currentColumn') || eventParams.currentColumn !== tableNode
              .attribute(
                'currentColumn');
            if (isActiveColumn) { // we check column on validation only if column is active
              this._currentColumnToValidate = eventParams.currentColumn;
            }
          }

          if (needFocus) {
            const event = new cls.VMConfigureEvent(tableNode.getId(), eventParams);
            let events = [event];
            if (!displayDialog) {
              const event2 = new cls.VMConfigureEvent(containerNode.getId(), {
                cursor: this._cursor,
                cursor2: this._cursor2
              });
              events = events.concat(event2);
            }
            return events;
          }
          return [];
        },

        /**
         * Checks that the appropriate scrollgrid line has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateScrollGridFocus: function() {
          const currentRow = this._node.attribute('currentRow');
          return this._currentRowToValidate === currentRow;
        },

        /**
         * Checks that the appropriate matrix cell has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateMatrixCellFocus: function() {
          const containerNode = this._node.isInMatrix() ? this._node.getAncestor("Matrix") : this._node.getAncestor("ScrollGrid");
          const ui = this._app.uiNode();
          const dialogType = containerNode.attribute('dialogType');
          // if no dialogtype, then we miss Matrix parent and may be a direct child of ScrollGrid. We consider we are in display.
          const displayDialog = !dialogType || dialogType === "Display" || dialogType === "DisplayArray";

          // validate focused column only in input/input array mode
          if (!displayDialog && ui.attribute("focus") !== containerNode.getId()) {
            return false;
          }

          const currentRow = containerNode.attribute('currentRow');
          return (this._currentRowToValidate === currentRow);
        },

        /**
         * Checks that the appropriate table cell has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateTableCellFocus: function() {
          const containerNode = this._node.getParentNode().getParentNode();
          const tableNode = containerNode.getParentNode();

          const ui = this._app.uiNode();
          if (ui.attribute("focus") !== tableNode.getId()) {
            return false;
          }

          const currentRow = tableNode.attribute('currentRow');

          let valid = (this._currentRowToValidate === currentRow);

          if (this._currentColumnToValidate >= 0) {
            const currentColumn = tableNode.attribute('currentColumn');
            valid = valid && (this._currentColumnToValidate === currentColumn);
          }

          return valid;
        },

        /**
         * Checks that the appropriate widget has the focus
         * @returns {boolean} true if the focus is set properly, false otherwise
         * @private
         */
        _validateFocus: function() {
          const ui = this._app.uiNode();
          return ui.attribute("focus") === this._node.getId();
        },

      };
    });
  }
);
;

"use strict";

modulum('FunctionCallResultVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * FunctionCallResult VM event command
     * @class FunctionCallResultVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.FunctionCallResultVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.FunctionCallResultVMCommand.prototype */ {
        __name: "FunctionCallResultVMCommand",

        _status: null,
        _message: null,
        _values: null,

        /**
         * @param app {classes.VMApplication} app owner
         * @param status front call result status
         * @param message front call result status message
         * @param values front call result values
         */
        constructor: function(app, status, message, values) {
          $super.constructor.call(this, app, null);
          this._status = status;
          this._message = message;
          this._values = values;
          this._needsVmSync = true;
          this._executeImmediately = true;
          // Got the function call result, so functioncall is not processing anymore
          context.FrontCallService.setFunctionCallProcessing(false);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const event = new cls.VMFunctionCallEvent(this._status, this._message, this._values);
          this._vmEvents = [event];
          return true;
        }
      };
    });
  }
);
;

"use strict";

modulum('PageSizeVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * PageSize VM command.
     * @class PageSizeVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.PageSizeVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.PageSizeVMCommand.prototype */ {
        __name: "PageSizeVMCommand",

        /** @type number */
        _pageSize: 0,
        /** @type number */
        _bufferSize: 0,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node scroll target
         * @param {number} pageSize new pageSize
         * @param {number} bufferSize new bufferSize
         */
        constructor: function(app, node, pageSize, bufferSize) {
          $super.constructor.call(this, app, node);
          this._pageSize = pageSize;
          this._bufferSize = bufferSize;
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const pageSize = this._node.attribute('pageSize');
          const bufferSize = this._node.attribute('bufferSize');

          if (pageSize !== this._pageSize || bufferSize !== this._bufferSize) {
            const event = new cls.VMConfigureEvent(this._node.getId(), {
              pageSize: this._pageSize,
              bufferSize: this._bufferSize
            });

            this._vmEvents = [event];
          }

          return this._vmEvents && this._vmEvents.length > 0;
        },

      };
    });
  }
);
;

"use strict";

modulum('RowSelectionVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * RowSelection VM command.
     * @class RowSelectionVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.RowSelectionVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.RowSelectionVMCommand.prototype */ {
        __name: "RowSelectionVMCommand",

        $static: /** @lends classes.RowSelectionVMCommand */ {
          currentRow: 1,
          toggle: 2,
          selectAll: 3,
        },

        /** @type boolean */
        _ctrlKey: false,

        /** @type boolean */
        _shiftKey: false,

        /** @type number */
        _type: 1,

        /** @type String */
        _actionName: null,

        /**
         *
         * @param {classes.VMApplication} app owner
         * @param {classes.TableNode} node
         * @param {boolean} ctrlKey - ctrl key pressed
         * @param {boolean} shiftKey - shift key pressed
         * @param {number} type - type of row selection (currentRow, toggle, selectAll)
         * @param {string} [actionName] - actionName used to change current row
         */
        constructor: function(app, node, ctrlKey, shiftKey, type, actionName) {
          $super.constructor.call(this, app, node);
          this._ctrlKey = ctrlKey;
          this._shiftKey = shiftKey;
          this._type = type;
          this._actionName = actionName ? actionName : null;
        },

        /**
         * Build row selection event
         * @param {number} row - base row to compute selection
         * @returns {classes.VMRowSelectionEvent} row selection event
         */
        buildRowSelectionEvent: function(row) {

          const controller = this._node.getController();
          let startIndex = row;
          let endIndex = row;
          let mode = "set";

          if (this._shiftKey) {
            if (controller.multiRowSelectionRoot === -1) {
              controller.multiRowSelectionRoot = this._node.attribute('currentRow');
            }

            startIndex = controller.multiRowSelectionRoot;
            endIndex = row;
            mode = this._ctrlKey ? "exset" : "set";

            controller.updateMultiRowSelectionRoot = false;
          } else if (this._ctrlKey) {
            const children = this._node.getChildren();
            const rowInfoListNode = children[children.length - 1];
            const rowInfoNode = rowInfoListNode.getChildren()[row - this._node.attribute('offset')];

            mode = rowInfoNode && rowInfoNode.attribute('selected') === 1 ? "unset" : "exset";
          }

          return new cls.VMRowSelectionEvent(this._node.getId(), {
            startIndex: startIndex,
            endIndex: endIndex,
            selectionMode: mode
          });
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const events = [];

          if (this._type === cls.RowSelectionVMCommand.currentRow && this._actionName) {
            const newCurrentRow = cls.CurrentRowVMCommand.computeNewRowFromAction(this._node, this._actionName, this._node.attribute(
              "currentRow"), false);
            events.push(this.buildRowSelectionEvent(newCurrentRow));
          } else if (this._type === cls.RowSelectionVMCommand.toggle) { // toggle selection of currentRow
            events.push(this.buildRowSelectionEvent(this._node.attribute("currentRow")));
          } else if (this._type === cls.RowSelectionVMCommand.selectAll) { // select all
            events.push(new cls.VMRowSelectionEvent(this._node.getId(), {
              startIndex: 0,
              endIndex: this._node.attribute('size') - 1,
              selectionMode: "set"
            }));
          }
          this._vmEvents = events;
          return this._vmEvents.length > 0;
        }
      };
    });
  }
);
;

"use strict";

modulum('ScrollVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Scroll VM command.
     * @class ScrollVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.ScrollVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.ScrollVMCommand.prototype */ {
        __name: "ScrollVMCommand",

        /** @type number */
        _offset: 0,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node scroll target
         * @param {number} offset new scroll offset
         */
        constructor: function(app, node, offset) {
          $super.constructor.call(this, app, node);
          this._offset = offset;
          this._needsVmSync = true;
        },

        /**
         * @inheritDoc
         */
        needsRefreshLayout: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        execute: function() {

          const vmOffset = this._node.attribute("offset");

          if (this._offset !== vmOffset) {
            const event = new cls.VMConfigureEvent(this._node.getId(), {
              offset: this._offset
            });
            this._vmEvents = [event];
          }
          return this._vmEvents && this._vmEvents.length > 0;
        },

        /**
         * @inheritDoc
         */
        merge: function(command) {
          if (command instanceof cls.ScrollVMCommand) {
            if (command._node === this._node) {
              this._offset = command._offset;
              return true;
            }
          }
          return false;
        }
      };
    });
  }
);
;

"use strict";

modulum('ValueVMCommand', ['CommandVMBase'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Value VM command
     * This class updates the value of a widget
     * @class ValueVMCommand
     * @memberOf classes
     * @extends classes.CommandVMBase
     */
    cls.ValueVMCommand = context.oo.Class(cls.CommandVMBase, function($super) {
      return /** @lends classes.ValueVMCommand.prototype */ {
        __name: "ValueVMCommand",

        /** @type {?string} */
        _newValue: null,
        /** @type {boolean} */
        _canBeExecuted: true,

        /**
         * @param {classes.VMApplication} app owner
         * @param {classes.NodeBase} node - target node
         * @param {string} newValue - current value of the node
         * @param {boolean} [canBeExecuted] - true if the current command can be executed, false otherwise
         * @param {boolean} [vmSync] - by default value command requires a VM sync meaning generated command won't be merged with another command
         */
        constructor: function(app, node, newValue, canBeExecuted, vmSync = true) {
          $super.constructor.call(this, app, node);
          this._newValue = newValue;
          this._canBeExecuted = canBeExecuted;
          this._needsVmSync = vmSync;
        },

        /**
         * @inheritDoc
         */
        checkIntegrity: function() {
          let ok = false;

          // check integrity
          if (this._node && this._node.getController()) {

            // if value has not changed, no need to check focusVMNode for integrity
            if (!this._hasValueChanged(this._node.getController())) {
              return $super.checkIntegrity.call(this);
            }

            const focusedVMNode = this._app.getFocusedVMNode();

            // integrity is ok if:
            // value node is in the focused table
            ok = (this._node.getAncestor("Table") === focusedVMNode);
            // value node is in the focused matrix
            ok = ok || (this._node.getAncestor("Matrix") === focusedVMNode);
            // value node is in a webcomponent (this a special case because value can be sent even if webcomponent has the focus, specially when it is not active
            ok = ok || (this._node.getController() instanceof cls.WebComponentController);
            // In the case of richtext widget, it's a webcomponent and must be considered as previous case
            ok = ok || (this._node.getWidget().isInstanceOf(cls.WebComponentWidget));
            // or if value node is the focused one
            ok = ok || (focusedVMNode === this._node);
          }

          return ok && $super.checkIntegrity.call(this);
        },

        /**
         * @inheritDoc
         */
        execute: function() {
          const ctrl = this._node.getController();

          if (ctrl) {
            if (this._hasValueChanged(ctrl)) {

              if (this._isValueNode) {
                const tableNode = this._node.getAncestor("Table");
                // if we send a value in a table, update table cached data model with this new value
                if (tableNode) {
                  const tableWidgetBase = /** @type classes.TableWidgetBase */ tableNode.getWidget();
                  const tableCachedDataModel = tableWidgetBase.getCachedDataModel();
                  if (tableCachedDataModel) {
                    tableCachedDataModel.updateDataFromValueNode( /** @type classes.ValueNode */ this._node, "value", this._newValue);
                  }
                }
              }

              const valueObj = {
                value: this._newValue,
              };
              const event = new cls.VMConfigureEvent(this._node.getId(), valueObj);
              this._vmEvents = [event];
            }
          }
          return this._vmEvents && this._vmEvents.length > 0;
        },

        /**
         * Checks if the value has changed
         * @returns {boolean} true if the value has changed, false otherwise
         * @private
         */
        _hasValueChanged: function(controller) {
          return this._newValue !== controller.getAuiValue();
        },

        /**
         * @inheritDoc
         */
        canBeExecuted: function() {
          return this._canBeExecuted;
        },

      };
    });
  }
);
;

"use strict";

modulum('SchedulerApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Scheduler service.
     * This class is in charge of keeping track of the commands.
     * Stack commands, schedule their execution on the server
     * Manages client side life cycle representation of the node.
     * @class SchedulerApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.SchedulerApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.SchedulerApplicationService.prototype */ {
        __name: "SchedulerApplicationService",

        /** @type {classes.CommandBase[]} **/
        _commandsQueue: null,
        /** @type {classes.CommandBase[]} */
        _failedCommandsQueue: null,
        /** @type {classes.CommandBase[]} **/
        /* commands being converted and send as VM event to VM  */
        _processingCommands: null,
        /** @type {classes.CommandBase[]} */
        _commandsWhileFrontCallQueue: null,
        /** @type {number} */
        _lastCommandTime: 0,
        /** @type {boolean} */
        _isInNextCommandLoop: false,

        /** @type {classes.GroupCommand[]} */
        _currentGroupCommandQueue: null,

        /** @type {classes.LayoutCommand} */
        _layoutCommand: null,
        /** @type {classes.RestoreFocusCommand} */
        _restoreFocusCommand: null,

        /**
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._commandsQueue = [];
          this._failedCommandsQueue = [];
          this._commandsWhileFrontCallQueue = [];
          this._processingCommands = [];
          this._currentGroupCommandQueue = [];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
          this._processingCommands = [];
          this._commandsQueue = [];
          this._failedCommandsQueue = [];
          this._commandsWhileFrontCallQueue = [];
          this._currentGroupCommandQueue = [];
          this._layoutCommand = null;
          this._restoreFocusCommand = null;
        },

        /**
         * Returns true if the scheduler has command which are executed but not yet validated
         * @returns {boolean}
         */
        hasProcessingCommands: function() {
          return this._processingCommands.length !== 0;
        },

        /**
         * Returns true if the scheduler has finished to process all post treatment commands
         * - Execute layout command
         * - Restore Focus command
         * @returns {boolean}
         */
        hasPostTreatmentCommands: function() {
          return this._restoreFocusCommand !== null || this._layoutCommand !== null;
        },

        /**
         * Empty commands in the queue
         */
        emptyCommandsQueue: function() {
          if (this._commandsQueue.length > 0 || this._commandsWhileFrontCallQueue.length > 0) {
            context.LogService.scheduler.warn("Empty commands queue.");
            this._commandsQueue.length = 0;
            this._commandsWhileFrontCallQueue.length = 0;
          }
        },

        /**
         * Returns true if the scheduler has finished to process the command queue.
         * **The command queue don't include the post treatment commands**
         * @returns {boolean}
         */
        hasNoCommandToProcess: function() {
          return !this.hasProcessingCommands() && !this.hasPendingCommands();
        },

        /**
         * Returns true if the scheduler has finished to process all commands. 
         * **Post treatment included**
         * @returns {boolean}
         */
        hasNothingToProcess: function() {
          return !this.hasNoCommandToProcess() && !this.hasPostTreatmentCommands();
        },

        /**
         * Add a command in the scheduler list
         * @param {classes.CommandBase} cmd new command to add to the list
         * @param {boolean} execute if true execute the next command
         * @param {boolean} topOfQueue if true insert the command at the beginning of the queue. Otherwise, by default it's pushed at the end.
         * @private
         */
        _addCommand: function(cmd, execute = true, topOfQueue = false) {
          if (!this._application) {
            return null;
          }
          context.LogService.scheduler.log("[app" + this._application.applicationHash + "] " + cmd.__name + " command added",
            cmd);

          if (this._currentGroupCommandQueue.length > 0) { // if there is a current group command is added to this group
            this._currentGroupCommandQueue[this._currentGroupCommandQueue.length - 1].addCommand(cmd);
          } else {
            // if only one command of this type must be added, and there is already an existing command --> do nothing
            if (cmd.isUnique() && this.hasPendingCommands(cmd.__name)) {
              return null;
            }

            // If a FrontCall is processing, queue it in a special buffer
            if (context.FrontCallService.functionCallIsProcessing()) {
              this._commandsWhileFrontCallQueue.push(cmd);
            } else {
              if (topOfQueue) {
                this._commandsQueue.unshift(cmd);
              } else {
                this._commandsQueue.push(cmd);
              }
            }

            if (execute) {
              this._start(cmd);
            }
          }
          return cmd;
        },

        /**
         * @private
         */
        _initFullQueue() {
          let finalCommandsList = this._commandsQueue.slice();
          for (const failedCmd of this._failedCommandsQueue) {
            /*
             * If the command is unique and already in the command list (that means it was called again).
             * We don't use failed command, so it reset the attempt counter
             */
            if (!(failedCmd.isUnique() && (finalCommandsList.findIndex((cmdInList) => failedCmd.__name === cmdInList.__name) !== -1))) {
              finalCommandsList.push(failedCmd);
            }
          }
          this._failedCommandsQueue = [];

          finalCommandsList = finalCommandsList.concat(this._commandsWhileFrontCallQueue);
          this._commandsWhileFrontCallQueue = [];

          return finalCommandsList;
        },

        /**
         * Store failed command if the run attempt is under the maximum limit
         * @param {BaseCommand} cmd The Command to store
         * @private
         */
        _handleFailedCommand(cmd) {
          if (cmd.retryIfFailed() && cmd.getRunAttempts() < cmd.getMaxRunAttempts()) {
            this._failedCommandsQueue.push(cmd);
          }
        },

        /**
         * Starts scheduler
         * @param {classes.CommandBase} cmd new command just added in the list
         * @private
         */
        _start: function(cmd = null) {
          if (!this._isInNextCommandLoop) { // no need to start if it is already running
            this.emit(context.constants.schedulerEvents.commandProcessStarted);
            if (cmd === null || cmd.executeImmediately()) {
              // if command is send immediately no other cmd can be added before
              this._executeNextCommand();
            } else {
              // we execute it in the next animation frame to permit to add more cmd
              window.setTimeout(() => {
                this._executeNextCommand();
              });
            }
          }
        },

        /**
         * Remove a command not yet executed
         * @param {classes.CommandBase} cmd command to be removed
         */
        _removeCommand: function(cmd) {
          this._commandsQueue.remove(cmd);
        },

        /**
         * Execute next command
         * @private
         */
        _executeNextCommand: function() {
          if (this._destroyed || !this._application) {
            // application doesn't exist anymore
            return;
          }

          const isFrontCallProcessing = context.FrontCallService.functionCallIsProcessing();
          if (isFrontCallProcessing) {
            context.LogService.scheduler.warn(
              "VM is waiting for a FrontCall response. Do not send another command vm event during that process. Waiting...");
          }
          const isProcessing = this.hasProcessingCommands() || this._application?.isProcessing() || isFrontCallProcessing;

          if (!isProcessing) { // if app is processing don't send any command
            this._commandsQueue = this._initFullQueue();

            let cmd = null;
            let events = [];

            let integrityOk = true;
            while (events.length === 0 && this._commandsQueue.length !== 0 && integrityOk) {
              this._isInNextCommandLoop = true;
              do {
                cmd = this._commandsQueue.shift();

                context.LogService.scheduler.log("Executing " + cmd.__name + " command", cmd);

                // Merge beginning commands of the FIFO into cmd;
                while (this._commandsQueue.length !== 0 && cmd.merge(this._commandsQueue[0])) {
                  this._commandsQueue.shift();
                }

                // before checkIntegrity & execute need to updateNode
                // because node can have changed between command creation and command execution
                let commandProcessed = false;
                const executeCommand = cmd.updateNode();
                if (executeCommand) {
                  integrityOk = cmd.checkIntegrity();
                  if (integrityOk) {

                    // save existing scheduler list
                    let savedCommandsQueue = this._commandsQueue.slice();
                    this._commandsQueue = [];

                    commandProcessed = cmd.execute();

                    // all the commands created during the command execution must be added at the beginning of commandsQueue
                    this._commandsQueue = this._commandsQueue.concat(savedCommandsQueue);
                    savedCommandsQueue = [];

                    if (!commandProcessed) {
                      context.LogService.scheduler.log("Popping unused " + cmd.__name + " command", cmd);
                    } else if (cmd.getVMEvents) { // cmd is a CommandVMBase
                      const vmEvents = cmd.getVMEvents();
                      if (vmEvents && vmEvents.length > 0) {
                        events = events.concat(vmEvents);
                        // if command generate vm events, add it to processingCommands list
                        this._processingCommands.push(cmd);
                      }
                    }
                  }
                } else {
                  context.LogService.scheduler.log("Poping outdated " + cmd.__name + " command", cmd);
                }

                if (!commandProcessed) {
                  /* If the integrity is already ok, keep it like that.
                   * If the integrity is not okay, set it to true if rerun failed is true.
                   * So it doesn't break the loop on a command that is okay to fail
                   */
                  integrityOk = integrityOk || cmd.retryIfFailed();
                  cmd.fail();
                }
                // End Executing cmd group

              } while (this._commandsQueue.length !== 0 && !cmd.needsVmSync() && integrityOk);
            }

            this._isInNextCommandLoop = false;

            if (integrityOk === false) {
              context.LogService.scheduler.warn("Command integrity error", cmd);
              // if there is an integrity error in a command, don't execute it and stop to execute next queued commands which become invalid (but current commands being processed added before are still valid)
              this.emptyCommandsQueue();
            }

            // If there are events to send to VM
            if (events.length !== 0 && this._processingCommands.length !== 0) {
              this._lastCommandTime = this._processingCommands[this._processingCommands.length - 1].getTime();
              context.LogService.scheduler.log("Sending events to VM", events);
              // Send commands converted into events to VM
              this._application.protocolInterface.event(events);
            }
            // End execute next command group

          }

          // if there is nothing more to process, do nothing
          this._executePostTreatmentCommand();
          if (this.hasNoCommandToProcess()) {
            /**@todo : If the setTimeout of safari is removed, move the line :
             * this.emit(context.constants.schedulerEvents.commandProcessEnded);
             */
            return;
          }
        },

        _executePostTreatmentCommand() {
          // if there is nothing more to process, execute layout command
          if (this.hasNoCommandToProcess() && this._layoutCommand) {
            this._layoutCommand.execute();
            this._layoutCommand = null;
          }

          // Do this in a setTimeout because on Safari the element.focus doesn't work at the first display of a form
          // if you try to remove it, check GBC-1362 testcase at start focus must be in the first field
          const restoreFocusFunc = () => {
            // if there is nothing more to process, execute restoreFocus command
            if (this.hasNoCommandToProcess()) {
              if (this._restoreFocusCommand) {
                this._restoreFocusCommand.execute();
                this._restoreFocusCommand = null;
              }
              // Once the restore focus is done, we consider that the scheduler has ended the process
              this.emit(context.constants.schedulerEvents.commandProcessEnded);
            }
          };
          if (window.browserInfo.isSafari) {
            window.setTimeout(restoreFocusFunc, 100); // focus doesn't seem to work well if timeout <100ms for safari
          } else {
            restoreFocusFunc();
          }
        },

        /**
         * Validate the last commands send to the VM
         * This function is called each time we received a message from VM
         * @param {boolean} isNewTask - message send by VM is a new task (new app)
         */
        validateLastCommand: function(isNewTask = false) {

          if (isNewTask) {
            // no need to anything in this case juste empty the processing commands
            this._processingCommands = [];
            return;
          }

          let needsRefreshLayout = false;
          if (this._processingCommands.length !== 0) {
            let isLastCommandValidated = true;

            let cmd = null;
            const conflictFunc = function(command) {
              if (command instanceof cls.GroupCommand && command._commands && command._commands.length) {
                command._commands = command._commands.filter(conflictFunc);
              } else {
                return command.getNode() !== cmd._conflictNode;
              }
            };
            // validate each commands
            while (this._processingCommands.length > 0) {
              cmd = this._processingCommands.shift();
              needsRefreshLayout = needsRefreshLayout || cmd.needsRefreshLayout();
              if (isLastCommandValidated) {
                isLastCommandValidated = cmd.validate();
              }

              // check conflicts with pending commands
              // remove conflictNode commands from commandsQueue
              if (cmd._conflictNode) {
                this._commandsQueue = this._commandsQueue.filter(conflictFunc);
              }
            }

            context.LogService.scheduler.log("Command(s) validation OK", this._processingCommands);
            this.restoreFocusCommand(!isLastCommandValidated);

          } else {
            context.LogService.scheduler.log("No command to validate");
            needsRefreshLayout = true;
          }

          // require layout after each command validated
          this.layoutCommand({
            noLayout: !needsRefreshLayout
          });

          // try to send next commands
          this._executeNextCommand();
        },

        /**
         * Checks if the given node has pending VALUE command in the scheduler command list
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasPendingValueCommands: function(node = null) {
          for (const cmd of this._commandsQueue) {
            if (cmd instanceof cls.ValueVMCommand && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending VALUE command in the scheduler command list
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasPendingScrollCommands: function(node = null) {
          for (const cmd of this._commandsQueue) {
            if (cmd instanceof cls.ScrollVMCommand && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Returns true if processing commands queue contains at least one ScrollVMCommand
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        isProcessingScrollCommand: function(node = null) {
          for (const cmd of this._processingCommands) {
            if (cmd instanceof cls.ScrollVMCommand && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Returns true if there are some scroll commands in the commands queue or if a scroll command is processing
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasScrollCommandsToProcess(node = null) {
          return this.isProcessingScrollCommand(node) || this.hasPendingScrollCommands(node);
        },

        /**
         * Checks if the given node has pending FOCUS command in the scheduler command list
         * @param {classes.NodeBase} [node]
         * @returns {boolean}
         */
        hasPendingFocusCommands: function(node = null) {
          for (const cmd of this._commandsQueue) {
            if (cmd instanceof cls.FocusVMCommand && (!node || cmd.getNode() === node)) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending navigation command in the scheduler command list
         * @returns {boolean}
         */
        hasPendingNavigationCommands: function() {
          for (const cmd of this._commandsQueue) {
            if ((cmd instanceof cls.CurrentRowVMCommand || cmd instanceof cls.FocusVMCommand) && (cls.ActionNode
                .isTableNavigationAction(
                  cmd._actionName) || cls.ActionNode.isFieldNavigationAction(cmd._actionName))) {
              return true;
            }
          }
          return false;
        },

        /**
         * Checks if the given node has pending FunctionCallResult command in the scheduler command list
         * @param {boolean} [processing] - check also if there is a frontcall command in processing commands list
         * @returns {boolean}
         */
        hasPendingFunctionCallResultCommands: function(processing) {
          let i;
          let cmd;
          for (i = 0; i < this._commandsQueue.length; ++i) {
            cmd = this._commandsQueue[i];
            if (cmd instanceof cls.FunctionCallResultVMCommand) {
              return true;
            }
          }
          if (processing) {
            for (i = 0; i < this._processingCommands.length; ++i) {
              cmd = this._processingCommands[i];
              if (cmd instanceof cls.FunctionCallResultVMCommand) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * Checks if there are pending commands in the scheduler
         * @param {String} [classname] - class name of the command
         * @returns {boolean}
         */
        hasPendingCommands: function(classname) {
          if (!classname) {
            return this._commandsQueue.length > 0;
          } else {
            for (const cmd of this._commandsQueue) {
              if (cmd.__name === classname) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * @returns {number} the creation time of the last executed command
         */
        getLastCommandTime: function() {
          return this._lastCommandTime;
        },

        // ============== START - SPECIFIC COMMANDS ===================

        /**
         * Request focus on the given node
         * @param {classes.NodeBase} node - node which should get the focus
         * @param {number} [cursor1] - current starting cursor of the node
         * @param {number} [cursor2] - current ending cursor of the node
         * @param {number} [rowIndex] - hint for current row index requested
         */
        focusVMCommand: function(node, cursor1, cursor2, rowIndex) {
          return this._addCommand(new cls.FocusVMCommand(this.getApplication(), node, cursor1, cursor2, rowIndex));
        },

        /**
         * Send value on the given node
         * @param {classes.NodeBase} node - target node
         * @param {string} value - current value of the node
         * @param {boolean} [vmSync] - by default command value requires a VM sync
         */
        valueVMCommand: function(node, value, vmSync = true) {
          // If the value command is part of a GroupCommand, it's canBeExecuted should return false
          const canBeExecuted = this._currentGroupCommandQueue.length === 0;
          return this._addCommand(new cls.ValueVMCommand(this.getApplication(), node, value, canBeExecuted, vmSync));
        },

        /**
         * Send cursors of a given node
         * @param {classes.NodeBase} node - target node
         * @param {number} cursor1 - current starting cursor of the node
         * @param {number} cursor2 - current ending cursor of the node
         * @param {number} valueLength - node value length
         */
        cursorsVMCommand: function(node, cursor1, cursor2, valueLength) {
          // If the value command is part of a GroupCommand, it's canBeExecuted should return false
          const canBeExecuted = this._currentGroupCommandQueue.length === 0;
          return this._addCommand(new cls.CursorsVMCommand(this.getApplication(), node, cursor1, cursor2, valueLength, canBeExecuted));
        },

        /**
         * Send scroll change command. During a scroll
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {number} offset
         */
        scrollVMCommand: function(node, offset) {
          return this._addCommand(new cls.ScrollVMCommand(this.getApplication(), node, offset));
        },

        /**
         * Send pageSize change command.
         * @param {classes.TableNode} node
         * @param {number} pageSize
         * @param {number} bufferSize
         */
        pageSizeVMCommand: function(node, pageSize, bufferSize) {
          return this._addCommand(new cls.PageSizeVMCommand(this.getApplication(), node, pageSize, bufferSize));
        },

        /**
         * Send currentRow change command
         * @param {classes.TableNode|classes.MatrixNode} node
         * @param {string} actionName
         * @param {boolean} [ctrlKey] - ctrlKey pressed during command creation
         * @param {boolean} [shiftKey] - shiftKey pressed during command creation
         */
        currentRowVMCommand: function(node, actionName, ctrlKey, shiftKey) {
          return this._addCommand(new cls.CurrentRowVMCommand(this.getApplication(), node, actionName, ctrlKey, shiftKey));
        },

        /**
         * Send rowSelection change command
         * @param {classes.TableNode} node
         * @param {boolean} ctrlKey
         * @param {boolean} shiftKey
         * @param {number} type - type of row selection (merge, toggle, selectAll)
         * @param {string} [actionName] - actionName used to change current row
         */
        rowSelectionVMCommand: function(node, ctrlKey, shiftKey, type, actionName) {
          return this._addCommand(new cls.RowSelectionVMCommand(this.getApplication(), node, ctrlKey, shiftKey, type, actionName));
        },

        /**
         * Send action command
         * @param {classes.NodeBase} node
         * @param {Object} [options] - add options
         * @param {Boolean} [options.noUserActivity] - true if action is not from a user interaction
         * @param {String} [options.actionName] - action name instead of id
         */
        actionVMCommand: function(node, options = {}) {
          return this._addCommand(new cls.ActionVMCommand(this.getApplication(), node, options));
        },

        /**
         * Send a front call result
         * @param status front call result status
         * @param message front call result status message
         * @param values front call result values
         */
        functionCallResultVMCommand: function(status, message, values) {
          return this._addCommand(new cls.FunctionCallResultVMCommand(this.getApplication(), status, message, values), true, true);
        },

        /**
         * Send VM event command
         * @param {classes.VMEventBase} event
         * @param {classes.NodeBase} [node]
         * @param {boolean} [needsVmSync]
         */
        eventVMCommand: function(event, node, needsVmSync = false) {
          const cmd = new cls.EventVMCommand(this.getApplication(), event, node);
          cmd.setNeedsVmSync(needsVmSync);
          return this._addCommand(cmd);
        },

        /**
         * Send layout command.
         * @param {Object} opts
         */
        layoutCommand: function(opts = {}) {
          if (this._application) {
            const cmd = new cls.LayoutCommand(this.getApplication(), opts);
            context.LogService.scheduler.log("[app" + this._application.applicationHash + "] " + cmd.__name + " command set",
              cmd);
            if (this._layoutCommand === null) {
              this._layoutCommand = cmd;
            } else {
              this._layoutCommand.merge(cmd);
            }
            this._start(cmd);
            return cmd;
          }
          return null;
        },

        /**
         * Send restore focus command.
         */
        restoreFocusCommand: function(restoreDOMFocus) {
          if (this._application) {
            const cmd = new cls.RestoreFocusCommand(this.getApplication(), restoreDOMFocus);
            context.LogService.scheduler.log("[app" + this._application.applicationHash + "] " + cmd.__name + " command set",
              cmd);
            if (this._restoreFocusCommand === null) {
              this._restoreFocusCommand = cmd;
            } else {
              this._restoreFocusCommand.merge(cmd);
            }
            this._start(cmd);
            return cmd;
          }
          return null;
        },

        /**
         * Add a delayedKey command
         * @param {String} keyString string corresponding to the key
         * @param {Event} keyEvent
         */
        delayedKeyCommand: function(keyString, keyEvent) {
          return this._addCommand(new cls.DelayedKeyCommand(this.getApplication(), keyString, keyEvent));
        },

        /**
         * Add a delayedMouseClick command
         * @param {classes.WidgetBase} widget - widget where we must replay the event
         * @param {Event} mouseEvent
         */
        delayedMouseClickCommand: function(widget, mouseEvent) {
          return this._addCommand(new cls.DelayedMouseClickCommand(this.getApplication(), widget, mouseEvent));
        },

        /**
         * Add an open drop down command
         * @param {classes.NodeBase} node
         */
        openDropDownCommand: function(node) {
          return this._addCommand(new cls.OpenDropDownCommand(this.getApplication(), node));
        },

        /**
         * Add a native back command
         * @param {String[]} actionList list of actions
         */
        nativeBackCommand: function(actionList) {
          return this._addCommand(new cls.NativeBackCommand(this.getApplication(), actionList));
        },

        /**
         * Add a clipboard command for paste
         * @param {String} textToPaste text to paste
         * @param {classes.WidgetBase} widget
         */
        clipboardPasteCommand: function(textToPaste, widget) {
          return this._addCommand(new cls.ClipboardPasteCommand(this.getApplication(), textToPaste, widget));
        },

        /**
         * Add a clipboard command for cut
         * @param {Selection} selection selection to cut
         * @param {classes.WidgetBase} widget
         */
        clipboardCutCommand: function(selection, widget) {
          return this._addCommand(new cls.ClipboardCutCommand(this.getApplication(), selection, widget));
        },

        /**
         * Add a native close command
         */
        nativeCloseCommand: function() {
          return this._addCommand(new cls.NativeCloseCommand(this.getApplication()));
        },

        /**
         * Add a native notificationpushed command
         */
        nativeNotificationPushedCommand: function() {
          return this._addCommand(new cls.NativeNotificationPushedCommand(this.getApplication()));
        },

        /**
         * Add a native notificationselected command
         */
        nativeNotificationSelectedCommand: function() {
          return this._addCommand(new cls.NativeNotificationSelectedCommand(this.getApplication()));
        },

        /**
         * Add a enterbackground command
         */
        enterBackgroundCommand: function() {
          return this._addCommand(new cls.EnterBackgroundCommand(this.getApplication()));
        },

        /**
         * Add a enterforeground command
         */
        enterForegroundCommand: function() {
          return this._addCommand(new cls.EnterForegroundCommand(this.getApplication()));
        },

        /**
         * Add a native cordovacallback command
         */
        nativeCordovaCallbackCommand: function() {
          return this._addCommand(new cls.NativeCordovaCallbackCommand(this.getApplication()));
        },

        /**
         * Add a callback command
         * @param {function} callback - function to call when command is executed
         * @return {classes.CallbackCommand} callback command created
         */
        callbackCommand: function(callback) {
          return this._addCommand(new cls.CallbackCommand(this.getApplication(), callback));
        },

        /** Start group command.
         *  all commands added between call of startGroupCommand() and finishGroupCommand()
         *  will be added in a group command.
         */
        startGroupCommand: function() {
          const groupCommand = new cls.GroupCommand(this.getApplication(), [], null);
          this._currentGroupCommandQueue.push(groupCommand);
          context.LogService.scheduler.log("[app" + this._application.applicationHash + "] Start command group", groupCommand);
          return groupCommand;
        },

        /** Finish group command and add it in the scheduler queue.
         */
        finishGroupCommand: function() {
          const groupCommand = this._currentGroupCommandQueue.pop();
          context.LogService.scheduler.log("[app" + this._application.applicationHash + "] Finish command group", groupCommand);
          this._addCommand(groupCommand);
        },

        // ============== END - SPECIFIC COMMANDS ===================

        /**
         * Attach the hook function to schedulerProcessStarted event.
         * That is emitted once the start function is triggered.
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        schedulerProcessStartedEvent: function(hook, once) {
          return this.when(context.constants.schedulerEvents.commandProcessStarted, hook, once);
        },

        /**
         * Attach the hook function to schedulerProcessEnded event.
         * That is emitted once the layout and focus had been restored.
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        schedulerProcessEndedEvent: function(hook, once) {
          return this.when(context.constants.schedulerEvents.commandProcessEnded, hook, once);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Scheduler", cls.SchedulerApplicationService);
  }
);
;
"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.schedulerEvents = {
  commandProcessStarted: 'g_schedulerCommandProcessStarted',
  commandProcessEnded: 'g_schedulerCommandProcessEnded'
};
;

"use strict";

modulum('SessionService', ['InitService'],
  function(context, cls) {

    /**
     * Service that manages Sessions
     * @namespace gbc.SessionService
     * @gbcService
     * @publicdoc
     */
    context.SessionService = context.oo.StaticClass( /** @lends gbc.SessionService */ {
      __name: "SessionService",

      /**
       * Label for event listener
       * @private
       */
      sessionAdded: "sessionAdded",
      /**
       * Label for event listener
       * @private
       */
      sessionRemoved: "sessionRemoved",

      /**
       * session identifier
       * @type {Number}
       * @private
       */
      _identifier: 0,
      /**
       * @type {classes.VMSession[]}
       */
      _sessions: null,
      _bySessionId: null,
      _eventListener: null,

      /**
       * Initialize the session Service
       */
      init: function() {
        this._eventListener = new cls.EventListener();
        this._sessions = [];
        this._bySessionId = {};
      },

      /**
       * Start an application
       * @param appName {string}
       * @param params {Object}
       @param procId {string}
       * @returns {classes.VMSession}
       */
      startApplication: function(appName, params, procId) {
        const session = new cls.VMSession(this._identifier++);
        this._eventListener.emit(this.sessionAdded, session);
        const subAppInfo = context.bootstrapInfo.subAppInfo;
        if (subAppInfo) {
          let parentSession = context.BrowserWindowsService.getParentSession();
          session._baseInfos = parentSession && parentSession._baseInfos;
          session.startSubTask(subAppInfo, (app) => {
            if (procId) {
              app.info().connectionInfo = app.info().connectionInfo || {};
              app.info().procId = procId;
              app.info().connectionInfo.procId = procId;
            }
          });
        } else {
          let app = session.start(appName, params);
          if (procId) {
            app.info().connectionInfo = app.info().connectionInfo || {};
            app.info().procId = procId;
            app.info().connectionInfo.procId = procId;
          }
        }

        this._sessions.push(session);
        context.HostService.displaySession();
        return session;
      },

      /**
       * Start via a connection
       * @param {window.gbcWrapper} wrapper
       * @param {Object<string, *>} readyData
       * @return {*}
       */
      startDirect: function(wrapper, readyData) {
        let session = null;
        if (this._sessions.length) {
          session = this._sessions[0];
        } else {
          session = new cls.VMSession(this._identifier++);
          this._sessions.push(session);
          this._eventListener.emit(this.sessionAdded, session);
          context.HostService.displaySession();
        }
        session.startDirect(wrapper, readyData);
        return session;
      },

      fromSessionId: function(id) {
        return this._bySessionId[id];
      },

      updateSessionId: function(session, id) {
        this._bySessionId[id] = session;
      },

      /**
       * Remove a session
       * @param session
       * @param restarting
       */
      remove: function(session, restarting) {
        this._bySessionId[session.getSessionId()] = null;
        this._sessions.remove(session);
        this._eventListener.emit(this.sessionRemoved, session);
        if (!this._sessions.length && !restarting) {
          let baseURI = document.baseURI;
          if (!baseURI) {
            const base = document.getElementsByTagName("base");
            if (base.length) {
              baseURI = base[0].href || "";
            }
          }
          context.UrlService.setCurrentUrl(baseURI.replace(/\/$/, "/index.html"));
          context.HostService.displayNoSession();
        }
      },

      /**
       * Return active sessions
       * @returns {classes.VMSession[]}
       */
      getSessions: function() {
        return this._sessions;
      },

      /**
       * Return a session by id
       * @param identifier {string} id of the session to get
       * @return {classes.VMSession} the requested session
       */
      getSession: function(identifier) {
        return this._sessions.filter(function(item) {
          return item.getIdentifier() === identifier;
        })[0];
      },

      /**
       * Get the current running session
       * @returns {classes.VMSession} the current session
       * @publicdoc
       */
      getCurrent: function() {
        if (this._sessions) {
          return this._sessions[this._sessions.length - 1];
        } else {
          return null;
        }
      },

      /**
       * Handler called once a sesion has been added
       * @param hook
       * @return {*|HandleRegistration|promise.Promise<any>|Q.Promise<void>|Q.Promise<string>}
       */
      onSessionAdded: function(hook) {
        return this._eventListener.when(this.sessionAdded, hook);
      },
      /**
       * Handler called once a sesion has been removed
       * @param hook
       * @return {*|HandleRegistration|promise.Promise<any>|Q.Promise<void>|Q.Promise<string>}
       */
      onSessionRemoved: function(hook) {
        return this._eventListener.when(this.sessionRemoved, hook);
      }
    });
    context.InitService.register(context.SessionService);
  });
;

"use strict";

modulum('TemplateService', ['InitService'],
  function(context, cls) {

    /**
     * Template management service
     * @namespace gbc.TemplateService
     * @gbcService
     */
    context.TemplateService = context.oo.StaticClass( /** @lends gbc.TemplateService */ {
      __name: "TemplateService",
      _compiled: {},
      _rendered: {},
      init: function() {
        const templateKeys = Object.keys(window.gbcTemplates);
        for (const templateId of templateKeys) {
          if (window.gbcTemplates.hasOwnProperty(templateId)) {
            this.registerRawTemplate(templateId, window.gbcTemplates[templateId]);
          }
        }
      },
      /**
       * Registers a new template (string) with the given id.
       * @param id the template id
       * @param template the template text
       */
      registerRawTemplate: function(id, template) {
        if (this._compiled[id]) {
          context.LogService.error("templateService.registerRawTemplate: template id already exists : " + id);
          return;
        }
        this._compiled[id] = template;
      },
      /**
       * Renders a node depending on the given template id.
       * @param templateId the template id to use for rendering
       * @returns string a string of the compiled template given the node and the template id
       */
      renderAs: function(templateId) {
        if (this._compiled.hasOwnProperty(templateId)) {
          return this._compiled[templateId];
        } else {
          return "";
        }
      },
      /**
       * Renders a node depending on the given template id.
       * @param templateId the template id to use for rendering
       * @param ascendance
       * @returns {Node} the compiled template given the node and the template id
       */
      renderDOM: function(templateId, ascendance) {
        if (this._rendered[templateId]) {
          return this._rendered[templateId].cloneNode(true);
        }

        const div = document.createElement('div');
        div.insertAdjacentHTML("beforeend", this.renderAs(templateId));
        const result = div.firstChild;
        const elements = div.querySelectorAll("*"),
          len = elements.length,
          attrNames = ascendance ? ascendance.map(function(item) {
            return "__" + item;
          }) : ["__" + templateId],
          alen = attrNames.length;
        for (let i = 0; i < len; i++) {
          for (let j = 0; j < alen; j++) {
            elements.item(i).setAttribute(attrNames[j], "");
          }
        }
        this._rendered[templateId] = result;
        return result.cloneNode(true);
      }

    });
    context.InitService.register(context.TemplateService);
  });
;

"use strict";

modulum('ThemeService',
  function(context, cls) {

    /**
     * Theme Service to customize the application
     * @namespace gbc.ThemeService
     * @gbcService
     */
    context.ThemeService = context.oo.StaticClass( /** @lends gbc.ThemeService */ {
      __name: "ThemeService",

      /**
       * internal event emitter
       * @private
       */
      _eventListener: new cls.EventListener(),

      /**
       * current theme parsed values
       * @type {*}
       * @private
       */
      _currentVariables: [],

      /**
       * current theme in DOM resources
       * @type {*}
       * @private
       */
      _currentResources: {},

      /**
       * current theme resources pathes
       * @type {*}
       * @private
       */
      _currentPathes: {},

      /**
       * list of usable themes
       * @type {*}
       * @private
       */
      _availableThemes: window.__gbcThemesInfo,

      /**
       * current theme name
       * @type {string}
       * @private
       */
      _currentThemeName: "",

      _hasChanged: false,

      /**
       * collection of test functions used in theme conditions
       */
      _conditionMatchers: {
        isMobile: function() {
          return window.isMobile();
        },
        isPhone: function() {
          return window.isPhone();
        },
        isTablet: function() {
          return window.isTablet();
        },
        isDesktop: function() {
          return !window.isMobile();
        },
        isTouchDevice: function() {
          return window.isTouchDevice();
        },
        isUR: function() {
          return window.gbc.__wrapper.isNative();
        },
        isBrowser: function() {
          return window.gbc.__wrapper.isBrowser();
        },
        isChrome: function() {
          return window.browserInfo.isChrome;
        },
        isEdge: function() {
          return window.browserInfo.isEdge;
        },
        isFirefox: function() {
          return window.browserInfo.isFirefox;
        },
        isIE: function() {
          return window.browserInfo.isIE;
        },
        isOpera: function() {
          return window.browserInfo.isOpera;
        },
        isSafari: function() {
          return window.browserInfo.isSafari;
        },
        isAndroid: function() {
          return window.isAndroid();
        },
        isIOS: function() {
          return window.isIOS();
        }
      },

      /**
       * test theme conditions against matchers
       * @param {Array<string>} conditions list of theme conditions
       * @return {boolean} true if all conditions matches
       * @private
       */
      _conditionsMatches: function(conditions) {
        let i = 0;
        const len = conditions && conditions.length || 0;
        for (; i < len; i++) {
          try {
            if (!this._conditionMatchers[conditions[i]]()) {
              return false;
            }
          } catch (e) {
            return false;
          }
        }
        return true;
      },

      /**
       * filter list of themes against their conditions
       * @param {Array} list list of themes
       * @return {Array} filtered list of themes
       * @private
       */
      _filterThemeList: function(list) {
        const result = [];
        let i = 0;
        const len = list && list.length || 0;
        for (; i < len; i++) {
          if (this._conditionsMatches(list[i].conditions)) {
            result.push(list[i]);
          }
        }
        return result;
      },

      /**
       * return the gutter X value
       * @returns {number}
       */
      getGutterX: function() {
        return this.getValue("theme-grid-inner-gutter-x") || this.getValue("theme-grid-inner-gutter");
      },

      /**
       * return the gutter Y value
       * @returns {number}
       */
      getGutterY: function() {
        return this.getValue("theme-grid-inner-gutter-y") || this.getValue("theme-grid-inner-gutter");
      },

      /**
       * get a value from theme
       * @param {string} id the theme value id
       * @return {*} the value
       */
      getValue: function(id) {
        return context.ThemeService._currentVariables[id];
      },

      /**
       * set a value to the local theme - internal use only
       * @param {string} id the theme value id
       * @param {*} value the value
       * @ignore
       */
      setValue: function(id, value) {
        context.ThemeService._currentVariables[id] = value;
      },

      /**
       * get a resource path from theme
       * @param {string} id the theme resource id
       * @return {*} the resource path
       */
      getResource: function(id) {
        return context.ThemeService._currentPathes.themes[context.ThemeService._currentThemeName].indexOf(id) >= 0 ?
          ("themes/" + context.ThemeService._currentThemeName + "/resources/" + id) :
          ("resources/" + id);
      },

      /**
       * Thanks to Edge/IE, for need to be sure the current theme is well loaded
       * @returns {boolean} true if current theme is loaded
       * @private
       */
      _isCurrentThemeLoaded: function() {
        return Boolean(context.ThemeService._currentPathes.themes[context.ThemeService._currentThemeName]);
      },

      /**
       * Get available themes
       * @return {Array} the themes
       */
      getAvailableThemes: function() {
        return this._availableThemes;
      },

      /**
       * get current theme name
       * @return {string} the current theme name
       */
      getCurrentTheme: function() {
        return this._currentThemeName;
      },
      /**
       * parse theme variables from injected json
       * @return {{variables:Object, pathes:Object}} theme information
       * @private
       */
      _loadValues: function() {
        const styles = window.getComputedStyle(document.body, ":after"),
          vars = styles.getPropertyValue("content"),
          result = JSON.parse(Base64.fromBase64(vars)),
          variablesKeys = Object.keys(result.variables);
        let i = 0;
        const len = variablesKeys.length;
        for (; i < len; i++) {
          const key = variablesKeys[i];
          if (/^b64\(.*\)$/.test(result.variables[key])) {
            result.variables[key] = JSON.parse(Base64.fromBase64(result.variables[key].replace(/^b64\((.*)\)$/, "$1")));
          }
        }
        return result;
      },

      /**
       * load theme
       * @param {string} name theme name
       * @param {function} [callback] callback when theme has been loaded
       * @param {boolean} [noSave] true to avoid stored settings save
       */
      loadTheme: function(name, callback, noSave) {
        if (!noSave) {
          context.StoredSettingsService?.moveLayoutSettings();
          context.StoredSettingsService?.setSettings('gwc.app.theme', name);
          // force writing in browser'storage in case of new window opening
          context.StoredSettingsService?.syncApp();
        }
        if (context.ThemeService._currentThemeName !== name) {
          this._hasChanged = (!context.queryStringTheme && context.ThemeService._currentThemeName) ||
            (context.queryStringTheme && name !== context.queryStringTheme);
          context.ThemeService._currentThemeName = name;

          let cacheTimestamp = gbc.lastCompDate ? `?ct=${gbc.lastCompDate}` : '';
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.type = "text/css";
          link.href = "./themes/" + name + "/main.css" + cacheTimestamp;
          link.onload = function() {
            const themeInfo = context.ThemeService._loadValues();
            context.ThemeService._currentVariables = themeInfo.variables;
            context.ThemeService._currentPathes = themeInfo.pathes;
            if (this._isCurrentThemeLoaded()) {
              if (this._currentResources.link) {
                this._currentResources.link.remove();
              }
              this._currentResources.link = link;
              context.classes.WidgetFactory.registerThemeOverrides(themeInfo.widgetFactory);
              window.requestAnimationFrame(function() {
                // TODO: remove this second requestAnimationFrame when GBC-2251 is done (and fixes the font issue)
                window.requestAnimationFrame(function() {
                  this._onThemeLoaded();
                  if (typeof callback === "function") {
                    callback();
                  }
                }.bind(this));
              }.bind(this));
            } else {
              context.LogService.error("Theme '" + name + "' cannot be loaded!");
              link.remove();
              this.loadTheme(this._availableThemes[0].name, callback);
            }
          }.bind(this);
          link.onerror = function() {
            context.LogService.error("Theme '" + name + "' cannot be loaded!");
            link.remove();
            this.loadTheme(this._availableThemes[0].name, callback);
          }.bind(this);
          link.insertAfter(this._currentResources.link || document.head.getElementsByTagName("title")[0]);
        } else {
          if (typeof callback === "function") {
            callback();
          }
        }
        //once theme has been changed, tell native wrapper
        context.__wrapper.nativeCall(context.__wrapper.param({
          name: "themeChanged",
          args: {
            "name": `${this.getCurrentTheme()}_style`
          }
        }));
      },

      /**
       * updates theme dependant elements in loaded gbc
       * @private
       */
      _onThemeLoaded: function() {
        this._eventListener.emit(context.constants.widgetEvents.themeChange);
        document.getElementById("favicon_element").href = context.ThemeService.getResource("img/gbc_logo.ico");
        const session = context.SessionService.getCurrent();
        if (session) {

          // Tell native part to update icon as well
          context.__wrapper.nativeCall(context.__wrapper.param({
            name: "applicationIcon",
            args: {
              "type": "theme",
              "icon": context.ThemeService.getResource("img/gbc_logo.ico")
            }
          }, session.getCurrentApplication()));

          const apps = session.getApplications(),
            len = apps && apps.length || 0;
          let i = 0;
          for (; i < len; i++) {
            const app = apps[i],
              layout = app && app.layout,
              model = app && app.model;
            if (layout) {
              layout.reset();
            }
            if (model) {
              model.getNodesByTag("Window").forEach(function(item) {
                item.getWidget().getLayoutEngine().reset(true);
              });
            }
          }
        }

        // If we choose a webkit rendering, use variable as scrollbarSize
        if (this.getValue("theme-webkit-scrollbars-global-enable") && 'WebkitAppearance' in document.documentElement.style && !window
          .isAndroid() && !window.isIOS()) {
          window.scrollBarSize = parseInt(this.getValue("theme-webkit-scrollbars-size"), 10); //offset for webkit scrollbar
        }
      },

      /**
       * fired when theme changed
       * @param {Hook} hook the hook
       * @return {HandleRegistration} the handle registration
       */
      whenThemeChanged: function(hook) {
        return this._eventListener.when(context.constants.widgetEvents.themeChange, hook);
      },

      /**
       * Finds the name of the dark version of the theme provided if it exists
       * @param {string} name
       * @return {string} the name of the dark theme if it exists, or the name provided as param otherwise
       */
      getDarkSchemeName(name) {
        const darkSchemeName = name + "_dark";
        return this._availableThemes.find((theme) => theme.name === darkSchemeName) ? darkSchemeName : name;
      },

      /**
       * Finds the name of the light version of the theme provided if it exists
       * @param {string} name
       * @return {string} the name of the light theme if it exists, or the name provided as param otherwise
       */
      getLightSchemeName(name) {
        if (!this.isDarkScheme(name)) {
          return name;
        }
        const lightSchemeName = name.slice(0, -"_dark".length);
        return this._availableThemes.find((theme) => theme.name === lightSchemeName) ? lightSchemeName : name;
      },

      /**
       * @param {string} name
       * @returns {boolean}
       */
      isDarkScheme(name) {
        return name.endsWith("_dark");
      },

      /**
       * Checks if theme provided has a corresponding light/dark mode
       * @param {string} name
       * @returns {boolean}
       */
      hasMultipleSchemes(name) {
        if (this.isDarkScheme(name)) {
          return this.getLightSchemeName(name) !== name;
        }
        return this.getDarkSchemeName(name) !== name;
      },

      /**
       * load initial theme
       * @param {?string} initialTheme initial theme to load
       * @param {function} callback callback when theme has been loaded
       */
      initTheme: function(initialTheme, callback) {
        this._availableThemes = this._filterThemeList(this._availableThemes);
        if (this._availableThemes.length) {
          // Priority 1: initialTheme parameter
          let themeToLoad = initialTheme;
          if (!initialTheme) {
            // Priority 2: stored theme
            const storedTheme = context.StoredSettingsService.getSettings('gwc.app.theme');
            if (storedTheme) {
              if (this._availableThemes.find(function(item) {
                  return item.name === storedTheme;
                })) {
                themeToLoad = storedTheme;
              }
            }
            if (!themeToLoad) {
              // Priority 3: First in list, dark flavor if browser is set to dark mode
              themeToLoad = this._availableThemes[0].name;
              if (window.matchMedia) {
                if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                  themeToLoad = this.getDarkSchemeName(themeToLoad);
                }
              }
            }
          }
          this.loadTheme(themeToLoad,
            callback, Boolean(initialTheme));
        } else {
          this._displayConsoleScreenOfDeath();
        }
      },

      /**
       * Show critical error if no theme is available
       * @private
       */
      _displayConsoleScreenOfDeath: function() {
        window.critical.display("Internal failure: No applicable theme found.");
      },

      /**
       * Get media string for initial handshake
       * @return {string} - media string "small"|"medium"|"large"
       */
      getMediaString: function() {
        const smallMax = this.getValue("responsive-small-width");
        const mediumMax = this.getValue("responsive-medium-width");
        if (window.matchMedia("(max-width: " + smallMax + ")").matches) {
          return "small";
        } else if (window.matchMedia("(max-width: " + mediumMax + ")").matches) {
          return "medium";
        } else {
          return "large";
        }
      },

      /**
       * Get the minimal row Height
       * @returns {number}
       */
      getTableMinimalRowHeight: function() {
        return (window.isTouchDevice()) ? this.getValue("theme-table-minimal-row-height-on-touchscreen") : this.getValue(
          "theme-table-minimal-row-height");
      }

    });
  });
;

"use strict";

modulum('QueryString',
  function(context, cls) {

    /**
     *
     * @class QueryString
     * @memberOf classes
     */
    cls.QueryString = context.oo.Class(function() {
      return /** @lends classes.QueryString.prototype */ {
        $static: /** @lends classes.QueryString */ {
          deletedTokenValue: {}
        },
        _contents: null,
        constructor: function(raw) {
          this._contents = {};
          this.fromRaw(raw);
        },
        fromRaw: function(raw) {
          if (raw instanceof cls.QueryString) {
            this._contents = raw.copyContentsObject();
          } else {
            if (Object.isString(raw)) {
              const tokens = raw.split("&");
              for (const token of tokens) {
                if (token) {
                  const q = /([^=]+)=(.*)/.exec(token);
                  if (q) {
                    this.add(q[1], q[2]);
                  }
                }
              }
            }
          }
        },
        copyContentsObject: function() {
          const result = {};
          const contentKeys = Object.keys(this._contents);
          for (const key of contentKeys) {
            const values = this._contents[key];
            if (Array.isArray(values)) {
              result[key] = [];
              for (const value of values) {
                result[key].push(value);
              }
            } else {
              if (values !== cls.QueryString.deletedTokenValue) {
                result[key] = values;
              }
            }
          }
          return result;
        },
        toString: function() {
          const result = [];
          const contentKeys = Object.keys(this._contents);
          for (const key of contentKeys) {
            const values = this._contents[key];
            if (Array.isArray(values)) {
              for (const value of values) {
                result.push(key + (value === false || value === 0 || value === "" || value ? ("=" + value) : ""));
              }
            } else {
              if (values !== cls.QueryString.deletedTokenValue) {
                result.push(key + (values === false || values === 0 || values === "" || values ? ("=" + values) : ""));
              }
            }
          }
          return result.join("&");
        },
        add: function(key, value) {
          if (this._contents.hasOwnProperty(key)) {
            if (Array.isArray(this._contents[key])) {
              this._contents[key].push(value);
            } else {
              this._contents[key] = [this._contents[key], value];
            }
          } else {
            this._contents[key] = value;
          }
        },
        /**
         *
         * @param key
         * @param value
         */
        remove: function(key, value) {
          if (value === false || value === 0 || value === "" || value) {
            if (Array.isArray(this._contents[key])) {
              if (this._contents[key].contains(value)) {
                this._contents[key].remove(value);
              }
              if (this._contents[key].length === 1) {
                this._contents[key] = this._contents[key][0];
              } else if (!this._contents[key].length) {
                this._contents[key] = cls.QueryString.deletedTokenValue;
              }
            } else if (this._contents.hasOwnProperty(key) && this._contents[key] === value) {
              this._contents[key] = cls.QueryString.deletedTokenValue;
            }
          } else if (this._contents.hasOwnProperty(key)) {
            this._contents[key] = cls.QueryString.deletedTokenValue;
          }
        },
        isEmpty: function() {
          return !Object.keys(this._contents).length;
        }
      };
    });
  });
;

"use strict";

modulum('Url',
  function(context, cls) {

    /**
     *
     * @class Url
     * @memberOf classes
     */
    cls.Url = context.oo.Class(function() {
      return /** @lends classes.Url.prototype */ {
        $static: /** @lends classes.Url */ {
          _defaultsPorts: {
            http: "80",
            https: "443"
          },
          isValid: function(urlString) {
            return Boolean(window.RegExpUrl.test(urlString));
          },
          protocolDefaultPort: function(protocol) {
            return this._defaultsPorts[protocol] || "80";
          }
        },
        /**
         * @type {?string}
         */
        _protocol: null,
        /**
         * @type {?string}
         */
        _username: null,
        /**
         * @type {?string}
         */
        _password: null,
        /**
         * @type {?string}
         */
        _host: null,
        /**
         * @type {?string}
         */
        _port: null,
        /**
         * @type {?string}
         */
        _path: null,
        /**
         * @type {classes.QueryString}
         */
        _queryString: null,
        /**
         * @type {?string}
         */
        _hash: null,
        /**
         * @type {boolean}
         */
        _invalid: false,
        constructor: function(urlString) {
          this._queryString = new cls.QueryString();
          if (urlString instanceof cls.Url) {
            this.fromUrl(urlString);
          } else {
            this.fromUrlString(urlString);
          }
        },
        fromUrl: function(url) {
          this._protocol = url._protocol;
          this._username = url._username;
          this._password = url._password;
          this._host = url._host;
          this._port = url._port;
          this._path = url._path;
          this._queryString.fromRaw(url._queryString);
          this._hash = url._hash;
        },
        fromUrlString: function(urlString) {
          urlString = urlString || window.location.href;
          const parts = window.RegExpUrl.exec(urlString);
          this._invalid = !parts;
          if (parts) {
            this._protocol = parts[1];
            this._username = parts[2];
            this._password = parts[3];
            this._host = parts[4];
            this._port = parts[5];
            this._path = parts[6];
            this._queryString.fromRaw(parts[7]);
            this._hash = parts[8];
          }
        },
        originString: function() {
          return [
            (this._protocol || context.UrlService.currentUrl()._protocol), "://", (this._username ? (this._username + (this
              ._password ?
              (":" + this._password) : "") + "@") : ""),
            this._host, (this._port ? (":" + this._port) : "")
          ].join("");
        },
        toRawString: function() {
          return this.originString() + (this._path || "");
        },
        toString: function() {
          const queryString = this._queryString && this._queryString.toString();
          return this.toRawString() +
            (queryString ? "?" + queryString : "") +
            (this._hash ? "#" + this._hash : "");
        },
        setQueryString: function(key, value) {
          this.removeQueryString(key);
          return this.addQueryString(key, value);
        },
        addQueryString: function(key, value) {
          (this._queryString = this._queryString || new cls.QueryString()).add(key, value);
          return this;
        },
        removeQueryString: function(key, value) {
          if (this._queryString) {
            this._queryString.remove(key, value);
            if (!this._queryString.toString().length) {
              this._queryString = null;
            }
          }
          return this;
        },
        hasSameOrigin: function(url) {
          if (!(url instanceof cls.Url)) {
            if (Object.isString(url)) {
              url = new cls.Url(url);
            } else {
              return false;
            }
          }
          return (url._protocol === this._protocol) &&
            (url._username === this._username) &&
            (url._password === this._password) &&
            (url._host === this._host) &&
            (
              (url._port || cls.Url.protocolDefaultPort(url._protocol)) ===
              (this._port || cls.Url.protocolDefaultPort(this._protocol))
            );
        },
        hasSamePath: function(url) {
          if (!(url instanceof cls.Url)) {
            if (Object.isString(url)) {
              url = new cls.Url(url);
            } else {
              return false;
            }
          }
          return (url._path === this._path);
        },
        isUaR: function() {
          return this._path.indexOf("/ua/r/") >= 0;
        },
        getQueryStringObject: function() {
          return this._queryString.copyContentsObject();
        }
      };
    });
  });
;

"use strict";

modulum('UrlService', ['InitService'],
  function(context, cls) {

    /**
     * Url management service
     * @namespace gbc.UrlService
     * @gbcService
     */
    context.UrlService = context.oo.StaticClass( /** @lends gbc.UrlService */ {
      __name: "UrlService",
      /** @type classes.Url */
      _current: null,
      init: function() {
        this._current = new cls.Url();
      },

      currentUrl: function() {
        return new cls.Url(this._current);
      },
      setCurrentUrl: function(url, forceLocation) {
        if (forceLocation) {
          window.location.href = url;
        } else {
          this._current = new cls.Url(url);
          if (window.isURLParameterEnabled("qainfo")) {
            this._current.addQueryString("qainfo", 1);
          }
          if (window.isURLParameterEnabled("noquitpopup")) {
            this._current.addQueryString("noquitpopup", 1);
          }
          window.history.pushState(null, "Genero Browser Client", this._current.toString());
        }
      },

      isValid: function(url) {
        const reWebUrl = new RegExp(
          "^" +
          // protocol identifier
          "(?:(?:https?|ftp)://)" +
          // user:pass authentication
          "(?:\\S+(?::\\S*)?@)?" +
          "(?:" +
          // IP address exclusion
          // private & local networks
          "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
          "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
          "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" +
          // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
          "|" +
          // host name
          "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
          // domain name
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
          // TLD identifier
          "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" +
          ")" +
          // port number
          "(?::\\d{2,5})?" +
          // resource path
          "(?:/\\S*)?" +
          "$", "i"
        );

        return Boolean(url) && Boolean(url.match(reWebUrl));

      },
      goTo: function(urlString) {
        const url = new cls.Url(urlString);
        if (cls.Url.isValid(urlString)) {
          const params = url.getQueryStringObject() || {};
          const currentUrl = this.currentUrl();
          if (url.isUaR() && (url.hasSameOrigin(currentUrl) || window.isURLParameterEnabled("crossdomain"))) {
            const urlParts = url.toRawString().split("/ua/r/");
            params.customUA = urlParts[0];
            params.app = urlParts[1];
            let historyUrl = currentUrl.setQueryString("app", params.app);
            if (url.originString() !== params.customUA) {
              historyUrl.setQueryString("customUA", params.customUA);
            } else {
              historyUrl = url;
            }
            this.setCurrentUrl(historyUrl);
            context.SessionService.startApplication(params.app, params);
          } else if (url.hasSameOrigin(currentUrl) && url.hasSamePath(currentUrl)) {
            if (params.app) {
              this.setCurrentUrl(url.toString());
              context.SessionService.startApplication(params.app, params);
            }
          } else {
            this.setCurrentUrl(url.toString(), true);
          }

        } else {
          this.setCurrentUrl(this.currentUrl().setQueryString("app", encodeURIComponent(urlString)).toString(), true);
        }
      }
    });
    context.InitService.register(context.UrlService);
  });
;

"use strict";

modulum('WebComponentService', ['InitService'],
  function(context, cls) {

    /**
     * Proxy Service used to forward webcomponent api
     * @namespace gbc.WebComponentService
     * @gbcService
     */
    context.WebComponentService = context.oo.StaticClass(
      /** @lends gbc.WebComponentService */
      {
        __name: "WebComponentService",
        /**
         * List of proxies
         * @type {Object}
         */
        _proxies: {},

        /**
         * Keep track of webcomponent URL provided by the GAS
         * @type {url}
         */
        _webcomponentUrl: null,

        /**
         * Init function, called once and mandatory
         */
        init: function() {

        },

        /**
         * Add or edit a new proxy
         * @param uid
         * @param widget
         */
        setProxy: function(uid, widget) {
          this._proxies[uid] = this._api(widget);
        },

        /**
         * Get a registered proxy
         * @param uid
         * @returns {*}
         */
        getProxy: function(uid) {
          return this._proxies[uid];
        },

        /**
         * Get the webcomponent URL defined by the GAS
         * @returns {url}
         */
        getWebcomponentUrl: function() {
          return this._webcomponentUrl;
        },

        /**
         * Set the webcomponent URL
         * @param url
         */
        setWebcomponentUrl: function(url) {
          this._webcomponentUrl = url;
        },

        /**
         * Api that will be binded to webcomponent
         * @returns {{setFocus: function, setData: function, action: function}}
         * @private
         */
        _api: function() {
          return /** @ignore */ {
            //Generates a focus request
            /** @ignore */
            setFocus: function(element) {
              context.LogService.gICAPI.log("Emit a focus request");
              element.emit(context.constants.widgetEvents.requestFocus);
            },
            //Registers data to be sent to the program, in order to set the form field value in the program.
            /** @ignore */
            setData: function(element, dataStr) {
              //Ensure dataStr is a string
              if (typeof dataStr !== "string") {
                dataStr = JSON.stringify(dataStr);
                context.LogService.gICAPI.warn("Data sent is not of type string, it will be automatically stringified");
              }
              element.emit(cls.WebComponentWidget.dataEvent, dataStr);
            },
            //Triggers an action event, which will execute the corresponding ON ACTION code.
            /** @ignore */
            action: function(element, actionName) {
              //Ensure actionName is a string, cancel and log otherwise
              if (typeof actionName === "string") {
                context.LogService.gICAPI.log("Call Action(" + actionName + ")");
                element.emit(cls.WebComponentWidget.actionEvent, actionName);
              } else {
                context.LogService.gICAPI.error("Action identifier is not of type string, action canceled.");
              }
            }
          };
        }

      });
    context.InitService.register(context.WebComponentService);
  });
;

"use strict";

modulum('WidgetService', ['InitService'],
  function(context, cls) {

    /**
     * Main widget service
     * @namespace gbc.WidgetService
     * @gbcService
     */
    context.WidgetService = context.oo.StaticClass( /** @lends gbc.WidgetService */ {
      __name: "WidgetService",

      /** @type number */
      cursorX: 0,
      /** @type number */
      cursorY: 0,

      /** @type classes.EventListener */
      _eventListener: null,

      /** @type {Map<string,classes.WidgetBase>} */
      _widgetsMap: null,

      /** @type {Array<string>} */
      _currentAppIds: null,

      /** @type {Array<classes.WidgetBase>} */
      _delayedWidgetDestroy: null,

      /**
       *  Init widget service
       */
      init: function() {
        this._eventListener = new cls.EventListener();
        this._widgetsMap = new Map();
        this._currentAppIds = [];
        this._delayedWidgetDestroy = [];
      },

      /**
       * Register VM application
       * @param app {classes.VMApplication} - app
       */
      registerVMApplication: function(app) {
        this._currentAppIds.push(app.applicationHash);
      },

      /**
       * Unregister VM application
       * @param app {classes.VMApplication} - app
       */
      unregisterVMApplication: function(app) {
        const appId = app.applicationHash;
        const delayedWidgets = [];

        this._delayedWidgetDestroy.forEach(function(w) {
          if (!w.isDestroyed() && (appId === null || w.getApplicationIdentifier() === appId)) {
            delayedWidgets.push(w);
          }
        }.bind(this));

        delayedWidgets.forEach(function(w) {
          w.destroy(true);
        });

        const widgets = this.getAllWidgets(appId);
        if (widgets.length !== 0) {
          gbc.error("WidgetService::unregisterVMApplication --> all widgets of the application are not destroyed");
          gbc.error(
            `Left ${widgets.length} Widgets: ${widgets.map(w=>w.__name + "-" + w._uuid + "@" + w._appHash + "/" + w._auiTag).join(",")}`);

          // anyway clean the widgets
          widgets.forEach(function(w) {
            if (!w.isDestroyed()) {
              w.destroy();
            }
          }.bind(this));
        }

        this._currentAppIds.remove(app.applicationHash);
      },

      /**
       * Register widget
       * @param widget {classes.WidgetBase} - widget
       */
      registerWidget: function(widget) {
        this._widgetsMap.set(widget.getUniqueIdentifier(), widget);

        if (widget.getApplicationIdentifier() === null) {
          gbc.error("WidgetService::registerWidget --> widget has no application id");
        }
      },

      /**
       * Unregister widget
       * @param widget {classes.WidgetBase} - widget
       */
      unregisterWidget: function(widget) {
        const success = this._widgetsMap.delete(widget.getUniqueIdentifier());
        if (!success) {
          gbc.error("WidgetService::unregisterWidget --> widget is not registered");
        }
      },

      /**
       * Add delayed widget destroy
       * @param widget {classes.WidgetBase} - widget
       */
      addDelayedWidgetDestroy: function(widget) {
        if (this._widgetsMap.has(widget.getUniqueIdentifier())) {
          const idx = this._delayedWidgetDestroy.findIndex(function(elm) {
            return elm.getUniqueIdentifier() === widget.getUniqueIdentifier();
          });

          if (idx < 0) {
            this._delayedWidgetDestroy.push(widget);
          }
        }
      },

      /**
       * Add delayed widget destroy
       * @param widget {classes.WidgetBase} - widget
       */
      removeDelayedWidgetDestroy: function(widget) {
        const idx = this._delayedWidgetDestroy.findIndex(function(elm) {
          return elm.getUniqueIdentifier() === widget.getUniqueIdentifier();
        });

        if (idx >= 0) {
          this._delayedWidgetDestroy.splice(idx);
        }
      },

      /**
       * Get a widget from its uuid
       * @param uuid {String} - uuid of widget
       * @returns {classes.WidgetBase} widget
       */
      getWidget: function(uuid) {
        const widget = this._widgetsMap.get(uuid);
        return widget ? widget : null;
      },

      /**
       * Returns a Widget from a dom element
       * @param {Element} elem - dom element
       * @param {String} [widgetClass] - class name of the widget that we want to return (default=gbc_WidgetBase)
       * @return {classes.WidgetBase} Widget pointer
       */
      getWidgetFromElement: function(elem, widgetClass) {
        widgetClass = widgetClass ? widgetClass : "gbc_WidgetBase";
        let widget = null;
        if (elem && elem.elementOrParent) {
          const widgetElement = elem.elementOrParent(widgetClass);
          if (widgetElement) {
            const widgetUuid = widgetElement.id.slice(2);
            widget = context.WidgetService.getWidget(widgetUuid);
          }
        }
        return widget;
      },

      /**
       * Get all widgets of a given app
       * @param {String} [appId] - app id or null for all apps
       * @return {Array<classes.WidgetBase>} array of widgets
       */
      getAllWidgets: function(appId) {
        appId = (typeof(appId) === "undefined") ? null : appId;
        const widgets = [];
        this._widgetsMap.forEach(function(value, key, map) {
          if (appId === null || value.getApplicationIdentifier() === appId) {
            widgets.push(value);
          }
        });
        return widgets;
      },

      /**
       * Get number of widgets
       * @param {String} [appId] - app id or null for all apps
       * @return {number} number of widgets
       */
      getAllWidgetsCount: function(appId) {
        appId = (typeof(appId) === "undefined") ? null : appId;
        if (appId === null) {
          return this._widgetsMap.size;
        } else {
          return this.getAllWidgets(appId).length;
        }
      },

      /**
       * Emit an event
       * @param {string} type event type to emit
       * @param {*} data - data
       */
      _emit: function(type, data) {
        this._eventListener.emit(type, data);
      },

      // TODO comment
      onWidgetCreated: function(kind, hook) {
        this._eventListener.when(context.constants.widgetEvents.created, function(evt, src, data) {
          if (!hook) {
            hook = kind;
            kind = null;
          }
          if (!kind || data.__name === kind) {
            hook(evt, src, data);
          }
        });
      }

    });
    context.InitService.register(context.WidgetService);
  });
;

"use strict";

modulum('DateTimeHelper',
  function(context, cls) {

    /**
     * Helpers for time related widgets.
     * @namespace classes.DateTimeHelper
     */
    cls.DateTimeHelper = context.oo.StaticClass(function() {
      return /** @lends classes.DateTimeHelper */ {
        __name: "DateTimeHelper",

        /**
         * Transform Informix DBDATE Format (ex : MDY4/) to traditional format
         * @param dbformat
         */
        parseDbDateFormat: function(dbformat) {
          // supported DBDATE separators are '-', '/', '.' and '0'. Default is '/'. '0' means no separator
          let sep = dbformat.match(/[.\/\-0]/) || '/';
          sep = sep.toString();
          if (sep === '0') {
            sep = "";
          }
          let format = "";
          for (let i = 0; i < 4; i++) {
            const c = dbformat[i];
            // add separator & duplicate char if 'D' or 'M'. if 'Y', multiply by its next number.
            format += (i !== 0 ? sep : "") + new Array((c === "Y" ? ~~dbformat[++i] : 2) + 1).join(c);
          }
          return format;
        },

        /**
         * Convert Date time to Locale format
         * @param datetimestring
         * @param format
         * @return {*}
         */
        toDbDateFormat: function(datetimestring, format) {
          // Deprecated by MomentJs but needed for Safari. Using new Date('ISO string') raise invalid date on Safari.
          const localDateTime = context.dayjs(datetimestring);
          // Date object may be valid under Chrome and invalid for other browsers with incomplete date values such as "dd mm" format
          if (localDateTime.isValid()) {
            return localDateTime.format(format);
          } else {
            return datetimestring;
          }
        },

        /**
         * Convert Date time to ISO format
         * @param datetimestring
         * @param format
         * @returns {*|string}
         */
        toISOFormat: function(datetimestring, format) {
          let currentISODateTime = "";
          if (datetimestring) {
            if (window.browserInfo.isSafari) {
              datetimestring = datetimestring.replace(/-/g, '/');
            }

            const d = context.dayjs(datetimestring, format);
            if (!d.isValid()) {
              return datetimestring;
            }
            const hasSec = Boolean(~format.toLowerCase().indexOf("s"));
            currentISODateTime = d.format("YYYY-MM-DD " + (hasSec ? "HH:mm:ss" : "HH:mm"));
          }
          return currentISODateTime;
        },

        /**
         * Convert Date time to Locale format
         * @param datetimestring
         * @param seconds
         * @returns {string}
         */
        toLocaleFormat: function(datetimestring, seconds) {
          const localDateTime = context.dayjs(datetimestring);
          if (localDateTime.isValid()) {
            return localDateTime.format("L") + " " + localDateTime.format((seconds ? "LTS" : "LT"));
          } else {
            return datetimestring;
          }
        },

        /**
         * Get client locale format
         * @param seconds
         * @returns {string}
         */
        getISOFormat: function(seconds) {
          return "YYYY-MM-DD HH:mm" + (seconds ? ":ss" : "");
        },

        /**
         * Builds a time fragment handling object.
         * Ex: For minutes: group(60) increments from 0 to 59 and wraps.
         * @param {number} highLimit upper limit
         * @returns {{fromText: Function, increaseValue: Function, decreaseValue: Function, getText: Function}}
         */
        timeFragment: function(highLimit) {
          const limit = highLimit;
          const maxChars = String(highLimit).length;
          let value = 0;
          return {
            /**
             * @param {string} text
             * @param {boolean} force
             * @ignore
             * @returns {boolean}
             */
            fromText: function(text, force) {
              if (!text) {
                return false;
              }
              let isComplete = true;
              const intValue = parseInt(text, 10);

              if (isNaN(intValue)) {
                value = 0;
              } else {
                if (text.length > maxChars) {
                  value = limit - 1;
                } else if (text.length === maxChars) {
                  if (intValue >= limit) {
                    value = limit - 1;
                  } else {
                    value = intValue;
                  }
                } else {

                  isComplete = false;

                }

              }
              return isComplete;
            },
            /**
             * @ignore
             * @returns {boolean} true if the value has wrapped.
             */
            increaseValue: function() {
              if ((value + 1) === limit) {
                value = 0;
                return true;
              } else {
                value++;
                return false;
              }
            },
            /**
             * @ignore
             * @returns {boolean} true if the value has wrapped
             */
            decreaseValue: function() {
              if (value === 0) {
                value = limit - 1;
                return true;
              } else {
                value--;
                return false;
              }
            },
            /**
             * @ignore
             * @returns {string} the current value
             */
            getText: function() {
              return value.pad(2);
            }
          };
        },

        /**
         * Convert traditional year of date to Ming guo year format
         * @param {string} datestring
         * @returns {string} return ming guo year
         */
        mingGuoToGregorianYears: function(datestring) {
          const str = datestring.match(/\d{3}/);
          if (str) {
            const year = str.toString();
            return datestring.replace(year, "" + (~~year + 1911));
          } else {
            return datestring;
          }
        },

        gregorianToMingGuoYears: function(date) {
          return date.getFullYear() - 1911;
        }
      };
    });
  });
;

"use strict";

modulum('DebugHelper',
  function(context, cls) {
    /**
     *
     * @class DebugHelper
     * @memberOf classes
     */
    cls.DebugHelper = context.oo.StaticClass(function() {
      return /** @lends classes.DebugHelper */ {
        activateDebugHelpers: function() {
          if (!window.gbcNode) {
            /**
             *
             * @param elementOrIdRef
             * @return {classes.NodeBase}
             */
            window.gbcNode = this.gbcNode;
          }
          if (!window.gbcJsonAui) {
            /**
             * Return Json formatted AUI tree
             * @param {number} nodeId - node to start aui display from
             * @param {Object} aui - not used yet, for future optim
             * @return {{}|{children: *, attributes: *, id: *, tag: *}|{attributes: *, id: *, tag: *}}
             */
            window.gbcJsonAui = this.getJsonAui;
          }
          if (!window.gbcController) {
            window.gbcController = function(elementOrIdRef) {
              const node = window.gbcNode(elementOrIdRef);
              return node ? node.getController() : null;
            };
          }
          if (!window.gbcWidget) {
            /**
             *
             * @param elementOrIdRef
             * @returns {classes.WidgetBase}
             */
            window.gbcWidget = function(elementOrIdRef) {
              const controller = window.gbcController(elementOrIdRef);
              return controller ? controller.getWidget() : null;
            };
          }
          if (!window.gbcMeasuring) {
            /**
             * Switch from g_measured to g_measuring layout and conversely on each element
             * @param {boolean} b - if true g_measured to g_measuring else g_measuring to g_measured
             */
            window.gbcMeasuring = function(b = true) {
              const list = document.getElementsByClassName(b ? "g_measured" : "g_measuring");
              for (const elem of list) {
                if (b) {
                  elem.removeClass("g_measured").addClasses("g_measuring", "__debug");
                } else {
                  elem.addClass("g_measured").removeClass("g_measuring").removeClass("__debug");
                }
              }
            };
          }
        },
        gbcNode: function(elementOrIdRef) {
          if (typeof(elementOrIdRef) === 'object') {
            let element = elementOrIdRef;
            while (element) {
              const classList = element.classList;
              for (const cls of classList) {
                if (cls.startsWith("aui__")) {
                  const id = parseInt(cls.substr(5), 10);
                  return context.SessionService.getCurrent().getCurrentApplication().getNode(id);
                }
              }
              element = element.parentElement;
            }
            return null;
          } else {
            return context.SessionService.getCurrent().getCurrentApplication().getNode(elementOrIdRef);
          }
        },
        getJsonAui: function(nodeId = 0, aui = {}) {
          const {
            _id,
            _attributes,
            _children,
            _tag
          } = {
            ...cls.DebugHelper.gbcNode(nodeId)
          };
          // out if node isn't found
          if (_id === null || (typeof _id === 'undefined')) {
            return {};
          }
          //out of recursive if leaf
          if (_children.length <= 0) {
            return {
              id: _id,
              tag: _tag,
              attributes: _attributes
            };
          }
          return {
            id: _id,
            tag: _tag,
            attributes: _attributes,
            // jshint ignore:start
            // spread is not ES9 compliant
            children: _children.reduce((a, child) => ({
              ...a,
              [child._id]: cls.DebugHelper.getJsonAui(child._id, aui)
            }), {})
            // jshint ignore:end
          };
        }
      };
    });
  });
;

"use strict";

modulum('EncodingHelper',
  function(context, cls) {

    /**
     * Helper to use Encodig
     * @namespace classes.EncodingHelper
     */
    cls.EncodingHelper = context.oo.StaticClass(function() {
      return /** @lends classes.EncodingHelper */ {
        __name: "EncodingHelper",

        /**
         * UTf-16 authorized codes for specific encoding
         */
        _EncodingTable: {
          'ascii': [
            [1, 127]
          ],
          'iso-8859-1': [
            [1, 127],
            [129, 129],
            [141, 141],
            [143, 144],
            [157, 157],
            [160, 255],
            [338, 339],
            [352, 353],
            [376, 376],
            [381, 382],
            [402, 402],
            [710, 710],
            [732, 732],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'iso-8859-2': [
            [1, 160],
            [164, 164],
            [167, 168],
            [173, 173],
            [176, 176],
            [180, 180],
            [184, 184],
            [193, 194],
            [196, 196],
            [199, 199],
            [201, 201],
            [203, 203],
            [205, 206],
            [211, 212],
            [214, 215],
            [218, 218],
            [220, 221],
            [223, 223],
            [225, 226],
            [228, 228],
            [231, 231],
            [233, 233],
            [235, 235],
            [237, 238],
            [243, 244],
            [246, 247],
            [250, 250],
            [252, 253],
            [258, 263],
            [268, 273],
            [280, 283],
            [313, 314],
            [317, 318],
            [321, 324],
            [327, 328],
            [336, 337],
            [340, 341],
            [344, 347],
            [350, 357],
            [366, 369],
            [377, 382],
            [711, 711],
            [728, 729],
            [731, 731],
            [733, 733]
          ],
          'iso-8859-3': [
            [1, 160],
            [163, 164],
            [167, 168],
            [173, 173],
            [176, 176],
            [178, 181],
            [183, 184],
            [189, 189],
            [192, 194],
            [196, 196],
            [199, 207],
            [209, 212],
            [214, 215],
            [217, 220],
            [223, 226],
            [228, 228],
            [231, 239],
            [241, 244],
            [246, 247],
            [249, 252],
            [264, 267],
            [284, 289],
            [292, 295],
            [304, 305],
            [308, 309],
            [348, 351],
            [364, 365],
            [379, 380]
          ],
          'iso-8859-4': [
            [1, 160],
            [164, 164],
            [167, 168],
            [173, 173],
            [175, 176],
            [180, 180],
            [184, 184],
            [193, 198],
            [201, 201],
            [203, 203],
            [205, 206],
            [212, 216],
            [218, 220],
            [223, 223],
            [225, 230],
            [233, 233],
            [235, 235],
            [237, 238],
            [244, 248],
            [250, 252],
            [256, 257],
            [260, 261],
            [268, 269],
            [272, 275],
            [278, 281],
            [290, 291],
            [296, 299],
            [302, 303],
            [310, 312],
            [315, 316],
            [325, 326],
            [330, 333],
            [342, 343],
            [352, 353],
            [358, 363],
            [370, 371],
            [381, 382],
            [711, 711],
            [729, 729],
            [731, 731]
          ],
          'iso-8859-5': [
            [1, 160],
            [167, 167],
            [173, 173],
            [1025, 1036],
            [1038, 1103],
            [1105, 1116],
            [1118, 1119],
            [8470, 8470]
          ],
          'iso-8859-6': [
            [1, 160],
            [164, 164],
            [173, 173],
            [1548, 1548],
            [1563, 1563],
            [1567, 1567],
            [1569, 1594]
          ],
          'iso-8859-7': [
            [1, 160],
            [163, 163],
            [166, 169],
            [171, 173],
            [176, 179],
            [183, 183],
            [187, 187],
            [189, 189],
            [890, 890],
            [900, 902],
            [904, 906],
            [908, 908],
            [910, 929],
            [931, 974],
            [8213, 8213],
            [8216, 8217],
            [8364, 8364],
            [8367, 8367]
          ],
          'iso-8859-8': [
            [1, 160],
            [162, 169],
            [171, 185],
            [187, 190],
            [215, 215],
            [247, 247],
            [1488, 1514],
            [8206, 8207],
            [8215, 8215]
          ],
          'iso-8859-9': [
            [1, 127],
            [129, 129],
            [141, 144],
            [157, 158],
            [160, 207],
            [209, 220],
            [223, 239],
            [241, 252],
            [255, 255],
            [286, 287],
            [304, 305],
            [338, 339],
            [350, 353],
            [376, 376],
            [402, 402],
            [710, 710],
            [732, 732],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'iso-8859-10': [
            [1, 160],
            [167, 167],
            [173, 173],
            [176, 176],
            [183, 183],
            [193, 198],
            [201, 201],
            [203, 203],
            [205, 208],
            [211, 214],
            [216, 216],
            [218, 223],
            [225, 230],
            [233, 233],
            [235, 235],
            [237, 240],
            [243, 246],
            [248, 248],
            [250, 254],
            [256, 257],
            [260, 261],
            [268, 269],
            [272, 275],
            [278, 281],
            [290, 291],
            [296, 299],
            [302, 303],
            [310, 312],
            [315, 316],
            [325, 326],
            [330, 333],
            [352, 353],
            [358, 363],
            [370, 371],
            [381, 382],
            [8213, 8213]
          ],
          'iso-8859-11': [
            [1, 127],
            [129, 132],
            [134, 144],
            [152, 160],
            [3585, 3642],
            [3647, 3675],
            [8211, 8212],
            [8216, 8217],
            [8220, 8221],
            [8226, 8226],
            [8230, 8230],
            [8364, 8364]
          ],
          'iso-8859-13': [
            [1, 160],
            [162, 164],
            [166, 167],
            [169, 169],
            [171, 174],
            [176, 179],
            [181, 183],
            [185, 185],
            [187, 190],
            [196, 198],
            [201, 201],
            [211, 211],
            [213, 216],
            [220, 220],
            [223, 223],
            [228, 230],
            [233, 233],
            [243, 243],
            [245, 248],
            [252, 252],
            [256, 257],
            [260, 263],
            [268, 269],
            [274, 275],
            [278, 281],
            [290, 291],
            [298, 299],
            [302, 303],
            [310, 311],
            [315, 316],
            [321, 326],
            [332, 333],
            [342, 343],
            [346, 347],
            [352, 353],
            [362, 363],
            [370, 371],
            [377, 382],
            [8217, 8217]
          ],
          'iso-8859-14': [
            [1, 160],
            [163, 163],
            [167, 167],
            [169, 169],
            [173, 174],
            [182, 182],
            [192, 207],
            [209, 214],
            [216, 221],
            [223, 239],
            [241, 246],
            [248, 253],
            [255, 255],
            [266, 267],
            [288, 289],
            [372, 376],
            [7682, 7683],
            [7690, 7691],
            [7710, 7711],
            [7744, 7745],
            [7766, 7767],
            [7776, 7777],
            [7786, 7787],
            [7808, 7813]
          ],
          'iso-8859-15': [
            [1, 163],
            [165, 165],
            [167, 167],
            [169, 179],
            [181, 183],
            [185, 187],
            [191, 255],
            [338, 339],
            [352, 353],
            [376, 376],
            [381, 382],
            [8364, 8364]
          ],
          'iso-8859-16': [
            [1, 160],
            [167, 167],
            [169, 169],
            [171, 171],
            [173, 173],
            [176, 177],
            [182, 183],
            [187, 187],
            [192, 194],
            [196, 196],
            [198, 207],
            [210, 212],
            [214, 214],
            [217, 220],
            [223, 226],
            [228, 228],
            [230, 239],
            [242, 244],
            [246, 246],
            [249, 252],
            [255, 255],
            [258, 263],
            [268, 269],
            [272, 273],
            [280, 281],
            [321, 324],
            [336, 339],
            [346, 347],
            [352, 353],
            [368, 369],
            [376, 382],
            [536, 539],
            [8221, 8222],
            [8364, 8364]
          ],
          'windows-1250': [
            [1, 127],
            [129, 129],
            [131, 131],
            [136, 136],
            [144, 144],
            [152, 152],
            [160, 160],
            [164, 164],
            [166, 169],
            [171, 174],
            [176, 177],
            [180, 184],
            [187, 187],
            [193, 194],
            [196, 196],
            [199, 199],
            [201, 201],
            [203, 203],
            [205, 206],
            [211, 212],
            [214, 215],
            [218, 218],
            [220, 221],
            [223, 223],
            [225, 226],
            [228, 228],
            [231, 231],
            [233, 233],
            [235, 235],
            [237, 238],
            [243, 244],
            [246, 247],
            [250, 250],
            [252, 253],
            [258, 263],
            [268, 273],
            [280, 283],
            [313, 314],
            [317, 318],
            [321, 324],
            [327, 328],
            [336, 337],
            [340, 341],
            [344, 347],
            [350, 357],
            [366, 369],
            [377, 382],
            [711, 711],
            [728, 729],
            [731, 731],
            [733, 733],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1251': [
            [1, 127],
            [152, 152],
            [160, 160],
            [164, 164],
            [166, 167],
            [169, 169],
            [171, 174],
            [176, 177],
            [181, 183],
            [187, 187],
            [1025, 1036],
            [1038, 1103],
            [1105, 1116],
            [1118, 1119],
            [1168, 1169],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8470, 8470],
            [8482, 8482]
          ],
          'windows-1252': [
            [1, 127],
            [129, 129],
            [141, 141],
            [143, 144],
            [157, 157],
            [160, 255],
            [338, 339],
            [352, 353],
            [376, 376],
            [381, 382],
            [402, 402],
            [710, 710],
            [732, 732],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1253': [
            [1, 127],
            [129, 129],
            [136, 136],
            [138, 138],
            [140, 144],
            [152, 152],
            [154, 154],
            [156, 160],
            [163, 169],
            [171, 174],
            [176, 179],
            [181, 183],
            [187, 187],
            [189, 189],
            [402, 402],
            [900, 902],
            [904, 906],
            [908, 908],
            [910, 929],
            [931, 974],
            [8211, 8213],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1254': [
            [1, 127],
            [129, 129],
            [141, 144],
            [157, 158],
            [160, 207],
            [209, 220],
            [223, 239],
            [241, 252],
            [255, 255],
            [286, 287],
            [304, 305],
            [338, 339],
            [350, 353],
            [376, 376],
            [402, 402],
            [710, 710],
            [732, 732],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1255': [
            [1, 127],
            [129, 129],
            [138, 138],
            [140, 144],
            [154, 154],
            [156, 163],
            [165, 169],
            [171, 185],
            [187, 191],
            [215, 215],
            [247, 247],
            [402, 402],
            [710, 710],
            [732, 732],
            [1456, 1475],
            [1488, 1514],
            [1520, 1524],
            [8206, 8207],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8362, 8362],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1256': [
            [1, 127],
            [160, 160],
            [162, 169],
            [171, 185],
            [187, 190],
            [215, 215],
            [224, 224],
            [226, 226],
            [231, 235],
            [238, 239],
            [244, 244],
            [247, 247],
            [249, 249],
            [251, 252],
            [338, 339],
            [402, 402],
            [710, 710],
            [1548, 1548],
            [1563, 1563],
            [1567, 1567],
            [1569, 1594],
            [1600, 1618],
            [1657, 1657],
            [1662, 1662],
            [1670, 1670],
            [1672, 1672],
            [1681, 1681],
            [1688, 1688],
            [1705, 1705],
            [1711, 1711],
            [1722, 1722],
            [1726, 1726],
            [1729, 1729],
            [1746, 1746],
            [8204, 8207],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1257': [
            [1, 127],
            [129, 129],
            [131, 131],
            [136, 136],
            [138, 138],
            [140, 140],
            [144, 144],
            [152, 152],
            [154, 154],
            [156, 156],
            [159, 160],
            [162, 164],
            [166, 169],
            [171, 185],
            [187, 190],
            [196, 198],
            [201, 201],
            [211, 211],
            [213, 216],
            [220, 220],
            [223, 223],
            [228, 230],
            [233, 233],
            [243, 243],
            [245, 248],
            [252, 252],
            [256, 257],
            [260, 263],
            [268, 269],
            [274, 275],
            [278, 281],
            [290, 291],
            [298, 299],
            [302, 303],
            [310, 311],
            [315, 316],
            [321, 326],
            [332, 333],
            [342, 343],
            [346, 347],
            [352, 353],
            [362, 363],
            [370, 371],
            [377, 382],
            [711, 711],
            [729, 729],
            [731, 731],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8364, 8364],
            [8482, 8482]
          ],
          'windows-1258': [
            [1, 127],
            [129, 129],
            [138, 138],
            [141, 144],
            [154, 154],
            [157, 158],
            [160, 194],
            [196, 203],
            [205, 207],
            [209, 209],
            [211, 212],
            [214, 220],
            [223, 226],
            [228, 235],
            [237, 239],
            [241, 241],
            [243, 244],
            [246, 252],
            [255, 255],
            [258, 259],
            [272, 273],
            [338, 339],
            [376, 376],
            [402, 402],
            [416, 417],
            [431, 432],
            [710, 710],
            [732, 732],
            [768, 769],
            [771, 771],
            [777, 777],
            [803, 803],
            [8211, 8212],
            [8216, 8218],
            [8220, 8222],
            [8224, 8226],
            [8230, 8230],
            [8240, 8240],
            [8249, 8250],
            [8363, 8364],
            [8482, 8482]
          ]
        },

        /**
         * UTf-16 full width codes
         */
        _FullWidthChar: [
          [0x1100, 0x115F], // Hangul Jamo,
          [0x11A3, 0x11A7], // Hangul Jamo,
          [0x11FA, 0x11FF], // Hangul Jamo,
          [0x2329, 0x232A], // Miscellaneous Technical,
          [0x2E80, 0x2E99], // CJK Radicals Supplement,
          [0x2E9B, 0x2EF3], // CJK Radicals Supplement,
          [0x2F00, 0x2FD5], // Kangxi Radicals,
          [0x2FF0, 0x2FFB], // Ideographic Description Characters,
          [0x3000, 0x303E], // CJK Symbols and Punctuation,
          [0x3041, 0x3096], // Hiragana,
          [0x3099, 0x30FF], // Hiragana,
          [0x3105, 0x312D], // Bopomofo,
          [0x3131, 0x318E], // Hangul Compatibility Jamo,
          [0x3190, 0x31BA], // Kanbun + Bopomofo Extended,
          [0x31C0, 0x31E3], // CJK Strokes,
          [0x31F0, 0x321E], // Katakana Phonetic Extensions,
          [0x3220, 0x3247], // Enclosed CJK Letters and Months,
          [0x3250, 0x32FE], // Enclosed CJK Letters and Months,
          [0x3300, 0x4DBF], // CJK Compatibility + CJK Unified Ideographs Extension A,
          [0x4E00, 0xA48C], // CJK Unified Ideographs + Yi Syllables,
          [0xA490, 0xA4C6], // Yi Radicals,
          [0xA960, 0xA97C], // Hangul Jamo Extended-A,
          [0xAC00, 0xD7A3], // Hangul Syllables,
          [0xD7B0, 0xD7C6], // Hangul Jamo Extended-B,
          [0xD7CB, 0xD7FB], // Hangul Jamo Extended-B,
          [0xF900, 0xFAFF], // CJK Compatibility Ideographs,
          [0xFE10, 0xFE19], // Variation Selectors,
          [0xFE30, 0xFE52], // CJK Compatibility Forms + Small Form Variants,
          [0xFE54, 0xFE66], // Small Form Variants,
          [0xFE68, 0xFE6B], // Small Form Variants,
          [0xFF01, 0xFF60], // Halfwidth and Fullwidth Forms,
          [0xFFE0, 0xFFE6], // Specials --,
          [0x01B000, 0x01B001], // Kana Supplement,
          [0x01F200, 0x01F202], // Enclosed Ideographic Supplement,
          [0x01F210, 0x01F23A], // Enclosed Ideographic Supplement,
          [0x01F240, 0x01F248], // Enclosed Ideographic Supplement,
          [0x01F250, 0x01F251], // Enclosed Ideographic Supplement,
          [0x020000, 0x02FFFD], // CJK Unified Ideographs Extension B,
          [0x030000, 0x03FFFD] // CJK Unified Ideographs Extension G
        ],

        _VmEncoding: "utf-8",

        /**
         * Text encoder for utf-8 string byte count
         */
        _TextEncoder: new TextEncoder(),

        /**
         * Get the VM encoding
         * @return {string}
         */
        getVMEncoding: function() {
          return this._VmEncoding;
        },

        /**
         * Set the VM encoding
         * @param encoding
         */
        setVMEncoding: function(encoding) {
          this._VmEncoding = encoding;
        },

        /**
         * @param {string} str
         * @return {number} string byte count for big5 encoding
         */
        big5Count: function(str) {
          let n = 0;

          let i = 0;
          const l = str.length;
          for (; i < l; i++) {
            const hi = str.charCodeAt(i);
            if (hi < 0x0080) { //[0x0000, 0x007F]
              n += 1;
            } else {
              n += 2;
            }
          }

          return n;
        },

        /**
         * @param {string} str
         * @return {number} string byte count for utf-8 encoding
         */
        utf8Count: function(str) {
          return this._TextEncoder.encode(str).length;
        },

        /**
         * @param {string} str
         * @return {number} string byte count for iso-8859-xxx encoding
         */
        iso8859Count: function(str) {
          return str.length;
        },

        /**
         * Give the display width of str
         * @param {string} str
         * @return {number}
         */
        displayWidth: function(str) {
          let width = 0;

          for (let i = 0; i < str.length; i++) {
            const unicode = str.charCodeAt(i);
            let fullWidth = false;
            for (let j = 0; j < this._FullWidthChar.length && !fullWidth && this._FullWidthChar[j][0] <= unicode; j++) {
              if (this._FullWidthChar[j][0] <= unicode && unicode <= this._FullWidthChar[j][1]) {
                fullWidth = true;
              }
            }

            width += fullWidth ? 2 : 1;
          }

          return width;
        },

        /**
         * Remove unauthorized char for the current encoding
         * @param {string} str string to fix
         * @return {string} return a clean string
         */
        removeUnknownChar: function(str) {
          let res = "";
          const table = this._EncodingTable[this._VmEncoding];

          if (!table) {
            return str;
          }

          for (let i = 0; i < str.length; i++) {
            const unicode = str.charCodeAt(i);
            if (String.charExistInEncoding(table, unicode)) {
              res += str.substring(i, i + 1);
            }
          }

          return res;
        }

      };
    });
  }
);
;

"use strict";

modulum('Factory', ['LogService'],
  function(context, cls) {
    /**
     * @memberOf classes
     * @class Factory
     * @template T
     * @memberOf classes
     */
    cls.Factory = context.oo.Class(function() {
      return /** @lends classes.Factory.prototype */ {
        __name: "Factory",
        _default: null,
        _fabrics: null,
        _topic: "",
        /**
         * @constructs
         * @param {string} topic
         * @param {?function=} defaultConstructor
         */
        constructor: function(topic, defaultConstructor) {
          this._topic = topic;
          this._default = defaultConstructor || null;
          this._fabrics = {};
        },
        /**
         *
         * @param {?function=} constructor
         */
        setDefault: function(constructor) {
          this._default = constructor;
        },
        /**
         *
         * @param {string} id
         * @param {function} constructor
         */
        register: function(id, constructor) {
          if (this._fabrics[id]) {
            context.LogService.log("Factory (" + this._topic + ") already registered : " + id);
          }
          if (typeof(constructor) === "function") {
            this._fabrics[id] = constructor;
          }
        },
        /**
         *
         * @param {string} id
         */
        unregister: function(id) {
          this._fabrics[id] = null;
        },
        /**
         *
         * @param {string} id
         */
        has: function(id) {
          return Boolean(this._fabrics[id]);
        },
        /**
         *
         * @param {string} id
         * @returns {T}
         */
        create: function(id, arg1, arg2, arg3, arg4, arg5) {
          const Fabric = this._fabrics[id] || this._default;
          if (Fabric) {
            return new Fabric(arg1, arg2, arg3, arg4, arg5);
          }
          context.LogService.log("Factory (" + this._topic + ") not found : " + id);
          return null;
        }
      };
    });
  });
;

"use strict";

modulum('KeyboardHelper',
  function(context, cls) {

    /**
     * Helper functions for keyboard.
     * @namespace classes.KeyboardHelper
     */
    cls.KeyboardHelper = context.oo.StaticClass(function() {
      return /** @lends classes.KeyboardHelper */ {
        __name: "KeyboardHelper",

        /**
         *
         * @param sequence
         * @return {boolean}
         */
        isModifier: function(sequence) {
          return ["ctrl", "shift", "alt", "meta"].indexOf(sequence) !== -1;
        },

        /**
         *
         * @param {string} keyString - string of the key
         * @return {boolean}
         */
        isSpecialCommand: function(keyString) {
          let result = ["home", "end", "left", "right", "up", "down", "del", "backspace"].contains(keyString);
          result = result || (keyString.startsWith("ctrl+") || keyString.startsWith("meta+")) && keyString.indexOf("alt") === -1;
          return result;
        },

        /**
         *
         * @param char
         * @return {boolean}
         */
        isDecimal: function(char) {
          return /^[,.+\-0-9]+$/.test(char);
        },
        /**
         *
         * @param char
         * @return {boolean}
         */
        isNumeric: function(char) {
          return /^\d+$/.test(char);
        },

        /**
         * Check if a string length is equal to 1
         * @param {string} str
         * @returns {boolean}
         */
        isChar: function(str) {
          return str.length === 1;
        },
        /**
         *
         * @param char
         * @return {boolean}
         */
        isLetter: function(char) {
          return /^[A-Za-z\u00C0-\u017F]+$/.test(char); // alphabetic characters + special accent chars
        },

        /**
         * Validate new number with typed char at specified position
         * @param initialValue
         * @param position
         * @param typedChar
         * @param min
         * @param max
         * @returns {boolean}
         */
        validateNumber: function(initialValue, position, typedChar, min, max) {
          let newVal = "";
          if (position === 0) {
            newVal = typedChar + initialValue;
          } else {
            newVal = initialValue.substr(0, position) + typedChar + initialValue.substr(position);
          }
          if (newVal === '-' || newVal === '+') {
            return true;
          } else {
            // TODO what happens if newVal contains ',' shall we not replace ',' by '.' ?
            const newNumber = parseInt(newVal, 10);

            return !(isNaN(newVal) || (max !== null && newNumber > max) || (min !== null && newNumber < min));
          }
        },

        /**
         * Convert VM bindings to key combination that we can interpret in a browser
         * @param {string} bindName - vm key to convert to dom key
         * @returns {string} browser key combination
         */
        convertVMKeyToBrowserKey: function(bindName) {
          let key = bindName.toString().toLowerCase(); // VM returns all accelerators in lowercase
          if (key === "return") {
            return "enter";
          }
          key = key.replace("prior", "pageup");
          key = key.replace("next", "pagedown");
          key = key.replace("-", "+");
          key = key.replace("control", "ctrl");
          return key;
        },

        /**
         * Transform key to vmKey
         * @param {string} bindName browserKey
         * @returns {string} vmKey
         */
        convertBrowserKeyToVMKey: function(bindName) {
          let key = (bindName || "");
          key = key.toLowerCase();
          key = key.replace("pageup", "prior");
          key = key.replace("pagedown", "next");
          // Special case where the accelerator is '+'
          if (key.length !== 1) {
            key = key.replace(/\+/g, '-');
          }
          key = key.replace("ctrl", "control");
          key = key.replace("meta", "control"); //  macOS command key acts as control key in our cases
          key = key.replace("esc", "escape");
          return key;
        }
      };
    });
  });
;

'use strict';

modulum('ModelHelper', ['EventListener'],
  function(context, cls) {
    /**
     * Helper to ease AUI tree access for customized widgets,
     * Manages client side life cycle representation of the node.
     * @class ModelHelper
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.ModelHelper = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ModelHelper.prototype */ {
        __name: 'ModelHelper',

        /** @type {classes.WidgetBase} */
        _widget: null,
        /** @type {?Function[]} */
        _newApplicationsListeners: null,
        /** @type {?Function[]} */
        _closeApplicationsListeners: null,
        /** @type {?Function[]} */
        _sessionEndListeners: null,
        /** @type {?Function[]} */
        _auiUpdateListeners: null,
        /** @type {?Function[]} */
        _currentWindowListeners: null,
        /** @type {?Function[]} */
        _activeListenersHandlers: null,

        /**
         * @constructs
         * @param {classes.WidgetBase} widget the widget to handle
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;
        },

        /**
         * Unbind all active listeners and destroy the current instance.
         */
        destroy: function() {
          // unbind all active listeners
          let h = null;
          if (this._activeListenersHandlers) {
            while (this._activeListenersHandlers.length > 0) {
              h = this._activeListenersHandlers.pop();
              if (h) {
                h(); // unregister listener
              }
            }
            h = null;
            this._activeListenersHandlers = null;
          }
          this._newApplicationsListeners = null;
          this._closeApplicationsListeners = null;
          this._sessionEndListeners = null;
          this._auiUpdateListeners = null;
          this._currentWindowListeners = null;

          this._widget = null;
          $super.destroy.call(this);
        },

        /**
         * Registers a listener which will be called when a new application is started
         * @param listener {Function=} - the function to call when a new application is started
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for new applications
         * @publicdoc
         */
        addNewApplicationListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._newApplicationsListeners === null) {
            this._newApplicationsListeners = [];

            const onApplicationAdded = function(event, sender, app) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (let i = 0; this._newApplicationsListeners && i < this._newApplicationsListeners.length; ++i) {
                this._newApplicationsListeners[i](app);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded,
                  onApplicationAdded));
              }
            }.bind(this)));
            const session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded, onApplicationAdded));
            }
          }
          this._newApplicationsListeners.push(listener);

          return function() {
            if (this._newApplicationsListeners) {
              this._newApplicationsListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when an application is closed
         * @param listener {Function=} - the function to call when an application is closed
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for closed applications
         * @publicdoc
         */
        addCloseApplicationListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._closeApplicationsListeners === null) {
            this._closeApplicationsListeners = [];

            const onApplicationClosed = function(event, sender, app) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (let i = 0; this._closeApplicationsListeners && i < this._closeApplicationsListeners.length; ++i) {
                this._closeApplicationsListeners[i](app);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationRemoved,
                  onApplicationClosed));
              }
            }.bind(this)));
            const session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationRemoved, onApplicationClosed));
            }
          }
          this._closeApplicationsListeners.push(listener);

          return function() {
            if (this._closeApplicationsListeners) {
              this._closeApplicationsListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when all applications are closed and session end page is displayed.
         * @param listener {Function=} - the function to call when session end page is displayed
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for session end
         * @publicdoc
         */
        addSessionEndListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._sessionEndListeners === null) {
            this._sessionEndListeners = [];

            const onSessionEndClosed = function(event, sender, sessionId) {
              // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
              for (let i = 0; this._sessionEndListeners && i < this._sessionEndListeners.length; ++i) {
                this._sessionEndListeners[i](sessionId);
              }
            }.bind(this);

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, sender, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.displayEnd, onSessionEndClosed));
              }
            }.bind(this)));
            const session = context.SessionService.getCurrent();
            if (session) {
              this._activeListenersHandlers.push(session.when(context.constants.baseEvents.displayEnd, onSessionEndClosed));
            }
          }
          this._sessionEndListeners.push(listener);

          return function() {
            if (this._sessionEndListeners) {
              this._sessionEndListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when the current window changes
         * @param listener {Function=} - the function to call when the current window changes
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for window changes
         * @publicdoc
         */
        addCurrentWindowChangeListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._currentWindowListeners === null) {
            this._currentWindowListeners = [];

            this._activeListenersHandlers.push(context.HostService.onCurrentWindowChange(
              /**
               * @param {classes.Event} event event object
               * @param {Object} src event emitter
               * @param {classes.WindowWidget} win data
               */
              function(event, sender, win) {
                let i;
                let windowNode = null;
                let w = win;
                let appHash = null;
                while (w) {
                  if (w._appHash !== undefined) {
                    appHash = w._appHash;
                    break;
                  }
                  w = w.getParentWidget();
                }
                if (appHash !== null) {
                  let app = null;
                  const session = context.SessionService.getCurrent();
                  for (i = 0; i < session._applications.length; ++i) {
                    const a = session._applications[i];
                    if (a.applicationHash === appHash) {
                      app = a;
                      break;
                    }
                  }
                  windowNode = app?.model.getNode(win._auiTag);
                }
                // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
                for (i = 0; this._currentWindowListeners && i < this._currentWindowListeners.length; ++i) {
                  this._currentWindowListeners[i](windowNode);
                }
              }.bind(this)));
          }
          this._currentWindowListeners.push(listener);

          return function() {
            if (this._currentWindowListeners) {
              this._currentWindowListeners.remove(listener);
            }
          }.bind(this);
        },

        /**
         * Registers a listener which will be called when any DVM answer is received.
         * You can update your widget in the provided callback
         * This listening method is general to all started applications. If your UI updates are heavy, prefer more fine-grained update notification mechanisms
         * @param {Function=} listener - the function to call when a new application is started
         * @returns {function(this:classes.ModelHelper)} The unregister handler. Simply call this function to stop listening for new applications
         * @publicdoc
         */
        addAuiUpdateListener: function(listener) {
          if (this._activeListenersHandlers === null) {
            this._activeListenersHandlers = [];
          }
          if (this._auiUpdateListeners === null) {
            this._auiUpdateListeners = [];

            this._activeListenersHandlers.push(context.SessionService.onSessionAdded(function(event, session) {
              // If null, widget may have been destroyed. We stop to create listeners. Otherwise, we attach new one.
              if (this._activeListenersHandlers) {
                this._activeListenersHandlers.push(session.when(context.constants.baseEvents.applicationAdded, this._onApplicationAdded
                  .bind(this)));
              }
            }.bind(this)));
            const session = context.SessionService.getCurrent();
            if (session) {
              for (const element of session._applications) {
                this._activeListenersHandlers.push(element.dvm.onOrdersManaged(this._dispatchUpdate.bind(this)));
              }
            }
          }
          this._auiUpdateListeners.push(listener);
          return function() {
            if (this._auiUpdateListeners) {
              this._auiUpdateListeners.remove(listener);
            }
          }.bind(this);
        },

        _dispatchUpdate: function(event, src, data) {
          // for each iteration we recheck if array is defined because modelhelper may have been destroyed in a previous iteration
          for (let i = 0; this._auiUpdateListeners && i < this._auiUpdateListeners.length; ++i) {
            this._auiUpdateListeners[i](src, data);
          }
        },

        _onApplicationAdded: function(event, app) {
          if (this._activeListenersHandlers) {
            this._activeListenersHandlers.push(app.dvm.onOrdersManaged(this._dispatchUpdate.bind(this)));
          }
        },

        /**
         * Get the current application
         * @returns {?classes.VMApplication} the currently visible application or null if it cannot be found.
         * @publicdoc
         */
        getCurrentApplication: function() {
          const session = context.SessionService.getCurrent();
          if (session) {
            return session.getCurrentApplication();
          }
          return null;
        },

        /**
         * Get the widget application
         * @returns {?classes.VMApplication} the VM application to which this widget is attached. null if the widget isn't below a VM application
         * @publicdoc
         */
        getApplication: function() {
          const session = context.SessionService.getCurrent();
          if (session) {
            for (const app of session.getApplications()) {
              if (app.applicationHash === this._widget._appHash) {
                return app;
              }
            }
          }
          return null;
        },

        /**
         * Get a node with its id
         * @param {number} idRef - the VM id of the node to return
         * @returns {?classes.NodeBase} the requested node or null if it couldn't be found
         * @publicdoc
         */
        getNode: function(idRef) {
          const app = this.getApplication();
          if (app) {
            return app.model.getNode(idRef);
          }
          return null;
        },

        /**
         * Get the UserInterface Node
         * @returns {?classes.NodeBase} the UserInterface node of the current application or null if it couldn't be found
         * @publicdoc
         */
        getUserInterfaceNode: function() {
          return this.getNode(0);
        },

        /**
         * Get Anchor Node of the widget
         * @returns {?classes.NodeBase} the AUI anchor node of this widget. Generally the corresponding node or the node holding the displayed value
         * @publicdoc
         */
        getAnchorNode: function() {
          if (this._widget._auiTag !== null) {
            const app = this.getApplication();
            if (app) {
              return app.model.getNode(this._widget._auiTag);
            }
          }
          return null;
        },

        /**
         * Applies only to entry fields (FormField, Matrix or TableColumn)
         * @returns {?classes.NodeBase} the field node corresponding to the widget or null if it doesn't apply
         * @publicdoc
         */
        getFieldNode: function() {
          const anchorNode = this.getAnchorNode();
          if (anchorNode) {
            if (anchorNode.getTag() === 'FormField') {
              return anchorNode;
            } else if (anchorNode.getTag() === 'Value') {
              return anchorNode.getParentNode().getParentNode();
            }
          }
          return null;
        },

        /**
         * Applies only to entry fields (FormField, Matrix or TableColumn)
         * A decoration node is the node holding visual information (Edit, CheckBox, ComboBox, etc...)
         * @returns {?classes.NodeBase} the decoration node corresponding to the widget or null if it doesn't apply
         * @publicdoc
         */
        getDecorationNode: function() {
          const fieldNode = this.getFieldNode();
          if (fieldNode) {
            return fieldNode.getChildren()[0];
          }
          return null;
        },

        /**
         * Try to find & execute an action by name (search in the active Dialog/Menu of the current Window).
         * Note that the focused widget with pending changes will send its value to the VM
         * @param {string} name of the action
         * @returns {boolean} true if an action has been found and executed, false otherwise.
         * @publicdoc
         */
        executeActionByName: function(name) {
          let actionExecuted = false;
          const currentApp = this.getCurrentApplication();
          if (currentApp) {
            // TODO GBC-1760 we should use ActionApplicationService to search an action
            const activeWindow = currentApp.getVMWindow();
            if (activeWindow) {
              const activeDialog = activeWindow.getActiveDialog();
              if (activeDialog) {
                const action = activeDialog.getFirstChildWithAttribute(null, 'name', name);
                if (action) {
                  currentApp.action.execute(action.getId(), null, {
                    sendValue: true
                  });
                  actionExecuted = true;
                }
              }
            }
          }
          return actionExecuted;
        }
      };
    });
  }
);
;

"use strict";

modulum('NodeHelper',
  function(context, cls) {
    /**
     * Memory implementation of an AUI Node.
     *
     * Reflects the state of the AUI node in the DVM.
     *
     * @namespace classes.NodeHelper
     * @extends classes.EventListener
     */
    cls.NodeHelper = context.oo.StaticClass(function() {
      return /** @lends classes.NodeHelper */ {
        /**
         *
         * @param {string} nodeTag
         */
        getDefaultAttributes: function(nodeTag) {
          const result = context.constants.nodeAttributes[nodeTag];
          return result || [];
        },
        /**
         *
         * @param {classes.NodeBase} node
         * @param {string} attributeName
         */
        setAttributeDefaultValue: function(node, attributeName) {
          node._attributes[attributeName] = this.getAttributeDefaultValue(node._tag, attributeName);
        },
        /**
         *
         * @param {string} nodeTag
         * @param {string} attributeName
         */
        getAttributeDefaultValue: function(nodeTag, attributeName) {
          let value = null;
          const defaultsForTag = context.constants.attributeDefaultValuesByNodeType[nodeTag];
          const defaultsForAny = context.constants.attributeDefaultValues;

          if (defaultsForTag && defaultsForTag.hasOwnProperty(attributeName)) {
            value = defaultsForTag[attributeName];
          } else {
            value = defaultsForAny[attributeName];
          }
          return value;
        },
        /**
         *
         * @param {classes.NodeBase} node
         * @param {classes.NodeBase=} originNode
         */
        addToParentWidget: function(node, originNode) {
          originNode = originNode || node;
          if (!originNode.getController()) {
            this.failed("adding from node without controller", originNode._tag);
          } else if (!originNode.getController().getWidget()) {
            this.failed("adding from node without widget", originNode._tag);
          } else {
            node = node.getParentNode();
            if (!node) {
              if (originNode._id > 0) { // Don't display error for UserInterface which doesn't have parent
                this.failed("could not find parent widget", originNode._tag);
              }
            } else {
              if (!node.getController()) {
                this.addToParentWidget(node, originNode);
              } else {
                if (!node.getController().getWidget()) {
                  this.addToParentWidget(node, originNode);
                } else {
                  if (!node.getController().getWidget().addChildWidget) {
                    this.failed("Parent widget cannot hosts children");
                  } else {
                    node.getController().getWidget().addChildWidget(originNode.getController().getWidget());
                  }
                }
              }
            }
          }
        },
        /**
         *
         * @param msg
         * @params {*[]} param
         */
        failed: function(msg, param) {
          gbc.error(msg, param);
        }
      };
    });
  });
;

"use strict";

(
  function(context) {
    /**
     *
     * @type {HTMLElement}
     * @private
     */
    context.__testhostelement = null;
    if (context.gbc.unitTestMode) {
      if (!context.__testhostelement) {
        context.__testhostelement = document.createElement("div");
        context.__testhostelement.setAttribute("class", "unittesthost");

        context.__testhostelement.style.position = "absolute";
        context.__testhostelement.style.top = "-1000px";
        context.__testhostelement.style.left = "-1000px";
        context.__testhostelement.style.width = "600px";
        context.__testhostelement.style.height = "600px";
        context.__testhostelement.style.zIndex = 55;

        document.body.appendChild(context.__testhostelement);
      }
      /**
       * @memberOf gbc
       * @private
       */
      context.gbc.__unitTestingCloseCurrentSession = function() {
        const session = context.gbc.SessionService && context.gbc.SessionService.getCurrent();
        if (session) {
          const apps = session.getApplications().slice(),
            appsLen = apps.length;
          for (let i = 0; i < appsLen; i++) {
            if (apps[i]) {
              apps[i].stop();
              apps[i].destroy();
            }
          }
          let app = session && session.getCurrentApplication();
          while (app) {
            const currentApp = app;
            try {
              app.stop();
              app.destroy();
            } catch (e) {}
            app = session && session.getCurrentApplication();
            app = currentApp !== app && app;
          }
          context.gbc.SessionService.getCurrent().destroy(true);
        }
        if (!window.gbc.__unitTestingModeActivated) {
          window.gbc.__unitTestingModeActivated = true;
          window.gbc.__unitTestingModeActivated = true;
          window.__desactivateEndingPopup = true;
          window.gbc.showExitWarning = function() {};
        }
      };
      /**
       * @memberOf Window
       * @param {classes.NodeBase} node
       * @param attrs
       * @param noApply
       */
      context.testUpdateAttributes = function(node, attrs, noApply) {
        if (node) {
          context.styler.bufferize();
          const mods = [];
          mods[node._id] = true;
          node.updateAttributes(attrs);
          if (!noApply) {
            const treeModificationTrack = new context.gbc.classes.TreeModificationTracker();
            (node._id === 0 ? node : node.getAncestor("UserInterface")).applyBehaviors(treeModificationTrack, true, true);
          }
          context.styler.flush();
        }
      };
    }
  })(window);
;

"use strict";

modulum('ServerHelper',
  function(context, cls) {

    /**
     * Helper for server informations
     * @namespace classes.ServerHelper
     */
    cls.ServerHelper = context.oo.StaticClass(function() {
      return /** @lends classes.ServerHelper */ {
        __name: "ServerHelper",
        verRE: /GAS\/([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9]+))?/,
        /**
         * is version valid
         * @param ver
         * @return {boolean}
         */
        isValid: function(ver) {
          return this.verRE.test(ver);
        },
        /**
         * compare versions
         * @param a
         * @param b
         * @return {number}
         */
        compare: function(a, b) {
          const pa = this.verRE.exec(a) || [];
          const pb = this.verRE.exec(b) || [];
          for (let i = 0; i < 3; i++) {
            const na = Number(pa[i + 1]);
            const nb = Number(pb[i + 1]);
            if (na > nb) {
              return 1;
            }
            if (nb > na) {
              return -1;
            }
            if (!isNaN(na) && isNaN(nb)) {
              return 1;
            }
            if (isNaN(na) && !isNaN(nb)) {
              return -1;
            }
          }
          return 0;
        }
      };
    });
  });
;

"use strict";

modulum('WindowHelper',
  function(context, cls) {

    /**
     * Helper to use Window
     * @namespace classes.WindowHelper
     */
    cls.WindowHelper = context.oo.StaticClass(function() {
      return /** @lends classes.WindowHelper */ {
        __name: "WindowHelper",
        _opened: [],
        /**
         * open browser window
         * @param url
         * @param once
         * @return {Window}
         */
        openWindow: function(url, once) {
          if (once) {
            if (this._opened.indexOf(url) >= 0) {
              return null;
            }
            this._opened.push(url);
          }
          return window.open(url);
        },
        /**
         * close browser window
         */
        closeWindow: function() {
          window.close();
        }
      };
    });
  });
;

"use strict";

modulum('ActionDefaultNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * AUI Node ActionDefault
     *
     * @class ActionDefaultNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ActionDefaultNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ActionDefaultNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("ActionDefault", cls.ActionDefaultNode);
  });
;

"use strict";

modulum('ActionNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * Action node (AUI)
     * @class ActionNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ActionNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ActionNode.prototype */ {

        $static: /** @lends classes.ActionNode */ {
          /**
           * Return true if actionName correspond to a field navigation action
           * @param {string} actionName - name of the action
           * @returns {boolean} true if action is field navigation
           */
          isFieldNavigationAction: function(actionName) {
            return ['nextfield', 'prevfield'].indexOf(actionName) > -1;
          },

          /**
           * Return true if actionName correspond to a table/matrix navigation action
           * @param {string} actionName - name of the action
           * @returns {boolean} true if action is table navigation
           */
          isTableNavigationAction: function(actionName) {
            return ['nextrow', 'prevrow',
              'firstrow', 'lastrow',
              'nextpage', 'prevpage'
            ].indexOf(actionName) > -1;
          },

          /**
           * Returns required accelerator for some specific actions (required by VM)
           * @param {string} actionName - name of the action
           * @returns {string} required accelerator or null
           */
          getRequiredAccelerator: function(actionName) {
            let requiredAccelerator = null;
            if (actionName === 'nextfield') {
              requiredAccelerator = "tab";
            } else if (actionName === 'prevfield') {
              requiredAccelerator = "shift-tab";
            }
            return requiredAccelerator;
          }
        },

        /**
         * Send action event to VM.
         */
        execute: function() {
          const actionService = this.getApplication().getActionApplicationService();
          actionService.execute(this._id);
        }
      };
    });
    cls.NodeFactory.register("Action", cls.ActionNode);
  });
;

"use strict";

modulum('ButtonNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ButtonNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ButtonNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.ButtonNode.prototype */ {
        __name: "ButtonNode",
        /**
         * @inheritDoc
         */
        _createController: function(additionalBindings) {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            additionalBindings: additionalBindings,
            form: this.getAncestor("Form")
          });
        }
      };
    });
    cls.NodeFactory.register("Button", cls.ButtonNode);
  });
;

"use strict";

modulum('FormFieldNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class FormFieldNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.FormFieldNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.FormFieldNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createController: function() {
          const decoratorNode = this._children[0];
          const controllerType = decoratorNode?._tag;
          return cls.ControllerFactory.create(controllerType, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode,
            container: this,
            form: this.getAncestor("Form")
          });
        },
        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {},

        /**
         * @inheritDoc
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          // On FormFields, take the decorator node into account
          const decoratorNode = this.getChildren()[0];
          const pseudoSelectors = forcedPseudoSelectors || this._computePseudoSelectors();
          return decoratorNode._getStyleAttributeImpl(styleAttr, pseudoSelectors);
        }
      };
    });
    cls.NodeFactory.register("FormField", cls.FormFieldNode);
  });
;

"use strict";

modulum('IdleActionNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class IdleActionNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.IdleActionNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.IdleActionNode.prototype */ {

        _timer: null,
        _timeout: 1000,
        _suffix: null,

        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          this._isTimer = this.attribute("isTimer");

          this._suffix = "idleAction_" + id;

          const timeoutAttr = this.attribute("timeout");
          if (timeoutAttr > 0) {
            const timeout = timeoutAttr * 1000 || this._timeout;
            this.setTimeout(timeout);

            if (this._isTimer) {
              this.start();
            } else {
              this.activate();
            }
          }
        },

        /**
         * Stop the timer and start it again
         */
        reset: function() {
          this.stop();
          this._timer = window.setTimeout(this.onTimer.bind(this), this._timeout);
        },

        /**
         * Stop the timer
         */
        stop: function() {
          if (this._timer) {
            window.clearTimeout(this._timer);
            this._timer = null;
          }
        },

        /**
         * Start the timer
         * note: alias for reset()
         */
        start: function() {
          this.reset();
        },

        /**
         * Check if timer is running
         * @returns {boolean} true if running, false otherwise
         */
        isRunning: function() {
          return Boolean(this._timer);
        },

        /**
         * Define the timeout value for this timer
         * @param {number} timeout time in ms
         */
        setTimeout: function(timeout) {
          this._timeout = timeout;
          if (this.isRunning()) {
            this.reset();
          }
        },

        /**
         * Action trigged when timer is over: send the event to the VM
         */
        onTimer: function() {
          this._timer = null;
          if (this.getApplication() && !this.getApplication().ending && !this.getApplication().isBypassedIdleTimer()) {
            //Do not send the event if the parent container is not active
            if (this.getParentNode() && this.getParentNode().attribute("active")) {
              this.getApplication().action.execute(this.getId(), null, {
                noUserActivity: true,
                sendValue: true
              });
            }
            this.getApplication().dvm.onOrdersManaged(this.start.bind(this), true);
          }
        },

        /**
         * Activate the area where the idle will be caught
         */
        activate: function() {

          this._application._ui.getWidget().getElement()
            .on("mousemove." + this._suffix, this.reset.bind(this))
            .on("mousedown." + this._suffix, this.reset.bind(this))
            .on("keydown." + this._suffix, this.reset.bind(this));
          this.start();
        },

        /**
         * Deactivate the area where the idle won't be caught
         */
        desactivate: function() {
          this._application._ui.getWidget().getElement()
            .off("mousemove." + this._suffix)
            .off("mousedown." + this._suffix)
            .off("keydown." + this._suffix);
          this.stop();
        },

        destroy: function() {
          this.stop();
          $super.destroy.call(this);
        }
      };
    });
    cls.NodeFactory.register("IdleAction", cls.IdleActionNode);
  });
;

"use strict";

modulum('ImageFontNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ImageFontNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.ImageFontNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.ImageFontNode.prototype */ {
        _ttfName: null,
        _stylesheetId: null,
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          const ttfFile = this._application.wrapResourcePath(this.attribute("href"));
          this._ttfName = "image2font_" + this.attribute("name").replace(".ttf", "");
          this._stylesheetId = this._ttfName.replace(/\s/g, "_") + this.getApplication().info().session + this.getApplication()
            .applicationHash;
          const styleRules = {
            "@font-face": {
              "font-family": '"' + this._ttfName.trim() + '"',
              "src": "url('" + ttfFile + "')"
            }
          };
          context.styler.appendStyleSheet(styleRules, this._stylesheetId, true);
        },
        destroy: function() {
          context.styler.removeStyleSheet(this._stylesheetId);
          $super.destroy.call(this);
        }
      };
    });
    cls.NodeFactory.register("ImageFont", cls.ImageFontNode);
  });
;

"use strict";

modulum('ItemNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ItemNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ItemNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ItemNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("Item", cls.ItemNode);
  });
;

"use strict";

modulum('MatrixNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class MatrixNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.MatrixNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.MatrixNode.prototype */ {
        __name: "MatrixNode",
        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {
          for (let i = 1; i < this._children.length; i++) {
            this._children[i].createController(_queue);
          }
        },

        /**
         * Will get current value node in matrix
         * @param {boolean} inputModeOnly - return value node only if is node is in INPUT mode
         * @returns {*}
         */
        getCurrentValueNode: function(inputModeOnly) {
          const dialogType = this.attribute('dialogType');
          const isInputMode = (dialogType === "Input" || dialogType === "InputArray" || dialogType === "Construct");
          if (!inputModeOnly || isInputMode) {
            const currentRow = this.attribute("currentRow") || 0;
            const offset = this.attribute("offset");
            const valueIndex = currentRow - offset;
            if (this._children[1]._children[valueIndex]) {
              return this._children[1]._children[valueIndex];
            }
          }
          return null;
        }
      };
    });
    cls.NodeFactory.register("Matrix", cls.MatrixNode);
  });
;

"use strict";

modulum('NoControllerNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class NoControllerNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.NoControllerNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.NoControllerNode.prototype */ {};
    });
    cls.NodeFactory.register("ActionDefaultList", cls.NoControllerNode);
    cls.NodeFactory.register("StyleAttribute", cls.NoControllerNode);
    cls.NodeFactory.register("ImageFonts", cls.NoControllerNode);
    cls.NodeFactory.register("DialogInfo", cls.NoControllerNode);
  });
;

"use strict";
modulum('NodeBase', ['EventListener'],
  function(context, cls) {
    /**
     * Memory implementation of an AUI Node.
     *
     * Reflects the state of the AUI node in the DVM.
     *
     * @class NodeBase
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.NodeBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.NodeBase.prototype */ {
        $static: /** @lends classes.NodeBase */ {
          stylesSeparatorRegExp: /\s+/,
          /**
           * @type {Object.<string, string>}
           */
          __attributeChangedEventNames: {},
          __attributeChangedPrefixEventName: "g_attributeChanged",
          /**
           *
           * @param {string} attrName
           * @return {*}
           */
          attributeChangedEventName: function(attrName) {
            if (!this.__attributeChangedEventNames[attrName]) {
              this.__attributeChangedEventNames[attrName] = this.__attributeChangedPrefixEventName + attrName;
            }
            return this.__attributeChangedEventNames[attrName];
          },

          /**
           * Nodes with some style attributes which must not be inherited
           * list of not inherited styles: notInheritedStyleAttributes
           * @type {string[]}
           */
          nodesWithNotInheritedStyleAttributes: ["FormField", "TopMenu", "ToolBar", "TopMenuGroup",
            "TopMenuCommand", "ToolBarItem", "Button", "MenuAction", "Action", "Group"
          ],

          /**
           * Style attributes which should not be inherited by specific nodes
           * list of nodes: nodesWithNotInheritedStyleAttributes
           * @type {string[]}
           */
          notInheritedStyleAttributes: ["backgroundColor", "border", "collapsible", "initiallyCollapsed", "position"]
        },
        __name: "NodeBase",
        /**
         * parent node in aui tree
         * @type {classes.NodeBase}
         */
        _parent: null,
        _parentInfo: null,
        /**
         * aui id
         * @type {?number}
         */
        _id: null,
        /**
         * children nodes
         * @type {classes.NodeBase[]}
         */
        _children: null,
        /**
         * linked controller
         * @type {classes.ControllerBase}
         */
        _controller: null,
        /**
         * owning application
         * @type {classes.VMApplication}
         */
        _application: null,
        /**
         * node tag name
         * @type {?string}
         */
        _tag: null,
        /**
         * node's attribute set
         * @type {Object.<string, *>}
         * */
        _attributes: null,
        /**
         * flag set of vm provided attributes
         * @type {Object.<string, boolean>}
         * */
        _attributesSetByVM: null,
        /**
         * list of styles applied by the vm
         * @type {string[]}
         */
        _vmStyles: null,
        /**
         * node's attribute values set that where set previously
         * @type {Object.<string, *>}
         */
        _previousAttributes: null,
        /**
         * list
         * @type {Object[]}
         */
        _stylesByPseudoSelectors: null,
        /**
         * list
         * @type {string[]}
         */
        _activePseudoSelectors: null,
        /**
         * list
         * @type {Object}
         */
        _pseudoSelectorsUsedInSubTree: null,
        /**
         * flag
         * @type {boolean}
         */
        _canEmitNodeMutation: false,
        /**
         * list
         * @type {Object.<string, *>}
         */
        _initialStyleAttributes: null,
        /**
         * flag set to true once node is added to DOM
         * @type {boolean}
         */
        _attached: false,
        /**
         * @constructs
         * @param {classes.NodeBase} parent parent node
         * @param {string|nodeInfo} tag tag name (WINDOW, GROUP, MENU, etc...) or an object containing type, id, attributes
         * @param {?number|classes.VMApplication} id id
         * @param {Object=} attributes attributes list
         * @param {classes.VMApplication} app application
         */
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this);

          this._pseudoSelectorsUsedInSubTree = {};

          if (tag?.attributes) {
            app = id;
            attributes = tag.attributes;
            id = tag.id;
            tag = tag.type;
          }
          this._parent = parent;
          this._id = id;
          this._application = app;
          this._children = [];
          this._tag = tag;

          const matrixNode = this.getAncestor("Matrix");
          const scrollGridNode = this.getAncestor("ScrollGrid");
          const tableColumnNode = this.getAncestor("TableColumn");
          const toolBarNode = this.getAncestor('ToolBar');

          this._parentInfo = {
            container: tableColumnNode || matrixNode || scrollGridNode,
            inMatrix: Boolean(matrixNode),
            inScrollGrid: Boolean(scrollGridNode),
            inTable: Boolean(tableColumnNode),
            inToolBar: Boolean(toolBarNode),
            inStack: Boolean(this.getAncestor("Stack")) // TODO Deprecated ?
          };

          this._attributes = {};
          this._vmStyles = [];
          this._initialStyleAttributes = {};
          this._attributesSetByVM = {};
          this._previousAttributes = {};
          // Set the default attributes
          const nodeAttributes = cls.NodeHelper.getDefaultAttributes(tag);
          for (const element of nodeAttributes) {
            cls.NodeHelper.setAttributeDefaultValue(this, element);
          }
          // Set the attributes with VM info
          const attributesToSet = Object.keys(attributes);
          for (const attributeName of attributesToSet) {
            this._attributesSetByVM[attributeName] = true;
            this._attributes[attributeName] = attributes[attributeName];
            if (attributeName === "style") {
              const styles = attributes[attributeName]?.trim();
              if (styles) {
                this._vmStyles = styles.split(cls.NodeBase.stylesSeparatorRegExp);
              }
            }
          }

          // Attaching the node to its parent children list
          if (parent !== null) {
            const valueIndex = parent.addChildNode(this);
            if (this._parentInfo.inTable) {
              this._parentInfo.inFirstTableRow = (valueIndex === 0);
            }
          }

          // Registering the node in the global hash
          if (this._application) {
            this._application.model.addNode(id, this);
          }
          if (this._parent && (context.ThemeService.getValue("aui-mutation-watch") || this._canEmitNodeMutation)) {
            this._parent._emitNodeCreated(this);
          }
        },
        /**
         * Destroy a node (and remove all its references)
         */
        destroy: function() {
          // destroy children first
          while (this._children.length > 0) {
            this._children[this._children.length - 1].destroy();
          }
          if (this._parent) {
            this._parent._emitNodeDestroyed(this);
          }
          // Remove node from the parent children list
          if (this._id !== 0) {
            this._parent.removeChildNode(this);
          }
          this.destroyController();
          if (this._application) {
            this._application.model.removeNode(this._id);
            this._application = null;
          }
          this._children = null;
          this._parent = null;

          this._stylesByPseudoSelectors = null;
          this._activePseudoSelectors = null;
          this._pseudoSelectorsUsedInSubTree = null;
          this._initialStyleAttributes = null;
          this._vmStyles = null;

          this._attributesSetByVM = null;
          this._attributes = null;
          this._previousAttributes = null;
          this._attached = false;

          $super.destroy.call(this);
        },

        _emitNodeCreated: function(node) {
          this.emit(context.constants.baseEvents.nodeCreated, node);
          if (this._parent) {
            this._parent._emitNodeCreated(node);
          }
        },
        _emitNodeDestroyed: function(node) {
          this.emit(context.constants.baseEvents.nodeDestroyed, node);
          if (this._parent) {
            this._parent._emitNodeDestroyed(node);
          }
        },

        /**
         * tag name of this node
         * @returns {string} tag name of this node
         */
        getTag: function() {
          return this._tag;
        },

        /**
         * add child node
         * @param {classes.NodeBase} node node to add
         * @return {number} index of newly added element
         */
        addChildNode: function(node) {
          const index = this._children.length;
          this._children.push(node);
          return index;
        },
        /**
         * remove child node
         * @param {classes.NodeBase} node node to remove
         */
        removeChildNode: function(node) {
          this._children.splice(this._children.indexOf(node), 1);
        },
        /**
         * get parent node
         * @returns {classes.NodeBase} the parent node
         * @publicdoc
         */
        getParentNode: function() {
          return this._parent;
        },
        /**
         * get children (direct only)
         * @param {string=} tag if provided, returns only child nodes of the given type.
         * @returns {classes.NodeBase[]} list of matching children
         * @publicdoc
         */
        getChildren: function(tag) {
          if (tag) {
            const result = [];
            for (const child of this._children) {
              if (child._tag === tag) {
                result.push(child);
              }
            }
            return result;
          }
          return this._children.slice();
        },
        /**
         *  Get a sorted children list based in tabIndex value with all tabindex 0 excluded from the list.
         * @returns {classes.NodeBase[]}
         */
        getTabIndexSortedChildren: function(tag) {
          const children = this.getChildren(tag);
          if (children.length > 1) {
            let childrenIncludingNestedHBoxes = [...children];
            for (const child of children) {
              if (child.getTag() === "HBox") {
                // If we meet an HBox, append its children to the current children array
                // as it can include tabindexed nodes (i.e. if an EditWidget has a spacer)
                childrenIncludingNestedHBoxes = [...childrenIncludingNestedHBoxes, ...child.getChildren()];
              }
            }

            return childrenIncludingNestedHBoxes.filter(function(node) {
              return !node.isAttributeSetByVM("tabIndex") || node.attribute("tabIndex") !== 0;
            }).sort(function(a, b) {
              const aValue = a.isAttributeSetByVM("tabIndex") ? a.attribute("tabIndex") : 9999999;
              const bValue = b.isAttributeSetByVM("tabIndex") ? b.attribute("tabIndex") : 9999999;
              return aValue - bValue;
            });
          } else {
            return children;
          }
        },
        /**
         * Get the raw list of children. Be aware this list could change while
         * it is passed through. If you are not sure, prefer getChildren that clones the list
         * @returns {classes.NodeBase[]}
         */
        getRawChildren: function() {
          return this._children;
        },
        /**
         * get first direct child
         * @param {string=} tag if provided, returns only a child node of the given type.
         * @returns {classes.NodeBase} the node found
         */
        getFirstChild: function(tag) {
          if (tag) {
            for (const child of this._children) {
              if (child._tag === tag) {
                return child;
              }
            }
          } else if (this._children.length) {
            return this._children[0];
          }
          return null;
        },
        /**
         * get the last child
         * @param {string=} tag if provided, returns only a child node of the given type.
         * @returns {classes.NodeBase} the last child
         */
        getLastChild: function(tag) {
          if (tag) {
            const length = this._children.length;
            for (let i = length - 1; i > -1; i--) {
              const child = this._children[i];
              if (child._tag === tag) {
                return child;
              }
            }
          } else if (!this._children.isEmpty()) {
            return this._children[this._children.length - 1];
          }
          return null;
        },
        /**
         * Usage:
         *  - getChildrenWithAttribute("TagName", "attributeName", "attributeValue");
         *  - getChildrenWithAttribute("attributeName", "attributeValue");
         *  - getChildrenWithAttribute("attributeName");
         * @param {?string} tag node tag name
         * @param {string} attributeName searched attribute name
         * @param {?string} attributeValue searched attribute value
         * @returns {classes.NodeBase[]} List of matching nodes
         */
        getChildrenWithAttribute: function(tag, attributeName, attributeValue) {
          if (!attributeName) {
            attributeName = tag;
            tag = null;
          }
          const result = [];
          for (const child of this._children) {
            if (!tag || child._tag === tag) {
              if (child.isAttributePresent(attributeName)) {
                const value = child.attribute(attributeName);
                if (typeof attributeValue === "undefined" || attributeValue === value) {
                  result.push(child);
                }
              }
            }
          }
          return result;
        },
        /**
         * Usage:
         *  - getFirstChildWithAttribute("TagName", "attributeName", "attributeValue");
         *  - getFirstChildWithAttribute("attributeName", "attributeValue");
         *  - getFirstChildWithAttribute("attributeName");
         * @param {?string=} tag node tag name
         * @param {string} attributeName searched attribute name
         * @param {?string=} attributeValue searched attribute value
         * @returns {classes.NodeBase} first matching node or null
         */
        getFirstChildWithAttribute: function(tag, attributeName, attributeValue) {
          if (!attributeName) {
            attributeName = tag;
            tag = null;
          }
          for (const child of this._children) {
            if (!tag || child._tag === tag) {
              if (child.isAttributePresent(attributeName)) {
                const value = child.attribute(attributeName);
                if (typeof attributeValue === "undefined" || attributeValue === value) {
                  return child;
                }
              }
            }
          }
          return null;
        },
        /**
         * get first child with id
         * @param {number} id - node id
         * @returns {classes.NodeBase} first matching node or null
         */
        getFirstChildWithId: function(id) {
          if (this._children) {
            for (const child of this._children) {
              if (child._id === id) {
                return child;
              }
            }
          }
          return null;
        },
        /**
         * Will return the first ancestor that has this tag, null otherwise.
         * @param {string} tag name of the ancestor node
         * @returns {classes.NodeBase} a node if found, null otherwise
         */
        getAncestor: function(tag) {
          let result = this._parent;
          while (result && result._tag !== tag) {
            result = result._parent;
          }
          return result;
        },
        /**
         * Will return the first ancestor that has this tag and potential style, null otherwise.
         * @param {string} tag name of the ancestor node
         * @param {string} style name of the ancestor node style to match
         * @returns {classes.NodeBase} a node if found, null otherwise
         */
        getAncestorWithStyle: function(tag, style) {
          let found = false,
            result = this;
          while (!found) {
            result = result._parent;
            found = !result ||
              result._tag === tag &&
              (!style || result._vmStyles.indexOf(style) >= 0);
          }
          return result;
        },
        /**
         * Will return the first ancestor that has this tag and attribute, null otherwise.
         * @param {string} attributeName name of the ancestor node attribute to match
         * @returns {classes.NodeBase} a node if found, null otherwise
         */
        getAncestorWithAttribute: function(attributeName) {
          let result = this._parent;
          while (result && !result.isAttributePresent(attributeName)) {
            result = result._parent;
          }
          return result;
        },
        /**
         * get all descendants of tag type
         * @param {string} tag tag name of the descendants
         * @returns {classes.NodeBase[]} list of descendants matching the given tag
         * @public
         */
        getDescendants: function(tag) {
          return this._getDescendants(tag);
        },

        /**
         * get all descendants of tag type (recursion)
         * @param {string} tag tag name of the descendants
         * @param {classes.NodeBase[]} [result] optional array to populate. (For internal use only)
         * @returns {classes.NodeBase[]} list of descendants matching the given tag
         * @private
         */
        _getDescendants: function(tag, result) {
          if (result === undefined) {
            result = [];
          } else if (tag === this._tag || tag === null) {
            // Matching tags should only be added for children
            result.push(this);
          }
          for (const child of this._children) {
            child._getDescendants(tag, result);
          }
          return result;
        },

        /**
         * Get index of node in its parent's children
         * @param {string=} tag tag name of the siblings to consider
         * @returns {number} The index of this node in its parent's children array
         */
        getIndex: function(tag = null) {
          const siblings = this._parent._children;
          let index = 0;
          for (const sibling of siblings) {
            if (sibling === this) {
              break;
            }
            if (!tag || sibling._tag === tag) {
              ++index;
            }
          }
          return index;
        },

        /**
         * Get the index of the node where we take care of the elements inside the placeholder
         * @return {number}
         */
        getVirtualIndex: function() {
          const siblings = this._parent._children;
          let index = 0;
          for (const sibling of siblings) {
            if (sibling === this) {
              break;
            }
            if (sibling.getController() instanceof cls.ControllerPlaceholderBase) {
              index += sibling.getController().getWidget().getDisplayedWidgetCount();
            } else {
              ++index;
            }
          }
          return index;
        },

        /**
         * Will get the previous Sibling node
         * @param {?string|string[]} tag optional tag name to limit result by name
         * @returns {?classes.NodeBase} next Sibling if exists
         */
        getPreviousSibling: function(tag) {
          const children = this.getParentNode().getChildren();
          const initialIndex = children.indexOf(this);
          let index = -1;
          if (tag) {
            if (!Array.isArray(tag)) {
              tag = [tag];
            }
            for (let i = initialIndex - 1; i >= 0; i--) {
              const child = children[i];
              if (tag.indexOf(child._tag) !== -1) {
                index = i;
                break;
              }
            }
          } else {
            index = initialIndex - 1;
          }
          if (index < 0) {
            return null;
          }
          return children[index];
        },

        /**
         * Will get the next Sibling node
         * @param {?string|string[]} tag optional tag name to limit result by name
         * @returns {?classes.NodeBase} next Sibling if exists
         */
        getNextSibling: function(tag) {
          const children = this.getParentNode().getChildren(),
            len = children.length;
          const initialIndex = children.indexOf(this);
          let index = len;
          if (tag) {
            if (!Array.isArray(tag)) {
              tag = [tag];
            }
            for (let i = initialIndex + 1; i < len; i++) {
              const child = children[i];
              if (tag.indexOf(child._tag) !== -1) {
                index = i;
                break;
              }
            }
          } else {
            index = initialIndex + 1;
          }
          if (index >= len) {
            return null;
          }
          return children[index];
        },
        /**
         * Get descendant with attribute
         * @param {?string} tag tag name
         * @param {string} attributeName attribute name
         * @param {*} [attributeValue] the value to find
         * @returns {classes.NodeBase} matching nodes
         */
        findNodeWithAttribute: function(tag, attributeName, attributeValue) {
          const tagged = this.getDescendants(tag);
          for (const child of tagged) {
            if (child.isAttributePresent(attributeName)) {
              const value = child.attribute(attributeName);
              if (typeof attributeValue === "undefined" || attributeValue === value) {
                return child;
              }
            }
          }
          return null;
        },

        /**
         * Execute callback for this node and each descendant
         * @param {function} callback function to call
         */
        forThisAndEachDescendant: function(callback) {
          callback(this);
          for (const element of this._children) {
            element.forThisAndEachDescendant(callback);
          }
        },

        /**
         *get owning application
         * @returns {classes.VMApplication} owning application
         * @publicdoc
         */
        getApplication: function() {
          return this._application;
        },
        /**
         * update attribute values
         * @param {Object.<string, *>} attributes new values
         */
        updateAttributes: function(attributes) {
          const attributesToSet = Object.keys(attributes);
          for (const attributeName of attributesToSet) {
            this._attributesSetByVM[attributeName] = true;
            this._previousAttributes[attributeName] = this._attributes[attributeName];
            this._attributes[attributeName] = attributes[attributeName];
            if (attributeName === "style") {
              const styles = attributes[attributeName]?.trim();
              this._vmStyles = styles ? styles.split(cls.NodeBase.stylesSeparatorRegExp) : [];
            }
          }
        },
        /**
         * get attribute value
         * @param {string} attributeName attribute name
         * @returns {*} attribute value
         * @publicdoc
         */
        attribute: function(attributeName) {
          return this._attributes[attributeName];
        },

        /**
         * get the attribute set by vm
         * @param {string} attributeName name of the attribute
         * @returns {*} attribute value
         */
        attributeByVM: function(attributeName) {
          return this._attributesSetByVM.hasOwnProperty(attributeName) ? this._attributes[attributeName] : null;
        },
        /**
         * get attribute previous value
         * @param {string} attributeName attribute name
         * @returns {*} attribute previous value
         */
        previousAttribute: function(attributeName) {
          return this._previousAttributes[attributeName];
        },

        /**
         * set by vm info
         * @param {string} attributeName name of the attribute
         * @returns {boolean} true if the attribute has been set by the VM, false otherwise
         */
        isAttributeSetByVM: function(attributeName) {
          return this._attributesSetByVM.hasOwnProperty(attributeName);
        },
        /**
         * attribute existence
         * @param {string} attributeName name of the attribute
         * @returns {boolean} true if the attribute exists
         */
        isAttributePresent: function(attributeName) {
          return this._attributes.hasOwnProperty(attributeName);
        },
        /**
         * attach hook when attribute changes
         * @param {string} attributeName attribute name
         * @param {function} handler the hook
         * @returns {HandleRegistration} the handler to release the hook
         * @publicdoc
         */
        onAttributeChanged: function(attributeName, handler) {
          return this.when(cls.NodeBase.attributeChangedEventName(attributeName), this._onAttributeChanged.bind(null, handler));
        },
        /**
         * hook wrapper
         * @param {function} handler the hook
         * @param {classes.Event} event the event
         * @param {classes.NodeBase} node the src node
         * @param {*} data data bag
         * @private
         */
        _onAttributeChanged: function(handler, event, node, data) {
          handler(event, node, data);
        },

        /**
         * find whether or not this node is in the given list (or one of its parents)
         * @param list the list to check
         * @param lookIfAParentIs look for parents as well
         * @returns {boolean}
         */
        containedInList: function(list, lookIfAParentIs) {
          if (list?.length) {
            if (list.indexOf(this) >= 0) {
              return true;
            }
            if (lookIfAParentIs) {
              let parent = this.getParentNode();
              while (parent) {
                if (list.indexOf(parent) >= 0) {
                  return true;
                }
                parent = parent.getParentNode();
              }
            }
          }
          return false;
        },

        /**
         * update applicable styles
         * @param {boolean} [recursive] do it recursively
         * @param {boolean} [stylesChanged] if done recursively, did the 4st styles changed?
         * @param {Array} [styleAttributesChanged] if done recursively, list of nodes which changed style attribute
         * @param {classes.TreeModificationTracker} [treeModificationTrack] if done recursively, need information about node tree changes
         */
        updateApplicableStyles: function(recursive, stylesChanged, styleAttributesChanged, treeModificationTrack) {
          let i;
          const ui = this.getApplication().uiNode();
          if (!recursive || stylesChanged ||
            this.containedInList(styleAttributesChanged, true) ||
            treeModificationTrack.isNodeCreated(this._id) ||
            treeModificationTrack.attributeChanged(this._id, "style")) {
            const matchingAttributesByPseudoSelectors = {};
            const styleLists = ui.getChildren('StyleList');
            for (i = 0; i < styleLists.length; i++) {
              const styleList = styleLists[i];
              styleList.populateMatchingStyles(matchingAttributesByPseudoSelectors, this);
            }
            this._stylesByPseudoSelectors = [];
            const pseudoSelectorKeys = Object.keys(matchingAttributesByPseudoSelectors);
            for (i = 0; i < pseudoSelectorKeys.length; i++) {
              const pseudoSelectorKey = pseudoSelectorKeys[i];
              const styleAttributes = matchingAttributesByPseudoSelectors[pseudoSelectorKey];
              const styles = {};
              const styleAttributeKeys = Object.keys(styleAttributes);
              for (const styleAttributeName of styleAttributeKeys) {
                styles[styleAttributeName] = styleAttributes[styleAttributeName];
              }
              this._stylesByPseudoSelectors.push({
                pseudoSelector: styleAttributes[styleAttributeKeys[0]].getParentNode().getPseudoSelectors(),
                styles: styles
              });
            }
            // Sort by pseudo-selector priority
            this._stylesByPseudoSelectors.sort(this._pseudoSelectorPrioritySorter);
          }
          if (recursive) {
            for (i = 0; i < this._children.length; ++i) {
              this._children[i].updateApplicableStyles(true, stylesChanged, styleAttributesChanged, treeModificationTrack);
            }
          }
        },

        resetActivePseudoSelectors: function() {
          this._activePseudoSelectors = null;
        },
        resetPseudoSelectorsUsedInSubTree: function() {
          this._pseudoSelectorsUsedInSubTree = {};
        },
        updatePseudoSelectorsUsedInSubTree: function(recursive) {
          let pseudoSelectors = {},
            i;
          if (this._stylesByPseudoSelectors) {
            for (i = 0; i < this._stylesByPseudoSelectors.length; ++i) {
              const entry = this._stylesByPseudoSelectors[i];
              for (const element of entry.pseudoSelector) {
                pseudoSelectors[element] = true;
              }
            }
          }
          pseudoSelectors = Object.keys(pseudoSelectors);
          for (i = 0; i < pseudoSelectors.length; ++i) {
            const pseudoSelector = pseudoSelectors[i];
            let p = this;
            while (p !== null) {
              if (!p._pseudoSelectorsUsedInSubTree[pseudoSelector]) {
                p._pseudoSelectorsUsedInSubTree[pseudoSelector] = true;
                p = p._parent;
              } else {
                break;
              }
            }
          }

          if (recursive) {
            for (i = 0; i < this._children.length; ++i) {
              this._children[i].updatePseudoSelectorsUsedInSubTree(true);
            }
          }
        },

        setInitialStyleAttributes: function() {
          const initialStyles = this._stylesByPseudoSelectors.filter(function(item) {
            return !item.pseudoSelector.length;
          })[0];
          if (initialStyles) {
            const keys = Object.keys(initialStyles.styles);
            for (const element of keys) {
              this._initialStyleAttributes[element] = initialStyles.styles[element]._attributes.value;
            }
          }
        },

        _pseudoSelectorPrioritySorter: function(pss1, pss2) {
          const firstStyleAttr1 = pss1.styles[Object.keys(pss1.styles)[0]];
          const firstStyleAttr2 = pss2.styles[Object.keys(pss2.styles)[0]];
          let pss1Weight = firstStyleAttr1.getParentNode().getWeight();
          let pss2Weight = firstStyleAttr2.getParentNode().getWeight();
          if (pss1Weight === pss2Weight) {
            pss1Weight = firstStyleAttr1.getParentNode().getPseudoSelectorWeight();
            pss2Weight = firstStyleAttr2.getParentNode().getPseudoSelectorWeight();
          }
          return pss2Weight - pss1Weight;
        },
        /**
         * return the value of the specified style attribute for the current node
         * @param {string} styleAttr the style attribute
         * @param {?string[]} [forcedPseudoSelectors] activate pseudo selectors
         * @returns {string} the style
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          return this._getStyleAttributeImpl(styleAttr, forcedPseudoSelectors);
        },

        /**
         * return the value of the specified style attribute for the current node
         * This is the implementation method which computes the style.
         * The public getStyleAttribute method invokes this method directly or forwards it
         * to the appropriate node depending on the context (FormFieldNode, ValueNode)
         * @param {string} styleAttr the style attribute
         * @param {?string[]} forcedPseudoSelectors activate pseudo selectors
         * @param {boolean} [onlyPseudoSelectorStyles] search only styles with pseudoSelector
         * @returns {?string} the style
         */
        _getStyleAttributeImpl: function(styleAttr, forcedPseudoSelectors, onlyPseudoSelectorStyles = false) {
          if (!this._application.usedStyleAttributes[styleAttr]) {
            return null;
          }
          let pseudoSelectors = forcedPseudoSelectors;
          if (!pseudoSelectors) {
            if (!this._activePseudoSelectors) {
              this._activePseudoSelectors = this._computePseudoSelectors();
            }
            pseudoSelectors = this._activePseudoSelectors;
          }
          let matchingStyleAttribute = null;
          const pseudoSelectorCheck = function(ps) {
            return pseudoSelectors.indexOf(ps) !== -1;
          };
          if (this._stylesByPseudoSelectors) {
            for (const pseudoSelectorStyle of this._stylesByPseudoSelectors) {
              if (!onlyPseudoSelectorStyles || pseudoSelectorStyle.pseudoSelector.length > 0) {
                // dict lookup first, as it is faster
                const styleAttribute = pseudoSelectorStyle.styles[styleAttr];
                if (styleAttribute !== undefined && !styleAttribute._destroyed) {
                  const matches = pseudoSelectorStyle.pseudoSelector.every(pseudoSelectorCheck);
                  if (matches) {
                    matchingStyleAttribute = styleAttribute;
                    break;
                  }
                }
              }
            }
          }
          if (matchingStyleAttribute) {
            return matchingStyleAttribute.attribute('value');
          } else {
            // if no style is found, check parent node styles for inheritance
            const parent = this.getParentNode();
            if (parent) {
              const isNodeWithNotInheritedStyleAttribute = cls.NodeBase.nodesWithNotInheritedStyleAttributes.contains(this
                .getTag());
              const isNotInheritedStyleAttribute = cls.NodeBase.notInheritedStyleAttributes.contains(styleAttr);

              // TODO anbr : shouldn't the condition be && instead of || ? Tried to replace but it broke some tests such as GBC-877 or GBC-699
              if (!isNodeWithNotInheritedStyleAttribute || !isNotInheritedStyleAttribute) {
                // if widget isInTable we search only pseudoSelector styles
                // other styles are managed by CSS
                const searchOnlyPseudoSelectorStyles = isNotInheritedStyleAttribute && (onlyPseudoSelectorStyles || this.isInTable());
                return parent._getStyleAttributeImpl(styleAttr, pseudoSelectors, searchOnlyPseudoSelectorStyles);
              }

            }
          }
          return null;
        },
        /**
         * compute pseudo selectors
         * @returns {Array} computed pseudo selectors
         * @protected
         */
        _computePseudoSelectors: function() {
          const focusedNodeIdRef = this.getApplication().uiNode().attribute('focus');
          const pseudoSelectors = this._populatePseudoSelectors({
            __dialogTypeDefined: false,
            __activeDefined: false
          }, focusedNodeIdRef);
          const availableSelectors = [];
          const keys = Object.keys(pseudoSelectors);
          for (const ps of keys) {
            if (pseudoSelectors[ps]) {
              availableSelectors.push(ps);
            }
          }
          return availableSelectors;
        },

        /**
         * populate pseudo selectors
         * @param {?Object.<string, boolean>=} pseudoSelectors a dictionnary which will be populated. Keys are the active pseudo-selectors
         * @param {number} focusedNodeIdRef the idref of the focused node. Passed as parameter to avoid tree lookups.
         * @returns {Object} returns the pseudoSelectors parameter
         * @private
         */
        _populatePseudoSelectors: function(pseudoSelectors, focusedNodeIdRef) {
          if (focusedNodeIdRef === 0) {
            return pseudoSelectors; // no need to compute for userinterface node
          }
          const dialogType = this.attribute('dialogType');
          if (focusedNodeIdRef === this._id &&
            (dialogType && (dialogType === 'Display' || dialogType === 'DisplayArray') || this._tag !== 'Table' && this._tag !==
              'Matrix') && !Object.isBoolean(pseudoSelectors.focus)) {
            // Table and Matrix focus is ignored as the real focused item is their current element
            pseudoSelectors.focus = true;
          }
          // Active attribute on Button is actionActive: this defines the state of the button
          const active = this.__name === "ButtonNode" ? this.attribute('actionActive') : this.attribute('active');
          // active will be undefined if the current node doesn't have this attribute
          if (active !== undefined) {
            if (!pseudoSelectors.__dialogTypeDefined) {
              if (active || (this.attribute('noEntry') && this._tag === 'TableColumn')) {
                if (dialogType) {
                  pseudoSelectors.__dialogTypeDefined = true;
                  if (dialogType === 'Display' || dialogType === 'DisplayArray') {
                    pseudoSelectors.display = true;
                    pseudoSelectors.input = false;
                    pseudoSelectors.query = false;
                  } else if (dialogType === 'Input' || dialogType === 'InputArray') {
                    pseudoSelectors.display = false;
                    pseudoSelectors.input = true;
                    pseudoSelectors.query = false;
                  } else if (dialogType === 'Construct') {
                    pseudoSelectors.display = false;
                    pseudoSelectors.input = false;
                    pseudoSelectors.query = true;
                  }
                }
              } else {
                pseudoSelectors.__dialogTypeDefined = true;
                pseudoSelectors.display = false;
                pseudoSelectors.input = false;
                pseudoSelectors.query = false;
              }
            }
            if (!pseudoSelectors.__activeDefined) {
              pseudoSelectors.__activeDefined = true;
              if (active) {
                pseudoSelectors.active = true;
              } else {
                pseudoSelectors.inactive = true;
              }
            }
          }

          if (this._parent) {
            return this._parent._populatePseudoSelectors(pseudoSelectors, focusedNodeIdRef);
          }
          return pseudoSelectors;
        },

        /**
         * Override this method when no controller should automatically be created for this node, neither for the
         * node itself nor for its children
         * This method is called in createController()
         * @return {boolean} true if this node and its children controllers' are allowed to be created automatically
         */
        autoCreateController: function() {
          if (this._parent) {
            return this._parent.autoCreateChildrenControllers();
          } else {
            return true;
          }
        },

        /**
         * Override this method when no controller should automatically be created for the children of this node.
         * The node itself will have a controller created.
         * @return {boolean} true if this node's children controllers' are allowed to be created automatically
         */
        autoCreateChildrenControllers: function() {
          if (this._parent) {
            return this._parent.autoCreateChildrenControllers();
          } else {
            return true;
          }
        },

        /**
         * create controllers recursively
         * @param {number[]} [_queue] aui id queue
         * @param {boolean} [force] force controller creation
         */
        createController: function(_queue, force) {
          if (force || this.autoCreateController()) {
            const queue = _queue || [];
            if (!this._controller) {
              queue.push(this._id);
              this._createChildrenControllers(queue);
            }
            if (!_queue) {
              for (const element of queue) {
                const node = this._application.model.getNode(element);
                node._controller = node._createController();
                node.emit(context.constants.baseEvents.controllerCreated);
              }
            }
          }
        },
        /**
         * attach hook when controller created
         * @param {Hook} hook event hook
         * @param {boolean=} once - if true, will only fire once
         * @return {HandleRegistration} a handle to unregister the hook
         */
        whenControllerCreated: function(hook, once) {
          return this.when(context.constants.baseEvents.controllerCreated, hook, once);
        },
        /**
         * Applies all behaviors
         * @param {classes.TreeModificationTracker} treeModificationTrack collection of affected nodes
         * @param {boolean} recursive apply behaviors to child nodes as well
         * @param {boolean} force force apply behaviors
         */
        applyBehaviors: function(treeModificationTrack, recursive, force) {
          let stillDirty = false;
          const park = [this];
          if (recursive) {
            while (park.length) {
              const i = park.shift();
              park.unshift.apply(park, i._children);
              if (i._controller) {
                stillDirty = i._controller.applyBehaviors(treeModificationTrack, force) || stillDirty;
              }
            }
          } else if (this._controller) {
            stillDirty = this._controller.applyBehaviors(treeModificationTrack, force) || stillDirty;
          }
          return stillDirty;
        },
        /**
         * creates a controller associated to the node
         * @returns {classes.ControllerBase} the created controller
         * @public
         */
        _createController: function() {
          return null;
        },
        /**
         * create the controllers in child nodes
         * @param {Array<classes.ControllerBase>} _queue traversing array
         * @protected
         */
        _createChildrenControllers: function(_queue) {
          for (const element of this._children) {
            element.createController(_queue);
          }
        },
        /**
         * Removes the associated controller
         */
        destroyController: function() {
          if (this._controller) {
            this._controller.destroy();
            this._controller = null;
          }
        },
        /**
         * attaches the node's UI in DOM
         * @returns {HTMLElement} the attached element, if any
         */
        attachUI: function() {
          for (const element of this._children) {
            element.attachUI();
          }
          if (!this._attached && this.getController() && this.getController().getWidget()) {
            this.getController().attachUI();
            this._attached = true;
            return this.getController().getWidget().getElement();
          }
          return null;
        },
        /**
         * get the node's controller
         * @returns {classes.ControllerBase} the node's controller
         */
        getController: function() {
          return this._controller;
        },

        /**
         * Gets the node's widget
         * @returns {classes.WidgetBase} the node's widget
         * @publicdoc
         */
        getWidget: function() {
          return this._controller ? this._controller.getWidget() : null;
        },

        /**
         * gets the node's aui id
         * @returns {number} the node's aui id
         */
        getId: function() {
          return this._id;
        },
        onNodeCreated: function(hook, tag) {
          return this.when(context.constants.baseEvents.nodeCreated, this._onNodeCreated.bind(null, tag, hook));
        },
        _onNodeCreated: function(tag, hook, event, src, node) {
          if (!tag || tag === node._tag) {
            hook(event, src, node);
          }
        },
        onNodeRemoved: function(hook, tag) {
          return this.when(context.constants.baseEvents.nodeDestroyed, this._onNodeRemoved.bind(this, tag, hook));
        },
        _onNodeRemoved: function(tag, hook, event, src, node) {
          if (!tag || tag === node._tag) {
            hook(event, src, node);
          }
        },
        /**
         * Once all children are created, emit the corresponding event
         */
        childrenCreated: function() {
          this.emit(context.constants.baseEvents.childrenNodeCreated);
        },

        /**
         * Renders this node as a json object
         * @param {boolean} recursive includes children nodes
         * @return {Object} a json object representing this node
         */
        getJson: function(recursive) {
          if (typeof recursive === "undefined") {
            recursive = false;
          }

          const jsonTree = {
            id: this._id,
            name: this._tag,
            attributes: this._attributes,
            children: recursive ? [] : null
          };

          if (recursive) {
            if (this._children.length > 0) {
              for (const element of this._children) {
                jsonTree.children.push(element.getJson(true));
              }
            } else {
              jsonTree.children = false;
            }
          }

          return this._id === 0 ? [jsonTree] : jsonTree;
        },

        isInTable: function() {
          return Boolean(this._parentInfo?.inTable);
        },

        isInMatrix: function() {
          return Boolean(this._parentInfo?.inMatrix);
        },

        isInScrollGrid: function() {
          return Boolean(this._parentInfo?.inScrollGrid);
        },

        isInToolBar: function() {
          return Boolean(this._parentInfo?.inToolBar);
        },

        isInFirstTableRow: function() {
          return Boolean(this._parentInfo?.inFirstTableRow);
        },

        isInStack: function() {
          return Boolean(this._parentInfo?.inStack);
        },

        /**
         * Use the current application focused VM Node
         * to compare against this node
         * @returns {boolean} True if the node has the focus
         */
        hasVMFocus: function() {
          if (this.getId() === 0) {
            return true; // consider UserInterface node has always VM focus
          }
          // Compare this node and the focused one
          return this === this.getApplication().getFocusedVMNode();
        },

        /**
         * Test if this node must ignore an action
         * @param {String} actionName - name of the action to be tested
         * @returns {boolean} true if the action must be ignored
         */
        ignoreAction: function(actionName) {
          if (this._parentInfo?.container) {
            return this._parentInfo.container.ignoreAction(actionName);
          }
          return false;
        }
      };
    });
  });
;

"use strict";
/**
 * @typedef {Object} nodeInfo
 * @property {string} type
 * @property {number} id
 * @property {Object.<string, *>} attributes
 * @property {nodeInfo[]} children
 */

modulum('NodeFactory', ['Factory', 'StandardNode'],

  function(context, cls) {
    /**
     * @namespace classes.NodeFactory
     */
    cls.NodeFactory = context.oo.StaticClass(function() {
      /**
       *
       * @type {classes.Factory<classes.NodeBase>}
       */
      const factory = new cls.Factory("Node", cls.StandardNode);
      return /** @lends classes.NodeFactory */ {
        _ripWidgetCreated: false,

        /**
         *
         * @param {string} type
         * @param {Function} constructor
         */
        register: function(type, constructor) {
          factory.register(type, constructor);
        },
        /**
         *
         * @param {string} type
         */
        unregister: function(type) {
          factory.unregister(type);
        },
        /**
         *
         * @param {string} type
         * @returns {classes.NodeBase}
         */
        create: function(type, arg1, arg2, arg3, arg4, arg5) {
          return factory.create(type, arg1, arg2, arg3, arg4, arg5);
        },
        /**
         * Create recursively all model nodes for the given nodeInfo
         * @param {classes.NodeBase} parent parent node
         * @param {nodeInfo} nodeInfo node information
         * @param {classes.VMApplication=} app owner application
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @returns {classes.NodeBase[]} created nodes
         */
        createRecursive: function(parent, nodeInfo, app, treeModificationTrack) {
          this._ripWidgetCreated = false;
          return this._createRecursive(parent, nodeInfo, app, treeModificationTrack, true);
        },
        /**
         * Create recursively all model nodes for the given nodeInfo
         * Internal implementation
         * @param {classes.NodeBase} parent parent node
         * @param {nodeInfo} nodeInfo node information
         * @param {classes.VMApplication=} app owner application
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @param {boolean} isSubTreeRoot true if the node to create is a subtree root
         * @returns {classes.NodeBase[]} created nodes
         * @private
         */
        _createRecursive: function(parent, nodeInfo, app, treeModificationTrack, isSubTreeRoot) {
          if (app.ended) {
            // If app ended, get out of this recursive function
            return null;
          }
          const current = factory.create.call(factory, nodeInfo.type, parent, nodeInfo, app);
          if (nodeInfo.type.startsWith("Rip") && nodeInfo.type !== "RipGraphic") {
            this._ripWidgetCreated = true;
          }
          treeModificationTrack.nodeCreated(current._id, current._tag, isSubTreeRoot);
          if (nodeInfo.children && Array.isArray(nodeInfo.children)) {
            const jsonAuiProtocol = window.isURLParameterEnabled("json") || context.ThemeService.getValue("aui-json-protocol");
            for (const element of nodeInfo.children) {
              let child = element;
              if (jsonAuiProtocol && Array.isArray(element)) {
                child = {
                  type: element[0], // same as tag
                  id: element[1],
                  attributes: element[2],
                  children: element[3]
                };
              }
              this._createRecursive(current, child, app, treeModificationTrack);
            }
          }
          current.childrenCreated();
          return current;
        },

        /**
         * True if a widget type started with Rip was created in the last createRecursive
         * @returns {boolean}
         */
        ripWidgetCreated: function() {
          return this._ripWidgetCreated;
        }
      };
    });
  });
;

"use strict";

modulum('PropertyArrayNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyArrayNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyArrayNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyArrayNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("PropertyArray", cls.PropertyArrayNode);
  });
;

"use strict";

modulum('PropertyDictNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyDictNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyDictNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyDictNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("PropertyDict", cls.PropertyDictNode);
  });
;

"use strict";

modulum('PropertyNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class PropertyNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.PropertyNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.PropertyNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          this._canEmitNodeMutation = true;
          $super.constructor.call(this, parent, tag, id, attributes, app);
        }
      };
    });
    cls.NodeFactory.register("Property", cls.PropertyNode);
  });
;

"use strict";

modulum('RowInfoNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class RowInfoNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.RowInfoNode = context.oo.Class(cls.StandardNode, function() {
      return /** @lends classes.RowInfoNode.prototype */ {
        /**
         * @inheritDoc
         */
        _createController: function() {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            table: this._parent._parent,
            ui: this.getApplication().getNode(0),
            form: this.getAncestor("Form")
          });
        }
      };
    });
    cls.NodeFactory.register("RowInfo", cls.RowInfoNode);
  });
;

"use strict";

modulum('ScrollGridNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ScrollGridNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.ScrollGridNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.ScrollGridNode.prototype */ {

        /**
         * @returns {boolean} True if the VM focused node is a child (whatever the depth) of this node
         */
        hasVMFocus: function() {
          // VM set the focus on matrix nodes when they are in VM
          for (const childMatrix of this.getDescendants("Matrix")) {
            // Into each child recursivelly ask focus until a positive result, or the end of children of children
            if (childMatrix.hasVMFocus()) {
              return true;
            }
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        autoCreateChildrenControllers: function() {
          // Stretchable and Paged ScrollGrids have their custom
          // line controllers in StretchableScrollGridPageSizeVMBehavior
          return this.attribute("wantFixedPageSize") !== 0;
        }
      };
    });
    cls.NodeFactory.register("ScrollGrid", cls.ScrollGridNode);
  });
;

"use strict";

modulum('StandardNode', ['NodeBase'],
  function(context, cls) {
    /**
     * AUI Node default
     *
     * @class StandardNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StandardNode = context.oo.Class(cls.NodeBase, function() {
      return /** @lends classes.StandardNode.prototype */ {
        __name: "StandardNode",
        /**
         *
         * @inheritDoc
         */
        _createController: function() {
          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            form: this.getAncestor("Form")
          });
        }
      };
    });
  });
;

"use strict";

modulum('StyleListNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class StyleListNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StyleListNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.StyleListNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          this.getApplication().styleListsChanged = true;
        },

        destroy: function() {
          this.getApplication().styleListsChanged = true;
          $super.destroy.call(this);
        },

        populateMatchingStyles: function(matchingAttributesByPseudoSelectors, node) {
          const children = this.getRawChildren();
          for (const styleNode of children) {
            styleNode.populateMatchingStyles(matchingAttributesByPseudoSelectors, node);
          }
        }
      };
    });
    cls.NodeFactory.register("StyleList", cls.StyleListNode);
  });
;

"use strict";

modulum('StyleNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class StyleNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.StyleNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.StyleNode.prototype */ {
        $static: {
          _pseudoSelectorsPriority: {
            focus: 1024,
            query: 512,
            display: 256,
            input: 128,
            even: 64,
            odd: 32,
            inactive: 16,
            active: 8,
            message: 4,
            error: 2,
            summaryLine: 1
          }
        },
        _parsedElementType: null,
        _parsedStyleName: null,
        _parsedPseudoSelectors: null,
        /** @type {number} */
        _weight: 0,
        /** @type {number} */
        _pseudoSelectorWeight: 0,

        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          const name = this.attribute("name");
          const dotIndex = name.indexOf('.');
          const colonIndex = name.indexOf(':');
          this._parsedStyleName = "";
          if (dotIndex === -1 && colonIndex === -1) { // ElementType || *
            this._parsedElementType = name;
            this._weight = name === '*' ? 1 : 2;
          } else if (dotIndex !== -1 && colonIndex === -1) { // ElementType.stylename || .stylename
            this._parsedElementType = name.substring(0, dotIndex);
            this._parsedStyleName = name.substring(dotIndex + 1);
            this._weight = !this._parsedElementType.length ? 3 : 6;
          } else if (dotIndex === -1 && colonIndex !== -1) { // ElementType:pseudoselector || :pseudoselector
            this._parsedElementType = name.substring(0, colonIndex);
            this._parsedPseudoSelectors = name.substring(colonIndex).split(':').splice(1).sort();
            this._weight = !this._parsedElementType.length ? 4 : 5;
          } else { // ElementType.stylename:pseudoselector || .stylename:pseudoselector
            this._parsedElementType = name.substring(0, dotIndex);
            this._parsedStyleName = name.substring(dotIndex + 1, colonIndex);
            this._parsedPseudoSelectors = name.substr(colonIndex).split(':').splice(1).sort();
            this._weight = !this._parsedElementType.length ? 7 : 8;
          }
          this._parsedPseudoSelectors = this._parsedPseudoSelectors || [];
          for (const pseudoSelector of this._parsedPseudoSelectors) {
            this._pseudoSelectorWeight += cls.StyleNode._pseudoSelectorsPriority[pseudoSelector];
          }
        },

        getPseudoSelectors: function() {
          return this._parsedPseudoSelectors;
        },

        getWeight: function() {
          return this._weight;
        },

        getPseudoSelectorWeight: function() {
          return this._pseudoSelectorWeight;
        },

        matches: function(node) {
          let isMatching = true;
          if (this._parsedElementType.length !== 0) {
            isMatching = this._parsedElementType === '*' || this._parsedElementType === node.getTag();
          }
          if (isMatching && this._parsedStyleName.length !== 0) {
            const styleNames = node.attribute('style');
            if (styleNames) {
              isMatching = styleNames.split(' ').indexOf(this._parsedStyleName) !== -1;
            } else {
              isMatching = false;
            }
          }
          return isMatching;
        },

        populateMatchingStyles: function(matchingAttributesByPseudoSelectors, node) {
          if (this.getRawChildren().length && this.matches(node)) {
            let psKey = '';
            if (this._parsedPseudoSelectors.length) {
              psKey = ':' + this._parsedPseudoSelectors.join(':');
            }
            let dict = matchingAttributesByPseudoSelectors[psKey];
            if (!dict) {
              dict = {};
              matchingAttributesByPseudoSelectors[psKey] = dict;
            }
            for (const child of this._children) {
              const childName = child.attribute('name');
              const styleAttribute = dict[childName];
              if (!styleAttribute || styleAttribute.getParentNode()._weight < this._weight) {
                dict[childName] = child;
              }
            }
          }
        }
      };
    });
    cls.NodeFactory.register("Style", cls.StyleNode);
  });
;

"use strict";

modulum('TableColumnNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TableColumnNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.TableColumnNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.TableColumnNode.prototype */ {
        /** @type {number} */
        _initialTabIndex: -1,

        /**
         * @inheritDoc
         */
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);

          this._initialTabIndex = this.attribute("tabIndex");
        },

        /**
         * @inheritDoc
         */
        _createChildrenControllers: function(_queue) {
          for (let i = 1; i < this._children.length; i++) {
            const child = this._children[i];
            if (child._tag === "ValueList") {
              for (const element of child._children) { // create value controller
                element.createController(_queue);
              }
            } else {
              child.createController(_queue);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _createController: function() {
          const decoratorNode = this._children[0];

          return cls.ControllerFactory.create(this._tag, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode,
            form: this.getAncestor("Form")
          });
        },

        /**
         * Returns initial tabIndex of column
         * @returns {number} initial tabIndex
         */
        getInitialTabIndex: function() {
          return this._initialTabIndex;
        },

        /**
         * @inheritDoc
         */
        ignoreAction: function(actionName) {
          if (this._parent) {
            return this._parent.ignoreAction(actionName);
          }
          return $super.ignoreAction.call(this, actionName);
        }

      };
    });
    cls.NodeFactory.register("TableColumn", cls.TableColumnNode);
  });
;

"use strict";

modulum('TableNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TableNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.TableNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.TableNode.prototype */ {

        /** @type boolean */
        _isTree: false,

        /**
         * @inheritDoc
         */
        setInitialStyleAttributes: function() {
          $super.setInitialStyleAttributes.call(this);
          let defaultWidget = context.ThemeService.getValue("theme-table-default-widget");

          if (this._initialStyleAttributes.tableType === "normal" ||
            this._initialStyleAttributes.tableType === "frozenTable") {
            this._initialStyleAttributes.tableType = "table";
          }

          if (defaultWidget && typeof(this._initialStyleAttributes.tableType) === "undefined") {
            defaultWidget = defaultWidget.toLowerCase();
            if (!this._isTree && defaultWidget === "listview") {
              // if theme default is listView and there is no tableType 4ST defined
              this._initialStyleAttributes.tableType = "listView";
            } else if (defaultWidget === "table") {
              // if theme default is table and there is no tableType 4ST defined
              this._initialStyleAttributes.tableType = "table";
            }
          }
        },

        /**
         * @inheritDoc
         */
        autoCreateChildrenControllers: function() {
          // Tables as ListViews have their custom line controllers in ListViewPageSizeVMBehavior
          return !this.isListView();
        },

        /**
         * @inheritDoc
         */
        updateAttributes: function(attributes) {
          $super.updateAttributes.call(this, attributes);
          if (attributes.bufferSize !== undefined) {
            const treeInfo = this.getFirstChild('TreeInfo');
            if (treeInfo) {
              treeInfo.applyBehaviors(null, true, true);
            }
          }
        },

        /**
         * Return if table is a tree view.
         * @return {boolean} true if it is a tree
         */
        isTreeView: function() {
          return this._isTree;
        },

        /**
         * Return if table is a listView.
         * @return {boolean} true if it is a listView
         */
        isListView: function() {
          return (this._initialStyleAttributes.tableType === "listView");
        },

        /**
         * Returns current row index in the table viewport
         * @return {number} - row index
         */
        getCurrentRowValueIndex: function() {
          return this.attribute('currentRow') - this.attribute('offset');
        },

        /**
         * Will get current value node in table
         * @param {boolean} inputModeOnly - return value node only if is node is in INPUT mode
         * @returns {*}
         */
        getCurrentValueNode: function(inputModeOnly) {
          const dialogType = this.attribute('dialogType');
          const isInputMode = (dialogType === "Input" || dialogType === "InputArray" || dialogType === "Construct");
          if (!inputModeOnly || isInputMode) {
            const valueIndex = this.getCurrentRowValueIndex();
            const bufferSize = this.attribute('bufferSize');
            // check valueIndex validity
            if (valueIndex < 0 || valueIndex >= bufferSize) {
              return null;
            }
            const columnNodes = this.getChildren('TableColumn');
            if (!this.isAttributeSetByVM('currentColumn')) {
              return null; // if attribute is not specified by VM consider that there is no current value
            }
            const currentColumn = this.attribute('currentColumn');
            if (currentColumn < columnNodes.length) {
              const columnNode = columnNodes[currentColumn];
              const valueListNode = columnNode.getFirstChild('ValueList');
              if (valueListNode) {
                const valueNodes = valueListNode.getChildren();
                if (valueIndex < valueNodes.length) {
                  return valueNodes[valueIndex];
                }
              }
            }

          }
          return null;
        },

        /**
         * @inheritDoc
         */
        ignoreAction: function(actionName) {
          let actionsIgnored = ["nextpage", "prevpage"]; // always ignored page action, it is managed by the GBC directly
          if (this.attribute("dialogType") === "DisplayArray") {
            actionsIgnored.push("nextfield", "prevfield"); // next field et prev field should do nothing in DisplayArray
          }
          return actionsIgnored.contains(actionName);
        }
      };
    });
    cls.NodeFactory.register("Table", cls.TableNode);
  });
;

"use strict";

modulum('TreeInfoNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class TreeInfoNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.TreeInfoNode = context.oo.Class(cls.NodeBase, function($super) {

      return /** @lends classes.TreeInfoNode.prototype */ {
        constructor: function(parent, tag, id, attributes, app) {
          // when a treeInfo node is created must immediately inform parent table node
          if (parent.getWidget()) {
            // If this node is created while the table has already built its widget, stop the application
            window.requestAnimationFrame(function() {
              parent.getApplication().stop("Can't dynamically transform a table to a TreeView");
            });
          } else {
            parent._isTree = true;
          }
          $super.constructor.call(this, parent, tag, id, attributes, app);
        },
      };

    });
    cls.NodeFactory.register("TreeInfo", cls.TreeInfoNode);
  });
;

"use strict";

modulum('ValueListNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ValueListNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.ValueListNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.ValueListNode.prototype */ {

        /**
         * @inheritDoc
         */
        addChildNode: function(node) {
          ( /** @type {classes.ValueNode} */ node).setIndex(this._children.length);
          return $super.addChildNode.call(this, node);
        },
      };
    });
    cls.NodeFactory.register("ValueList", cls.ValueListNode);
  });
;

"use strict";

modulum('ValueNode', ['NodeBase', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class ValueNode
     * @memberOf classes
     * @extends classes.NodeBase
     */
    cls.ValueNode = context.oo.Class(cls.NodeBase, function($super) {
      return /** @lends classes.ValueNode.prototype */ {

        /** @type ?number */
        _index: null,

        /**
         * @inheritDoc
         */
        _createController: function() {
          const containerNode = this._parent?._parent;
          const decoratorNode = containerNode?._children[0];
          const controllerType = decoratorNode?._tag;
          const tableNode = containerNode._tag === 'TableColumn' ? containerNode._parent : undefined;
          return cls.ControllerFactory.create(controllerType, {
            anchor: this,
            parent: this._parent,
            ui: this.getApplication().getNode(0),
            decorator: decoratorNode,
            container: containerNode,
            table: tableNode,
            treeItem: null,
            form: this.getAncestor("Form")
          });
        },

        /**
         * @inheritDoc
         */
        getStyleAttribute: function(styleAttr, forcedPseudoSelectors) {
          // On value nodes, the styles should be interpreted as if they were asked on the decorator node
          const decoratorNode = this._parent._parent._children[0];
          const pseudoSelectors = forcedPseudoSelectors || this._computePseudoSelectors();
          return decoratorNode._getStyleAttributeImpl(styleAttr, pseudoSelectors);
        },

        /**
         * @inheritDoc
         */
        _populatePseudoSelectors: function(pseudoSelectors, focusedNodeIdRef) {
          const container = this._parent._parent;
          let positionHolder = container;
          const index = this.getIndex();
          let offset = null;
          const tag = container.getTag();

          if (tag === 'TableColumn' || tag === 'Matrix') {
            const table = tag === 'TableColumn' ? container._parent : container;
            if (table.getId() === focusedNodeIdRef) {
              pseudoSelectors.focus = false;
              const dialogType = container.attribute('dialogType');
              if (dialogType === "Input" || dialogType === "InputArray") {
                const currentRow = table.attribute('currentRow');
                offset = table.attribute('offset');
                if (currentRow - offset === index) {
                  if (tag === 'TableColumn') {
                    const currentColumn = table.attribute('currentColumn');
                    if (currentColumn === container.getIndex()) {
                      pseudoSelectors.focus = true;
                    }
                  } else {
                    pseudoSelectors.focus = true;
                  }
                }
              }
            }
            positionHolder = table;
          }

          offset = positionHolder.attribute('offset');
          if ((offset + index + 1) % 2) {
            pseudoSelectors.odd = true;
          } else {
            pseudoSelectors.even = true;
          }
          return $super._populatePseudoSelectors.call(this, pseudoSelectors, focusedNodeIdRef);
        },

        /**
         * @inheritDoc
         */
        getIndex: function(tag) {

          // value nodes can only have value nodes as sibling, no need to consider "tag" parameter
          return this._index;
        },

        /**
         * Set node index in its parent's children
         * @param index
         */
        setIndex: function(index) {
          this._index = index;
        },

        /**
         * @inheritDoc
         */
        hasVMFocus: function() {
          return this === this.getApplication().getFocusedVMNodeAndValue(true);
        },
      };
    });
    cls.NodeFactory.register("Value", cls.ValueNode);
  });
;

"use strict";

modulum('WindowNode', ['StandardNode', 'NodeFactory'],
  function(context, cls) {
    /**
     * @class WindowNode
     * @memberOf classes
     * @extends classes.StandardNode
     */
    cls.WindowNode = context.oo.Class(cls.StandardNode, function($super) {
      return /** @lends classes.WindowNode.prototype */ {

        __name: "WindowNode",

        /** @type {string} */
        _title: null,
        /** @type {string} */
        _icon: null,
        /** @type {?number} */
        _parentWindowId: null,

        /** @type {boolean} */
        _isModal: null,

        /** @type {boolean} */
        _isDestroying: false,

        /**
         * @inheritDoc
         */
        constructor: function(parent, tag, id, attributes, app) {
          $super.constructor.call(this, parent, tag, id, attributes, app);
          this._isDestroying = false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._isDestroying = true;
          $super.destroy.call(this);
        },

        /**
         * Get the window title
         * @returns {string}
         */
        getTitle: function() {
          return this._title;
        },

        /**
         * Set the window title
         * @param {string} title
         */
        setTitle: function(title) {
          this._title = title;
          this.emit(context.constants.widgetEvents.titleChanged, title);
        },

        /**
         * Get the window icon
         * @returns {string}
         */
        getIcon: function() {
          return this._icon;
        },

        /**
         * Set the window icon
         * @param {string} icon
         */
        setIcon: function(icon) {
          this._icon = icon;
          const widget = this.getWidget();
          if (widget) {
            widget.setImage(icon);
          }
          this.emit(context.constants.widgetEvents.iconChanged, icon);
        },

        /**
         * Return whether this window is the current one in the application or not
         * @returns {boolean}
         */
        isCurrentWindowNode: function() {
          const uiNode = this.getApplication().getNode(0);
          return uiNode.attribute('currentWindow') === this.getId();
        },

        /**
         * Is this window in traditional mode
         * @returns {boolean}
         */
        isTraditional: function() {
          const uiNode = this.getApplication().getNode(0);
          const winStyle = this.attribute("style");

          // Traditional mode is not applied on dialog (as GDC)
          if (uiNode.attribute("uiMode") === "traditional" && winStyle !== 'dialog') {
            const formNode = this.getFirstChild("Form");
            if (formNode) {
              const screenNode = formNode.getFirstChild("Screen");
              if (screenNode) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * Get the first traditional window
         * @returns {null|classes.WindowNode}
         */
        getFirstTraditionalWindow: function() {
          const children = this.getApplication().getNode(0).getChildren();
          for (const child of children) {
            if (child.getTag() === "Window" && child.isTraditional()) {
              return child;
            }
          }
          return null;
        },

        /**
         * Get the active dialog
         * @returns {classes.NodeBase}
         */
        getActiveDialog: function() {
          const length = this._children.length;
          for (let i = length - 1; i >= 0; --i) {
            const child = this._children[i];
            if (child._tag === 'Menu' || child._tag === 'Dialog') {
              if (child.attribute('active') === 1) {
                return child;
              }
            }
          }
        },

        /**
         * Is this window modal
         * @returns {boolean}
         */
        isModal: function() {
          if (this._isDestroying) {
            return this._isModal;
          }

          const windowTypeAttr = this.getStyleAttribute("windowType");
          this._isModal = windowTypeAttr === "modal" ||
            windowTypeAttr === "popup" ||
            (windowTypeAttr === "modalOnLargeScreen" && gbc.ThemeService.getMediaString() === "large");
          return this._isModal;
        },

        _setProcessingStyle: function(processing) {
          const widget = this._controller && this._controller.getWidget();
          if (widget?._setProcessingStyle) {
            widget._setProcessingStyle(processing);
          }
        },

        /**
         * Set the parent window identifier
         * @param {number} parentWindowId identifier o17f the parent window
         */
        setParentWindowId: function(parentWindowId) {
          this._parentWindowId = parentWindowId;
        },

        /**
         * Get the parent window identifier
         * @return {number} - the id of the parent window
         */
        getParentWindowId: function() {
          return this._parentWindowId;
        },

        /**
         * Get the pasent window when modal
         * @returns {null|classes.WindowNode}
         */
        getParentNodeWhenModal: function() {
          if (this.isModal() && this.getParentWindowId() > 0) {
            return this.getParentNode().getFirstChildWithId(this.attribute("parent"));
          }
          return null;
        }
      };
    });
    cls.NodeFactory.register("Window", cls.WindowNode);
  });
;

"use strict";

/**
 * @typedef {Object} ControllerBindings
 * @property {classes.NodeBase} anchor
 * @property {?classes.NodeBase} decorator
 * @property {?classes.NodeBase} container
 * @property {?Object} additionalBindings
 */

modulum('ControllerBase', ['EventListener'],
  /**
   * @namespace Controllers
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ControllerBase
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ControllerBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ControllerBase.prototype */ {
        __name: "ControllerBase",
        /**
         * list of controller's node binding
         * @type {?ControllerBindings}
         */
        _nodeBindings: null,
        /**
         * list of controller's node binding ids
         * @type {number[]}
         */
        _nodeBindingsIds: null,
        /**
         * list of controller's node binding ids
         * @type {Set<string>}
         */
        _watchedNodeBindings: null,
        /**
         * list of controller's node binding ids
         * @type {Set<string>}
         */
        _watchedNodeBindingsAttributes: null,
        _watchesStyleNodeBinding: false,
        /**
         * linked behaviors
         * @type {Object[]}
         */
        _behaviors: null,
        /**
         * controller's widget
         * @type {classes.WidgetBase}
         */
        _widget: null,
        /**
         * controller's widget kind
         * @type {?string}
         */
        _widgetKind: null,
        /**
         * controller's widget active status
         * @type {?boolean}
         */
        _widgetActive: null,
        /**
         * controller's widget nbmp
         * @type {?string}
         */
        _widgetType: null,
        /**
         * if false, don't create controller's widget automatically
         * @type {boolean}
         */
        _autoCreateWidget: true,

        /**
         * Controller unique id
         * @type {number}
         */
        //_id: null,

        /**
         * List of the virtual widgets known by the real controller (not the placeholder controller)
         */
        _virtualWidgets: null,

        /**
         * Index of the current virtual widget (used by getWidget), -1 otherwise
         */
        _virtualWidgetsIdx: null,

        /**
         * Behaviors name to apply to the virtual widgets
         * @type {Set}
         */
        _behaviorToApplytoVirtualWidgets: null,

        /**
         * Behavior name list of the current controller
         * @type {Set}
         */
        _behaviorsNameList: null,

        /**
         * List of the placeholder controller known by the parent controller (ex: MenuController, DialogController)
         * @type {Map}
         */
        _placeholderControllers: null,

        /**
         * @constructs
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this);
          this._nodeBindings = bindings;
          this._watchedNodeBindings = new Set();
          this._watchedNodeBindingsAttributes = new Set();
          this._behaviors = [];
          this._widget = null;

          this._virtualWidgets = [];
          this._virtualWidgetsIdx = -1;
          this._behaviorToApplytoVirtualWidgets = new Set();
          this._behaviorsNameList = new Set();
          this._placeholderControllers = new Map();

          this.createWidget();
          this._initBehaviors();
          this.updateNodeBindingsIds();
          if (gbc.qaMode) {
            this._addBehavior(cls.QAInfoVMBehavior);
          }
          this._addBehavior(cls.AuiNameVMBehavior);
        },

        _initWidgetKind: function() {
          if (this._nodeBindings.container) {
            this._widgetKind = this._nodeBindings.container.attribute("dialogType");
            this._widgetActive = this._nodeBindings.container.attribute("active");
          }
          this._widgetType = this._getWidgetType(this._widgetKind, this._widgetActive);
        },

        isInMatrix: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInMatrix();
        },

        isInTable: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInTable();
        },

        isInFirstTableRow: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInFirstTableRow();
        },

        isInStack: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInStack();
        },

        isInScrollGrid: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInScrollGrid();
        },

        isInToolBar: function() {
          return this.getAnchorNode() && this.getAnchorNode().isInToolBar();
        },

        /**
         * init behaviors: override in children class
         * @protected
         * @abstract
         */
        _initBehaviors: function() {},

        /**
         * Link behavior to the controller
         * @param {Function} BehaviorClass the behavior class to link
         * @param {*} [config] configuration object
         * @protected
         */
        _addBehavior: function(BehaviorClass, config) {
          const behaviorContainer = {
            _behavior: BehaviorClass,
            dirty: true,
            appliedOnce: false
          };

          if (BehaviorClass.watchedAttributes) {
            Object.keys(BehaviorClass.watchedAttributes).forEach(binding => {
              this._watchedNodeBindings.add(binding);
              BehaviorClass.watchedAttributes[binding].forEach(attr => this._watchedNodeBindingsAttributes.add(attr));
            });
          }
          if (BehaviorClass.usedStyleAttributes && BehaviorClass.usedStyleAttributes.length) {
            this._watchesStyleNodeBinding = true;
          }
          if (BehaviorClass.setup) {
            BehaviorClass.setup(this, behaviorContainer, config);
          }
          this._behaviors.push(behaviorContainer);
          BehaviorClass.firstAttach(this, behaviorContainer);

          this._behaviorsNameList.add(behaviorContainer._behavior.__name);
        },

        /**
         * Applies all behaviors attached to this controller
         * @param {classes.TreeModificationTracker} treeModificationTrack list of nodes where behaviors were applied
         * @param {?boolean} force true force apply all
         * @return {boolean} true if behaviors went dirty
         */
        applyBehaviors: function(treeModificationTrack, force) {
          let remainingDirty = false,
            invalidatesFollowing = false;
          const len = this._behaviors.length;

          for (let i = 0; i < len; i++) {
            const behaviorContainer = this._behaviors[i];
            const behavior = behaviorContainer._behavior;
            if (behavior === cls.QAInfoVMBehavior || behavior === cls.AuiNameVMBehavior) {
              behavior.apply(this, behaviorContainer);
              if (this._widget) {
                this._widget.addAppliedBehavior(behavior.__name);
              }

            } else {
              if (force || invalidatesFollowing || behaviorContainer.dirty ||
                (!treeModificationTrack || treeModificationTrack.hasOne(this.getNodeBindingsIds(),
                  this._watchedNodeBindingsAttributes, this._watchesStyleNodeBinding)) &&
                behavior.canApply(this, behaviorContainer, treeModificationTrack)) {
                invalidatesFollowing = behavior.apply(this, behaviorContainer) || invalidatesFollowing;

                if (this._widget) {
                  this._widget.addAppliedBehavior(behavior.__name);
                }

                //Placeholder management
                if (this._behaviorToApplytoVirtualWidgets.has(behavior.__name)) {
                  //Apply behavior on virtual widget
                  for (this._virtualWidgetsIdx = 0; this._virtualWidgetsIdx < this._virtualWidgets.length; this._virtualWidgetsIdx++) {
                    const authBehaviors = this._virtualWidgets[this._virtualWidgetsIdx].commonBehaviorsName;
                    if (authBehaviors.has(behavior.__name)) {
                      let virtualWidget = this.getWidget();
                      behavior.apply(this, behaviorContainer);
                      virtualWidget.addAppliedBehavior(behavior.__name);
                    }
                  }
                  this._virtualWidgetsIdx = -1;
                }
              }
              remainingDirty = remainingDirty || behavior.dirty;
            }
          }

          return remainingDirty;
        },

        /**
         * Reapply behaviours to all the virtual widgets that are not yet applied once
         */
        reapplyBehaviourToVirtualWidgets: function() {
          let len = this._behaviors.length;

          for (let i = 0; i < len; i++) {
            let behaviorContainer = this._behaviors[i];
            let behavior = behaviorContainer._behavior;

            if (behaviorContainer.appliedOnce && this._behaviorToApplytoVirtualWidgets.has(behavior.__name)) {
              for (this._virtualWidgetsIdx = 0; this._virtualWidgetsIdx < this._virtualWidgets.length; this._virtualWidgetsIdx++) {
                let authBehaviors = this._virtualWidgets[this._virtualWidgetsIdx].commonBehaviorsName;
                let virtualWidegt = this.getWidget();

                if (!virtualWidegt.isAppliedBehavior(behavior.__name) && authBehaviors.has(behavior.__name)) {
                  behavior.apply(this, behaviorContainer);
                }
              }
            }
          }

          this._virtualWidgetsIdx = -1;
        },

        /**
         * attach widget
         * @protected
         */
        _attachWidget: function() {
          for (const element of this._behaviors) {
            const behaviorContainer = element;
            behaviorContainer._behavior.attachWidget(this, behaviorContainer);
          }
        },
        /**
         * detach widget
         * @protected
         */
        _detachWidget: function() {
          for (const element of this._behaviors) {
            const behaviorContainer = element;
            behaviorContainer._behavior.detachWidget(this, behaviorContainer);
          }
        },
        /**
         * destroy behaviors
         * @protected
         */
        _destroyBehaviors: function() {
          for (const element of this._behaviors) {
            const behaviorContainer = element;
            behaviorContainer._behavior.cleanup(this, behaviorContainer);
            behaviorContainer._behavior = null;
          }
          this._behaviors.length = 0;
          this._behaviors = null;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.emit(context.constants.controllerEvents.beforeDestroy);

          this._destroyBehaviors();
          this.detachUI();
          this._nodeBindings = null;
          this._widget = null;

          this._behaviorsNameList.clear();
          this._behaviorToApplytoVirtualWidgets.clear();
          for (const element of this._virtualWidgets) {
            element.commonBehaviorsName.clear();
          }
          this._virtualWidgets.length = 0;
          this._virtualWidgets = null;

          this._placeholderControllers.clear();
          this._placeholderControllers = null;

          $super.destroy.call(this);
        },

        /**
         * Get the anchor node
         * @returns {classes.NodeBase} the anchor node
         */
        getAnchorNode: function() {
          return this._nodeBindings && this._nodeBindings.anchor;
        },
        /**
         * Get the application node
         * @returns {classes.NodeBase} the ui node
         */
        getUINode: function() {
          return this._nodeBindings && this._nodeBindings.ui;
        },
        /**
         * get the nodes linked to the controller
         * @returns {ControllerBindings} the nodes
         */
        getNodeBindings: function() {
          return this._nodeBindings;
        },
        /**
         * get the nodes linked to the controller
         * @returns {ControllerBindings} the nodes
         */
        getNodeBindingsIds: function() {
          return this._nodeBindingsIds;
        },
        /**
         * update the nodes ids linked to the controller
         */
        updateNodeBindingsIds: function() {
          let keys = this._nodeBindings && Object.keys(this._nodeBindings) || [];
          this._nodeBindingsIds = keys.map(k => {
            if (this._watchedNodeBindings.has(k)) {
              let id = this._nodeBindings[k] && this._nodeBindings[k].getId();
              return Object.isNumber(id) ? id : -1;
            }
            return -1;
          });
        },
        /**
         * create widget
         * @returns {classes.WidgetBase} the widget
         */
        createWidget: function() {
          if (!this._widget && this.autoCreateWidget()) {
            this._initWidgetKind();
            this._widget = this._createWidget(this._widgetType);
          }
          return this._widget;
        },

        /**
         * create widget from given type
         * @param {string} widgetType the widget type
         * @returns {classes.WidgetBase} the widget
         */
        createWidgetFromType: function(widgetType) {
          if (!this._widget) {
            this._widgetType = widgetType;
            this._widget = this._createWidget(this._widgetType);
          }
          return this._widget;
        },

        /**
         * Check if the widget should be automatically created.
         * @return {boolean} true if controller will create widget automatically
         */
        autoCreateWidget: function() {
          return this._autoCreateWidget;
        },

        /**
         * Set if widget should be automatically created
         * @param {boolean} b true if widget should be automatically created
         */
        setAutoCreateWidget: function(b) {
          this._autoCreateWidget = b;
        },

        /**
         * Basic widget types depending on dialogType. To override for specific rules
         * @param {string} kind widget dialogType
         * @param {boolean} [active] is dialog active ?
         * @returns {string} widget type
         * @protected
         */
        _getWidgetType: function(kind, active) {
          return this.__name.replace("Controller", "");
        },

        /**
         * create widget
         * @param {string} [type] the widget type
         * @returns {classes.WidgetBase} the created widget
         * @protected
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            realWidget: this._widget,
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid(),
            inToolBar: this.isInToolBar()
          }, this.getAnchorNode());
        },

        /**
         * create a virtual widget
         * @param {classes.ControllerPlaceholderBase} placeholderController controller of the placeholder
         * @param {string} type the widget type
         * @returns {classes.WidgetBase} the created widget
         * @protected
         */
        createVirtualWidget: function(placeholderController, type) {
          const infoVirtualWidget = this._virtualWidgets.find(i => i.placeholderController === placeholderController);

          if (infoVirtualWidget) {
            return null;
          }

          const widget = this._createWidget(type);
          const info = {
            placeholderController: placeholderController,
            widget: widget,
            commonBehaviorsName: placeholderController._commonBehaviors(this)
          };

          //Update commons bevahiors
          info.commonBehaviorsName.forEach((behaviorName) => {
            this._behaviorToApplytoVirtualWidgets.add(behaviorName);
          });

          this._virtualWidgets.push(info);

          let hdl = widget.when(context.constants.widgetEvents.destroyed, (event) => {
            if (hdl) {
              hdl();
              hdl = null;
            }

            if (this._virtualWidgets) {
              this._virtualWidgets = this._virtualWidgets.filter(i => i !== info);
            }
          });

          return widget;
        },
        /**
         * Recreate widget depending on dialogType
         * @param {string} kind widget kind
         * @param {boolean} active is dialog active ?
         */
        changeWidgetKind: function(kind, active) {
          if ((kind !== this._widgetKind || active !== this._widgetActive) && this.autoCreateWidget()) {
            this._widgetKind = kind;
            this._widgetActive = active;
            const type = this._getWidgetType(kind, active);
            if (type !== this._widgetType) {
              this._widgetType = type;
              const oldWidget = this._widget;
              this._detachWidget();
              this._widget = this._createWidget(type);
              if (this._widget) {
                if (oldWidget) {
                  oldWidget.replaceWith(this._widget);
                } else {
                  // No older widget to replace, attach new one
                  this.attachUI();
                }
              }

              if (oldWidget) {
                oldWidget.destroy();
              }
              this._attachWidget();
              return true;
            } else if (this._widget.setWidgetMode) {
              this._widget.setWidgetMode(kind, active);
            }
          }
          return false;
        },

        /**
         * attach UI
         */
        attachUI: function() {
          const anchorNode = this.getAnchorNode();
          cls.NodeHelper.addToParentWidget(anchorNode, null);

          //Real widget controller attach virtual widgets in the placeholder
          if (this._virtualWidgets.length > 0) {
            const position = anchorNode.getIndex();
            const parentNode = anchorNode.getParentNode();

            const parentController = parentNode.getController();
            const parentId = parentNode.getId();

            for (this._virtualWidgetsIdx = 0; this._virtualWidgetsIdx < this._virtualWidgets.length; this._virtualWidgetsIdx++) {
              const info = this._virtualWidgets[this._virtualWidgetsIdx];
              const placeholderWidget = info.placeholderController.getWidget();

              placeholderWidget.setPositionInParent(info.placeholderController.getAnchorNode().getVirtualIndex());
              placeholderWidget.addVirtualChildWidget(parentId, info.widget, position);
              parentController._addPlaceholderController(info.placeholderController);
            }

            this._virtualWidgetsIdx = -1;
          }
        },

        /**
         * detach UI
         */
        detachUI: function() {
          if (this._widget) {
            if (this.autoCreateWidget()) { // if auto create --> auto destroy
              this._widget.destroy();
            }
            this._widget = null;
          }

          for (this._virtualWidgetsIdx = 0; this._virtualWidgetsIdx < this._virtualWidgets.length; this._virtualWidgetsIdx++) {
            const info = this._virtualWidgets[this._virtualWidgetsIdx];

            info.widget.destroy();
            info.commonBehaviorsName.clear();
            //TODO Maybe refresh the commonBehavior list (don't know if it is usefull in real life)
          }

          this._virtualWidgets.length = 0;
          this._virtualWidgetsIdx = -1;
        },

        /**
         * get the widget
         * @returns {classes.WidgetBase} the widget
         */
        getWidget: function() {
          if (this._virtualWidgetsIdx >= 0) {
            return this._virtualWidgets[this._virtualWidgetsIdx].widget;
          }

          return this._widget;
        },

        /**
         * Returns current internal widget (in table or matrix)
         * @returns {classes.WidgetBase} current internal widget
         * @public
         */
        getCurrentInternalWidget: function() {
          let widget = null;
          const node = this.getAnchorNode();
          if (node.getCurrentValueNode) {
            const valueNode = node.getCurrentValueNode(false);
            if (valueNode) {
              const controller = valueNode.getController();
              if (controller) {
                widget = controller.getWidget();
              }
            }
          }
          return widget;
        },

        /**
         * Ensures the widget corresponding to this controller is visible to the user
         * @param {boolean} [executeAction] - true to execute action linked (e.g. for a page, the linked action when showing)
         * @return {boolean} true if a layout is needed after that
         */
        ensureVisible: function(executeAction) {
          let p = this.getAnchorNode().getParentNode(),
            result = false;
          while (p !== null) {
            const controller = p.getController();
            if (controller !== null) {
              result = result || controller.ensureVisible(executeAction);
              break;
            }
            p = p.getParentNode();
          }
          return result;
        },

        /**
         * Try to set focus to controller's widget
         */
        setFocus: function() {
          if (this._widget && this._widget.setFocus) {
            this._widget.setFocus();
            this._widget.emit(context.constants.widgetEvents.focus);
          }
          // Hide filter menu item from chrome bar
          this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(false);
        },

        /**
         * update dirty state of style application behaviors
         *
         * @param {boolean} noUsageCheck if false or not defined, set as dirty in all cases
         * @param {boolean} noRecurse if false or not defined, do it recursively
         * @param {boolean} fromPseudoSelection
         * @protected
         */
        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse, fromPseudoSelection) {
          const app = this.getAnchorNode().getApplication();
          for (const element of this._behaviors) {
            const behaviorContainer = element;
            const behavior = behaviorContainer._behavior,
              len = behavior.usedStyleAttributes && behavior.usedStyleAttributes.length;
            if (fromPseudoSelection) {
              behaviorContainer.dirty = true;
            } else if (len) {
              if (noUsageCheck) {
                behaviorContainer.dirty = true;
              } else {
                for (let j = 0; j < len; ++j) {
                  if (app.usedStyleAttributes[behavior.usedStyleAttributes[j]]) {
                    behaviorContainer.dirty = true;
                    break;
                  }
                }
              }
            }
          }
          if (!noRecurse) {
            const children = this.getAnchorNode().getRawChildren();
            for (const child of children) {
              const ctrl = child.getController();
              if (ctrl) {
                ctrl.setStyleBasedBehaviorsDirty(noUsageCheck, null, fromPseudoSelection);
              }
            }
          }
        },

        /**
         * Set stored setting for this controller
         * @param key {string} Setting key
         * @param value {*} Setting value
         */
        setStoredSetting: function(key, value) {},

        /**
         * Get stored setting for this controller
         * @param key {string} Setting key
         * @returns {*} the stored settings object, if any
         */
        getStoredSetting: function(key) {
          return null;
        },

        /**
         * Sends the updated value to the DVM
         * @param {?string} [newValue] - new value to send to VM. If not specified we send current widget value.
         */
        sendWidgetValue: function(newValue = null) {},

        /**
         * Sends the updated cursors to the DVM
         */
        sendWidgetCursors: function() {},

        /**
         * Check if Widget should be display in chromebar or keep the default behavior
         * @return {Boolean} true if it's displayed in the chromebar
         */
        isInChromeBar: function() {
          const anchor = this.getAnchorNode();
          const ancestorWindow = anchor.getAncestor("Window");
          const isInTabbedContainer = anchor.getApplication().getSession().isInTabbedContainerMode();
          const ancestorMenu = anchor.getAncestor("Menu");
          const isMenuWinMsg = ancestorMenu && ancestorMenu._vmStyles.indexOf("winmsg") >= 0 || anchor._vmStyles.indexOf("winmsg") >=
            0; //menu item in winmsg
          const isDialogMenu = ancestorMenu && ancestorMenu._vmStyles.indexOf("dialog") >= 0;
          const isPopupMenu = ancestorMenu && ancestorMenu._vmStyles.indexOf("popup") >= 0 || anchor._vmStyles.indexOf("popup") >=
            0; //menu item in popup
          const isWinMsg = ancestorWindow && ancestorWindow._vmStyles.indexOf("winmsg") >= 0; //menu item in winmsg
          const isWinModal = ancestorWindow && ancestorWindow.getStyleAttribute("windowType") === "modal"; //menu item in modal window

          // Position style for all MENU (and MENU items under this instruction)
          let ringMenuPositionStyle = ancestorWindow && (ancestorWindow._initialStyleAttributes.ringMenuPosition || gbc.ThemeService
            .getValue("gbc-WindowWidget-defaultRingMenuPosition"));
          // Position style for all ACTIONs in a DIALOG
          let actionPanelPositionStyle = ancestorWindow && (ancestorWindow._initialStyleAttributes.actionPanelPosition || gbc
            .ThemeService
            .getValue("gbc-WindowWidget-defaultActionPanelPosition"));

          // Position style for TOOLBAR
          // For the window toolbar, get the parent window style
          // For a global toolbar, get the first window style in userInterface node
          const tbWindow = ancestorWindow || anchor.getAncestor("UserInterface").getChildren("Window")[0];
          let toolbarPositionStyle = tbWindow && (tbWindow._initialStyleAttributes.toolBarPosition || gbc.ThemeService.getValue(
            "gbc-WindowWidget-defaultToolBarPosition"));
          //Override if chrome position is set at toolbar level
          const toolBarNode = this.isInstanceOf(cls.ToolBarItemController) ? this.getAnchorNode().getParentNode() : this.getAnchorNode();
          toolbarPositionStyle = toolBarNode._initialStyleAttributes.position ?? toolbarPositionStyle;
          // In tabbed container mode, override the default theme / 4ST to never use the chromebar
          if (isInTabbedContainer) {
            toolbarPositionStyle = toolbarPositionStyle === "chrome" ? "top" : toolbarPositionStyle;
            ringMenuPositionStyle = ringMenuPositionStyle === "chrome" ? "right" : ringMenuPositionStyle;
            actionPanelPositionStyle = actionPanelPositionStyle === "chrome" ? "right" : actionPanelPositionStyle;
          }

          // This final step defines if the position is in chromeBar
          let position4STChrome = false;
          if (this.isInstanceOf(cls.ToolBarController) || this.isInstanceOf(cls.ToolBarItemController) || this.isInstanceOf(cls
              .ToolBarAutoItemsController)) {
            position4STChrome = toolbarPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.MenuActionController) || this.isInstanceOf(cls.MenuController)) {
            position4STChrome = ringMenuPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.ActionController)) {
            position4STChrome = actionPanelPositionStyle === "chrome";
          } else if (this.isInstanceOf(cls.DialogController)) {
            position4STChrome = actionPanelPositionStyle === "chrome";
          }

          // Don't display menus as chromebar on modal or popup
          return position4STChrome && !isDialogMenu && !isMenuWinMsg && !isPopupMenu && !isWinMsg && !isWinModal;
        },

        /**
         * Register a placeholder controller
         * @param {classes.ControllerPlaceholderBase} controller
         * @private
         */
        _addPlaceholderController: function(controller) {
          let hdl = controller.getWidget().when(context.constants.widgetEvents.destroyed, (event) => {
            if (hdl) {
              hdl();
              hdl = null;
            }

            if (this._placeholderControllers) {
              this._placeholderControllers.delete(controller.getWidget().getUniqueIdentifier());
            }
          });

          this._placeholderControllers.set(controller.getWidget().getUniqueIdentifier(), controller);
        },

        /**
         * Get the placeholder controller Map
         * @return {Map}
         */
        getPlaceholderControllers: function() {
          return this._placeholderControllers;
        },

        /**
         * Returns true if the widget has an associated dropdown opened
         * @returns {boolean}
         */
        hasActiveDropDown: function() {
          return false;
        }
      };
    });
  });
;
"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.controllerEvents = {
  created: 'g_created'
};
;

"use strict";

modulum('ControllerFactory', ['Factory'],
  function(context, cls) {
    /**
     * @namespace classes.ControllerFactory
     */
    cls.ControllerFactory = context.oo.StaticClass(function() {
      const _eventListener = new cls.EventListener();

      /**
       *
       * @type {classes.Factory}
       */
      const factory = new cls.Factory("Controller");
      return /** @lends classes.ControllerFactory */ {

        /**
         * Trigger the handler when a controller for node name kind is created
         * @param {string} kind node name
         * @param {Hook} handler - handler to trigger
         * @returns {classes.ControllerBase}
         */
        onControllerCreated: function(kind, handler) {
          return _eventListener.when(context.constants.controllerEvents.created, function(id) {
            if (handler && id.data[0] === kind) {
              handler(id.data[0], id.data[1]);
            }
          });
        },

        /**
         *
         * @param {string} id
         * @param {Function} constructor
         */
        register: function(id, constructor) {
          factory.register(id, constructor);
        },
        /**
         *
         * @param {string} id
         */
        unregister: function(id) {
          factory.unregister(id);
        },
        /**
         *
         * @param {string} id
         * @returns {classes.ControllerBase}
         */
        create: function(id, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
          const controller = factory.create(id, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

          _eventListener.emit(context.constants.controllerEvents.created, id, controller);

          return controller;
        }

      };
    });
  });
;

"use strict";

modulum('ControllerGroup', ['EventListener'],
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ControllerGroup
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ControllerGroup = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ControllerGroup.prototype */ {
        __name: "ControllerGroup",
        /**
         * @type {classes.NodeBase}
         */
        _anchorNode: null,
        /**
         * @type {classes.ControllerBase[]}
         */
        _controllers: null,

        /**
         * @param {classes.NodeBase} anchorNode bindings
         */
        constructor: function(anchorNode) {
          $super.constructor.call(this);
          this._anchorNode = anchorNode;
          this._controllers = [];
        },

        addController: function(controller) {
          this._controllers.push(controller);
        },

        getControllers: function() {
          return this._controllers;
        },

        /**
         * Applies all behaviors of sub-controllers
         */
        applyBehaviors: function(treeModificationTrack, force) {
          for (const element of this._controllers) {
            element.applyBehaviors(treeModificationTrack, force);
          }
        },

        destroy: function() {
          for (const element of this._controllers) {
            element.destroy();
          }
        },
        /**
         * Get the anchor node
         * @returns {classes.NodeBase}
         */
        getAnchorNode: function() {
          return this._anchorNode;
        },

        getWidget: function() {
          if (this._controllers.length) {
            return this._controllers[this._controllers.length - 1].getWidget();
          } else {
            return null;
          }
        },

        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse, fromPseudoSelection) {
          for (const element of this._controllers) {
            element.setStyleBasedBehaviorsDirty(noUsageCheck, noRecurse, fromPseudoSelection);
          }
        },

        ensureVisible: function() {}
      };
    });
  }
);
;

"use strict";

modulum('ControllerPlaceholderBase', ['ControllerBase'],
  function(context, cls) {
    /**
     * @class ControllerPlaceholderBase
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ControllerPlaceholderBase = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ControllerPlaceholderBase.prototype */ {
        __name: "ControllerPlaceholderBase",

        /**
         * Set of behavior name to be applied by the placeholder on the virtual widgets
         * @type {Set}
         */
        _behaviorsApplyedByPlaceholderOnVirtualWidget: null,

        constructor: function(bindings) {
          this._behaviorsApplyedByPlaceholderOnVirtualWidget = new Set();

          $super.constructor.call(this, bindings);
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          //If we are a placeholder only children are added to the parent widget (ex:TopMenuGroup)
          const anchorNode = this.getAnchorNode();
          const parentWidget = anchorNode.getParentNode().getWidget();

          if (parentWidget.isChromeBar && anchorNode.getParentNode().getController().isInChromeBar()) {
            //If we are in the chromebar put the placeholder in the DOM
            this.getWidget().setPositionInParent(0);
            $super.attachUI.call(this);
          } else {
            this.getWidget().setPositionInParent(anchorNode.getVirtualIndex());
            this.getWidget().setParentWidget(parentWidget);
          }
        },

        /**
         * Return the common behaviours
         * @param {classes.ControllerBase} controller
         * @return {Set} common behaviors
         */
        _commonBehaviors: function(controller) {
          const res = new Set();

          this._behaviorsNameList.forEach((behaviorName) => {
            if (!this._behaviorsApplyedByPlaceholderOnVirtualWidget.has(behaviorName) && controller._behaviorsNameList.has(
                behaviorName)) {
              res.add(behaviorName);
            }
          });

          return res;
        },

        /**
         * Link behavior to the controller
         * @param {Function} BehaviorClass the behavior class to link
         * @param {boolean} applyOnlyByPlaceholderWidget true if the behavior must be applied to the virtual widgets
         * @param {*} [config] configuration object
         * @protected
         */
        _addBehavior: function(BehaviorClass, applyOnlyByPlaceholderWidget, config) {
          $super._addBehavior.call(this, BehaviorClass, config);

          if (applyOnlyByPlaceholderWidget) {
            this._behaviorsApplyedByPlaceholderOnVirtualWidget.add(BehaviorClass.__name);
          }
        },

        /**
         * Set the active parent id (example: Menu id)
         * @param {number} parentId
         */
        setActiveParentId: function(parentId) {
          const anchorNode = this.getAnchorNode();
          const placeholderWidget = this.getWidget();

          placeholderWidget.setPositionInParent(anchorNode.getVirtualIndex());
          placeholderWidget.setActiveParentId(parentId);
        }

      };
    });
  });
;

"use strict";

modulum('CanvasArcController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasArcController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasArcController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasArcController.prototype */ {
        __name: "CanvasArcController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasArcParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasArc", cls.CanvasArcController);

  });
;

"use strict";

modulum('CanvasCircleController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasCircleController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasCircleController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasCircleController.prototype */ {
        __name: "CanvasCircleController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasCircleParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasCircle", cls.CanvasCircleController);

  });
;

"use strict";

modulum('CanvasController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasController.prototype */ {
        __name: "CanvasController",
        _afterLayoutHandler: null,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          const layoutService = this.getAnchorNode().getApplication().layout;
          this._afterLayoutHandler = layoutService.afterLayout(this.onAfterLayout.bind(this));
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        },

        onAfterLayout: function() {
          const children = this.getAnchorNode().getChildren();
          for (const element of children) {
            const ctrl = element.getController();
            if (ctrl.onAfterLayout) {
              ctrl.onAfterLayout();
            }
          }
        }
      };
    });
    cls.ControllerFactory.register("Canvas", cls.CanvasController);

  });
;

"use strict";

modulum('CanvasLineController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasLineController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasLineController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasLineController.prototype */ {
        __name: "CanvasLineController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasLineParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasLine", cls.CanvasLineController);

  });
;

"use strict";

modulum('CanvasOvalController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasOvalController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasOvalController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasOvalController.prototype */ {
        __name: "CanvasOvalController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasOvalParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasOval", cls.CanvasOvalController);

  });
;

"use strict";

modulum('CanvasPolygonController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasPolygonController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasPolygonController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasPolygonController.prototype */ {
        __name: "CanvasPolygonController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasPolygonParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasPolygon", cls.CanvasPolygonController);

  });
;

"use strict";

modulum('CanvasRectangleController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasRectangleController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasRectangleController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasRectangleController.prototype */ {
        __name: "CanvasRectangleController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasRectangleParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        }
      };
    });
    cls.ControllerFactory.register("CanvasRectangle", cls.CanvasRectangleController);

  });
;

"use strict";

modulum('CanvasTextController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CanvasTextController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.CanvasTextController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.CanvasTextController.prototype */ {
        __name: "CanvasTextController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.CanvasTextParametersVMBehavior);
          this._addBehavior(cls.CanvasFillColorVMBehavior);
          this._addBehavior(cls.CanvasItemOnClickUIBehavior);
        },

        onAfterLayout: function() {
          this.applyBehaviors(null, true);
        }
      };
    });
    cls.ControllerFactory.register("CanvasText", cls.CanvasTextController);

  });
;

"use strict";

modulum('FolderController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class FolderController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FolderController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FolderController.prototype */ {
        __name: "FolderController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.TabPosition4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.CollapserPosition4STBehavior);
          this._addBehavior(cls.NoSwipeVMBehavior);
          this._addBehavior(cls.NavigationArrows4STBehavior);
          this._addBehavior(cls.NavigationDots4STBehavior);

          // ui behaviors
          this._addBehavior(cls.ChangePageUIBehavior);

          const layoutService = this.getAnchorNode().getApplication().layout;
          this._afterLayoutHandler = layoutService.afterLayout(this.onAfterLayout.bind(this));

          // Set rendering mode from 4ST (must be applied before childs insertion)
          const lateRendering = this.getAnchorNode().getStyleAttribute('lateRendering');
          if (lateRendering && this.getWidget().setLateRendering) {
            this.getWidget().setLateRendering(lateRendering === "yes");
          }
        },

        onAfterLayout: function() {
          if (this.getWidget() && this.getWidget().updateScrollersVisibility) {
            this.getWidget().updateScrollersVisibility();
          }
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        }

      };
    });
    cls.ControllerFactory.register("Folder", cls.FolderController);

  });
;

"use strict";

modulum('FormController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class FormController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FormController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FormController.prototype */ {
        __name: "FormController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          if (this.getAnchorNode().getParentNode().isTraditional()) {
            this._addBehavior(cls.TraditionalFormSizingVMBehavior);
          }

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.VisibleIdVMBehavior);

          // ui behaviors
        },

        attachUI: function() {
          if (this._widget) {
            const layoutService = this.getAnchorNode().getApplication().layout;
            this._afterLayoutHandler = layoutService.afterLayout(function() {
              this._widget.removeClass("visibility-hidden");
              if (this._afterLayoutHandler) {
                this._afterLayoutHandler();
                this._afterLayoutHandler = null;
              }
            }.bind(this));
            this._widget.addClass("visibility-hidden");
          }
          $super.attachUI.call(this);
        },

        detachUI: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.detachUI.call(this);
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        }
      };
    });
    cls.ControllerFactory.register("Form", cls.FormController);

  });
;

"use strict";

modulum('GridController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class GridController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.GridController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.GridController.prototype */ {
        __name: "GridController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          // ui behaviors

          this._addBehavior(cls.GridAutomaticStack4STBehavior);
        },
        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Grid", cls.GridController);

  });
;

"use strict";

modulum('GroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class GroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.GroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.GroupController.prototype */ {
        __name: "GroupController",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Collapsible4STBehavior);
          this._addBehavior(cls.CollapserPosition4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          // ui behaviors
          this._addBehavior(cls.GridAutomaticStack4STBehavior);
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget(),
            result = widget.setCollapsed(false);
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return result || $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Group", cls.GroupController);

  });
;

"use strict";

modulum('HBoxController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class HBoxController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.HBoxController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.HBoxController.prototype */ {
        __name: "HBoxController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Packed4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.SplitterVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.SplitVMBehavior);
          this._addBehavior(cls.NoSwipeVMBehavior);
          this._addBehavior(cls.NavigationArrows4STBehavior);
          this._addBehavior(cls.NavigationDots4STBehavior);

          // ui behaviors
          this._addBehavior(cls.OnSplitterUIBehavior);
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid(),
            uiWidget: this.getUINode().getController().getWidget()
          }, this.getAnchorNode());
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("HBox", cls.HBoxController);

  });
;

"use strict";

modulum('MatrixController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MatrixController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MatrixController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MatrixController.prototype */ {
        __name: "MatrixController",
        _currentRow: 0,
        /**
         * true if value list has been initialized and created manually next to a delayed attribute change
         */
        _isValueListCreationForced: false,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this.setCurrentRow(this.getAnchorNode().attribute("currentRow"));
          // pseudo-selector behaviors
          this._addBehavior(cls.FocusCurrentCellPseudoSelectorBehavior);
          this._addBehavior(cls.OffsetPseudoSelectorBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
        },

        /**
         * @inheritDoc
         */
        setFocus: function() {
          const widget = this.getCurrentInternalWidget();
          if (widget) {
            if (this.isInScrollGrid()) {
              const scrollGridNode = this.getAnchorNode().getAncestor('ScrollGrid');
              const scrollGridController = scrollGridNode.getController();
              if (scrollGridController.getWidget() && scrollGridController.getWidget().activateRowBound) {
                scrollGridController.getWidget().activateRowBound();
              }
              // show filter when matrix is in scrollgrid
              scrollGridController.showReduceFilter();
            }
            widget.setFocus();
          } else {
            const appWidget = context.SessionService.getCurrent().getCurrentApplication().getUI().getWidget();
            if (appWidget) {
              const uiWidget = appWidget._uiWidget;
              if (uiWidget) {
                uiWidget.setFocus();
              }
            }
          }
        },

        setCurrentRow: function(currentRow) {
          this._currentRow = currentRow;
        },

        getCurrentRow: function() {
          return this._currentRow;
        },

        // @todo : not used at the moment
        updateCurrentRow: function(matrixNode, currentRow) {
          // Check if we are in a ScrollGrid
          const scrollGridNode = matrixNode.getAncestor('ScrollGrid');
          const scrollGridWidget = scrollGridNode ? scrollGridNode.getController().getWidget() : null;
          if (scrollGridWidget && scrollGridWidget.setCurrentRow) { // SCROLLGRID
            if (currentRow === -1 && scrollGridNode.attribute("active") === 1) {
              // if one matrix in scrollgrid has a currentRow equal to -1 --> focusOnField activated
              scrollGridWidget.setFocusOnField(true);
            }
            scrollGridWidget.setCurrentRow(currentRow);
            this.updateAllSiblingMatrixCurrentRow(currentRow, true, true);
          } else { // SIMPLE MATRIX
            const dialogType = matrixNode.attribute('dialogType');
            const displayDialog = dialogType === "Display" || dialogType === "DisplayArray";
            if (matrixNode.getTag() === "Matrix" && displayDialog) {
              matrixNode.getController().updateAllSiblingMatrixCurrentRow(currentRow, true);
            }
          }
          return null;
        },

        updateAllSiblingMatrixCurrentRow: function(currentRow, updateCss, isScrollGrid) {
          const matrixParent = this.getAnchorNode().getParentNode();
          if (!matrixParent) {
            return;
          }

          const childrenMatrix = matrixParent.getChildren("Matrix");
          if (!childrenMatrix) {
            return;
          }

          for (const colMatrix of childrenMatrix) {
            // update processing current row
            const matrixCtrl = colMatrix.getController();
            if (!matrixCtrl) {
              continue;
            }

            const previousRow = matrixCtrl.getCurrentRow();
            if (matrixCtrl && matrixCtrl.setCurrentRow) {
              matrixCtrl.setCurrentRow(currentRow);
            }

            // update current row css
            if (!updateCss) {
              continue;
            }

            const valueList = colMatrix.getFirstChild("ValueList");
            const widgets = valueList ? colMatrix.getFirstChild("ValueList").getChildren() : [];

            if (currentRow >= widgets.length || previousRow >= widgets.length) {
              continue;
            }

            const previousWidget = widgets[previousRow];
            if (previousWidget) {
              previousWidget.getController().getWidget().removeClass("currentRow");
            }
            const newWidget = widgets[currentRow];
            if (!newWidget) {
              continue;
            }
            let addCurrentRowOnField = true;
            const matrixParentWidget = matrixParent.getController().getWidget();
            if (isScrollGrid && matrixParentWidget.hasFocusOnField) {
              const matrixNode = this.getAnchorNode();
              const uiNode = matrixParent.getApplication().uiNode();
              const hasFocus = matrixNode.getId() === uiNode.attribute("focus");

              const isDisplayArray = (matrixNode.attribute("dialogType") === "DisplayArray");

              if (isDisplayArray && matrixParentWidget.hasFocusOnField()) {
                addCurrentRowOnField = addCurrentRowOnField && matrixParentWidget.isHighlightCurrentCell();
              } else if (!isDisplayArray && !matrixParentWidget.isHighlightCurrentRow()) {
                addCurrentRowOnField = addCurrentRowOnField && hasFocus && matrixParentWidget.isHighlightCurrentCell();
              }

            }
            newWidget.getController().getWidget().toggleClass("currentRow", addCurrentRowOnField);
          }
        },

        /**
         * Sends the updated value to the DVM
         * @private
         */
        sendWidgetValue: function(newValue = null) {
          const valueNode = this.getAnchorNode().getCurrentValueNode(true);
          if (valueNode) {
            const ctrl = valueNode.getController();
            if (ctrl) {
              ctrl.sendWidgetValue(newValue);
            }
          }
        },
      };
    });
    cls.ControllerFactory.register("Matrix", cls.MatrixController);

  });
;

"use strict";

modulum('PageController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class PageController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.PageController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.PageController.prototype */ {
        __name: "PageController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
        },

        /**
         *
         * @param {string=} type
         * @returns {classes.WidgetBase}
         * @protected
         */
        _createWidget: function(type) {
          const pageWidget = $super._createWidget.call(this, type);
          let parentPageWidget = null;
          const parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }
          pageWidget.emit(context.constants.widgetEvents.ready, parentPageWidget);
          return pageWidget;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const folderWidget = this.getAnchorNode().getParentNode().getController().getWidget();
          folderWidget.setCurrentPage(this.getWidget(), executeAction === true);
          folderWidget.emit(context.constants.widgetEvents.splitViewChange, this.getWidget());
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Page", cls.PageController);

  });
;

"use strict";

modulum('RowInfoController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class RowInfoController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.RowInfoController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.RowInfoController.prototype */ {
        __name: "RowInfoController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // vm behaviors
          this._addBehavior(cls.RowSelectedVMBehavior);
          // ui behaviors
        }
      };
    });
    cls.ControllerFactory.register("RowInfo", cls.RowInfoController);

  });
;

"use strict";

modulum('ScreenController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScreenController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScreenController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScreenController.prototype */ {
        __name: "ScreenController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);

          // ui behaviors
        },
        _getWidgetType: function() {
          const windowNode = this.getAnchorNode().getAncestor("Window");
          if (windowNode.isTraditional()) {
            return "TraditionalScreen";
          } else {
            return "Grid";
          }
        }
      };
    });
    cls.ControllerFactory.register("Screen", cls.ScreenController);

  });
;

"use strict";

modulum('ScrollAreaController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScrollAreaController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScrollAreaController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScrollAreaController.prototype */ {
        __name: "ScrollAreaController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.ThinScrollBarDisplayTime4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.ScrollVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ScrollUIBehavior);
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(newValue = null) {
          const ui = this.getUINode();
          const focusedNode = ui.getApplication().getNode(ui.attribute('focus'));
          const focusedWidgetController = focusedNode.getController();
          focusedWidgetController.sendWidgetValue(newValue);
        }
      };
    });
    cls.ControllerFactory.register("ScrollArea", cls.ScrollAreaController);

  });
;

"use strict";

modulum('ScrollGridController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ScrollGridController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ScrollGridController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ScrollGridController.prototype */ {
        __name: "ScrollGridController",
        /** @type {?classes.ScrollGridLineController[]} */
        _lineControllers: null,
        /** @type {?boolean} */
        _isPagedScrollGrid: null,

        /** @type {function} */
        _requestFocusHandler: null,

        /**
         * @inheritdoc
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);

          this._requestFocusHandler = this.getWidget().when(context.constants.widgetEvents.requestFocus, this._onRequestFocus.bind(this));
        },

        /**
         * @inheritdoc
         */
        destroy: function() {
          if (this._requestFocusHandler) {
            this._requestFocusHandler();
            this._requestFocusHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          if (this._ensureSupportedPagedScrollGrid()) {
            const isStretchable = this.getAnchorNode().attribute("wantFixedPageSize") === 0;
            this.nativeVerticalScroll = isStretchable;

            if (isStretchable) {
              this._lineControllers = [];
            }

            // These behaviors should stay added at first
            // WARNING : DO NOT ADD BEHAVIORS BEFORE
            this._addBehavior(cls.LayoutInfoVMBehavior);
            this._addBehavior(cls.StyleVMBehavior);
            // END WARNING

            // pseudo-selector behaviors
            this._addBehavior(cls.ActivePseudoSelectorBehavior);

            // vm behaviors
            this._addBehavior(cls.EnabledVMBehavior);
            this._addBehavior(cls.HiddenVMBehavior);
            this._addBehavior(cls.BackgroundColorVMBehavior);
            this._addBehavior(cls.FontFamilyVMBehavior);
            if (isStretchable) {
              this._addBehavior(cls.NativeScrollVMBehavior);
              this._addBehavior(cls.StretchableScrollGridPageSizeVMBehavior);
            } else {
              this._addBehavior(cls.ScrollVMBehavior);
            }
            if (this.isPagedScrollGrid()) {
              this._addBehavior(cls.PagedScrollGridCurrentRowVMBehavior);
            } else {
              this._addBehavior(cls.CurrentRowVMBehavior);
            }

            // 4st behaviors
            this._addBehavior(cls.Reverse4STBehavior);
            this._addBehavior(cls.RowActionTrigger4STBehavior);
            this._addBehavior(cls.Border4STBehavior);
            if (isStretchable) {
              this._addBehavior(cls.RowAspect4STBehavior);
              this._addBehavior(cls.ItemsAlignment4STBehavior);
              this._addBehavior(cls.ReduceFilter4STBehavior);
            }
            this._addBehavior(cls.Highlight4STBehavior);

            //ui behaviors
            this._addBehavior(cls.RowActionUIBehavior);
            this._addBehavior(cls.RowAndSelectionUIBehavior);
            if (this.isPagedScrollGrid()) {
              this._addBehavior(cls.OnLayoutPagedUIBehavior);
              this._addBehavior(cls.ScrollOffsetUIBehavior);
            } else if (isStretchable) {
              this._addBehavior(cls.NativeScrollUIBehavior);
              this._addBehavior(cls.OnLayoutUIBehavior);
              this._addBehavior(cls.RowBoundUIBehavior);
              this._addBehavior(cls.HaveRowActionsVMBehavior);
            } else {
              this._addBehavior(cls.ScrollUIBehavior);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          let parentPageWidget = null;
          const uiWidget = this.getUINode().getController().getWidget();
          const wantFixedPageSize = this.getAnchorNode().attribute("wantFixedPageSize") !== 0;
          const widgetKind = wantFixedPageSize ? 'ScrollGrid' : 'StretchableScrollGrid';
          const parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }
          return cls.WidgetFactory.createWidget(widgetKind, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            uiWidget: uiWidget,
            folderPageWidget: parentPageWidget
          }, this.getAnchorNode());
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(newValue = null) {
          const ui = this.getUINode();
          const focusedNode = ui.getApplication().getNode(ui.attribute('focus'));
          const focusedWidgetController = focusedNode.getController();
          focusedWidgetController.sendWidgetValue(newValue);
        },

        /**
         * Add a ScrollGrid line controller
         * @param {classes.ScrollGridLineController} lineController
         */
        pushLineController: function(lineController) {
          this._lineControllers.push(lineController);
        },

        /**
         * Removes the last ScrollGrid line controller
         * @returns {classes.ScrollGridLineController}
         */
        popLineController: function() {
          return this._lineControllers.pop();
        },

        /**
         * @param {number} index index of the line controller
         * @returns {classes.ScrollGridLineController} the line controller
         */
        getLineController: function(index) {
          return this._lineControllers[index];
        },

        /**
         * @returns {number} the number of line controllers
         */
        getLineControllersCount: function() {
          return this._lineControllers.length;
        },

        /**
         * @returns {number} the current row of the scrollgrid node
         */
        getCurrentRow: function() {
          return this.getAnchorNode().attribute("currentRow");
        },

        getOffset: function() {
          return this.getAnchorNode().attribute("offset");
        },

        /**
         * @return {boolean} true if this is a paged ScrollGrid
         */
        isPagedScrollGrid: function() {
          if (this._isPagedScrollGrid === null && this.getAnchorNode()) {
            const anchorNode = this.getAnchorNode();
            this._isPagedScrollGrid = anchorNode._initialStyleAttributes.customWidget === "pagedScrollGrid" && anchorNode.attribute(
              "wantFixedPageSize") === 0;
          }
          return this._isPagedScrollGrid;
        },

        /**
         * @return {boolean} true if this is a paged ScrollGrid
         */
        _ensureSupportedPagedScrollGrid: function() {
          const anchorNode = this.getAnchorNode();
          if (anchorNode) {
            if (anchorNode._initialStyleAttributes.customWidget === "pagedScrollGrid" && anchorNode.attribute(
                "wantFixedPageSize") === 1) {
              const app = anchorNode && anchorNode.getApplication();
              app.dvm.onOrdersManaged(function(app) {
                if (app) {
                  app.close();
                  app.stop("Paged Scrollgrid widget not supported with a Fixed page size");
                }
              }.bind(this, app), true);
              return false;
            }
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        },

        /**
         * Show filter in chrome bar.
         */
        showReduceFilter: function() {
          let widget = this.getWidget();
          if (widget.hasReduceFilter) {
            let showFilter = widget.hasReduceFilter();
            // show filter menu item from chrome bar
            let filterAttribute = this.getAnchorNode().attribute("filter");
            this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(showFilter, filterAttribute);
          }
        },

        /**
         * Bound to the scrollgrid widget RequestFocus method
         * @param {*} event 
         */
        _onRequestFocus: function(event) {
          let currentRow = event.data[0]?.currentRow;
          if (currentRow === undefined) {
            currentRow = -1;
          }
          this.getAnchorNode().getApplication().scheduler.focusVMCommand(this.getAnchorNode(), 0, 0, currentRow);
        }
      };
    });
    cls.ControllerFactory.register("ScrollGrid", cls.ScrollGridController);

  });
;

"use strict";

modulum('ScrollGridLineController', ['EventListener'],
  function(context, cls) {
    /**
     * This class need to be refactored and removed
     * @class ScrollGridLineController
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ScrollGridLineController = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ScrollGridLineController.prototype */ {
        __name: "ScrollGridLineController",
        /**
         * Controller widget
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type {number}
         */
        _index: -1,
        _scrollGridNode: null,
        _childrenControllers: null,

        constructor: function(scrollGridNode, index) {
          this._scrollGridNode = scrollGridNode;
          this._childrenControllers = [];
          this._index = index;
          this._widget = cls.WidgetFactory.createWidget('StretchableScrollGridLine',
            scrollGridNode.getController().getWidget().getBuildParameters());
          // we need to track row index of the widget because we may not be able to retrieve it from node later on (static image)
          this._widget.setRowIndex(index);
          const children = this._scrollGridNode.getChildren();
          for (const element of children) {
            this._createControllers(element, this._widget);
          }
        },

        destroy: function() {
          this._recursiveRemove(this._scrollGridNode);
          this._widget.destroy();
        },

        _applyBehaviors: function() {
          for (const ctrl of this._childrenControllers) {
            if (ctrl._behaviors !== null) {
              ctrl.applyBehaviors(null, true);
            }
          }
        },

        /**
         * Makes sure each child has controllers
         */
        updateControllers: function() {
          for (let element of this._scrollGridNode.getChildren()) {
            this._createControllers(element, this._widget);
          }
        },

        _createControllers: function(node, parentWidget) {
          let ctrl = null;
          let widget = null;
          if (node.getTag() === "Matrix") {
            if (node._controller === null) {
              node._controller = node._createController();
            }
            const valueList = node.getFirstChild("ValueList");
            if (valueList) {
              const valueNode = valueList.getChildren()[this._index];
              if (valueNode) {
                ctrl = valueNode.getController();
                if (!ctrl) {
                  ctrl = valueNode._createController({
                    scrollGridLineController: this
                  });
                  valueNode._controller = ctrl;
                  widget = ctrl.createWidget();
                  ctrl.applyBehaviors();
                  parentWidget.addChildWidget(widget);
                  ctrl._attachWidget();

                  this._childrenControllers.push(ctrl);
                }
              }
            }
          } else {
            let ctrlGroup = null;
            const nodeController = node._controller;
            if (!nodeController) {
              ctrlGroup = new cls.ControllerGroup(node);
              node._controller = ctrlGroup;
            } else if (nodeController.isInstanceOf(cls.ControllerGroup)) {
              ctrlGroup = nodeController;
            } else {
              return; // if controller is already created and if it is not a ControllerGroup, nothing to do
            }
            ctrl = node._createController({
              scrollGridLineController: this
            });
            if (ctrl) {
              ctrlGroup.addController(ctrl);
              widget = ctrl.createWidget();
              ctrl.applyBehaviors();
              parentWidget.addChildWidget(widget);
              ctrl._attachWidget();
              if (node.getTag() === "HBox" || node.getTag() === "Group") {
                const nodeChildren = node.getChildren();
                for (const element of nodeChildren) {
                  this._createControllers(element, widget);
                }
              }
            }
          }
        },

        _recursiveRemove: function(node) {
          const children = node.getChildren();
          for (const element of children) {
            this._recursiveRemove(element, this._index);
          }
          if (node._controller) {
            if (node._controller instanceof cls.ControllerGroup) {
              const ctrls = node._controller.getControllers();
              if (ctrls[this._index]) {
                ctrls[this._index].destroy();
              }
              ctrls.splice(this._index);
            } else if (node.getTag() === "Value" && node.getIndex() === this._index) {
              node._controller.destroy();
              node._controller = null;
            }
          }
        },

        getWidget: function() {
          return this._widget;
        },

        getIndex: function() {
          return this._index;
        },
      };
    });
  });
;

"use strict";

modulum('SpacerItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class SpacerItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.SpacerItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.SpacerItemController.prototype */ {
        __name: "SpacerItemController",

      };
    });
    cls.ControllerFactory.register("SpacerItem", cls.SpacerItemController);

  });
;

"use strict";

modulum('StackController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StackController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StackController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StackController.prototype */ {
        __name: "StackController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          // ui behaviors
        }
      };
    });
    cls.ControllerFactory.register("Stack", cls.StackController);

  });
;

"use strict";

modulum('TableColumnController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableColumnController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableColumnController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableColumnController.prototype */ {
        __name: "TableColumnController",

        /** @type {boolean} */
        _isTreeViewColumn: false,
        /** @type {boolean} */
        _isInitiallyHidden: false,

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {

          let tableColumnNode = bindings.anchor;
          let tableNode = tableColumnNode.getParentNode();

          this._isTreeViewColumn = Boolean(tableNode.getFirstChild('TreeInfo')) &&
            tableNode.getFirstChild('TableColumn') === tableColumnNode;

          $super.constructor.call(this, bindings);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE

          // END WARNING

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TableColumnTextVMBehavior);
          this._addBehavior(cls.TableRowHeightVMBehavior);
          this._addBehavior(cls.AggregateVMBehavior);
          this._addBehavior(cls.TableColumnTabIndexVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.UnhidableVMBehavior);
          this._addBehavior(cls.UnmovableVMBehavior);
          this._addBehavior(cls.UnsizableVMBehavior);

          // ui behaviors
          this._addBehavior(cls.TableColumnHideUIBehavior);
          this._addBehavior(cls.TableColumnOrderUIBehavior);
          this._addBehavior(cls.TableColumnDndUIBehavior);
          this._addBehavior(cls.TableColumnResizeUIBehavior);

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          const columnNode = this.getNodeBindings().anchor;
          const widget = cls.WidgetFactory.createWidget('RTableColumn', {
            appHash: columnNode.getApplication().applicationHash,
            appWidget: columnNode.getApplication().getUI().getWidget(),
            auiTag: columnNode.getId(),
            isTreeView: this._isTreeViewColumn,
            tableWidget: columnNode.getParentNode().getController().getWidget()
          }, columnNode);

          widget.setUserWidth(this.getStoredSetting("width"));
          return widget;
        },

        /**
         * @inheritDoc
         */
        setStoredSetting: function(key, value) {
          let anchor = this.getNodeBindings().anchor;
          let columnIndex = anchor.getParentNode().getChildren("TableColumn").indexOf(anchor);
          anchor.getParentNode().getController().setStoredSetting("columns.col" + columnIndex +
            "." + key, value);
        },

        /**
         * @inheritDoc
         */
        getStoredSetting: function(key) {
          let anchor = this.getNodeBindings().anchor;
          let columnIndex = anchor.getParentNode().getChildren("TableColumn").indexOf(anchor);
          return anchor.getParentNode().getController().getStoredSetting("columns.col" + columnIndex +
            "." + key);
        },

        /**
         * Is initially hidden ?
         * @return {boolean} is initially hidden ?
         */
        isInitiallyHidden: function() {
          return this._isInitiallyHidden;
        },

        /**
         * Set if col is initially hidden
         * @param {boolean} hidden - is initially hidden ?
         */
        setInitiallyHidden: function(hidden) {
          this._isInitiallyHidden = hidden;
        }
      };
    });
    cls.ControllerFactory.register("TableColumn", cls.TableColumnController);

  });
;

"use strict";

modulum('TableController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TableController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TableController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TableController.prototype */ {
        __name: "TableController",

        /** @type {String|null} */
        _storedSettingsKey: null,

        // specific variables used for multirow selection
        /** @type {number} */
        multiRowSelectionRoot: -1,
        /** @type {boolean} */
        updateMultiRowSelectionRoot: false,

        /** @type {boolean} */
        _isListView: false,
        /** @type {boolean} */
        _isTreeView: false,

        /** @type {boolean} */
        forceDefaultSettings: false,
        /** @type {boolean} */
        nativeVerticalScroll: true,

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {

          this._isListView = bindings.anchor.isListView();
          this._isTreeView = bindings.anchor.isTreeView();

          $super.constructor.call(this, bindings);
          this._initStoredSettings();
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          let parentPageWidget = null;
          const uiWidget = this.getUINode().getController().getWidget();
          const parentPageNode = this.getAnchorNode().getAncestor("Page");
          if (parentPageNode) {
            parentPageWidget = parentPageNode.getController().getWidget();
          }

          return cls.WidgetFactory.createWidget('RTable', {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            uiWidget: uiWidget,
            folderPageWidget: parentPageWidget,
            isTreeView: this._isTreeView
          }, this.getAnchorNode());
        },

        /**
         * Initialize Stored Setting
         * @private
         */
        _initStoredSettings: function() {
          const node = this.getNodeBindings().anchor;

          // Build stored settings key
          const formName = node.getAncestor("Form").attribute("name");
          const tabName = node.attribute("tabName");

          this._storedSettingsKey = "gwc.forms." + formName + ".tables." + tabName;
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.FocusCurrentCellPseudoSelectorBehavior);
          this._addBehavior(cls.OffsetPseudoSelectorBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.TableDialogTypeVMBehavior);
          if (this._isListView) { // This behavior creates widgets it's better to call it before other behaviors
            this._addBehavior(cls.ListViewPageSizeVMBehavior);
          }
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.FocusOnFieldVMBehavior);
          this._addBehavior(cls.VisibleRowsVMBehavior);
          this._addBehavior(cls.TableSortVMBehavior);
          this._addBehavior(cls.TableCurrentVMBehavior);
          this._addBehavior(cls.MultiRowSelectionVMBehavior);
          this._addBehavior(cls.WantFixedPageSizeVMBehavior);
          this._addBehavior(cls.PageSizeVMBehavior);
          this._addBehavior(cls.NativeScrollVMBehavior);
          this._addBehavior(cls.FlippedVMBehavior);

          // ui behaviors
          this._addBehavior(cls.NativeScrollUIBehavior);
          this._addBehavior(cls.OnLayoutUIBehavior);
          this._addBehavior(cls.RowAndSelectionUIBehavior);
          this._addBehavior(cls.TableFrozenUIBehavior);
          this._addBehavior(cls.TableResetToDefaultUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.RowActionUIBehavior);
          this._addBehavior(cls.TableSortUIBehavior);
          if (this._isTreeView) {
            this._addBehavior(cls.TreeItemKeyExpandUIBehavior);
            this._addBehavior(cls.TreeItemToggleUIBehavior);
          }
          this._addBehavior(cls.RowBoundUIBehavior);
          this._addBehavior(cls.HaveRowActionsVMBehavior);
          this._addBehavior(cls.TableClickOnContainerUIBehavior);
          // Pagination nav WIP
          //this._addBehavior(cls.ScrollOffsetUIBehavior);

          // 4st behaviors
          this._addBehavior(cls.TableType4STBehavior);
          this._addBehavior(cls.FrozenColumns4STBehavior);
          this._addBehavior(cls.TableHeader4STBehavior);
          this._addBehavior(cls.ShowGrid4STBehavior);
          this._addBehavior(cls.AllowWebSelection4STBehavior);
          this._addBehavior(cls.RowAspect4STBehavior);
          this._addBehavior(cls.Highlight4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ResizeFillsEmptySpace4STBehavior);
          this._addBehavior(cls.RowActionTrigger4STBehavior);
          this._addBehavior(cls.ReduceFilter4STBehavior);
          this._addBehavior(cls.RowHover4STBehavior);
          this._addBehavior(cls.AlternateRows4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.SummaryLine4STBehavior);

          // should be set before table column widgets creation
          this.forceDefaultSettings = this.getAnchorNode().getStyleAttribute('forceDefaultSettings') === "yes";

        },

        /**
         * Build row selection event
         * @param {number} row - row selected
         * @param {boolean} ctrlKey - true if ctrl key is pressed
         * @param {boolean} shiftKey - true if shift key is pressed
         * @returns {object} row selection event
         */
        buildRowSelectionEvent: function(row, ctrlKey, shiftKey) {

          const node = this.getNodeBindings().anchor;
          let startIndex = row;
          let endIndex = row;
          let mode = "set";

          if (shiftKey) {
            if (this.multiRowSelectionRoot === -1) {
              this.multiRowSelectionRoot = node.attribute('currentRow');
            }

            startIndex = this.multiRowSelectionRoot;
            endIndex = row;
            mode = ctrlKey ? "exset" : "set";

            this.updateMultiRowSelectionRoot = false;
          } else if (ctrlKey) {
            const children = node.getChildren();
            const rowInfoListNode = children[children.length - 1];
            const rowInfoNode = rowInfoListNode.getChildren()[row - node.attribute('offset')];
            mode = rowInfoNode.attribute('selected') === 1 ? "unset" : "exset";
          }

          return new cls.VMRowSelectionEvent(node.getId(), {
            startIndex: startIndex,
            endIndex: endIndex,
            selectionMode: mode
          });
        },

        /**
         * @inheritDoc
         */
        setFocus: function() {
          let widget = this.getWidget();
          if (widget.isInputMode() || widget.isInputArrayMode()) {
            widget.setFocus(); //We need to set the focus on the Table to be able to show the rowbound
            widget = this.getCurrentInternalWidget();
          } else {
            let showFilter = (widget.hasReduceFilter() && !widget.isTreeView());
            // show filter menu item from chrome bar
            let filterAttribute = this.getAnchorNode().attribute("filter");
            this.getUINode().getController().getWidget().showChromeBarFilterMenuItem(showFilter, filterAttribute);
          }

          if (widget) {
            widget.setFocus();
          }
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(newValue = null) {
          const valueNode = this.getAnchorNode().getCurrentValueNode(true);
          if (valueNode) {
            valueNode.getController().sendWidgetValue(newValue);
          }
        },

        /**
         * @inheritDoc
         */
        setStoredSetting: function(key, value) {
          if (this.forceDefaultSettings) {
            return null;
          } else {
            gbc.StoredSettingsService.setSettings(this._storedSettingsKey + "." + key, value);
          }
        },

        /**
         * @inheritDoc
         */
        getStoredSetting: function(key) {
          if (this.forceDefaultSettings) {
            return null;
          } else {
            return gbc.StoredSettingsService.getSettings(this._storedSettingsKey + "." + key);
          }
        },

        /**
         * Reset Stored Setting
         */
        resetStoredSetting: function() {
          if (!this.forceDefaultSettings) {
            gbc.StoredSettingsService.removeSettings(this._storedSettingsKey);
          }
        },

        /**
         * Reset specific stored setting
         * @param {string} key - key to reset
         * 
         */
        removeStoredSetting: function(key) {
          if (!this.forceDefaultSettings) {
            gbc.StoredSettingsService.removeSettings(this._storedSettingsKey + "." + key);
          }
        },

        /**
         * Returns if table should be rendered as a listview
         * @returns {boolean}
         */
        isListView: function() {
          return this._isListView;
        },

        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("Table", cls.TableController);

  });
;

"use strict";

modulum('TreeItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TreeItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TreeItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TreeItemController.prototype */ {
        __name: "TreeItemController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // 4st behaviors

          // vm behaviors
          this._addBehavior(cls.TreeItemDecorationVMBehavior);
        },

        createWidget: function() {
          // TreeItems don't create own widgets, they simply act on the corresponding table column
          return null;
        }
      };
    });
    cls.ControllerFactory.register("TreeItem", cls.TreeItemController);
  });
;

"use strict";

modulum('UserInterfaceController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class UserInterfaceController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.UserInterfaceController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.UserInterfaceController.prototype */ {
        __name: "UserInterfaceController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // vm behaviors
          this._addBehavior(cls.FocusPseudoSelectorBehavior);
          this._addBehavior(cls.RuntimeStatusVMBehavior);
          this._addBehavior(cls.ApplicationTitleVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.CurrentWindowVMBehavior);
          this._addBehavior(cls.StartMenuPositionUIBehavior);
          this._addBehavior(cls.ApplicationImageVMBehavior);
          this._addBehavior(cls.DBDateVMBehavior);
          this._addBehavior(cls.CurrentTitleVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.BrowserMultiPage4STBehavior);
          this._addBehavior(cls.DesktopMultiWindow4STBehavior);
          this._addBehavior(cls.ApplicationListVisible4STBehavior);
          this._addBehavior(cls.WindowListVisible4STBehavior);

        },
        _createWidget: function(type) {
          const widget = $super._createWidget.call(this, type);
          widget.setCharLengthSemantics(Boolean(this.getNodeBindings().anchor.attribute("charLengthSemantics")));

          // Hack to prevent firefox to relayout and change richtext cursors
          const messageWidget = widget.getMessageWidget();
          messageWidget.setDummyMessage();
          widget.addChildWidget(messageWidget);

          return widget;
        }
      };
    });
    cls.ControllerFactory.register("UserInterface", cls.UserInterfaceController);

  });
;

"use strict";

modulum('VBoxController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class VBoxController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.VBoxController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.VBoxController.prototype */ {
        __name: "VBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Packed4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.SplitterVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.SplitVMBehavior);
          this._addBehavior(cls.NoSwipeVMBehavior);
          this._addBehavior(cls.NavigationArrows4STBehavior);
          this._addBehavior(cls.NavigationDots4STBehavior);

          // ui behaviors
          this._addBehavior(cls.OnSplitterUIBehavior);
        },
        /**
         * @inheritDoc
         */
        ensureVisible: function(executeAction) {
          const widget = this.getAnchorNode().getWidget();
          widget.emit(context.constants.widgetEvents.splitViewChange, widget);
          return $super.ensureVisible.call(this, executeAction);
        }
      };
    });
    cls.ControllerFactory.register("VBox", cls.VBoxController);

  });
;

"use strict";

modulum('WindowController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class WindowController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.WindowController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.WindowController.prototype */ {
        __name: "WindowController",
        _isWidgetOwner: true,

        /** @type {String} */
        _storedSettingsKey: null,

        /** @type {Boolean} */
        forceDefaultSettings: false,

        /**
         * @inheritDoc
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._initStoredSettings(); // used for modal window to store position and size
        },
        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // vm behaviors
          this._addBehavior(cls.WindowTitleVMBehavior);
          this._addBehavior(cls.WindowParentVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.WindowImageVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.WindowTypeVMBehavior);
          this._addBehavior(cls.CurrentTitleVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.WindowState4STBehavior);
          this._addBehavior(cls.WindowOptionClose4STBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.ForceDefaultSettings4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ToolBarPosition4STBehavior);
          this._addBehavior(cls.TopmenuRendering4STBehavior);
          this._addBehavior(cls.StartMenuPosition4STBehavior);
          this._addBehavior(cls.BackgroundImage4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.Position4STBehavior); // to keep after Reverse4STBehavior
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.AllowedOrientations4STBehavior);

          // ui behaviors
          this._addBehavior(cls.WindowCloseUIBehavior);

          this._addBehavior(cls.Sizable4STBehavior);
          this._addBehavior(cls.TabbedContainer4STBehavior);
        },

        // TODO incompatible override
        /**
         * @inheritDoc
         */
        createWidget: function() {
          const anchorNode = this.getAnchorNode(),
            application = anchorNode && anchorNode.getApplication(),
            session = application && application.getSession(),
            opts = {
              appHash: application && application.applicationHash,
              appWidget: application && application.getUI().getWidget(),
              auiTag: anchorNode.getId(),
              chromeBar: anchorNode.getParentNode().getWidget().getChromeBarWidget()
            };
          this._widget = cls.WidgetFactory.createWidget("Window", opts, anchorNode);

          context.HostService.registerClosableWindow(anchorNode, this._widget, opts);
          if (session) {
            session.getNavigationManager().addWindow(anchorNode);
          }

          if (anchorNode.isTraditional()) {
            this._widget.addClass("gbc_TraditionalContainerWindow");
          }

          this._widget.isModal = anchorNode.isModal();

          // Hack to prevent firefox to relayout and change richtext cursors
          const messageWidget = this._widget.getMessageWidget();
          messageWidget.setDummyMessage();
          this._widget.addChildWidget(messageWidget);
        },

        /**
         * @inheritDoc
         */
        setStyleBasedBehaviorsDirty: function(noUsageCheck, noRecurse, fromPseudoSelection) {
          $super.setStyleBasedBehaviorsDirty.call(this, noUsageCheck, noRecurse, fromPseudoSelection);
          this._widget.isModal = this.getAnchorNode().isModal();
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          if (this._isWidgetOwner) {
            $super.attachUI.call(this);
          }
        },

        /**
         * @inheritDoc
         */
        detachUI: function() {
          if (this._isWidgetOwner) {
            if (this._widget && this.autoCreateWidget() && this._widget._modalWidget) {
              this._widget._modalWidget.when(context.constants.widgetEvents.close, () => {
                //Restore the window icon
                if (gbc.HostService.getCurrentWindowNode()) {
                  gbc.HostService.setDisplayedWindowNode(gbc.HostService.getCurrentWindowNode());
                }
              }, true);
            }
            $super.detachUI.call(this);
          }
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          const anchorNode = this.getAnchorNode(),
            application = anchorNode && anchorNode.getApplication(),
            session = application && application.getSession();
          if (session) {
            session.getNavigationManager().removeWindow(anchorNode);
          }
          context.HostService.unregisterClosableWindow(anchorNode);
          $super.destroy.call(this);
        },

        /**
         * Initialize Stored Setting used for modal to store position and size
         * @private
         */
        _initStoredSettings: function() {
          const node = this.getNodeBindings().anchor;
          // Build stored settings key
          const windowName = node.attribute("name");
          const appId = node.getApplication().applicationInfo.appId;
          this._storedSettingsKey = `gwc.apps.${appId}.window.${windowName}`;

          const formName = node.getFirstChild("Form")?.attribute("name");
          if (formName) {
            this._storedSettingsKey += `.forms.${formName}`;
          }

        },

        /**
         * Get the StoredSettings key to access saved info about this window
         * @return {string} - access path to stored Settings
         */
        getStoredSettingKey: function() {
          return this._storedSettingsKey;
        }
      };
    });
    cls.ControllerFactory.register("Window", cls.WindowController);

  });
;

"use strict";

modulum('DragDropInfoController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DragDropInfoController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.DragDropInfoController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.DragDropInfoController.prototype */ {
        __name: "DragDropInfoController",

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);

          const anchor = this.getNodeBindings().anchor;
          // vm behaviors
          this._addBehavior(cls.DndAcceptedVMBehavior);

          context.DndService.dragDropInfoNode = anchor;
          context.DndService.dndAccepted = false;
        },

        /**
         *
         */
        destroy: function() {
          $super.destroy.call(this);

          context.DndService.dragDropInfoNode = null;
          context.DndService.dndAccepted = false;
        },

        createWidget: function() {
          // DragDropInfo don't create own widgets
          return null;
        }
      };
    });
    cls.ControllerFactory.register("DragDropInfo", cls.DragDropInfoController);
  });
;

"use strict";

modulum('FunctionCallController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * FunctionCallController
     * This handle any function call from the VM
     * @class FunctionCallController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.FunctionCallController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.FunctionCallController.prototype */ {
        __name: 'FunctionCallController',

        /**
         * The current file picket widget
         * @type {classes.FilePickerWidget}
         */
        _filePickerWidget: null,

        /**
         * @type {classes.BarcodeScannerWidget}
         */
        _barcodeScannerWidget: null,

        /**
         * @inheritDoc
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          context.FrontCallService.setFunctionCallProcessing(true);

          const functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();

          const moduleName = functionCallNode.attribute('moduleName').toLowerCase();
          const functionName = functionCallNode.attribute('name').toLowerCase();

          if (app.applicationInfo.ignoreFrontcallModules && app.applicationInfo.ignoreFrontcallModules.indexOf(moduleName) >= 0) {
            this.setReturnValues([]);
          } else if (context.__wrapper.isNative() && !context.__wrapper.isFrontcallURForced(moduleName, functionName)) {
            context.__wrapper.frontcall(context.__wrapper.param(functionCallNode.getId(), app), function(nativeResult) {
              if (nativeResult.status === cls.VMFunctionCallEvent.success) {
                this.setReturnValues(nativeResult.result instanceof Array ? nativeResult.result : [nativeResult.result]);
              } else if (nativeResult.status === cls.VMFunctionCallEvent.unknownModule ||
                nativeResult.status === cls.VMFunctionCallEvent.unknownFunction) {
                this.browserFrontcall(moduleName, functionName, app);
              } else if (nativeResult.status === cls.VMFunctionCallEvent.stackError) {
                this.parametersError(nativeResult.errorMessage);
              } else {
                this.runtimeError(nativeResult.errorMessage);
              }
            }.bind(this));
          } else {
            this.browserFrontcall(moduleName, functionName, app);
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          if (this._filePickerWidget) {
            this._filePickerWidget.destroy();
          }
          if (this._barcodeScannerWidget) {
            this._barcodeScannerWidget.destroy();
          }
        },

        browserFrontcall: function(moduleName, functionName, app) {
          const module = context.FrontCallService.modules[moduleName];
          if (module) {
            const moduleFunction = module[functionName];
            if (moduleFunction) {
              const result = moduleFunction.apply(this, this._parseArgs());
              // If the return value of the front call isn't an array (undefined),
              // it is up to the front-call to invoke this.setReturnValues
              // This is to implement asynchonous front-calls
              if (Array.isArray(result)) {
                this.setReturnValues(result);
              }
            } else {
              app.scheduler.functionCallResultVMCommand(cls.VMFunctionCallEvent.unknownFunction);
            }
          } else {
            app.scheduler.functionCallResultVMCommand(cls.VMFunctionCallEvent.unknownModule);
          }
        },

        /**
         * This node doesn't need to create a widget
         * @return {null}
         * @private
         */
        _createWidget: function() {
          return null;
        },

        /**
         * Parse arguments of a functionCall
         * @return {Array} - List of the parsed parameters
         * @private
         */
        _parseArgs: function() {
          const functionCallNode = this.getAnchorNode();
          const paramNodes = functionCallNode.getChildren();
          const params = [];
          for (const paramNode of paramNodes) {
            if (paramNode.getTag() === 'FunctionCallParameter') {
              if (paramNode.attribute('isNull')) {
                params.push(null);
              } else {
                const dataType = paramNode.attribute('dataType');
                const value = paramNode.attribute('value');
                if (dataType === 'INTEGER' || dataType === 'SMALLINT') {
                  params.push(parseInt(value, 10));
                } else if (dataType === 'FLOAT' || dataType === 'DOUBLE') {
                  params.push(parseFloat(value));
                } else if (dataType === 'RECORD') {
                  params.push(JSON.parse(value));
                } else if (dataType.indexOf('ARRAY') >= 0) {
                  params.push(JSON.parse(value));
                } else {
                  params.push(value);
                }
              }
            }
          }
          return params;
        },

        /**
         * The front call may call this method if a wrong number of parameters is given
         * @param message error message
         */
        parametersError: function(message) {
          const functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();
          const moduleName = functionCallNode.attribute("moduleName");
          const functionName = functionCallNode.attribute("name");
          let msg = "Wrong number of parameters when invoking '" + moduleName + "." + functionName + "'";
          if (message) {
            msg += ':\n' + message;
          }
          app.scheduler.functionCallResultVMCommand(cls.VMFunctionCallEvent.stackError, msg);
        },

        /**
         * The front call may call this method in case of runtime errors
         * @param {String} message error message
         * @param {Number?} resultCode - as defined in cls.VMFunctionCallEvent
         */
        runtimeError: function(message, resultCode) {
          const functionCallNode = this.getAnchorNode(),
            app = functionCallNode.getApplication();
          const moduleName = functionCallNode.attribute('moduleName');
          const functionName = functionCallNode.attribute('name');
          let msg = "Runtime error when invoking '" + moduleName + "." + functionName + "'";
          if (message) {
            msg += ':\n' + message;
          }
          app.scheduler.functionCallResultVMCommand(resultCode ? resultCode : cls.VMFunctionCallEvent.functionError, msg);
        },

        /**
         * Display un error message
         * @param {string} message - message to display
         */
        displayErrorMessage: function(message) {
          const application = context.SessionService.getCurrent().getCurrentApplication();
          const messageService = application.message;
          const userInterfaceNode = application.getNode(0);
          const userInterfaceWidget = userInterfaceNode.getController().getWidget();
          const msgWidget = userInterfaceWidget.getMessageWidget();
          msgWidget.setText(message);
          msgWidget.setMessageKind("error");

          messageService.addMessage("upload", msgWidget);
          messageService.handlePositions();
        },

        /**
         * The front call may call this method to set the return values in asynchronous mode
         * @param result list of result values
         */
        setReturnValues: function(result) {
          for (let i = 0; i < result.length; ++i) {
            if (typeof result[i] === 'object') {
              result[i] = JSON.stringify(result[i]);
            }
          }
          const functionCallNode = this.getAnchorNode();

          if (functionCallNode) {
            const app = functionCallNode.getApplication();
            app.scheduler.functionCallResultVMCommand(cls.VMFunctionCallEvent.success, null, result);
          }
        }
      };
    });
    cls.ControllerFactory.register('FunctionCall', cls.FunctionCallController);
  });
;

"use strict";

modulum('ActionController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ActionController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ActionController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ActionController.prototype */ {
        __name: "ActionController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          const anchor = this.getNodeBindings().anchor;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.ActionEnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          if (anchor.attribute('name') === 'close') {
            this._addBehavior(cls.WindowCanCloseVMBehavior);
          }

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);

        },

        _getWidgetType: function(kind, active) {
          let type;

          if (this.isInChromeBar()) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("Action", cls.ActionController);

  });
;

"use strict";

modulum('ActionDefaultController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ActionDefaultController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ActionDefaultController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ActionDefaultController.prototype */ {
        __name: "ActionDefaultController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // vm behaviors
          this._addBehavior(cls.ActionDefaultAcceleratorVMBehavior);
        },

        /**
         * @inheritDoc
         */
        createWidget: function() {
          return null;
        },
      };
    });
    cls.ControllerFactory.register("ActionDefault", cls.ActionDefaultController);

  });
;

"use strict";

modulum('DialogController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DialogController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.DialogController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.DialogController.prototype */ {
        __name: "DialogController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.MenuEnabledVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);

          // 4ST styles
          this._addBehavior(cls.ActionPanelPosition4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextAlign4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextHidden4STBehavior);
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          if (this._widget) {
            const chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;
            if (!chromeBar) {
              const anchorNode = this.getAnchorNode(),
                windowNode = anchorNode && anchorNode.getAncestor('Window'),
                windowController = windowNode && windowNode.getController(),
                windowWidget = windowController && windowController.getWidget();
              if (windowWidget && windowWidget.addMenu) {
                windowWidget.addMenu(this._widget);
              }
            } else {
              chromeBar.addMenu(this._widget);
            }
          }
        }
      };
    });
    cls.ControllerFactory.register("Dialog", cls.DialogController);

  });
;

"use strict";

modulum('MenuActionController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MenuActionController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MenuActionController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MenuActionController.prototype */ {
        __name: "MenuActionController",

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          const anchor = this.getNodeBindings().anchor;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.ActionEnabledVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          if (anchor.attribute('name') === 'close') {
            this._addBehavior(cls.WindowCanCloseVMBehavior);
          }

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);

          // aria behaviors
          this._addBehavior(cls.NavigationAriaBehavior);

        },

        destroy: function() {
          $super.destroy.call(this);
        },

        _getWidgetType: function(kind, active) {
          let type;

          if (this.isInChromeBar()) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }
          return type;
        }

      };
    });
    cls.ControllerFactory.register("MenuAction", cls.MenuActionController);

  });
;

"use strict";

modulum('MenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MenuController.prototype */ {
        __name: "MenuController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.WindowTypeVMBehavior);
          this._addBehavior(cls.VisibleMenuVMBehavior);
          this._addBehavior(cls.MenuEnabledVMBehavior);

          this._addBehavior(cls.WindowCloseUIBehavior);

          // 4ST styles
          this._addBehavior(cls.ActionPanelButtonTextAlign4STBehavior);
          this._addBehavior(cls.ActionPanelButtonTextHidden4STBehavior);
          this._addBehavior(cls.RingMenuPosition4STBehavior);

        },
        attachUI: function() {
          if (this._widget) {

            const chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;
            const isDialog = this.getAnchorNode()._vmStyles.indexOf("dialog") >= 0;

            if (chromeBar && !isDialog) {
              chromeBar.addMenu(this._widget);
            } else {
              this.getAnchorNode().getAncestor('Window').getController().getWidget().addMenu(this._widget);
            }

          }
        },

        _createWidget: function(type) {
          const widget = $super._createWidget.call(this, type);
          const ctrl = this.getNodeBindings().parent.getController();
          if (ctrl) {
            widget._windowWidget = ctrl.getWidget();
            return widget;
          } else {
            return null;
          }
        },

        detachUI: function() {
          if (this._widget && this.autoCreateWidget() && this._widget._modalWidget) {
            this._widget._modalWidget.when(context.constants.widgetEvents.close, () => {
              //Restore the window icon
              if (gbc.HostService.getCurrentWindowNode()) {
                gbc.HostService.setDisplayedWindowNode(gbc.HostService.getCurrentWindowNode());
              }
            }, true);
          }
          $super.detachUI.call(this);
        },

      };
    });
    cls.ControllerFactory.register("Menu", cls.MenuController);

  });
;

"use strict";

modulum('StartMenuCommandController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuCommandController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuCommandController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuCommandController.prototype */ {
        __name: "StartMenuCommandController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.DisabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          // ui behaviors
          this._addBehavior(cls.OnClickStartMenuCommandUIBehavior);
        },
        _getWidgetType: function(kind) {
          const parent = this.getAnchorNode().getAncestor("StartMenu");
          let type = null;
          if (parent) {
            type = parent.getController()._getWidgetType(kind) + "Command";
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuCommand", cls.StartMenuCommandController);

  });
;

"use strict";

modulum('StartMenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuController.prototype */ {
        __name: "StartMenuController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING
          this._addBehavior(cls.TextVMBehavior);

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.BackgroundColorVMBehavior);
        },

        _getWidgetType: function(kind) {
          let type;
          if (!kind) {
            const windowNode = this.getAnchorNode().getApplication().getVMWindow();
            if (windowNode) {
              kind = windowNode.getStyleAttribute("startMenuPosition");
            }
          }
          switch (kind) {
            case "poptree":
              // poptree isn't implemented, using tree instead
              /* falls through */
            case "tree":
              type = 'StartMenu';
              break;
            case "menu":
              type = 'TopMenu';
              break;
          }
          return type;
        },

        attachUI: function() {
          const session = this.getAnchorNode().getApplication().getSession();
          const uiWidget = this.getAnchorNode().getAncestor('UserInterface').getController().getWidget();
          // _widgetKind is probably obsolete but is kept as a security
          if (this._widgetType === "StartMenu" || this._widgetKind === "poptree" || this._widgetKind === "tree") {
            session.manageStartMenu(this.getAnchorNode(), this.getWidget());
          } else if (this._widgetType === "TopMenu" || this._widgetKind === "menu") {
            this.getWidget().setIsStartMenu(true);
            uiWidget.addTopMenu(this.getWidget(), 0, uiWidget);
          }
        },

        _detachWidgetRecursive: function(node) {
          const children = node.getChildren();
          for (const element of children) {
            this._detachWidgetRecursive(element);
          }
          node.getController()._detachWidget();
        },

        _attachWidgetRecursive: function(node) {
          node.getController()._attachWidget();
          const children = node.getChildren();
          for (const element of children) {
            this._attachWidgetRecursive(element);
          }
        },

        _createWidgetRecursive: function(node, kind) {
          const currentController = node.getController();
          const type = currentController._getWidgetType(kind);
          currentController._widget = currentController._createWidget(type === "TopMenu" ? "StartMenuTopMenu" : type);
          const children = node.getChildren();
          for (const element of children) {
            this._createWidgetRecursive(element, kind);
          }
        },

        _detachUIRecursive: function(node) {
          const children = node.getChildren();
          for (const element of children) {
            this._detachUIRecursive(element);
          }
          node.getController().detachUI();
        },

        _attachUIRecursive: function(node) {
          node.getController().attachUI();
          const children = node.getChildren();
          for (const element of children) {
            this._attachUIRecursive(element);
          }
        },

        changeWidgetKind: function(kind) {
          if (kind !== this._widgetKind) {
            this._widgetKind = kind;
            this._widgetType = this._getWidgetType(kind);
            const anchor = this.getAnchorNode();
            this._detachWidgetRecursive(anchor);
            this._detachUIRecursive(anchor);
            if (this._widgetKind !== "none") {
              this._createWidgetRecursive(anchor, kind);
              this._attachUIRecursive(anchor);
              this._attachWidgetRecursive(anchor);
            }
            anchor.applyBehaviors(null, true, true);
            return true;
          }
          return false;
        }
      };
    });
    cls.ControllerFactory.register("StartMenu", cls.StartMenuController);

  });
;

"use strict";

modulum('StartMenuGroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuGroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuGroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuGroupController.prototype */ {
        __name: "StartMenuGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.DisabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
        },
        _getWidgetType: function(kind) {
          const parent = this.getAnchorNode().getAncestor("StartMenu");
          let type = null;
          if (parent) {
            type = parent.getController()._getWidgetType(kind) + "Group";
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuGroup", cls.StartMenuGroupController);

  });
;

"use strict";

modulum('StartMenuSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class StartMenuSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.StartMenuSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.StartMenuSeparatorController.prototype */ {
        __name: "StartMenuSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        },
        _getWidgetType: function(kind) {
          let type;
          switch (kind) {
            case "poptree":
              // poptree isn't implemented, using tree instead
              /* falls through */
            case "tree":
              type = 'StartMenuSeparator';
              break;
            case "menu":
              type = 'TopMenuSeparator';
              break;
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("StartMenuSeparator", cls.StartMenuSeparatorController);

  });
;

"use strict";

modulum('ToolBarAutoItemsController', ['ControllerPlaceholderBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarAutoItemsController
     * @memberOf classes
     * @extends classes.ControllerPlaceholderBase
     */
    cls.ToolBarAutoItemsController = context.oo.Class(cls.ControllerPlaceholderBase, function($super) {
      return /** @lends classes.ToolBarAutoItemsController.prototype */ {
        __name: "ToolBarAutoItemsController",

        /**
         * MenuController creation handler
         */
        _controllerCreationHandlerMenu: null,
        /**
         * ActionController creation handler
         */
        _controllerCreationHandlerAction: null,

        /**
         * Application creation handler
         */
        _applicationAddHandler: null,
        /**
         * Application remove handler
         */
        _applicationRemoveHandler: null,

        /**
         * Window creation handler
         */
        _windowAddHandler: null,
        /**
         * Window remove handler
         */
        _windowRemoveHandler: null,
        /**
         * This placeholder contains application
         * @type {?boolean}
         */
        _isPrograms: null,
        /**
         * This placeholder contains windows
         * @type {?boolean}
         */
        _isWindows: null,
        /**
         * This placeholder contains actions
         * @type {?boolean}
         */
        _isActions: null,

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._isPrograms = false;
          this._isWindows = false;
          this._isActions = false;

          if (bindings.anchor.attribute("content") === 'actions') {
            this._isActions = true;
            this._controllerCreationHandlerMenu = cls.ControllerFactory.onControllerCreated("MenuAction",
              (event, realWidgetController) => {
                if (!this.isInChromeBar() && realWidgetController.getWidget().getApplicationIdentifier() === this.getWidget()
                  .getApplicationIdentifier()) {
                  realWidgetController.createVirtualWidget(this, this.isInChromeBar() ? "ChromeBarItem" : "ToolBarItem");
                }
              });
            this._controllerCreationHandlerAction = cls.ControllerFactory.onControllerCreated("Action",
              (event, realWidgetController) => {
                if (!this.isInChromeBar() && realWidgetController.getWidget().getApplicationIdentifier() === this.getWidget()
                  .getApplicationIdentifier()) {
                  realWidgetController.createVirtualWidget(this, this.isInChromeBar() ? "ChromeBarItem" : "ToolBarItem");
                }
              });
          } else if (bindings.anchor.attribute("content") === 'programs') {
            this._registerProgramsHandlers();
          } else if (bindings.anchor.attribute("content") === 'windows') {
            this._registerWindowsHandlers();
          }
        },

        /**
         * Register application handlers
         * @private
         */
        _registerProgramsHandlers: function() {
          if (this.isInChromeBar()) {
            return;
          }

          this._isPrograms = true;
          let navigationManager = context.SessionService.getCurrent().getNavigationManager();
          this._applicationAddHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .addSessionSidebarApplicationStackItem,
            (event) => {
              let applicationWidget = event.data[1];

              this.getWidget().setPositionInParent(this.getAnchorNode().getVirtualIndex());
              let virtualWidget = this._addApplication(applicationWidget);
              if (virtualWidget) {
                this.getWidget().applyCommonStyleToWidget(virtualWidget);
              }
            });

          this._applicationRemoveHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .removeSessionSidebarApplicationStackItem,
            (event) => {
              let applicationWidget = event.data[1];
              let virtualWidget = this.getWidget().getVirtualWidget(applicationWidget);

              if (virtualWidget) {
                let layoutEngine = this.getWidget().getLayoutEngine();
                layoutEngine.invalidateMeasure();
                layoutEngine.forceMeasurement();

                layoutEngine = this.getWidget().getParentWidget().getLayoutEngine();
                layoutEngine.invalidateMeasure();
                layoutEngine.forceMeasurement();

                virtualWidget.getAUIWidget().removeVirtualChildWidget(virtualWidget);
                virtualWidget.destroy();
              }
            });
        },

        /**
         * Register window handlers
         * @private
         */
        _registerWindowsHandlers: function() {
          if (this.isInChromeBar()) {
            return;
          }

          this._isWindows = true;
          let navigationManager = context.SessionService.getCurrent().getNavigationManager();

          this._windowAddHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents.addSessionSidebarWindowItem,
            (event) => {
              //We can add element only if we are already attached
              if (this.getWidget() && this.getWidget().getParentWidget()) {
                let windowWidget = event.data[1];
                let application = event.data[0];

                this.getWidget().setPositionInParent(this.getAnchorNode().getVirtualIndex());
                let virtualWidget = this._addWindow(application, windowWidget);
                if (virtualWidget) {
                  this.getWidget().applyCommonStyleToWidget(virtualWidget);
                }
              }
            });

          this._windowRemoveHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .removeSessionSidebarWindowItem,
            (event) => {
              let windowWidget = event.data[1];
              let virtualWidget = this.getWidget().getVirtualWidget(windowWidget);

              if (virtualWidget) {
                let layoutEngine = this.getWidget().getLayoutEngine();
                layoutEngine.invalidateMeasure();
                layoutEngine.forceMeasurement();

                layoutEngine = this.getWidget().getParentWidget().getLayoutEngine();
                layoutEngine.invalidateMeasure();
                layoutEngine.forceMeasurement();

                virtualWidget.getAUIWidget().removeVirtualChildWidget(virtualWidget);
                virtualWidget.destroy();
              }
            });
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          if (this._controllerCreationHandlerMenu) {
            this._controllerCreationHandlerMenu();
            this._controllerCreationHandlerMenu = null;
          }
          if (this._controllerCreationHandlerAction) {
            this._controllerCreationHandlerAction();
            this._controllerCreationHandlerAction = null;
          }
          if (this._applicationAddHandler) {
            this._applicationAddHandler();
            this._applicationAddHandler = null;
          }
          if (this._applicationRemoveHandler) {
            this._applicationRemoveHandler();
            this._applicationRemoveHandler = null;
          }
          if (this._windowAddHandler) {
            this._windowAddHandler();
            this._windowAddHandler = null;
          }
          if (this._windowRemoveHandler) {
            this._windowRemoveHandler();
            this._windowRemoveHandler = null;
          }
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior, true);
          this._addBehavior(cls.FontSize4STBehavior, true);
          this._addBehavior(cls.FontColor4STBehavior, true);
          this._addBehavior(cls.Border4STBehavior, true);
          this._addBehavior(cls.Reverse4STBehavior, true);

          this._addBehavior(cls.ScaleIcon4STBehavior, true, true);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true, true);
        },

        _getWidgetType: function(kind, active) {
          let type;
          const chromeBarTheme = this.isInChromeBar();

          if (chromeBarTheme) {
            type = "ChromeBarPlaceholder";
          } else {
            type = "ToolBarPlaceholder";
          }

          return type;
        },

        /**
         * attach UI
         */
        attachUI: function() {
          $super.attachUI.call(this);

          if (this._isPrograms) {
            //The placeholder is attached now. So we can add the children
            //Application is a parent of the TopMenu, so we need to attach it manually
            let navigationManager = context.SessionService.getCurrent().getNavigationManager();

            navigationManager.getApplicationWidgetList().forEach((applicationWidget) => {
              this._addApplication(applicationWidget);
            });
          } else if (this._isWindows) {
            //The placeholder is attached now. So we can add the children
            //Window can be a parent of the TopMenu, so we need to attach it manually
            let navigationManager = context.SessionService.getCurrent().getNavigationManager();

            navigationManager.getWindowWidgetList().forEach((windowWidget, windowNode) => {
              this._addWindow(windowNode.getApplication(), windowWidget);
            });
          } else if (this._isActions) {
            //The placeholder is attached now. So we can add the actions
            let uiNode = context.SessionService.getCurrent().getCurrentApplication().uiNode();
            let windowNode = uiNode.getFirstChildWithId(uiNode.attribute("currentWindow"));

            if (windowNode && !this.isInChromeBar()) {
              this._addActions(windowNode, "MenuAction");
              this._addActions(windowNode, "Action");
            }
          }
        },

        /**
         * detach UI
         */
        detachUI: function() {
          if (this._isPrograms || this._isWindows) {
            this.getWidget().destroyAllChildren();
          }

          $super.detachUI.call(this);
        },

        /**
         * Add an application in the placeholder
         * @param {classes.SessionSidebarApplicationStackItemWidget} applicationWidget
         * @return {null|classes.WidgetBase}
         * @private
         */
        _addApplication: function(applicationWidget) {
          let placeHolderWidget = this.getWidget();
          let controller = new cls.ToolBarDummyController();
          controller.setWidget(applicationWidget);

          let virtualWidget = controller.createVirtualWidget(this, this.isInChromeBar() ? "ChromeBarItem" : "ToolBarItem");

          virtualWidget.setText(applicationWidget.getTitle());
          if (applicationWidget.getIcon()) {
            virtualWidget.setImage(applicationWidget.getIcon());
          }
          placeHolderWidget.appendVirtualChildWidget(0, virtualWidget);
          applicationWidget.addVirtualChildWidget(virtualWidget);
          controller.destroy();

          return virtualWidget;
        },

        /**
         * Add a window in the placeholder
         * @param {classes.VMApplication} application
         * @param {classes.SessionSidebarWindowItemWidget} windowWidget
         * @return {null|classes.WindowWidget}
         * @private
         */
        _addWindow: function(application, windowWidget) {
          let navigationManager = application.getSession().getNavigationManager();

          if (navigationManager.getRootWaitingApplication(application).getProcId() !==
            navigationManager.getRootWaitingApplication(this.getAnchorNode().getApplication()).getProcId()) {
            return null;
          }

          let placeHolderWidget = this.getWidget();
          let controller = new cls.TopMenuDummyController();
          controller.setWidget(windowWidget);

          let virtualWidget = controller.createVirtualWidget(this, this.isInChromeBar() ? "ChromeBarItem" : "ToolBarItem");

          //If virtualWidget is null so it already exist
          if (virtualWidget) {
            if (windowWidget.getWindowName()) {
              virtualWidget.setText(windowWidget.getWindowName());
            }
            if (windowWidget.getWindowIcon()) {
              virtualWidget.setImage(windowWidget.getWindowIcon());
            }

            placeHolderWidget.appendVirtualChildWidget(0, virtualWidget);
            windowWidget.addVirtualChildWidget(virtualWidget);
          }

          controller.destroy();

          return virtualWidget;
        },

        /**
         * Add MenusActions in the placeholder
         * @param {classes.WindowNode} windowNode
         * @param {string} tagName
         * @return {null|classes.WindowWidget}
         * @private
         */
        _addActions: function(windowNode, tagName) {
          windowNode.getDescendants(tagName).forEach((menuAction) => {
            let realWidgetController = menuAction.getController();
            if (!realWidgetController) {
              return;
            }

            let parentController = menuAction.getParentNode().getController();
            let parentId = menuAction.getParentNode().getId();
            let position = menuAction.getIndex();
            let virtualWidget = realWidgetController.createVirtualWidget(this, this.isInChromeBar() ? "ChromeBarItem" : "ToolBarItem");

            if (virtualWidget) {
              let placeholderWidget = this.getWidget();

              placeholderWidget.setPositionInParent(this.getAnchorNode().getVirtualIndex());
              placeholderWidget.addVirtualChildWidget(parentId, virtualWidget, position);
              parentController._addPlaceholderController(this);
            }
          });
        },
      };
    });
    cls.ControllerFactory.register("ToolBarAutoItems", cls.ToolBarAutoItemsController);

  });
;

"use strict";

modulum('ToolBarController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarController.prototype */ {
        __name: "ToolBarController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.TextPosition4STBehavior);
          this._addBehavior(cls.Aspect4STBehavior);
          this._addBehavior(cls.Size4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.ToolBarItemsAlignment4STBehavior);
          this._addBehavior(cls.Position4STBehavior);

          // vm behaviors
          if (this.getAnchorNode().getParentNode().getTag() === 'Form') {
            this._addBehavior(cls.FormRelatedHiddenVMBehavior);
          }
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.ButtonTextHiddenVMBehavior);
        },

        /**
         * @inheritDoc
         */
        attachUI: function() {
          let parentNode = this.getAnchorNode().getParentNode();
          while (parentNode) {
            const controller = parentNode.getController();
            if (controller) {
              const widget = controller.getWidget();
              if (widget?.addToolBar) {
                const order = this.getAnchorNode().getParentNode().getTag() === 'Form' ? 1 : 0;

                const chromeBar = this.isInChromeBar() ? this.getUINode().getWidget().getChromeBarWidget() : false;

                // Ensure the form widget is correctly associated to the toolbar
                // This is done here, because when we set the toolbar allocated width, we need the parent form layout info
                // Those info are not available yet since the link between the toolbar and the form doesn't exist
                this.getWidget().setFormWidget(this.getAnchorNode().getParentNode().getWidget());

                if (!chromeBar) {
                  widget.addToolBar(this.getWidget(), order);
                } else {
                  chromeBar.addToolBar(this.getWidget(), order);
                }

                break;
              }
            }
            parentNode = parentNode.getParentNode();
          }
        },

        detachUI: function() {
          const winNode = this.getAnchorNode().getAncestor('Window');
          const uiNode = this.getAnchorNode().getAncestor('UserInterface');
          if (winNode) {
            const winWidget = winNode.getController().getWidget();
            winWidget.removeToolBar(this.getWidget());
          } else {
            const uiWidget = uiNode.getController().getWidget();
            uiWidget.removeToolBar(this.getWidget());
          }

          $super.detachUI.call(this);
        },

        destroy: function() {
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
          }
          $super.destroy.call(this);
        }

      };
    });
    cls.ControllerFactory.register("ToolBar", cls.ToolBarController);
  });
;

"use strict";

modulum('ToolBarDummyController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarDummyController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarDummyController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarDummyController.prototype */ {
        __name: "ToolBarDummyController",

        constructor: function() {
          $super.constructor.call(this, {});
        },

        /**
         * @inheritDoc
         */
        destroy: function() {},

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {},

        setWidget: function(widget) {
          this._widget = widget;
        },

        _createWidget: function(type) {
          //We only want to be able to create virtual widget
          if (this.getWidget()) {
            let params = this.getWidget().getBuildParameters();
            params.realWidget = this._widget;

            return cls.WidgetFactory.createWidget(type, params);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ToolBarItemController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarItemController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarItemController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarItemController.prototype */ {
        __name: "ToolBarItemController",

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, true);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        },

        _getWidgetType: function(kind, active) {
          let type;
          const chromeBarTheme = this.isInChromeBar();

          if (chromeBarTheme) {
            type = "ChromeBarItem";
          } else {
            type = $super._getWidgetType.call(this, kind, active);
          }

          return type;
        },

      };
    });
    cls.ControllerFactory.register("ToolBarItem", cls.ToolBarItemController);

  });
;

"use strict";

modulum('ToolBarSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ToolBarSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ToolBarSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ToolBarSeparatorController.prototype */ {
        __name: "ToolBarSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("ToolBarSeparator", cls.ToolBarSeparatorController);

  });
;

"use strict";

modulum('TopMenuAutoCommandsController', ['ControllerPlaceholderBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuAutoCommandsController
     * @memberOf classes
     * @extends classes.ControllerPlaceholderBase
     */
    cls.TopMenuAutoCommandsController = context.oo.Class(cls.ControllerPlaceholderBase, function($super) {
      return /** @lends classes.TopMenuAutoCommandsController.prototype */ {
        __name: "TopMenuAutoCommandsController",

        /**
         * MenuController creation handler
         */
        _controllerCreationHandlerMenu: null,
        /**
         * ActionController creation handler
         */
        _controllerCreationHandlerAction: null,

        /**
         * Application creation handler
         */
        _applicationAddHandler: null,
        /**
         * Application remove handler
         */
        _applicationRemoveHandler: null,

        /**
         * Window creation handler
         */
        _windowAddHandler: null,
        /**
         * Window remove handler
         */
        _windowRemoveHandler: null,

        /**
         * This placeholder contains application
         * @type {?boolean}
         */
        _isPrograms: null,
        /**
         * This placeholder contains windows
         * @type {?boolean}
         */
        _isWindows: null,
        /**
         * This placeholder contains actions
         * @type {?boolean}
         */
        _isActions: null,

        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._isPrograms = false;
          this._isWindows = false;
          this._isActions = false;

          if (bindings.anchor.attribute("content") === 'actions') {
            this._isActions = true;
            this._controllerCreationHandlerMenu = cls.ControllerFactory.onControllerCreated("MenuAction",
              (event, realWidgetController) => {
                if (realWidgetController.getWidget().getApplicationIdentifier() === this.getWidget().getApplicationIdentifier()) {
                  realWidgetController.createVirtualWidget(this, "TopMenuCommand");
                }
              });
            this._controllerCreationHandlerAction = cls.ControllerFactory.onControllerCreated("Action",
              (event, realWidgetController) => {
                if (realWidgetController.getWidget().getApplicationIdentifier() === this.getWidget().getApplicationIdentifier()) {
                  realWidgetController.createVirtualWidget(this, "TopMenuCommand");
                }
              });
          } else if (bindings.anchor.attribute("content") === 'programs') {
            this._registerProgramsHandlers();
          } else if (bindings.anchor.attribute("content") === 'windows') {
            this._registerWindowsHandlers();
          }
        },

        /**
         * Register application handlers
         * @private
         */
        _registerProgramsHandlers: function() {
          this._isPrograms = true;
          let navigationManager = context.SessionService.getCurrent().getNavigationManager();

          this._applicationAddHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .addSessionSidebarApplicationStackItem,
            (event) => {
              let applicationWidget = event.data[1];
              this.getWidget().setPositionInParent(this.getAnchorNode().getVirtualIndex());
              let virtualWidget = this._addApplication(applicationWidget);
              this.getWidget().applyCommonStyleToWidget(virtualWidget);
            });

          this._applicationRemoveHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .removeSessionSidebarApplicationStackItem,
            (event) => {
              let applicationWidget = event.data[1];

              let w = this.getWidget().getVirtualWidget(applicationWidget);
              if (w) {
                w.getAUIWidget().removeVirtualChildWidget(w);
                w.destroy();
              }
            });
        },

        /**
         * Register window handlers
         * @private
         */
        _registerWindowsHandlers: function() {
          this._isWindows = true;
          let navigationManager = context.SessionService.getCurrent().getNavigationManager();

          this._windowAddHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents.addSessionSidebarWindowItem,
            (event) => {
              //We can add element only if we are already attached
              if (this.getWidget() && this.getWidget().getParentWidget()) {
                let windowWidget = event.data[1];
                let application = event.data[0];

                this.getWidget().setPositionInParent(this.getAnchorNode().getVirtualIndex());
                let virtualWidget = this._addWindow(application, windowWidget);
                if (virtualWidget) {
                  this.getWidget().applyCommonStyleToWidget(virtualWidget);
                }
              }
            });

          this._windowRemoveHandler = navigationManager.when(context.constants.VMSessionNavigationManagerEvents
            .removeSessionSidebarWindowItem,
            (event) => {
              let windowWidget = event.data[1];

              let w = this.getWidget().getVirtualWidget(windowWidget);
              if (w) {
                w.getAUIWidget().removeVirtualChildWidget(w);
                w.destroy();
              }
            });
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          if (this._controllerCreationHandlerMenu) {
            this._controllerCreationHandlerMenu();
            this._controllerCreationHandlerMenu = null;
          }
          if (this._controllerCreationHandlerAction) {
            this._controllerCreationHandlerAction();
            this._controllerCreationHandlerAction = null;
          }
          if (this._applicationAddHandler) {
            this._applicationAddHandler();
            this._applicationAddHandler = null;
          }
          if (this._applicationRemoveHandler) {
            this._applicationRemoveHandler();
            this._applicationRemoveHandler = null;
          }
          if (this._windowAddHandler) {
            this._windowAddHandler();
            this._windowAddHandler = null;
          }
          if (this._windowRemoveHandler) {
            this._windowRemoveHandler();
            this._windowRemoveHandler = null;
          }
        },

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior, true);
          this._addBehavior(cls.FontSize4STBehavior, true);
          this._addBehavior(cls.Border4STBehavior, true);
          this._addBehavior(cls.Reverse4STBehavior, true);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
        },

        /**
         * @inheritDoc
         */
        _getWidgetType: function(kind) {
          return "TopMenuPlaceholder";
        },

        /**
         * attach UI
         */
        attachUI: function() {
          $super.attachUI.call(this);

          if (this._isPrograms) {
            //The placeholder is attached now. So we can add the children
            //Application is a parent of the TopMenu, so we need to attach it manually
            let navigationManager = context.SessionService.getCurrent().getNavigationManager();

            navigationManager.getApplicationWidgetList().forEach((applicationWidget) => {
              this._addApplication(applicationWidget);
            });
          } else if (this._isWindows) {
            //The placeholder is attached now. So we can add the children
            //Window can be a parent of the TopMenu, so we need to attach it manually
            let navigationManager = context.SessionService.getCurrent().getNavigationManager();

            navigationManager.getWindowWidgetList().forEach((windowWidget, windowNode) => {
              this._addWindow(windowNode.getApplication(), windowWidget);
            });
          } else if (this._isActions) {
            //The placeholder is attached now. So we can add the actions
            let uiNode = context.SessionService.getCurrent().getCurrentApplication().uiNode();
            let windowNode = uiNode.getFirstChildWithId(uiNode.attribute("currentWindow"));

            if (windowNode) {
              this._addActions(windowNode, "MenuAction");
              this._addActions(windowNode, "Action");
            }
          }
        },

        /**
         * detach UI
         */
        detachUI: function() {
          if (this._isPrograms || this._isWindows) {
            this.getWidget().destroyAllChildren();
          }

          $super.detachUI.call(this);
        },

        /**
         * Add an application in the placeholder
         * @param {classes.SessionSidebarApplicationStackItemWidget} applicationWidget
         * @return {null|classes.WidgetBase}
         * @private
         */
        _addApplication: function(applicationWidget) {
          let placeHolderWidget = this.getWidget();
          let controller = new cls.TopMenuDummyController();
          controller.setWidget(applicationWidget);

          let virtualWidget = controller.createVirtualWidget(this, "TopMenuCommand");
          virtualWidget.setText(applicationWidget.getTitle());
          if (applicationWidget.getIcon()) {
            virtualWidget.setImage(applicationWidget.getIcon());
          }
          placeHolderWidget.appendVirtualChildWidget(0, virtualWidget);
          applicationWidget.addVirtualChildWidget(virtualWidget);
          controller.destroy();

          return virtualWidget;
        },

        /**
         * Add a window in the placeholder
         * @param {classes.VMApplication} application
         * @param {classes.SessionSidebarWindowItemWidget} windowWidget
         * @return {null|classes.WindowWidget}
         * @private
         */
        _addWindow: function(application, windowWidget) {
          let navigationManager = application.getSession().getNavigationManager();

          if (navigationManager.getRootWaitingApplication(application).getProcId() !==
            navigationManager.getRootWaitingApplication(this.getAnchorNode().getApplication()).getProcId()) {
            return null;
          }

          let placeHolderWidget = this.getWidget();
          let controller = new cls.TopMenuDummyController();
          controller.setWidget(windowWidget);

          let virtualWidget = controller.createVirtualWidget(this, "TopMenuCommand");

          //If virtualWidget is null so it already exist
          if (virtualWidget) {
            if (windowWidget.getWindowName()) {
              virtualWidget.setText(windowWidget.getWindowName());
            }
            if (windowWidget.getWindowIcon()) {
              virtualWidget.setImage(windowWidget.getWindowIcon());
            }

            placeHolderWidget.appendVirtualChildWidget(0, virtualWidget);
            windowWidget.addVirtualChildWidget(virtualWidget);
          }

          controller.destroy();

          return virtualWidget;
        },

        /**
         * Add MenusActions in the placeholder
         * @param {classes.WindowNode} windowNode
         * @param {string} tagName
         * @return {null|classes.WindowWidget}
         * @private
         */
        _addActions: function(windowNode, tagName) {
          windowNode.getDescendants(tagName).forEach((menuAction) => {
            let parentController = menuAction.getParentNode().getController();
            let parentId = menuAction.getParentNode().getId();

            let position = menuAction.getIndex();
            let realWidgetController = menuAction.getController();
            let virtualWidget = realWidgetController.createVirtualWidget(this, "TopMenuCommand");

            if (virtualWidget) {
              let placeholderWidget = this.getWidget();

              placeholderWidget.setPositionInParent(this.getAnchorNode().getVirtualIndex());
              placeholderWidget.addVirtualChildWidget(parentId, virtualWidget, position);
              parentController._addPlaceholderController(this);
            }
          });
        },
      };
    });
    cls.ControllerFactory.register("TopMenuAutoCommands", cls.TopMenuAutoCommandsController);

  });
;

"use strict";

modulum('TopMenuCommandController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuCommandController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuCommandController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuCommandController.prototype */ {
        __name: "TopMenuCommandController",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        },

        /**
         * @inheritDoc
         */
        _getWidgetType: function(kind) {
          return "TopMenuCommand";
        },

      };
    });
    cls.ControllerFactory.register("TopMenuCommand", cls.TopMenuCommandController);

  });
;

"use strict";

modulum('TopMenuController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuController.prototype */ {
        __name: "TopMenuController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          if (this.getAnchorNode().getParentNode().getTag() === 'Form') {
            this._addBehavior(cls.FormRelatedHiddenVMBehavior);
          }
          this._addBehavior(cls.BackgroundColorVMBehavior);

        },
        attachUI: function() {
          let parentNode = this.getAnchorNode().getParentNode();
          while (parentNode) {
            const controller = parentNode.getController();
            if (controller) {
              const widget = controller.getWidget();
              if (widget?.addTopMenu) {
                let containerWidget = widget;
                // only topmenu from modal is being added inside modal
                if (!parentNode.isModal || !parentNode.isModal()) { // if parent isn't a modal
                  containerWidget = this.getAnchorNode().getAncestor('UserInterface').getController().getWidget();
                }
                const isUnderForm = this.getAnchorNode().getParentNode().getTag() === 'Form';
                const order = isUnderForm ? 2 : 1;
                widget.addTopMenu(this.getWidget(), order, containerWidget);
                break;
              }
            }
            parentNode = parentNode.getParentNode();
          }
        },
        detachUI: function() {
          const winNode = this.getAnchorNode().getAncestor('Window');
          if (winNode) {
            const winWidget = winNode.getController().getWidget();
            winWidget.removeTopMenu(this.getWidget());
          }

          $super.detachUI.call(this);
        }
      };
    });
    cls.ControllerFactory.register("TopMenu", cls.TopMenuController);

  });
;

"use strict";

modulum('TopMenuDummyController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuDummyController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuDummyController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuDummyController.prototype */ {
        __name: "TopMenuDummyController",

        constructor: function() {
          $super.constructor.call(this, {});
        },

        /**
         * @inheritDoc
         */
        destroy: function() {},

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {},

        setWidget: function(widget) {
          this._widget = widget;
        },

        _createWidget: function(type) {
          //We only want to be able to create virtual widget
          if (this.getWidget()) {
            let params = this.getWidget().getBuildParameters();
            params.realWidget = this._widget;

            return cls.WidgetFactory.createWidget(type, params);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TopMenuGroupController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuGroupController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuGroupController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuGroupController.prototype */ {
        __name: "TopMenuGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TextActionVMBehavior);
        },
        attachUI: function() {
          // get widget, assign its parent
          let topmenuWidget = this.getAnchorNode().getAncestor("TopMenu").getWidget();
          let groupWidget = this.getAnchorNode().getWidget();
          groupWidget.setTopMenuWidget(topmenuWidget);
          $super.attachUI.call(this);
        }
      };
    });
    cls.ControllerFactory.register("TopMenuGroup", cls.TopMenuGroupController);

  });
;

"use strict";

modulum('TopMenuSeparatorController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class TopMenuSeparatorController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.TopMenuSeparatorController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.TopMenuSeparatorController.prototype */ {
        __name: "TopMenuSeparatorController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("TopMenuSeparator", cls.TopMenuSeparatorController);

  });
;

"use strict";

modulum('ButtonController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ButtonController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ButtonController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ButtonController.prototype */ {
        __name: "ButtonController",
        _imageReadyHandler: null,
        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          this.scrollGridLineController = bindings.additionalBindings && bindings.additionalBindings.scrollGridLineController;

          $super.constructor.call(this, bindings);
        },

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          $super.destroy.call(this);
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.ButtonType4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          this._addBehavior(cls.Alignment4STBehavior);
          this._addBehavior(cls.TextButtonVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledButtonVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);

          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, false);

          // ui behaviors
          if (this.scrollGridLineController) {
            this._addBehavior(cls.ButtonRequestFocusUIBehavior);
          }
          this._addBehavior(cls.OnClickUIBehavior);
          this._addBehavior(cls.InterruptUIBehavior);
        },
        _createWidget: function(type) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          const button = $super._createWidget.call(this, type);
          this._imageReadyHandler = button.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          return button;
        },
        _imageLoaded: function(event, src, hasMeasure) {
          if (!hasMeasure) {
            this.getWidget().getLayoutEngine().forceMeasurement();
            this.getAnchorNode().getApplication().getUI().getWidget().getLayoutInformation().invalidateMeasure();
          }
          this.getAnchorNode().getApplication().scheduler.layoutCommand();
        }
      };
    });
    cls.ControllerFactory.register("Button", cls.ButtonController);

  });
;

"use strict";

modulum('ButtonEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ButtonEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ButtonEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ButtonEditController.prototype */ {
        __name: "ButtonEditController",
        _imageReadyHandler: null,

        /**
         * @constructs
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._setCompleterBindings(bindings);
        },

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          $super.destroy.call(this);
        },

        _setCompleterBindings: function(bindings) {
          if (this.isInMatrix() || this.isInTable()) {
            bindings.completer = bindings.container._children[0]._children[0];
          } else {
            bindings.completer = bindings.decorator._children[0];
          }
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.FieldButtonEnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.IsPasswordVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.ImageVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.KeyboardHintVMBehavior);
          this._addBehavior(cls.ActionTitleVMBehavior);
          this._addBehavior(cls.CompleterVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ScaleIcon requires that the image is already present
          this._addBehavior(cls.ScaleIcon4STBehavior, false);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OnClickUIBehavior);

          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyButtonEdit";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
        _createWidget: function(type) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          const buttonEdit = $super._createWidget.call(this, type);
          this._imageReadyHandler = buttonEdit.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          return buttonEdit;
        },
        _imageLoaded: function(event, src, hasMeasure) {
          if (!hasMeasure) {
            this.getWidget().getLayoutEngine().forceMeasurement();
            this.getAnchorNode().getApplication().getUI().getWidget().getLayoutInformation().invalidateMeasure();
          }
          this.getAnchorNode().getApplication().scheduler.layoutCommand();
        }
      };
    });
    cls.ControllerFactory.register("ButtonEdit", cls.ButtonEditController);

  });
;

"use strict";

modulum('CheckBoxController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class CheckBoxController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.CheckBoxController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.CheckBoxController.prototype */ {
        __name: "CheckBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TextVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.CheckBoxValuesVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);
          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _createWidget: function(type) {
          const checkBox = $super._createWidget.call(this, type);

          if (checkBox.setCheckedValue) {
            checkBox.setCheckedValue(this.getNodeBindings().decorator.attribute("valueChecked"));
          }
          if (checkBox.setUncheckedValue) {
            checkBox.setUncheckedValue(this.getNodeBindings().decorator.attribute("valueUnchecked"));
          }
          if (checkBox.setIndeterminateValue) {
            checkBox.setIndeterminateValue('');
          }
          return checkBox;
        }
      };
    });
    cls.ControllerFactory.register("CheckBox", cls.CheckBoxController);

  });
;

"use strict";

modulum('ComboBoxController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ComboBoxController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ComboBoxController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ComboBoxController.prototype */ {
        __name: "ComboBoxController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          // QueryEditableVMBehavior must be executed before ItemVMBehavior & ValueVMBehavior
          // in order to set value default value on proper widget
          this._addBehavior(cls.QueryEditableVMBehavior);
          this._addBehavior(cls.ItemVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OpenDropDownUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        }
      };
    });
    cls.ControllerFactory.register("ComboBox", cls.ComboBoxController);

  });
;

"use strict";

modulum('DateEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DateEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.DateEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.DateEditController.prototype */ {
        __name: "DateEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.FirstDayOfWeek4STBehavior);
          this._addBehavior(cls.DaysOff4STBehavior);
          this._addBehavior(cls.ShowWeekNumber4STBehavior);
          this._addBehavior(cls.CalendarType4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.ButtonIcon4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          /* WARNING : Format & Picture have to be set before value */
          this._addBehavior(cls.FormatVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OpenDropDownUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyDateEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("DateEdit", cls.DateEditController);

  });
;

"use strict";

modulum('DateTimeEditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class DateTimeEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.DateTimeEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.DateTimeEditController.prototype */ {
        __name: "DateTimeEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.FirstDayOfWeek4STBehavior);
          this._addBehavior(cls.DaysOff4STBehavior);
          this._addBehavior(cls.ShowWeekNumber4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.ButtonIcon4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors

          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DateTimeValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OpenDropDownUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyDateTimeEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },

        _isConstruct: function() {
          return this.getNodeBindings().container.attribute('dialogType') === "Construct";
        },

        /**
         * Strategy method which returns widget value in VM ready format
         * @returns {string}
         * @protected
         */
        getWidgetValue: function() {
          const anchorNode = this.getAnchorNode();
          const decoratorNode = this.getNodeBindings().decorator;
          const widget = this.getWidget();
          let value = widget.getValue();

          if (value === null || value === undefined) {
            value = "";
          } else {
            if (!this._isConstruct() && widget.getFormat) {
              value = cls.DateTimeHelper.toISOFormat(value, widget.getFormat());
            } else {
              value = value.toString();
            }
          }
          const varType = anchorNode.attribute('varType');
          if (varType && varType.startsWith('DATETIME YEAR TO FRACTION(')) {
            const start = varType.lastIndexOf('(');
            const end = varType.lastIndexOf(')');
            if (start !== -1 && end !== -1) {
              const count = parseInt(varType.substring(start + 1, end));
              if (!isNaN(count)) {
                value += '.';
                for (let i = 0; i < count; i++) {
                  value += '0';
                }
              }
            }
          }
          value = this._shiftConversion(value, widget, decoratorNode);
          return value;
        },

        /**
         * Strategy method which returns AUI value in VM ready format
         * @returns {string}
         * @protected
         */
        getAuiValue: function() {
          const valueNode = this.getNodeBindings().anchor;
          return valueNode.attribute("value").toString();
        }
      };
    });
    cls.ControllerFactory.register("DateTimeEdit", cls.DateTimeEditController);

  });
;

"use strict";

modulum('EditController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class EditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.EditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.EditController.prototype */ {
        __name: "EditController",

        /**
         * @param {ControllerBindings} bindings
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          this._setCompleterBindings(bindings);
        },

        _setCompleterBindings: function(bindings) {
          if (this.isInMatrix() || this.isInTable()) {
            bindings.completer = bindings.container._children[0]._children[0];
          } else {
            bindings.completer = bindings.decorator._children[0];
          }
        },

        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          if (!this.isInTable()) {
            this._addBehavior(cls.Border4STBehavior);
          }
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.IsPasswordVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.KeyboardHintVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.CompleterVMBehavior);
          this._addBehavior(cls.PictureVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray") &&
            !(this.getNodeBindings().decorator.attribute("isPassword"))) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
      };
    });
    cls.ControllerFactory.register("Edit", cls.EditController);
    cls.ControllerFactory.register("XEdit", cls.EditController);

  });
;

"use strict";

modulum('HLineController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class HLineController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.HLineController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.HLineController.prototype */ {
        __name: "HLineController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // 4st behaviors
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
        }
      };
    });
    cls.ControllerFactory.register("HLine", cls.HLineController);

  });
;

"use strict";

modulum('ImageController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ImageController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ImageController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ImageController.prototype */ {
        __name: "ImageController",
        _imageReadyHandler: null,
        _afterLayoutHandler: null,

        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        },
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          const decorator = this.getNodeBindings().decorator;
          const container = this.getNodeBindings().container;

          const isStatic = !decorator && !container;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          if (!isStatic) {
            this._addBehavior(cls.ActivePseudoSelectorBehavior);
            this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
            if (this.isInMatrix()) {
              this._addBehavior(cls.MatrixCurrentRowVMBehavior);
            }
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Alignment4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.AutoScaleVMBehavior);

          this._addBehavior(cls.DefaultTTFColor4STBehavior);
          this._addBehavior(cls.ClickableImageVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          if (isStatic) {
            this._addBehavior(cls.ImageVMBehavior);
          } else {
            this._addBehavior(cls.ValuePrefixedVMBehavior);
          }
          this._addBehavior(cls.RequestFocusUIBehavior);

          // ui behaviors
          this._addBehavior(cls.OnClickUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          // TODO why dont' call super._createWidget ?
          const styleNode = this.getNodeBindings().decorator ? this.getNodeBindings().decorator : this.getAnchorNode();
          const imgWidget = cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid(),
            inToolBar: this.isInToolBar(),
          }, styleNode);

          if (imgWidget.isInstanceOf(cls.ImageWidget)) {
            imgWidget.setStandaloneImage(!this.isInTable());
            if (this._imageReadyHandler) {
              this._imageReadyHandler();
              this._imageReadyHandler = null;
            }
            this._imageReadyHandler = imgWidget.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            const application = this.getAnchorNode() && this.getAnchorNode().getApplication();
            if (application) {
              if (this._afterLayoutHandler) {
                this._afterLayoutHandler();
                this._afterLayoutHandler = null;
              }
              this._afterLayoutHandler = application.layout.afterLayout(imgWidget._whenLayouted.bind(imgWidget));
            }
          }
          return imgWidget;
        },

        /**
         * Called when an image has been loaded
         * @private
         */
        _imageLoaded: function() {
          const application = this.getAnchorNode() && this.getAnchorNode().getApplication();
          if (application) {

            const widget = this.getWidget();
            let layoutNeeded = !widget.ignoreLayout();

            if (this.isInTable()) {
              const tableWidget = widget.getTableWidgetBase();
              const tableLayoutEngine = tableWidget.getLayoutEngine();
              // no need to relayout if layout is already done
              if (tableLayoutEngine.isLayoutDone && tableLayoutEngine.isLayoutDone()) {
                layoutNeeded = false;
              }
            }

            if (layoutNeeded) {
              application.scheduler.layoutCommand();
            }
          }
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(newValue = null) {
          // Images cannot send any value.
        }
      };
    });
    cls.ControllerFactory.register("Image", cls.ImageController);

  });
;

"use strict";

modulum('LabelController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class LabelController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.LabelController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.LabelController.prototype */ {
        __name: "LabelController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          const decorator = this.getNodeBindings().decorator;
          const container = this.getNodeBindings().container;
          const isStatic = !decorator && !container;

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          if (!isStatic) {
            this._addBehavior(cls.ActivePseudoSelectorBehavior);
            this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
            if (this.isInMatrix()) {
              this._addBehavior(cls.MatrixCurrentRowVMBehavior);
            }
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          if (isStatic) {
            this._addBehavior(cls.TextLabelVMBehavior);
          } else {
            this._addBehavior(cls.ValueVMBehavior);
            this._addBehavior(cls.RequestFocusUIBehavior);
          }
          this._addBehavior(cls.StretchVMBehavior);

          // ui behaviors
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }

          //Put this 4st Behavior at the end since it's reformatting the value content
          this._addBehavior(cls.TextFormat4STBehavior);
          this._addBehavior(cls.Sanitize4STBehavior);
        },

        /**
         * @inheritDoc
         */
        _createWidget: function(type) {
          // TODO why dont' call super._createWidget ?
          const styleNode = this.getNodeBindings().decorator ? this.getNodeBindings().decorator : this.getAnchorNode();
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, styleNode);
        }
      };
    });
    cls.ControllerFactory.register("Label", cls.LabelController);

  });
;

"use strict";

modulum('MessageController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class MessageController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.MessageController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.MessageController.prototype */ {
        __name: "MessageController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.StyleVMBehavior);
          // 4st behaviors
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.TextFormat4STBehavior);
          this._addBehavior(cls.Sanitize4STBehavior);
          // vm behaviors
          this._addBehavior(cls.ColorMessageVMBehavior);
          this._addBehavior(cls.BackgroundColorMessageVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.MessageTextVMBehavior);
          this._addBehavior(cls.DisplayMessageVMBehavior);
          // ui behaviors
        },

        /**
         * Avoid destruction of the shared message widget
         */
        destroy: function() {
          const messageService = this.getAnchorNode().getApplication().message;
          messageService.removeMessage(this.getAnchorNode().attribute("count"));
          if (this._widget) {
            this._widget.setHidden(true);
            this._widget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * Override default method to use the shared message widget
         */
        createWidget: function() {
          this._widget = this.getAnchorNode().getParentNode().getController().getWidget().getMessageWidget();

          const messageService = this.getAnchorNode().getApplication().message;
          messageService.addMessage(this.getAnchorNode().attribute("count"), this._widget);
        }

      };
    });
    cls.ControllerFactory.register("Message", cls.MessageController);

  });
;

"use strict";

modulum('ProgressBarController', ['ValueContainerControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class ProgressBarController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.ProgressBarController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.ProgressBarController.prototype */ {
        __name: "ProgressBarController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Percentage4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.RangeVMBehavior); // range before value! to calculate percentage
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          // ui behaviors
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _createWidget: function(type) {
          const widget = $super._createWidget.call(this, type);
          if (widget.setRunning) {
            widget.setRunning(true);
          }
          return widget;

        }
      };
    });
    cls.ControllerFactory.register("ProgressBar", cls.ProgressBarController);

  });
;

"use strict";

modulum('RadioGroupController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class RadioGroupController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.RadioGroupController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.RadioGroupController.prototype */ {
        __name: "RadioGroupController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ItemVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyRadioGroup";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },
        _createWidget: function(type) {
          const radioGroup = $super._createWidget.call(this, type);

          const choices = this.getNodeBindings().decorator.getChildren().map(function(item) {
            return {
              value: item.attribute("name"),
              text: item.attribute("text")
            };
          });
          radioGroup.setItems(choices);
          radioGroup.setOrientation(this.getNodeBindings().decorator.attribute('orientation'));
          return radioGroup;
        }
      };
    });
    cls.ControllerFactory.register("RadioGroup", cls.RadioGroupController);

  });
;

"use strict";

modulum('RipGraphicController', ['ControllerBase', 'ControllerFactory'],
  function(context, cls) {
    /**
     * @class RipGraphicController
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.RipGraphicController = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.RipGraphicController.prototype */ {
        __name: "RipGraphicController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          this._addBehavior(cls.LayoutInfoVMBehavior);
          this._addBehavior(cls.RipGraphicTypeVMBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

        },
      };
    });
    cls.ControllerFactory.register("RipGraphic", cls.RipGraphicController);

  });
;

"use strict";

modulum('SliderController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class SliderController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.SliderController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.SliderController.prototype */ {
        __name: "SliderController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.OrientationVMBehavior);
          this._addBehavior(cls.RangeVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        }
      };
    });
    cls.ControllerFactory.register("Slider", cls.SliderController);

  });
;

"use strict";

modulum('SpinEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class SpinEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.SpinEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.SpinEditController.prototype */ {
        __name: "SpinEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.RangeVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },
        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummySpinEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        }
      };
    });
    cls.ControllerFactory.register("SpinEdit", cls.SpinEditController);

  });
;

"use strict";

modulum('TextEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class TextEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.TextEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.TextEditController.prototype */ {
        __name: "TextEditController",
        _isRichText: false,

        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          //This has been place here to dynamicaly handle relayout when switching to RichText
          this._addBehavior(cls.TextFormat4STBehavior);
          this._addBehavior(cls.Sanitize4STBehavior);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }

          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.WrapPolicy4STBehavior);
          this._addBehavior(cls.ShowEditToolBox4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.TextEditRowsVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextTransformVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.WantTabsVMBehavior);
          this._addBehavior(cls.WantReturnsVMBehavior);
          this._addBehavior(cls.ScrollBarsVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          //related to richtext
          this._addBehavior(cls.OnDataUIBehavior);
          this._addBehavior(cls.OnActionUIBehavior);
          this._addBehavior(cls.WebComponentStateChangedVMBehavior);
          this._addBehavior(cls.WebComponentKeyboardUIBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
          this._addBehavior(cls.HasWebComponentUIBehavior);

        },
        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyTextEdit";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          if (this._isRichText) {
            type = "RichText";
          }

          return type;
        },

        setAsRichText: function(isRichText) {
          this._isRichText = isRichText;
        }

      };
    });
    cls.ControllerFactory.register("TextEdit", cls.TextEditController);

  });
;

"use strict";

modulum('TimeEditController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class TimeEditController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.TimeEditController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.TimeEditController.prototype */ {
        __name: "TimeEditController",
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          this._addBehavior(cls.DialogTypeVMBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);
          this._addBehavior(cls.DefaultTTFColor4STBehavior);

          // vm behaviors
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextAlignVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.DisplayFormatVMBehavior); // must be set before value
          this._addBehavior(cls.ValueVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.MaxLengthVMBehavior);
          this._addBehavior(cls.PlaceholderVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);
          this._addBehavior(cls.CursorsVMBehavior);

          //Field Validation
          this._addBehavior(cls.NotNullVMBehavior);
          this._addBehavior(cls.RequiredVMBehavior);
          this._addBehavior(cls.IncludeVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          if (this.isInTable()) {
            this._addBehavior(cls.TableImageVMBehavior);
            this._addBehavior(cls.RowSelectionUIBehavior);
            this._addBehavior(cls.TableItemCurrentRowVMBehavior);
          }
        },

        _getWidgetType: function(kind) {
          let type;
          if (kind === "Construct") {
            type = "DummyTimeEdit";
          } else if (this.isInTable() && (kind === "Display" || kind === "DisplayArray")) {
            type = "Label";
          } else {
            type = $super._getWidgetType.call(this, kind);
          }
          return type;
        },

        _isConstruct: function() {
          return this.getNodeBindings().container.attribute('dialogType') === "Construct";
        }
      };
    });
    cls.ControllerFactory.register("TimeEdit", cls.TimeEditController);

  });
;

"use strict";

modulum('WebComponentController', ['ValueContainerControllerBase', 'ControllerFactory', 'WidgetFactory'],
  function(context, cls) {
    /**
     * @class WebComponentController
     * @memberOf classes
     * @extends classes.ValueContainerControllerBase
     */
    cls.WebComponentController = context.oo.Class(cls.ValueContainerControllerBase, function($super) {
      return /** @lends classes.WebComponentController.prototype */ {
        __name: 'WebComponentController',

        _properties: null,
        _bufferPending: false,
        _ordersManagedHandler: null,

        /**
         * Initialize behaviors of the controller
         * @private
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);

          // These behaviors should stay added at first
          // WARNING : DO NOT ADD BEHAVIORS BEFORE
          if (this.isInTable()) {
            this._addBehavior(cls.TableSizeVMBehavior);
          }
          if (!this.isInTable() || this.isInFirstTableRow()) {
            this._addBehavior(cls.LayoutInfoVMBehavior);
          }
          this._addBehavior(cls.StyleVMBehavior);
          // END WARNING

          // pseudo-selector behaviors
          this._addBehavior(cls.ActivePseudoSelectorBehavior);
          this._addBehavior(cls.DialogTypePseudoSelectorBehavior);
          if (this.isInMatrix()) {
            this._addBehavior(cls.MatrixCurrentRowVMBehavior);
          }
          this._addBehavior(cls.FontStyle4STBehavior);
          this._addBehavior(cls.FontSize4STBehavior);
          this._addBehavior(cls.FontColor4STBehavior);
          this._addBehavior(cls.Border4STBehavior);
          this._addBehavior(cls.Reverse4STBehavior);

          // vm behaviors
          this._addBehavior(cls.PropertyVMBehavior);
          this._addBehavior(cls.ComponentTypeVMBehavior);
          this._addBehavior(cls.ValuePrefixedVMBehavior);
          this._addBehavior(cls.EnabledVMBehavior);
          this._addBehavior(cls.HiddenVMBehavior);
          this._addBehavior(cls.ColorVMBehavior);
          this._addBehavior(cls.BackgroundColorVMBehavior);
          this._addBehavior(cls.FontWeightVMBehavior);
          this._addBehavior(cls.FontFamilyVMBehavior);
          this._addBehavior(cls.TextDecorationVMBehavior);
          this._addBehavior(cls.TitleVMBehavior);
          this._addBehavior(cls.WebComponentStateChangedVMBehavior);
          this._addBehavior(cls.WebComponentCursorsVMBehavior);
          this._addBehavior(cls.StretchVMBehavior);

          // ui behaviors
          this._addBehavior(cls.ValueChangedUIBehavior);
          this._addBehavior(cls.RequestFocusUIBehavior);
          this._addBehavior(cls.OnActionUIBehavior);
          this._addBehavior(cls.OnDataUIBehavior);
          this._addBehavior(cls.HasWebComponentUIBehavior);
          this._addBehavior(cls.WebComponentKeyboardUIBehavior);
        },

        /**
         * @inheritDoc
         */
        constructor: function(bindings) {
          $super.constructor.call(this, bindings);
          const app = this.getAnchorNode().getApplication();

          // Webcomponent cannot be in a table!
          if (this.isInTable()) {
            app.fail("Cannot initialize table including web component");
          }

          // Once an order is managed, flush the property buffer
          if (app && app.dvm) {
            this._ordersManagedHandler = app.dvm.onOrdersManaged(function() {
              if (this._bufferPending && this.getWidget()) {
                this.getWidget().setProperty(JSON.stringify(this._properties));
                this._bufferPending = false;
              }
            }.bind(this));
          }
        },

        /**
         * Bufferize to unsure all properties are sent after a single order
         * @param {Object} properties - JSON object containing the webcomponent properties
         */
        bufferizeProperties: function(properties) {
          this._bufferPending = true;
          this._properties = Object.assign(this._properties || {}, properties);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._ordersManagedHandler) {
            this._ordersManagedHandler();
          }
          $super.destroy.call(this);
        }

      };
    });
    cls.ControllerFactory.register('WebComponent', cls.WebComponentController);
  });
;

"use strict";

modulum('ValueContainerControllerBase', ['ControllerBase'],
  function(context, cls) {
    /**
     * Base controller for an AUI node.
     * Manages client side life cycle representation of the node.
     * @class ValueContainerControllerBase
     * @memberOf classes
     * @extends classes.ControllerBase
     */
    cls.ValueContainerControllerBase = context.oo.Class(cls.ControllerBase, function($super) {
      return /** @lends classes.ValueContainerControllerBase.prototype */ {
        __name: "ValueContainerControllerBase",

        /**
         * @inheritDoc
         */
        _initBehaviors: function() {
          $super._initBehaviors.call(this);
          if (this.isInStack() && !(this.isInMatrix() || this.isInTable())) {
            this._addBehavior(cls.StackLabelVMBehavior);
          }
        },

        /**
         * Creates a new widget depending on the dialog type
         * @returns {classes.WidgetBase} the widget
         */
        createWidget: function() {
          if (!this._widget && this.autoCreateWidget()) {
            let dialogType = null;

            // Determine the widget kind of a valueNode
            if (this.getAnchorNode()) {
              dialogType = this.getAnchorNode().attribute('dialogType');
            }
            if (!dialogType && this.getNodeBindings().decorator) {
              dialogType = this.getNodeBindings().decorator.attribute('dialogType');
            }
            if (!dialogType && this.getNodeBindings().container) {
              dialogType = this.getNodeBindings().container.attribute('dialogType');
            }

            const type = this._getWidgetType(dialogType);

            this._widgetKind = dialogType;
            this._widgetType = type;

            this._widget = this._createWidget(type);
          }
          return this._widget;
        },

        /**
         *
         * @inheritDoc
         * @protected
         * @virtual
         */
        _createWidget: function(type) {
          return cls.WidgetFactory.createWidget(type, {
            appHash: this.getAnchorNode().getApplication().applicationHash,
            appWidget: this.getAnchorNode().getApplication().getUI().getWidget(),
            auiTag: this.getAnchorNode().getId(),
            inTable: this.isInTable(),
            inFirstTableRow: this.isInFirstTableRow(),
            inMatrix: this.isInMatrix(),
            inScrollGrid: this.isInScrollGrid()
          }, this.getNodeBindings().decorator);
        },

        /**
         * Strategy method which returns widget value in VM ready format
         * @returns {string} the widget value
         * @protected
         */
        getWidgetValue: function(newValue = null) {
          const decoratorNode = this.getNodeBindings().decorator;
          const widget = this.getWidget();
          let value = newValue !== null ? newValue : widget.getValue();

          if (value === null || value === undefined) {
            value = "";
          } else {
            value = value.toString();
          }
          value = this._shiftConversion(value, widget, decoratorNode);

          // Validate value, if not valid, rollback to old VM's value!
          if (widget instanceof cls.FieldWidgetBase && !widget.validateValue()) {
            value = widget._oldValue; // don't touch this, or it will break spinedit min value initialisation when out of allowed range
            widget.setValue(value);
          }
          return value;
        },

        /**
         * Strategy method which returns AUI value in VM ready format
         * @returns {string} the AUI value
         */
        getAuiValue: function() {
          const valueNode = this.getNodeBindings().anchor;
          return valueNode.attribute("value").toString();
        },

        /**
         * Get the value depending on the shift attribute
         * @param {string} value - value to process
         * @param {classes.WidgetBase} widget - concerned widget
         * @param {classes.NodeBase} decoratorNode - concerned Node
         * @return {string} - the updated value
         * @private
         */
        _shiftConversion: function(value, widget, decoratorNode) {
          // manage upshift & downshift case
          if (decoratorNode && decoratorNode.isAttributeSetByVM('shift')) {
            let shiftAttr = decoratorNode.attribute('shift');
            if (this.getWidget() && this.getWidget().getTextTransform) {
              shiftAttr = this.getWidget().getTextTransform();
            }
            if (shiftAttr !== "none" && (widget.isEditing && widget.isEditing())) {
              switch (shiftAttr) {
                case 'up':
                  value = value.toUpperCase();
                  break;
                case 'down':
                  value = value.toLowerCase();
                  break;
              }
            }
          }
          return value;
        },

        /**
         * @inheritDoc
         */
        sendWidgetValue: function(newValue = null) {
          const anchorNode = this.getAnchorNode();
          const widgetValue = this.getWidgetValue(newValue);
          anchorNode.getApplication().scheduler.valueVMCommand(anchorNode, widgetValue);
        },

        /**
         * @inheritDoc
         */
        sendWidgetCursors: function() {
          const widget = this.getWidget();
          if (!widget || !widget.hasCursors()) {
            return;
          }
          const cursors = widget.getCursors();
          const anchorNode = this.getAnchorNode();
          const widgetValueLength = this.getWidgetValue().length;
          anchorNode.getApplication().scheduler.cursorsVMCommand(anchorNode, cursors.start, cursors.end, widgetValueLength);
        },

        /**
         * @inheritDoc
         */
        hasActiveDropDown: function() {
          if (this._widget) {
            return !!this._widget.getDropDown && !!this._widget.getDropDown() && this._widget.getDropDown().isVisible();
          }
          return $super.hasActiveDropDown.call(this);
        }
      };
    });
  });
;

"use strict";

modulum('ColoredWidgetBase', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for all widgets handling colors (background and fore)
     * @class ColoredWidgetBase
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.ColoredWidgetBase = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ColoredWidgetBase.prototype */ {
        __name: "ColoredWidgetBase",
        __virtual: true,
        /**
         * true to ignore background color
         * @type {boolean}
         * @protected
         */
        _ignoreBackgroundColor: false,
        /**
         * the widget's main color
         * @type {?string}
         * @protected
         */
        _color: null,
        /**
         * the widget's main background color
         * @type {?string}
         * @protected
         */
        _backgroundColor: null,

        /**
         * Set the fore color
         * see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @param {string} color a CSS color definition. Can be a color name ('red', 'blue'),
         *                 a hex code ('#f5d48a') or a color function ('rgb(128, 255, 0)').
         *                 null restores the default value.
         * @publicdoc
         */
        setColor: function(color) {
          if (this._color === color) {
            return;
          }
          this._color = color;

          if (this.isInTable()) {
            this.getTableWidgetBase().setInTableWidgetColor(this, color);
            return;
          }

          this.setStyle({
            selector: ".gbc_WidgetBase_standalone",
            appliesOnRoot: true
          }, {
            "color": color ? color : null,
          });

          if (this.isInScrollGrid()) {
            this.setStyle({
              preSelector: ".nohighlight ",
              selector: ".gbc_WidgetBase_in_array",
              appliesOnRoot: true
            }, {
              "color": color ? color + " !important" : null,
            });
            this.setStyle({
              preSelector: ".highlight ",
              selector: ".gbc_WidgetBase_in_array:not(.currentRow)",
              appliesOnRoot: true
            }, {
              "color": color ? color + " !important" : null,
            });
          }
        },

        /**
         * Returns the fore color
         * see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @returns {?string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getColor: function() {
          return this._color;
        },

        /**
         * Returns the fore color (directly from style css)
         * see {@link http://www.w3.org/wiki/CSS/Properties/color}
         * @returns {string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getColorFromStyle: function() {
          return this.getStyle(".gbc_WidgetBase_standalone", "color", true);
        },

        /**
         * Sets the background color
         * see {@link http://www.w3.org/wiki/CSS/Properties/background-color}
         * @param {string} color a CSS color definition. Can be a color name ('red', 'blue'),
         *                 a hex code ('#f5d48a') or a color function ('rgb(128, 255, 0)')
         *                 null restores the default value.
         * @param {boolean} [notImportant] Set the CSS color definition on the ID whithout '!important'.
         * @publicdoc
         */
        setBackgroundColor: function(color, notImportant) {
          if (notImportant === true) {
            if (this._backgroundColor !== color) {
              this._backgroundColor = color;
              this.setStyle({
                "background-color": color && !this._ignoreBackgroundColor ? color : null
              });
            }

            return;
          }

          if (this._backgroundColor !== color) {
            this._backgroundColor = color;

            if (this.isInTable()) {
              this.getTableWidgetBase().setInTableWidgetBackgroundColor(this, color);
            } else {
              this.setStyle({
                selector: ".gbc_WidgetBase_standalone",
                appliesOnRoot: true
              }, {
                "background-color": color && !this._ignoreBackgroundColor ? color + " !important" : null
              });

              if (this.isInScrollGrid()) {
                this.setStyle({
                  preSelector: ".nohighlight ",
                  selector: ".gbc_WidgetBase_in_array",
                  appliesOnRoot: true
                }, {
                  "background-color": color && !this._ignoreBackgroundColor ? color + " !important" : null
                });
                this.setStyle({
                  preSelector: ".highlight ",
                  selector: ".gbc_WidgetBase_in_array:not(.currentRow)",
                  appliesOnRoot: true
                }, {
                  "background-color": color && !this._ignoreBackgroundColor ? color + " !important" : null
                });

                this.setStyle({
                  preSelector: ".gbc_ScrollGridWidget.highlight ",
                  selector: ".gbc_WidgetBase_in_array.gbc_Focus",
                  appliesOnRoot: true
                }, {
                  "background-color": color && !this._ignoreBackgroundColor ? color + " !important" : null
                });
              }
            }
          }
        },

        /**
         * Set whether to ignore the background color or not
         * @param {boolean} ignore true to ignore
         * @protected
         */
        setIgnoreBackgroundColor: function(ignore) {
          this._ignoreBackgroundColor = ignore;
          this.setBackgroundColor(this._backgroundColor);
        },

        /**
         * Returns the background color
         * see {@link http://www.w3.org/wiki/CSS/Properties/background-color}
         * @returns {?string} a color definition as an RGB function ('rgb(128, 255, 0)')
         * @publicdoc
         */
        getBackgroundColor: function() {
          return this._backgroundColor;
        }
      };
    });
  });
;

"use strict";

modulum('ColumnManipulationWidgetComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * A component that hold column management behavior
     * Usefull for table
     * @class ColumnManipulationWidgetComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.ColumnManipulationWidgetComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {

      return /** @lends classes.ColumnManipulationWidgetComponent.prototype */ {
        __name: "ColumnManipulationWidgetComponent",

        $static: /** @lends classes.ColumnManipulationWidgetComponent */ {
          /**
           * @static
           * @type {string}
           */
          dndModeReordering: "columnReordering",
          /**
           * @static
           * @type {string}
           */
          dndModeResizing: "columnResizing",
        },

        //#region Private fields

        /**
         * The hovered column during DnD events
         * @type {classes.RTableColumnWidget}
         */
        _hoveredColumnWidget: null,

        /**
         * The dragged column during DnD reordering events
         * or the resized column during DnD resize events
         * @type {classes.RTableColumnWidget}
         */
        _manipulatedColumnWidget: null,

        /**
         * The current drag and drop mode. Null if no DnD process is occuring
         * @type {string|null}
         */
        _dndMode: null,

        /**
         * The current value horizontal drag when Resize process is occuring
         * null otherwise 
         * @type {number|null} 
         */
        _lastPointerPosX: null,

        //#endregion private fields

        //#region ============== DnD Events FUNCTIONS ===================

        /**
         * If the Dragged element is part of a column, a DnD process is started,
         * otherwise the method do nothing
         * @param {DragEvent} evt The dragstart event triggered by the browser
         * @returns True if the DnD process is started, false otherwise
         */
        onDragStart: function(evt) {
          const columnWidget = this._getTargetAsColumn(evt.target);
          if (!columnWidget) {
            return false;
          }

          if (evt.target.hasClass("resizer")) { // drag start on resizer
            return this._onResizerDragStart(evt, columnWidget);
          } else if (evt.target.hasClass("headerText")) { // drag start on headerText
            return this._onReorderingDragStart(evt, columnWidget);
          }
          return false;
        },

        /**
         * If the Dragged element is part of a column, a DnD process is started,
         * otherwise the method do nothing
         * @param {TouchEvent} evt The touchstart event triggered by the browser
         * @returns True if the DnD process is started, false otherwise
         */
        onTouchStart: function(evt) {
          const columnWidget = this._getTargetAsColumn(evt.target);
          if (!columnWidget) {
            return false;
          }

          if (evt.target.hasClass("resizer")) { // drag start on resizer
            return this._onResizerTouchStart(evt, columnWidget);
          }
          return false;
        },

        /**
         * If the Dragged element is part of a column, the current DnD process is stopped,
         * otherwise the method do nothing
         * @param {DragEvent} evt The dragend event triggered by the browser
         * @returns True if the DnD process end was managed correctly, false otherwise
         */
        onDragEnd: function(evt) {
          const columnWidget = this._getTargetAsColumn(evt.target);
          // If the column triggering the dragend event is not the manipulated column, what happen ?
          if (!columnWidget || columnWidget !== this._manipulatedColumnWidget) {
            return false;
          }

          if (this.isResizing()) { // drag end on resizer
            return this._onResizerDragEnd(evt);
          } else if (this.isReordering()) { // drag end on headerText
            return this._onReorderingDragEnd(evt);
          }
          return false;
        },

        /**
         * If the touch target element is part of a column, the current DnD process is stopped,
         * otherwise the method do nothing
         * @param {DragEvent} evt The dragend event triggered by the browser
         * @returns True if the DnD process end was managed correctly, false otherwise
         */
        onTouchEnd: function(evt) {
          const columnWidget = this._getTargetAsColumn(evt.target);
          if (!columnWidget) {
            return false;
          }

          if (evt.target.hasClass("resizer")) { // drag start on resizer
            return this._onResizerTouchEnd();
          }
          return false;
        },

        /**
         * Handle dragover event.
         * Dispatch the event depending on the DnD mode
         * Store the mouse position 
         * @param {DragEvent} evt The dragover event triggered by the browser
         * @returns {boolean} True if the DnD Process was handled
         */
        onDragOver: function(evt) {
          // Prevent default on dragover, to remove forbidden icon on drag
          if (this._dndMode) {
            evt.preventCancelableDefault();
          }

          // If we are resizing, quit the process ...
          if (this._onResizerDragOver(evt)) {
            return true;
          }

          // ... else try to reorder
          const hoveredColumn = this._getTargetAsColumn(evt.target);
          return this._onReorderingDragOver(evt, hoveredColumn);
        },

        /**
         * Manage the touch event to resize accordingly with the pointer position
         * @param {TouchEvent} evt The touchmove event triggered by the browser
         * @returns {boolean} True if the current DnD Process was handled correctly
         */
        onTouchMove: function(evt) {
          if (evt.target?.hasClass("resizer")) {
            return this._onResizerTouchMove(evt);
          }
          return false;
        },

        /**
         * Handle the dragleave event when reordering is on
         * @param {DragEvent} evt The dragleave event triggered by the browser
         * @returns True if the dragleave event was managed
         */
        onDragLeave: function(evt) {
          return this._onReorderingDragLeave(evt);
        },

        /**
         * Handle Drop event
         * @param {DragEvent} evt The drop event triggered by the browser
         * @returns True if the drop event was managed
         */
        onDrop: function(evt) {
          let dropTargetColumn = this._getTargetAsColumn(evt.target);
          return this._onReorderingDrop(evt, dropTargetColumn);
        },

        //#endregion

        //#region ============== Resize Event/DnD FUNCTIONS ===================

        /**
         * Handle resizer dragStart event on resizer element
         * @param {DragEvent} evt The dragstart event triggered by the browser
         * @param {classes.RTableColumnWidget} columnWidget The column triggering the event 
         * @returns {boolean} True if the process is managed
         * @private
         */
        _onResizerDragStart: function(evt, columnWidget) {
          if (!columnWidget.isSizable()) {
            return false;
          }

          this._setIsResizing();
          this._manipulatedColumnWidget = columnWidget;
          this._lastPointerPosX = evt.clientX || evt.screenX;
          return true;
        },

        /**
         * Handle the touch event and store the position of the touch
         * @param {TouchEvent} evt The touchstart event triggered by the browser
         * @param {classes.RTableColumnWidget} columnWidget The touched column
         * @returns False if the column is not resizable
         * @private
         */
        _onResizerTouchStart: function(evt, columnWidget) {
          if (!columnWidget.isSizable()) {
            return false;
          }

          this._setIsResizing();
          this._manipulatedColumnWidget = columnWidget;

          let touch = evt.touches[0];
          if (touch) {
            this._lastPointerPosX = touch.clientX || touch.screenX;
            evt.preventCancelableDefault();
            return true;
          }

          this._lastPointerPosX = null;
          return false;
        },

        /**
         * Handle resizer dragEnd event on resizer element
         * @param {DragEvent} evt The dragend event triggered by the browser
         * @private
         */
        _onResizerDragEnd: function(evt) {
          if (!this.isResizing()) {
            return false;
          }

          this._exitDndProcess();
          return true;
        },

        /**
         * End the resize process if any
         * @returns {boolean} False if no resize process is occuring
         * @private
         */
        _onResizerTouchEnd: function() {
          if (!this.isResizing()) {
            return false;
          }

          this._exitDndProcess();
          return true;
        },

        /**
         * Handle resizer drag event on resizer element
         * Compute the new width, and send it to the ColumnWidget
         * @param {DragEvent} evt The dragover event triggered by the browser
         * @returns {boolean} True if the process was handled
         * @private
         */
        _onResizerDragOver: function(evt) {
          if (!this.isResizing()) {
            return false;
          }

          evt.preventCancelableDefault();
          return this._onResizerDrag(evt.clientX || evt.screenX);
        },

        /**
         * Resize the manipulated column widget according to the last pointer position and the new one
         * @param {TouchEvent} evt The touchmove event triggered by the browser
         * @private
         */
        _onResizerTouchMove: function(evt) {
          if (!this.isResizing()) {
            return false;
          }

          evt.preventCancelableDefault();
          if (!evt.touches || evt.touches.length === 0) {
            return false;
          }

          return this._onResizerDrag(evt.touches[0].clientX || evt.touches[0].screenX);
        },

        /**
         * @param {number} pointerPosX The horizontal position of the pointer
         * @returns False if no resizing process is occuring, or if we have no pointer position stored
         * @private
         */
        _onResizerDrag: function(pointerPosX) {
          if (!this.isResizing()) {
            return false;
          }

          // If there is no _resizerDragX, or we didn't store any DragX value
          if (!this._lastPointerPosX || !pointerPosX) {
            return false;
          }

          let dragDelta = pointerPosX - this._lastPointerPosX;
          let columnWidth = this._manipulatedColumnWidget.getWidth();

          let newWidth = columnWidth + dragDelta;
          if (this._manipulatedColumnWidget.isReversed()) {
            newWidth = columnWidth - dragDelta;
          }

          this._lastPointerPosX = pointerPosX;
          // Clamp the width to 30 pixels
          newWidth = Math.max(newWidth, 30);
          this._manipulatedColumnWidget.setUserWidthFromInteraction(newWidth);

          return true;
        },

        // #endregion Resize Event/DnD FUNCTIONS

        //#region ============== Reordering Event/DnD FUNCTIONS ===================

        /**
         * Set the dndMode to reordering and store the manipulated column
         * @param {DragEvent} evt The dragstart event triggered by the browser
         * @param {classes.RTableColumnWidget} columnWidget The Dragged column widget
         * @returns {boolean} True if the drag process is managed
         * @private
         */
        _onReorderingDragStart: function(evt, columnWidget) {
          if (!columnWidget.isMovable()) {
            evt.preventCancelableDefault();
            return false;
          }

          this._setIsReordering();
          this._manipulatedColumnWidget = columnWidget;
        },

        /**
         * Exit the DndProcess if we were reordering
         * @param {DragEvent} evt The dragend event triggered by the browser
         * @private
         */
        _onReorderingDragEnd: function(evt) {
          if (!this.isReordering()) {
            return false;
          }

          this._exitDndProcess();
          return true;
        },

        /**
         * Handle reordering dragover event
         * @param {DragEvent} evt The dragover event triggered by the browser
         * @param {classes.RTableColumnWidget} hoveredColumn The column that have triggered the dragover event
         * @returns {boolean} True if the process is handled right
         * @private
         */
        _onReorderingDragOver: function(evt, hoveredColumn) {
          if (!this.isReordering()) {
            return false;
          }
          // Allow drop
          evt.preventCancelableDefault();

          if (this._hoveredColumnWidget === hoveredColumn) {
            return true;
          }

          if (hoveredColumn) {
            // Find the new hovered columns, that is in the drag limits
            const dragLimit = this._manipulatedColumnWidget.getDragLimit();

            let hoverIndex = hoveredColumn.getOrderedColumnIndex();
            hoverIndex = Math.clamp(hoverIndex, dragLimit.min, dragLimit.max);
            // Get the column that match the limited over index
            hoveredColumn = this.getWidget().getOrderedColumns()[hoverIndex];
          }
          this._setHoveredColumn(hoveredColumn);
          if (this._hoveredColumnWidget) {
            this._hoveredColumnWidget.setReorderingSide(this._manipulatedColumnWidget.getOrderedColumnIndex());
          }
          return true;
        },

        /**
         * Set the currently hovered column to null if we are in a reordering process
         * @param {DragEvent} evt The dragleave event triggered by the browser
         * @returns False if no reordering process is occuring
         */
        _onReorderingDragLeave: function(evt) {
          if (!this.isReordering()) {
            return false;
          }

          this._setHoveredColumn(null);
          return true;
        },

        /**
         * Handle the drop event when reordering columns.
         * @param {DragEvent} evt The drop event fired by the browser
         * @returns False if no reordering process is occuring
         */
        _onReorderingDrop: function(evt, dropTargetColumn) {
          if (!this.isReordering()) {
            return false;
          }
          evt.preventCancelableDefault();

          // The manipulated column might have been dropped after the last column
          // Assuming that this method is only called by a drop event on the right DOM Element
          if (!dropTargetColumn) {
            const orderedColumns = this.getWidget().getOrderedColumns();
            dropTargetColumn = orderedColumns[orderedColumns.length - 1];
          }

          this._reorderColumns(this._manipulatedColumnWidget, dropTargetColumn);
          this._exitDndProcess();
          return true;
        },

        //#endregion Reordering Event/DnD FUNCTIONS

        //#region ============== GETTERS ==============

        /**
         * @returns {string | null} The current dnd mode, null if not in dnd process
         */
        getDndMode: function() {
          return this._dndMode;
        },

        /**
         * @returns {boolean} True if the dndMode is set to Resizing
         */
        isResizing: function() {
          return this.getDndMode() === cls.ColumnManipulationWidgetComponent.dndModeResizing &&
            this._manipulatedColumnWidget;
        },

        /**
         * @returns {boolean} True if the dndMode is set to Reordering
         */
        isReordering: function() {
          return this.getDndMode() === cls.ColumnManipulationWidgetComponent.dndModeReordering &&
            this._manipulatedColumnWidget;
        },
        //#endregion

        //#region ============== SETTERS ==============

        /**
         * Set the dnd mode to resizing
         * @private
         */
        _setIsResizing: function() {
          this._dndMode = cls.ColumnManipulationWidgetComponent.dndModeResizing;
        },

        /**
         * Set the dnd mode to reordering
         * Store the 
         * @private
         */
        _setIsReordering: function(manipulatedColumn) {
          this._dndMode = cls.ColumnManipulationWidgetComponent.dndModeReordering;
        },

        /**
         * - Set the dnd mode to null
         * - Clean CSS state of hovered column if any
         * - Clean widgets variables
         * @private
         */
        _exitDndProcess: function() {
          // resizing vars
          this._lastPointerPosX = null;

          this._setHoveredColumn(null);

          // common vars
          this._manipulatedColumnWidget = null;
          this._dndMode = null;
        },

        /**
         * Reset the currently hovered column CSS if any,
         * store the newly hovered column
         * @param {classes.RTableColumnWidget} hoveredColumn The newly hovered column
         */
        _setHoveredColumn: function(hoveredColumn) {
          if (this._hoveredColumnWidget === hoveredColumn) {
            return;
          }

          if (this._hoveredColumnWidget) {
            this._hoveredColumnWidget.cleanReorderingState();
          }
          this._hoveredColumnWidget = hoveredColumn;
        },

        //#endregion

        //#region ============== UTILS ==============

        /**
         * Get the Column Widget associated with the target if possible
         * @param {Element} target Event Target
         * @returns {classes.RTableColumnWidget} The target as ColumnWidget, or null
         * @private
         */
        _getTargetAsColumn(target) {
          //@todo : replace "gbc_RTableColumnWidget" to make this more generic
          return gbc.WidgetService.getWidgetFromElement(target, "gbc_RTableColumnWidget");
        },

        /**
         * Use the droppedColumn and the target column 
         * to compute the new index of the manipulated column
         * and then update the parent widget
         * @param {classes.RTableColumnWidget} droppedColumn
         * @param {classes.RTableColumnWidget} targetColumn
         * @private
         */
        _reorderColumns(droppedColumn, targetColumn) {
          let reorderedColumns = this.getWidget().getOrderedColumns().slice();

          let dragColIndex = reorderedColumns.indexOf(droppedColumn);
          let dropColIndex = reorderedColumns.indexOf(targetColumn);

          const dragLimit = droppedColumn.getDragLimit();

          dropColIndex = Math.clamp(dropColIndex, dragLimit.min, dragLimit.max);

          reorderedColumns.removeAt(dragColIndex);
          reorderedColumns.insert(droppedColumn, dropColIndex);

          // First set correct order on each column
          for (let i = 0; i < reorderedColumns.length; i++) {
            let col = reorderedColumns[i];
            col.setOrder(i, true);
          }

          this.getWidget().update(true, false, true);

          // And only after emit signal to send tabIndex to VM
          // (Don't do it in the same loop)
          for (let i = 0; i < reorderedColumns.length; i++) {
            let col = reorderedColumns[i];
            col.emit(context.constants.widgetEvents.tableOrderColumn, i);
          }
        }
        //#endregion
      }; // End return
    }); // End Class
  } // JS Face Function
); // End Modulum
;

"use strict";

modulum('HighlightWidgetComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * Highlight Widget Component.
     * Manage the highlight css classes and variables
     * @class HighlightWidgetComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.HighlightWidgetComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {

      return /** @lends classes.HighlightWidgetComponent.prototype */ {
        __name: "HighlightWidgetComponent",

        $static: /** @lends classes.HighlightWidgetComponent */ {

          /**
           * @static
           */
          _highlightCurrentRowCssClass: 'gbc_highlightCurrentRow',

          /**
           * @static
           */
          _highlightCurrentCellCssClass: 'gbc_highlightCurrentCell',

          /**
           * @static
           */
          _defaultHighlightBackgroundColorCssVar: '--default-highlightBackgroundColor',
          /**
           * @static
           */
          _highlightBackgroundColorCssVar: '--highlightBackgroundColor',

          /**
           * @static
           */
          _defaultHighlightTextColorCssVar: '--default-highlightColor',
          /**
           * @static
           */
          _highlightTextColorCssVar: '--highlightColor',
        },

        /**
         * Controls current row highlighting
         * @private
         * @type {boolean}
         */
        _shouldHighlightCurrentRow: null,

        /**
         * Controls current cell highlighting
         * @private
         * @type {boolean} 
         */
        _shouldHighlightCurrentCell: null,

        /**
         * Defines the background color.
         * *Genero equivalent : highlightColor*
         * @private
         * @type {string} 
         */
        _highlightBackgroundColor: null,

        /**
         * Defines the text/foreground color.
         * *Genero equivalent : highlightTextColor*
         * @private
         * @type {string} 
         */
        _highlightTextColor: null,

        /**
         * Build the component and init the default values;
         * @constructs
         */
        constructor: function(widget, shouldHighlightCurrentRow, shouldHighlightCurrentCell) {
          $super.constructor.call(this, widget);
        },

        /**
         * @returns The highlightCurrentRow value
         */
        getShouldHighlightCurrentRow: function() {
          return this._shouldHighlightCurrentRow;
        },

        /**
         * Apply the `highlightCurrentRow` css class to the HTML Element
         * Remove the `highlightCurrentCell` css class if the value is true, as `highlightCurrentRow` prevail on it.
         * But keep in memory `highlightCurrentCell` value 
         * @param {boolean} doHighlight True to highlight the current row. False otherwise
         */
        setShouldHighlightCurrentRow: function(doHighlight) {
          if (this.shouldHighlightCurrentRow === doHighlight) {
            return;
          }
          this._shouldHighlightCurrentRow = doHighlight;
          this.getWidget().toggleClass(cls.HighlightWidgetComponent._highlightCurrentRowCssClass, doHighlight);
        },

        /**
         * @returns Returns the highlightCurrentCell value
         */
        getShouldHighlightCurrentCell: function() {
          return this._shouldHighlightCurrentCell;
        },

        /**
         * Apply the `highlightCurrentCell` css class to the HTML Element
         * **IF** the `highlightCurrentRow` is false and the value is true.
         * Else, it remove the `highlightCurrentCell` class
         * @param {boolean} doHighlight True to highlight the current cell. False otherwise
         */
        setShouldHighlightCurrentCell: function(doHighlight) {
          if (this._shouldHighlightCurrentCell === doHighlight) {
            return;
          }
          this._shouldHighlightCurrentCell = doHighlight;
          this.getWidget().toggleClass(cls.HighlightWidgetComponent._highlightCurrentCellCssClass, doHighlight);
        },

        /**
         * @returns {string} Defines the highlight background color.
         * *Genero equivalent : highlightColor*
         */
        getHighlightBackgroundColor: function() {
          return this._highlightBackgroundColor;
        },

        /**
         * @param {string} color Store the highlight background color.
         * *Genero equivalent : highlightColor*
         */
        setHighlightBackgroundColor: function(color) {
          if (this._highlightBackgroundColor === color ||
            (this._highlightBackgroundColor === null && color === undefined)) {
            return;
          }

          this._highlightBackgroundColor = color;

          this.getWidget().setStyle({
            [cls.HighlightWidgetComponent._highlightBackgroundColorCssVar]: color
          });
        },

        /**
         * @returns {string} Defines the highlight foreground color.
         * *Genero equivalent : highlightTextColor*
         */
        getHighlightTextColor: function() {
          return this._highlightTextColor;
        },

        /**
         * @param {string} color Store the highlight foreground color.
         * *Genero equivalent : highlightTextColor*
         */
        setHighlightTextColor: function(color) {
          if (this._highlightTextColor === color ||
            (this._highlightTextColor === null && color === undefined)) {
            return;
          }

          this._highlightTextColor = color;

          this.getWidget().setStyle({
            [cls.HighlightWidgetComponent._highlightTextColorCssVar]: color
          });
        },
      };
    });
  }
);
;

"use strict";

modulum('InputPictureWidgetComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * Input Picture Widget Component
     * Manage the input picture (mask)
     * @class InputPictureWidgetComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.InputPictureWidgetComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {

      return /** @lends classes.InputPictureWidgetComponent.prototype */ {
        __name: "InputPictureWidgetComponent",

        /** @type {?string} */
        _picture: null,

        /** @type Object */
        _groups: null,

        /**
         * Manage input
         * @param {String} [dataString] - string with the inserted characters
         * @param {*} [event] - input event from DOM
         */
        manageInput: function(dataString = "", event = null) {
          // Picture mask don't apply in Construct
          if (this.getWidget().getDialogType() === "Construct") {
            return;
          }
          if (dataString === "") {
            return;
          }

          const widget = /** @type {classes.FieldWidgetBase} */ this.getWidget();
          const inputElement = widget.getInputElement();
          const inputTextState = widget.getInputTextState();

          // restore value before input
          inputElement.value = inputTextState.getBackupText();
          inputTextState.setRestored(true);

          // Specific code for composition event (Android hack)
          if (event?.inputType === "insertCompositionText") {
            // restore cursors (select only last char)
            inputTextState.restoreFromEndCursors(1);
            // try to only the last char of composition
            this._onPictureStringInput(dataString.slice(-1));
            return;
          }

          // Specific code for backspace
          if (event?.inputType === "deleteContentBackward") {
            // restore cursors
            inputTextState.restoreCursors();
            const processed = this.manageKeyDown("backspace", null, false);
            inputTextState.setRestored(!processed);
            return;
          }

          // restore cursors
          inputTextState.restoreCursors();

          // try to add new data string
          this._onPictureStringInput(dataString);
        },

        /**
         * manageKeyDown method.
         * @param {string} keyString - key combination
         * @param {object} domKeyEvent
         * @param {boolean} repeat
         * @returns {boolean} true if key has been processed
         * @private
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          const widget = /** @type {classes.FieldWidgetBase} */ this.getWidget();

          // Picture mask don't apply in Construct
          if (this.getWidget().getDialogType() === "Construct") {
            return false;
          }

          if (widget.isEnabled() && !widget.isReadOnly()) {

            const input = /** @type {HTMLInputElement} */ widget.getInputElement();
            const start = input.selectionStart;
            const value = input.value;
            let cursor = this._getNextCursor(start, value.length);

            // Manage picture specific special keys (left, right, backspace, del), then execute widget manageKeyDown rules.
            switch (keyString) {
              case widget.getStart():
                cursor = this._getPreviousCursor(start);
                if (cursor) {
                  input.setCursorPosition(cursor.start, cursor.start + 1);
                  keyProcessed = true;
                }
                break;
              case widget.getEnd():
                cursor = this._getNextCursor(start, value.length);
                if (cursor) {
                  input.setCursorPosition(cursor.start, cursor.start + 1);
                  keyProcessed = true;
                }
                break;
              case "backspace":
                keyProcessed = this._onPictureBackspaceKey();
                break;
              case "del":
              case "delete":
                keyProcessed = this._onPictureDeleteKey();
                break;
            }
          }

          if (keyProcessed) {
            return true;
          } else if (cls.KeyboardHelper.isSpecialCommand(keyString)) { // let browser manages native combination
            return false;
          }
        },

        /**
         * @returns {?string} The picture string
         */
        getPicture: function() {
          return this._picture;
        },

        /**
         * @param {string} picture - set the picture string
         */
        setPicture: function(picture) {
          this._picture = picture;

          this._groups = [];

          for (const element of this._picture) {
            this._groups.push(this._createGroup(element));
          }
        },

        /**
         * Parse the PICTURE letter and get a corresponding group rule
         * @param type
         * @returns {Object}
         * @private
         */
        _createGroup: function(type) {
          const group = {};
          switch (type) {
            case 'A': // Alpha numeric
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isLetter;
              break;
            case '#': // Numeric only
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isNumeric;
              break;
            case 'X': // All
              group.isEditable = true;
              group.isValid = cls.KeyboardHelper.isChar;
              break;
            default: // Mask separator
              group.isEditable = false;
              group.isValid = null;
              group.separator = type;
          }
          return group;
        },

        /**
         * Insert string at correct position if allowed by PICTURE mask. Otherwise, do nothing
         * @param {string} str
         * @private
         */
        _onPictureStringInput: function(str) { // paste

          const widget = /** @type {classes.FieldWidgetBase} */ this.getWidget();
          const input = /** @type {HTMLInputElement} */ widget.getInputElement();

          // Build new value till no conflict is met. when one conflict is met, take mask value for all remaining length.
          let newValue = "";
          let j = 0;

          const mask = this._picture;
          const pastedTextLength = str?.length || 0;

          let start = input.selectionStart;
          if (start === null) {
            return;
          }

          let value = input.value;
          let cursor = this._getNextCursor(start, value.length);

          // start at first editable position from cursor position (editable group)
          while (this._groups[start] && !this._groups[start].isEditable) {
            const separator = this._groups[start].separator;
            if (value[start] !== separator) {
              input.value = value = (value.substring(0, start) + separator + value.substring(start + 1));
              cursor = this._getNextCursor(start + 1, value.length);
            }
            start++;
          }

          // loop length will depend on parsedText length. If parsedText length is higher than mask (data.groups), we take mask length
          const length = pastedTextLength;
          let i = start;
          while (j < length) { // loop on each pastedText char from starting cursor position
            if (i >= this._groups.length) { // end of editable zone
              break;
            }
            const group = this._groups[i];
            if (!group.isEditable) { // separator are kept intact --> copy them into new value
              const separator = mask[i];
              newValue += separator;
              if (separator === str[j]) { // if current pasted char == current group seperator, we will not analyse it afterward
                j++;
              }
            } else { // current group is editable, check if current pasted char is valid
              let char = str[j];
              if (group.isValid && group.isValid(char)) {
                // if previously no conflict met and current char is valid, we add it to new value
                newValue += char;
                j++;
              } else { // char is not valid, take mask value (whitespace since it's not a separator)
                break;
              }
            }
            i++;
          }

          if (newValue !== "") {
            const existingValue = input.value;
            // Set input new value
            input.value = existingValue.substring(0, start) + newValue + existingValue.substring(start + newValue.length);
            const cursors = this._getNextCursor(i - 1, input.value.length);
            input.setCursorPosition(cursors.start, cursors.end);
            widget._editingTime = Date.now();
            widget.setEditing(widget.isEditing() || widget.getValue() !== widget._oldValue);

            // Picture has changed the widget value so set restored to false
            widget.getInputTextState().setRestored(false);
          }
        },

        /**
         * Manage backspace key. Erase previous key if allowed to.
         * @returns {boolean}
         * @private
         */
        _onPictureBackspaceKey: function() {
          const widget = /** @type {classes.FieldWidgetBase} */ this.getWidget();
          const input = widget.getInputElement();
          const start = input.selectionStart;
          const end = input.selectionEnd;

          const manySelected = end - start > 1;

          const cursor = this._getPreviousCursor(start);
          if (cursor || manySelected) {
            const value = input.value;

            // Correctly remove many char at the same time
            if (manySelected) {
              this._removeManyChars(input);
            } else {
              input.value = (value.substring(0, cursor.start) + ' ' + value.substring(cursor.start + 1));
              input.setCursorPosition(cursor.start, cursor.start + 1);
            }
            widget._editingTime = Date.now();
            widget.setEditing(widget.isEditing() || widget.getValue() !== widget._oldValue);
          }
          return true;
        },

        /**
         * Manage delete key.
         * @returns {boolean}
         * @private
         */
        _onPictureDeleteKey: function() {
          const widget = /** @type {classes.FieldWidgetBase} */ this.getWidget();
          const input = widget.getInputElement();
          const start = input.selectionStart;
          const end = input.selectionEnd;

          const value = input.value;
          let cursor = {
            start: start,
            end: start + 1
          };
          const manySelected = end - start > 1;
          if (manySelected) {
            this._removeManyChars(input);
          } else {
            if (start < value.length) {
              if (this._groups[start].isEditable) {
                input.value = (value.substring(0, start) + ' ' + value.substring(start + 1));
              }
              if (!this._groups[start].isEditable) {
                cursor = this._getNextCursor(start, value.length);
              }
              input.setCursorPosition(cursor.start, cursor.end);
            }
          }
          widget._editingTime = Date.now();
          widget.setEditing(widget.isEditing() || widget.getValue() !== widget._oldValue);
          return true;
        },

        /**
         * Remove all selected chars from PICTURE mask
         * @param input
         * @private
         */
        _removeManyChars: function(input) {
          const value = input.value;
          const start = input.selectionStart;
          const end = input.selectionEnd;

          const resultArray = value.split("");
          let tmpStart = start;

          while (this._groups.length > tmpStart && tmpStart !== end) {
            if (this._groups[tmpStart].isEditable) {
              resultArray[tmpStart] = " ";
            }
            tmpStart++;
          }
          let jumpStart = 0;
          let jumpStop = 0;

          // Set the cursor correctly
          while (this._groups[start + jumpStart] && !this._groups[start + jumpStart].isEditable) {
            jumpStart++;
          }
          while (this._groups[end + jumpStop - 1] && !this._groups[end + jumpStop - 1].isEditable) {
            jumpStop++;
          }
          input.value = resultArray.join("");
          input.setCursorPosition(start + jumpStart, end - jumpStop);
        },

        /**
         * Get previous editing position
         * @param ind
         * @returns {*}
         * @private
         */
        _getPreviousCursor: function(ind) {
          if (ind === 0) {
            return null;
          }
          let start = ind;
          let jump = false;
          while (start > 0 && this._groups[start - 1] && !this._groups[start - 1].isEditable) {
            jump = true;
            start--;
          }
          if (start === 0) {
            return null;
          } else {
            return {
              start: start - 1,
              jump: jump
            };
          }
        },

        /**
         * Get next editing position
         * @param ind
         * @param length
         * @returns {{start: *, end: *, jump: boolean}}
         * @private
         */
        _getNextCursor: function(ind, length) {
          let start = ind + 1;
          let jump = false;
          while (this._groups.length > start && !this._groups[start].isEditable) {
            jump = true;
            start++;
          }
          let end = start;
          if (start < length) {
            end = start + 1;
          }
          return {
            start: start,
            end: end,
            jump: jump
          };
        },

      }; // End return
    }); // End Class
  } // JS Face Function
); // End Modulum
;

"use strict";

modulum('InputTextStateComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * Text state of input element
     * @class InputTextStateComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.InputTextStateComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {
      return /** @lends classes.InputTextStateComponent.prototype */ {
        __name: "InputTextStateComponent",

        /**
         * text selection start
         * @type {number}
         */
        _selectionStart: 0,
        /**
         * text selection end
         * @type {number}
         */
        _selectionEnd: 0,
        /**
         * true if the value was restored
         * @type {boolean}
         */
        _isRestored: false,
        /**
         * widget value
         * @type {string}
         */
        _text: '',
        /**
         * Input element
         * @type {HTMLInputElement}
         */
        _inputElement: null,

        /**
         * @inheritDoc
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);

          // the widget must be a field widget base
          this._inputElement = ( /** @type {classes.FieldWidgetBase} */ widget).getInputElement();
        },

        /**
         * @inheritdoc
         */
        destroy: function() {
          this._inputElement = null;

          $super.destroy.call(this);
        },

        /**
         * Backup current input element state (Text + cursors)
         */
        backup: function() {
          try {
            this._selectionStart = this._inputElement.selectionStart;
            this._selectionEnd = this._inputElement.selectionEnd;
          } catch (e) {}
          this._text = this._inputElement.value;
          this._isRestored = false;
        },

        /**
         * Restore from last backup only input element cursors
         */
        restoreCursors: function() {
          try {
            this._inputElement.selectionStart = this._selectionStart;
            this._inputElement.selectionEnd = this._selectionEnd;
          } catch (e) {}
        },

        /**
         * Restore end cursor from backup and start cursor from backup end - length
         * @param {number} length
         */
        restoreFromEndCursors: function(length) {
          try {
            this._inputElement.selectionStart = this._selectionEnd - length;
            this._inputElement.selectionEnd = this._selectionEnd;
          } catch (e) {}
        },

        /**
         * Restore from last backup input element state (Text + cursors)
         * @param {string} partToAdd - Text to add
         */
        restore: function(partToAdd) {
          const partToAddLength = partToAdd.length;
          try {
            this._inputElement.value = this._text.substring(0, this._selectionStart) + partToAdd +
              this._text.substring(this._selectionEnd);
            this._inputElement.selectionStart = this._selectionStart + partToAddLength;
            this._inputElement.selectionEnd = this._selectionStart + partToAddLength;
          } catch (e) {}
          this._isRestored = true;
        },

        /**
         * True if the value was restored
         * @return {boolean}
         */
        isRestored: function() {
          return this._isRestored;
        },

        /**
         * Set the restored value
         * @param {boolean} restored - true if the value is restored
         */
        setRestored: function(restored) {
          this._isRestored = restored;
        },

        /**
         * Get the new text part since the last backup
         * @param {string} text new value
         * @return {string} new text part
         */
        newPart: function(text) {
          const diff = text.length - this._text.length;

          if (diff > 0 || this._selectionStart !== this._selectionEnd) {
            return text.substring(this._selectionStart, this._selectionEnd + diff);
          }

          return '';
        },

        /**
         * Get the backup text without the selected part
         * @return {string}
         */
        getBackupTextWithoutSelected: function() {
          return this._text === null ? null : this._text.substring(0, this._selectionStart) + this._text.substring(this._selectionEnd);
        },

        /**
         * Get the backup text.
         * @return {string}
         */
        getBackupText: function() {
          return this._text;
        },

        /**
         * Get the selected part of saved text
         * @returns {string}
         */
        getSelectedText: function() {
          return this._text.substring(this._selectionStart, this._selectionEnd);
        },

        /**
         * True if we have a selected part
         * @returns {boolean}
         */
        hasSelectedText: function() {
          return this._selectionStart !== this._selectionEnd;
        }
      };
    });
  });
;

"use strict";

modulum('RowAspectWidgetComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * Row Aspect Widget Component
     * Manage the CSS variables and classes
     * @class RowAspectWidgetComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.RowAspectWidgetComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {

      return /** @lends classes.RowAspectWidgetComponent.prototype */ {
        __name: "RowAspectWidgetComponent",

        $static: /** @lends classes.RowAspectWidgetComponent */ {

          /**
           * @static
           * @param {string} value the rowAspect value
           * @returns The Css Class name
           */
          _getRowAspectClass: function(value) {
            return `gbc_rowAspect_${value.toLowerCase()}`;
          },

          /**
           * @static
           */
          rowAspectWasSetEventType: "rowAspectWasSet"
        },

        /** @type {?string} */
        _rowAspect: null,

        /**
         * @returns {string} The row aspec of the scroll grid
         */
        getRowAspect: function() {
          return this._rowAspect;
        },

        /**
         * @param {string} rowAspect Set the row aspect of the widget
         */
        setRowAspect: function(rowAspect) {
          if (rowAspect === null) {
            rowAspect = "default";
          }
          if (this._rowAspect !== rowAspect) {
            if (this.getRowAspect() !== null) {
              this.getWidget().removeClass(cls.RowAspectWidgetComponent._getRowAspectClass(this.getRowAspect()));
            }
            this._rowAspect = rowAspect;
            this.getWidget().addClass(cls.RowAspectWidgetComponent._getRowAspectClass(this.getRowAspect()));
          }
        },
      }; // End return
    }); // End Class
  } // JS Face Function
); // End Modulum
;

"use strict";

modulum('TableMenuButtonWidgetComponent', ['WidgetComponentBase'],
  function(context, cls) {

    /**
     * Highlight Widget Component.
     * Manage the highlight css classes and variables
     * @class TableMenuButtonWidgetComponent
     * @memberOf classes
     * @extends classes.WidgetComponentBase
     * @publicdoc
     */
    cls.TableMenuButtonWidgetComponent = context.oo.Class(cls.WidgetComponentBase, function($super) {

      return /** @lends classes.TableMenuButtonWidgetComponent.prototype */ {
        __name: "TableMenuButtonWidgetComponent",

        $static: /** @lends classes.TableMenuButtonWidgetComponent */ {
          /** @static */
          _elementCssClass: 'gbc_TableMenuButton',

          /** @static */
          _inViewCssClass: 'visible',

          /**
           * in milliseconds
           * @static
           * @type {number}
           */
          _defaultDelay: 2500,

          /**
           * in milliseconds
           * @static
           * @type {number}
           */
          _postHoverDelay: 650,
        },

        /**
         * The DOM element to show/hide
         * @type {HTMLElement}
         */
        _element: null,

        /**
         * The timer id, to handle the timer destruction
         * @type {number}
         */
        _timerId: -1,

        /**
         * Used to know if the button should be frozen in place
         * For exemple when the menu is open
         * @type {boolean}
         */
        _isFrozen: false,

        /**
         * @inheritdoc
         * @param {boolean} visibleAtStartup Should the button visible at startup (for a delay of default * 2)
         */
        constructor: function(widget, visibleAtStartup = false) {
          $super.constructor.call(this, widget);

          this._isFrozen = false;

          this.getElement().on("transitionend.TableMenuButtonWidgetComponent", this.hide.bind(this, cls.TableMenuButtonWidgetComponent
            ._defaultDelay));
          this.getElement().on("mouseover.TableMenuButtonWidgetComponent", this._clearTimeout.bind(this));
          this.getElement().on("mouseout.TableMenuButtonWidgetComponent", this.hide.bind(this, cls.TableMenuButtonWidgetComponent
            ._postHoverDelay));

          if (visibleAtStartup) {
            /* Make the button visible at start. As the transitionend event might not be triggered by the CSS/JS engine,
             * the hide timer will be forced to initialize
             */
            this.show(cls.TableMenuButtonWidgetComponent._defaultDelay * 2);
            this.hide(cls.TableMenuButtonWidgetComponent._defaultDelay * 2);
          }
        },

        /**
         * @inheritdoc
         */
        destroy: function() {
          this._clearTimeout();

          if (this._element) {
            this._element.off("transitionend.TableMenuButtonWidgetComponent");
            this._element.off("mouseover.TableMenuButtonWidgetComponent");
            this._element.off("mouseout.TableMenuButtonWidgetComponent");
            this._element = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Returns the Table Menu Icon DOM Element
         * @returns {HTMLElement} header group DOM Element
         */
        getElement: function() {
          if (!this._element) {
            this._element = this.getWidget().getElement().getElementsByClassName(cls.TableMenuButtonWidgetComponent._elementCssClass)[0];
          }
          return this._element;
        },

        /**
         * @returns {boolean} True if the menu icon is in the view 
         */
        isVisible: function() {
          return this.getElement().hasClass(cls.TableMenuButtonWidgetComponent._inViewCssClass);
        },

        /**
         * Show the menu button if not in view,
         * else restart the timer
         */
        show: function(delay, evt) {
          if (this._isFrozen) {
            return;
          }

          if (this.isVisible()) {
            this.hide(delay);
          } else {
            this.getElement().addClass(cls.TableMenuButtonWidgetComponent._inViewCssClass);
          }
        },

        /**
         * Trigger a timer to hide the menu after a dedicated time
         * if the button is not frozen
         * @param {number} delay Time to wait before hiding the menu
         * @param {TransitionEvent|null} [evt] The transition end event
         */
        hide: function(delay, evt = null) {
          if (this._isFrozen || !this.isVisible()) {
            return;
          }

          // Clear the previous timeout before making a new one
          this._clearTimeout();
          this._timerId = setTimeout(function(thisArg) {
            thisArg.getElement().removeClass(cls.TableMenuButtonWidgetComponent._inViewCssClass);
            thisArg._timerId = -1;
          }, delay, this);
        },

        /**
         * Freeze the button in place if it's visible 
         */
        freeze: function() {
          if (this.isVisible()) {
            this._isFrozen = true;
            this._clearTimeout();
          }
        },

        /**
         * Unfreeze and hide the menu button even if it was frozen.
         * @param {number} delay in milliseconds
         */
        unfreezeAndHide: function(delay) {
          this._isFrozen = false;
          this.hide(delay);
        },

        /**
         * Clear the current timeout if any
         * and reset the timer id
         * @private
         */
        _clearTimeout() {
          if (this._timerId !== -1) {
            clearTimeout(this._timerId);
          }
          this._timerId = -1;
        }
      };
    });
  }
);
;

"use strict";

modulum('WidgetComponentBase',
  function(context, cls) {

    /**
     * Widget Component
     * @class WidgetComponentBase
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc
     */
    cls.WidgetComponentBase = context.oo.Class(function() {

      return /** @lends classes.WidgetComponentBase.prototype */ {
        __name: "WidgetComponentBase",

        /**
         * The parent widget
         * @private
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * Build the component and init the default values;
         * @constructs
         * @param {classes.WidgetBase} widget The parent widget
         */
        constructor: function(widget) {
          this._widget = widget;
        },

        /**
         * Destroy properly the component
         */
        destroy: function() {
          this._widget = null;
        },

        /**
         * @returns {classes.WidgetBase} The parent widget
         */
        getWidget: function() {
          return this._widget;
        }
      };
    });
  }
);
;

"use strict";

modulum('TextWidgetBase', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for all widgets handling text attributes
     * @class TextWidgetBase
     * @memberOf classes
     * @publicdoc Widgets
     * @extends classes.ColoredWidgetBase
     */
    cls.TextWidgetBase = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.TextWidgetBase.prototype */ {
        __name: "TextWidgetBase",
        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,
        /**
         * Current font family used
         * @type {string}
         */
        _fontFamily: "",
        /**
         * Current font weight used
         * @type {string}
         */
        _fontWeight: "",
        /**
         * Current font style used
         * @type {string}
         */
        _fontStyle: "",
        /**
         * Current font size used
         * @type {string}
         */
        _fontSize: "",
        /**
         * Current text aligned used
         * @type {string}
         */
        _textAlign: "",
        /**
         * Current text transform used
         * @type {string}
         */
        _textTransform: "none",
        /**
         * Current text decoration used
         * @type {string}
         */
        _textDecoration: "",

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Set the font-family used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/font-family}
         * @param {string} fontFamily the font family to use. null restores the default value.
         * @publicdoc
         */
        setFontFamily: function(fontFamily) {
          if (this._fontFamily !== fontFamily) {
            this._fontFamily = fontFamily === null || fontFamily === undefined ? fontFamily : fontFamily.escapeFontFamily();
            this.setStyle({
              "font-family": fontFamily
            });
          }
        },

        /**
         * Get the font-family used by this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/font-family}
         * @returns {string} the used font family
         * @publicdoc
         */
        getFontFamily: function() {
          return this.getStyle("font-family"); // TODO must return this._fontFamily
        },

        /**
         * Set the font weight used for this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-weight}
         * @param weight {string} a CSS font weight value. null restores the default value.
         * @publicdoc
         */
        setFontWeight: function(weight) {
          if (this._fontWeight !== weight) {
            this._fontWeight = weight;
            this.setStyle({
              "font-weight": weight
            });
          }
        },

        /**
         * Get the font-family used by this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-weight}
         * @returns {string} a CSS font weight value
         * @publicdoc
         */
        getFontWeight: function() {
          return this._fontWeight;
        },

        /**
         * Set the font-style used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/font-style}
         * @example setFontStyle("italic")
         * @param style {string} a CSS font style value. null restores the default value.
         * @publicdoc
         */
        setFontStyle: function(style) {
          if (this._fontStyle !== style) {
            this._fontStyle = style;
            this.setStyle({
              "font-style": style
            });
          }
        },

        /**
         * Get the font-style used by this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-style}
         * @returns {string} a CSS font style value
         * @publicdoc
         */
        getFontStyle: function() {
          return this._fontStyle;
        },

        /**
         * Set the font-size used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/font-size}
         * @param size {string} a CSS font size value. null restores the default value.
         * @example setFontSize("12px")
         * @publicdoc
         */
        setFontSize: function(size) {
          if (this._fontSize !== size) {
            this._fontSize = size;
            this.setStyle({
              "font-size": size
            });
          }
        },

        /**
         * Set the font color used by this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-size}
         * @returns {string} a CSS font color value
         * @publicdoc
         */
        setFontColor: function(color) {
          if (this._color !== color) {
            this._color = color;
            this.setStyle({
              "color": color
            });
          }
        },

        /**
         * Get the font color used by this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-size}
         * @returns {string} a CSS font color value
         * @publicdoc
         */
        getFontColor: function(color) {
          return this._color;
        },

        /**
         * Get the font-size used by this widget
         * see {@link http://www.w3org/wiki/CSS/Properties/font-size}
         * @returns {string} a CSS font size value
         * @publicdoc
         */
        getFontSize: function() {
          return this.getStyle("font-size"); // TODO must return this._fontSize
        },

        /**
         * Set the text-align used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-align}
         * @param align {string} a CSS text alignment. null restores the default value.
         * @example setTextAlign("right")
         * @publicdoc
         */
        setTextAlign: function(align) {
          if (this._textAlign !== align) {
            this._textAlign = align;
            this.setStyle({
              "text-align": align
            });
          }
        },

        /**
         * Get the text-align used by this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-align}
         * @returns {string} a text alignment
         * @publicdoc
         */
        getTextAlign: function() {
          return this._textAlign;
        },

        /**
         * Set the text-transform used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-transform}
         * @param transform {string} a CSS text transform. null restores the default value.
         * @example setTextTransform("upper")
         * @publicdoc
         */
        setTextTransform: function(transform) {
          if (this._textTransform !== transform) {
            this._textTransform = transform;
            this.addClass(transform + "shift");
          }
        },

        /**
         * Remove both class which cause text-transform
         * @publicdoc
         */
        removeTextTransform: function() {
          this.removeClass("upshift");
          this.removeClass("downshift");
          this._textTransform = "none";
        },

        /**
         * Get the text-transform used by this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-transform}
         * @returns {string} a CSS text transform
         * @publicdoc
         */
        getTextTransform: function() {
          return this._textTransform;
        },

        /**
         * Get the text-decoration used by this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-decoration}
         * @return {string} a CSS text decoration
         * @publicdoc
         */
        getTextDecoration: function() {
          return this._textDecoration;
        },

        /**
         * Set the text-decoration used for this widget
         * see {@link http://www.w3.org/wiki/CSS/Properties/text-decoration}
         * @publicdoc
         */
        setTextDecoration: function(decoration) {
          if (this._textDecoration !== decoration) {
            this._textDecoration = decoration;
            this.setStyle({
              "text-decoration": decoration
            });
          }
        },

      };
    });
  });
;

"use strict";

modulum('WidgetBase', ['EventListener'],
  function(context, cls) {
    const SPACES_RE = /\s+/;

    /**
     * Base class for widgets.
     * @class WidgetBase
     * @memberOf classes
     * @tutorial widgets
     * @extends classes.EventListener
     * @publicdoc Widgets
     */
    cls.WidgetBase = context.oo.Class({
      base: cls.EventListener
    }, function($super) {

      const __charMeasurer = document.createElement('char-measurer');
      __charMeasurer.className = "g_layout_charMeasurer";
      const __charMeasurer1 = document.createElement('char-measurer-item');
      __charMeasurer1.className = "g_layout_charMeasurer1";
      __charMeasurer1.textContent = "MMMMMMMMMM\nM\nM\nM\nM\nM\nM\nM\nM\nM";
      const __charMeasurer2 = document.createElement('char-measurer-item');
      __charMeasurer2.className = "g_layout_charMeasurer2";
      __charMeasurer2.textContent = "0000000000";
      __charMeasurer.appendChild(__charMeasurer1);
      __charMeasurer.appendChild(__charMeasurer2);
      __charMeasurer.setAttribute("aria-hidden", "true");

      return /** @lends classes.WidgetBase.prototype */ {
        $static: /** @lends classes.WidgetBase */ {
          /** Generic click events handler */
          // TODO is it still necessary to have these methods static ?
          /** Generic focus events handler */
          _onFocus: function(event) {
            this.emit(context.constants.widgetEvents.focus, event);
          },
          /**
           * Need to listen mouseup event on body to be able to focus an input field if selection ends outside the field.
           * If selection ends inside the field, click event will be raised
           * @protected
           */
          _onSelect: function() {
            document.body.on('mouseup.DetectTextSelection', function(event) {
              document.body.off('mouseup.DetectTextSelection');
              this._element.off('mouseleave.DetectTextSelection');
            }.bind(this));
            this._element.on('mouseleave.DetectTextSelection', function(event) {
              document.body.off('mouseup.DetectTextSelection');
              this._element.off('mouseleave.DetectTextSelection');
              if (event.buttons === 1) { // only if button is pressed when mouse leave
                this._onRequestFocus(event); // request focus
              }
            }.bind(this));
          },
          selfDataContent: {}
        },
        __name: "WidgetBase",
        __templateName: null,
        __charMeasurer: null,
        __dataContentPlaceholderSelector: null,
        /**
         * Current widget's unique ID (GBC system wide)
         * @type {?string}
         */
        _uuid: null,

        /**
         * Incremental ID for widgets that are linked to the AUI, 0 otherwise
         * @type {number}
         */
        _nUuid: 0,

        /**
         * Widget root class name (based on widget's unique ID)
         * @type {?string}
         */
        _rootClassName: null,
        _auiTag: null,
        _auiName: null,
        /**
         * the dom element
         * @type {HTMLElement}
         * @protected
         */
        _element: null,
        /**
         * the parent widget
         * @type {classes.WidgetGroupBase}
         * @protected
         */
        _parentWidget: null,
        /**
         * Current instance stylesheet
         * @type {Object}
         */
        _stylesheet: null,
        /**
         * stylesheet context ('global', 'window')
         * @type {string}
         */
        _stylingContext: "global",
        /**
         * the layout engine
         * @type {classes.LayoutEngineBase}
         * @protected
         */
        _layoutEngine: null,
        /**
         * the layout information
         * @type {classes.LayoutInformation}
         * @protected
         */
        _layoutInformation: null,
        /**
         * the user interface widget
         * @type {classes.UserInterfaceWidget}
         * @protected
         */
        _uiWidget: null,
        /**
         * Application widget
         * @type {classes.ApplicationWidget}
         * @protected
         */
        _appWidget: null,
        _appHash: null,
        _windowWidget: null,
        _formWidget: null,
        _tableWidgetBase: null,
        _scrollGridWidget: null,
        _stretchableScrollGridWidgetBase: null,

        _i18NList: null,
        _i18nTranslateListener: null,

        /**
         * Dialog type of the widget (Input, Input Array, Display, Display Array, Construct)
         * @type {?string}
         * @protected
         */
        _dialogType: false,
        _enabled: true,
        _noBorder: false,
        _hidden: false,
        _focusable: false,

        _startKey: null,
        _endKey: null,

        _inMatrix: false,
        _inTable: false,
        _inScrollGrid: false,
        _inFirstTableRow: false,
        _inToolBar: false,
        _ignoreLayout: false,

        // arabic mode
        _isReversed: false,

        /**
         * @type {?string}
         */
        _rawStyles: null,

        /**
         * @type {Array<string>}
         */
        _applicationStyles: null,

        /**
         * An interruptible widget is active when the VM is processing
         * @type {boolean}
         */
        _interruptable: false,
        _hasWebcomp: false,

        /**
         * The real AUI widget
         * @type {classes.WidgetBase}
         */
        _realWidget: null,

        /**
         * True if the widget accept events when inside an inactive windows
         * @type {boolean}
         */
        _acceptEventWhenWindowInactive: null,

        /**
         * All the applied behaviors;
         * @type {Set}
         */
        _applyedBehaviors: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {Object} opts instantiation options
         * @param {number} opts.appHash internal app hash
         * @param {classes.ApplicationWidget} opts.appWidget early ApplicationWidget link
         * @param {number} opts.auiTag internal aui tag id
         * @param {boolean} opts.inTable internal is in table
         * @param {boolean} opts.inMatrix internal is in matrix
         * @param {boolean} opts.inFirstTableRow internal
         * @param {boolean} opts.inScrollGrid internal is in a scroll grid
         * @param {boolean} opts.inToolBar internal is in a toolbar
         * @param {boolean} opts.ignoreLayout ignore layout char measurer
         */
        constructor: function(opts) {
          opts = opts || {};
          this._realWidget = opts.realWidget;
          this._appHash = opts.appHash;
          this._appWidget = opts.appWidget;
          this._auiTag = opts.auiTag;
          this._inTable = opts.inTable === true;
          this._inFirstTableRow = opts.inFirstTableRow === true;
          this._inMatrix = opts.inMatrix === true;
          this._inScrollGrid = opts.inScrollGrid === true;
          this._inToolBar = opts.inToolBar === true;
          this._ignoreLayout = this._inTable && !this._inFirstTableRow || opts.ignoreLayout;

          this._applyedBehaviors = new Set();
          this._uuid = context.InitService.uniqueIdAsString();
          this._nUuid = this._auiTag ? context.InitService.uniqueId() : 0;
          this._acceptEventWhenWindowInactive = false;
          $super.constructor.call(this, opts);
          this._rootClassName = "w_" + this._uuid;
          this._initElement();
          this._afterInitElement();
          this._initLayout();
          this._initTranslation();
          if (this._auiTag) {
            this._element.addClass("aui__" + this._auiTag);
            this._element.setAttribute("data-aui-id", this._auiTag);
          }
          context.WidgetService._emit(context.constants.widgetEvents.created, this);
          context.WidgetService.registerWidget(this);
        },

        /**
         * get the real AUI Widget
         * @return {classes.WidgetBase}
         */
        getAUIWidget: function() {
          return this._realWidget;
        },

        /**
         * Define the widget layout on traditional mode
         * @param {!number} letterSpacing - letter spacing in pixel
         * @param {!number} fieldHeight - field height in pixel
         * @param {!number} heightPadding - height padding between 2 lines
         */
        traditionalDisplay: function(letterSpacing, fieldHeight, heightPadding) {
          const layoutInfo = this.getLayoutInformation();

          if (layoutInfo) {
            const left = layoutInfo.getGridX();
            const top = (layoutInfo.getGridY()) * (fieldHeight + 2 * heightPadding) + heightPadding;
            const width = layoutInfo.getGridWidth();
            const height = layoutInfo.getGridHeight() * fieldHeight;

            layoutInfo.getHostElement().toggleClass(layoutInfo.className, true);
            const style = this._element.parentElement.style;
            style.left = 'calc(' + left + 'ch + ' + left + ' * ' + letterSpacing + ')';
            style.top = top + 'px';
            style.width = 'calc(' + width + 'ch + ' + width + ' * ' + letterSpacing + ')';
            style.height = height + 'px';
          }
        },

        /**
         * Returns build parameters
         * @returns {{appHash: (null|*), auiTag: (null|*), inTable: (boolean|*), inFirstTableRow: (boolean|*), inMatrix: (boolean|*), inScrollGrid: *, ignoreLayout: (boolean|*)}} build parameters
         * @publicdoc
         */
        getBuildParameters: function() {
          return {
            realWidget: this._realWidget,
            appHash: this._appHash,
            appWidget: this._appWidget,
            auiTag: this._auiTag,
            inTable: this._inTable,
            inFirstTableRow: this._inFirstTableRow,
            inMatrix: this._inMatrix,
            inScrollGrid: this._inScrollGrid,
            inToolBar: this._inToolBar,
            ignoreLayout: this._ignoreLayout
          };
        },

        /**
         * Destroy style sheet related to widget
         * @private
         */
        _destroyStyle: function() {
          context.styler.removeStyleSheet(this.getUniqueIdentifier());
          if (this._stylingContext === "window") {
            const win = this.getWindowWidget();
            const sheetId = win && win.getUniqueIdentifier() || this._appHash || "_";
            context.styler.appendStyleSheet({}, this.getRootClassName(), true, sheetId);
          } else {
            context.styler.appendStyleSheet({}, this.getRootClassName(), true, this._appHash || "_");
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyStyle();

          if (this._i18nTranslateChangeListener) {
            this._i18nTranslateChangeListener();
            this._i18nTranslateChangeListener = null;
          }
          this.emit(context.constants.widgetEvents.destroyed, this);
          context.WidgetService._emit(context.constants.widgetEvents.destroyed, this);
          if (this._layoutEngine) {
            this._layoutEngine.destroy();
            this._layoutEngine = null;
          }
          if (this._parentWidget && this._parentWidget.removeChildWidget) {
            this._parentWidget.removeChildWidget(this);
          }
          if (this._layoutInformation) {
            this._layoutInformation.destroy();
            this._layoutInformation = null;
          }
          document.body.off('mouseup.DetectTextSelection');
          if (this._element) {
            this._element.remove();
          }

          this._applyedBehaviors.clear();
          this._applyedBehaviors = null;

          this.__charMeasurer1 = null;
          this.__charMeasurer2 = null;
          this.__charMeasurer = null;
          this._stylesheet = null;

          this._uiWidget = null;
          this._appWidget = null;
          this._windowWidget = null;
          this._formWidget = null;
          this._tableWidgetBase = null;
          this._scrollGridWidget = null;
          this._stretchableScrollGridWidgetBase = null;
          this._element = null;

          if (this._i18nTranslateListener) {
            this._i18nTranslateListener();
            this._i18nTranslateListener = null;
          }
          this._i18NList = null;

          $super.destroy.call(this);

          context.WidgetService.unregisterWidget(this);
        },

        /**
         * Method called after the element is initialized
         * Override in inherited widgets if necessary
         * @private
         */
        _afterInitElement: function() {
          this.getElement().toggleClass("gbc_WidgetBase_standalone", !(this._inTable || this._inScrollGrid));
          this.getElement().toggleClass("gbc_WidgetBase_in_array", this._inTable || this._inScrollGrid);
          // For GBC-4255 :  this line can be removed once the highlight system is fixed.
          // PLEASE DO NOT USE THIS CSS Class for anything else
          // Don't add Technical Debt
          this.getElement().toggleClass("gbc_WidgetBase_in_grid_matrix", this._inMatrix && !this._inScrollGrid);
        },

        /**
         * Create all instances for layout management
         * @protected
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.NoLayoutEngine(this);
        },

        /**
         * function to be called by widget's layout engine when resetting the layout if needed
         */
        resetLayout: function() {},

        /**
         * Get the widget's layout information
         * @returns {classes.LayoutInformation} the widget's layout information
         * @publicdoc
         */
        getLayoutInformation: function() {
          return this._layoutInformation;
        },

        /**
         * Get the widget's layout engine
         * @returns {classes.LayoutEngineBase} the widget's layout engine
         * @publicdoc
         */
        getLayoutEngine: function() {
          return this._layoutEngine;
        },

        /**
         * Get the styling context of widget style sheet (global, window or widget);
         * @returns {string} widget styling context used in its style sheet
         */
        getStylingContext: function() {
          return this._stylingContext;
        },

        /**
         * Setups the DOM element
         * @protected
         */
        _initElement: function() {
          this._element = context.TemplateService.renderDOM(this.__templateName || this.__name, this.__ascendance);
          const id = this.getRootClassName();
          this._element.id = id;

          this._element.className += ["", this.__ascendanceClasses, id, "g_measureable"].join(" ");
          // TODO we add class g_measureable in all cases, we should probably just add this class if ignoreLayout=false
          if (!this._ignoreLayout) {
            this._initCharMeasurer();
          }
        },

        /**
         * Init the char Measurer for proper layout management
         * @private
         */
        _initCharMeasurer: function() {
          this.__charMeasurer = __charMeasurer.cloneNode(true);
          this.__charMeasurer1 = this.__charMeasurer.children[0];
          this.__charMeasurer2 = this.__charMeasurer.children[1];
          this._element.appendChild(this.__charMeasurer);
        },

        /**
         * Handle request Focus
         * @param {UIEvent} event - dom event
         */
        _onRequestFocus: function(event) {
          const isFocusable = this.isFocusable() && (this.isEnabled() || this.getDialogType() === "DisplayArray");
          if (this.isInTable()) {
            this.getTableWidgetBase().requestFocusFromWidget(this, event);
            // TODO check if test isInMatrix is still necessary with bellow check Display Array
          } else if (this.isInMatrix() || this.isInScrollGrid() || isFocusable) {
            this.emit(context.constants.widgetEvents.requestFocus, event);
          }
        },

        /**
         * Returns id widget should show application contextmenu
         * @returns {boolean} true if application contextmenu should be displayed
         */
        shouldShowApplicationContextMenu: function() {
          return true;
        },

        /**
         * Build/add extra actions to app contextmenu
         * Must be redefined by widget which must add extra actions
         * @param {classes.ContextMenuWidget} contextMenu - widget
         */
        buildExtraContextMenuActions: function(contextMenu) {
          // prepare cut/copy/past actions
          let copyFunction = null;
          let cutFunction = null;
          let pasteFunction = null;
          const clipboardValue = this.getClipboardValue();
          const authorizedClipboardActions = this.getClipboardAuthorizedAction();

          if (authorizedClipboardActions.copy) {
            if (clipboardValue !== null) {
              copyFunction = function(contextMenu) {
                contextMenu.hide();
                gbc.ClipboardService.copyFromWidget(this);
              }.bind(this);
            }
          }

          if (authorizedClipboardActions.paste && this.isEnabled() && this.isVisible()) {
            if (context.ClipboardService.canPaste() && !context.ClipboardService.isClipboardEmpty()) {
              pasteFunction = function(contextMenu) {
                contextMenu.hide();
                context.ClipboardService.pasteToWidget(this);
              };
            }

            //We can only have a cut where we can paste
            if (authorizedClipboardActions.cut && copyFunction) {
              cutFunction = function(contextMenu) {
                contextMenu.hide();
                gbc.ClipboardService.cutFromWidget(this);
              };
            }
          }

          if (cutFunction) {
            contextMenu.addAction("cut", i18next.t("gwc.clipboard.cut"), null, null, {
              clickCallback: cutFunction.bind(this, contextMenu)
            }, true);
          }

          if (this.getDialogType() !== "DisplayArray" && this.getDialogType() !== "Display") {
            // if copyfunction exists add it to contextmenu
            if (authorizedClipboardActions.copy && copyFunction) {
              contextMenu.addAction("copy", i18next.t("gwc.clipboard.copy"), null, "Control+C", {
                clickCallback: copyFunction.bind(this, contextMenu)
              }, true);
            }
          }

          if (this.isInTable()) {
            const widgetValue = this.getClipboardValue(true);
            const widgetTable = this.getTableWidgetBase();
            if (widgetValue !== null && widgetTable.canShowCopyCellAndRow()) {
              const copyWidgetValueFunction = function(contextMenu) {
                contextMenu.hide();
                gbc.ClipboardService.copyFromWidget(this, false, true);
              }.bind(this);

              contextMenu.addAction("copyCell", i18next.t("gwc.contextMenu.copyCell"), null, null, {
                clickCallback: copyWidgetValueFunction.bind(this, contextMenu)
              }, true);
            }

            // build table contextmenu
            this.getTableWidgetBase().buildExtraContextMenuActions(contextMenu);
          }

          // if pasteFunction exists add it to contextmenu
          if (pasteFunction && context.ClipboardService.isApiAvailable()) {
            contextMenu.addAction("paste", i18next.t("gwc.clipboard.paste"), null, null, {
              clickCallback: pasteFunction.bind(this, contextMenu)
            }, true);
          }
        },

        /**
         * Defines if the widget is focusable
         * @param {boolean} focusable - State of focusable
         * @publicdoc
         */
        setFocusable: function(focusable) {
          this._focusable = focusable;
          this._setElementAttribute('tabindex', focusable ? '0' : null);
        },

        /**
         * Returns if the widget is focusable
         * @return {boolean} State of focusable
         * @publicdoc
         */
        isFocusable: function() {
          return this._focusable;
        },

        /**
         * Tests if the widget has really the DOM focus (check document.activeElement)
         * @returns {boolean} true if the widget has the DOM focus
         */
        hasDOMFocus: function() {
          return this._element === document.activeElement;
        },

        /**
         * Initialization of internationalization engine
         * @private
         */
        _initTranslation: function() {
          // Will ask the translation once ready
          this._i18NList = this._element.querySelectorAll("[data-i18n]");
          this._i18nTranslateListener = context.I18NService.translate(this);
          this._i18nTranslateChangeListener = context.I18NService.whenLangChange(function() {
            context.I18NService.translate(this);
          }.bind(this));
        },

        /**
         * Translate the widget
         * @publicdoc
         */
        translate: function() {
          const allSelectors = this._i18NList;
          for (const element of allSelectors) {
            element.innerHTML = i18next.t(element.getAttribute("data-i18n"));
          }
        },

        /**
         * Get the unique identifier of the widget
         * @returns {string} the unique identifier of the widget
         * @publicdoc
         */
        getUniqueIdentifier: function() {
          return this._uuid;
        },

        /**
         * Get the increment identifier of the widget if linked to AUI, 0 otherwise
         * @returns {number} the increment identifier of the widget if linked to AUI, 0 otherwise
         */
        getAuiLinkedUniqueIdentifier: function() {
          return this._nUuid;
        },

        /**
         * Get the unique identifier of the application
         * @returns {string} the unique identifier of the application
         * @publicdoc
         */
        getApplicationIdentifier: function() {
          return this._appHash !== undefined ? this._appHash : null;
        },

        /**
         * Get the root element of the widget
         * @returns {HTMLElement} the root element of the widget
         * @publicdoc
         */
        getElement: function() {
          return this._element;
        },

        /**
         * Get the main class name of the widget
         * @return {string} the main class name
         * @publicdoc
         */
        getClassName: function() {
          return "gbc_" + this.__name;
        },

        /**
         * Get the name of the widget class
         * @return {string} the widget class name
         * @publicdoc
         */
        getName: function() {
          return this.__name;
        },

        /**
         * Get the Aui Tree Tag
         * @return {?number} aui tree tag
         */
        getAuiTag: function() {
          return this._auiTag;
        },

        /**
         * Get the Aui Tree Tag
         * @return {string} html class ready name
         * @private
         */
        _getAuiTagClass: function() {
          return ".aui__" + this._auiTag;
        },

        /**
         * Get the unique class name identifying a widget instance
         * @returns {*|string} the unique class name identifying a widget instance
         */
        getRootClassName: function() {
          return this._rootClassName;
        },

        /**
         * Get the CSS id selector of the widget
         * @param {string=} [subSelector] selector targeting an element below the widget's root node
         * @param {boolean=} [appliesOnRoot] true if the returned selector should match the root too.
         * @param {string} [preSelector] pre selector rule, if any
         * @returns {string} the CSS selector corresponding to the requested DOM element
         * @public
         */
        _getCssSelector: function(subSelector, appliesOnRoot, preSelector) {
          return (preSelector || "") + "#" + this.getRootClassName() +
            (appliesOnRoot ? "" : " ") +
            (subSelector || "");
        },

        /**
         * Get widget style property value
         * @param {?string} [selector] additional sub selector
         * @param {string} property property name
         * @param {boolean=} appliesOnRoot - true if the returned selector should match the root too.
         * @returns {*} property value if set, undefined otherwise
         * @publicdoc
         */
        getStyle: function(selector, property, appliesOnRoot) {
          if (!property) {
            property = selector;
            selector = null;
          }
          const cssSelector = this._getCssSelector(selector, appliesOnRoot);
          return this._stylesheet && this._stylesheet[cssSelector] && this._stylesheet[cssSelector][property];
        },

        /**
         * Updates widget style with new rules
         * @param {?string|{selector:String, preSelector:String, appliesOnRoot:boolean=}} [selector] additional sub selector
         * @param {Object.<string, *>} style style properties to set
         * @publicdoc
         */
        setStyle: function(selector, style) {
          if (!style) {
            style = selector;
            selector = null;
          }
          let subSelector = selector,
            preSelector = null,
            appliesOnRoot = null;
          if (selector && (selector.selector || selector.preSelector)) {
            subSelector = selector.selector;
            preSelector = selector.preSelector;
            appliesOnRoot = selector.appliesOnRoot;
          }
          const cssSelector = this._getCssSelector(subSelector, appliesOnRoot, preSelector);
          if (!this._stylesheet) {
            this._stylesheet = {};
          }
          let localStyle = this._stylesheet[cssSelector];
          if (!localStyle) {
            localStyle = this._stylesheet[cssSelector] = {};
          }
          const keys = Object.keys(style);
          for (const element of keys) {
            if (style[element] === null) {
              delete localStyle[element];
            } else {
              localStyle[element] = style[element];
            }
          }
          const win = this.getWindowWidget(),
            contextChanged = (this._stylingContext === "global" && win) || (this._stylingContext === "window" && !win);

          context.styler.appendStyleSheet(this._stylesheet,
            this.getRootClassName(), true, this._stylingContext === "widget" ? this.getUniqueIdentifier() : this.getStyleSheetId()
          );

          if (contextChanged) {
            this._stylingContext = win ? "window" : "global";
            if (win) {
              context.styler.appendStyleSheet({}, this.getRootClassName(), true, this._appHash || "_");
            }
          }
        },

        /**
         * Retrieve stylesheet id which stores all widget css rules
         * @returns {string|string}
         */
        getStyleSheetId: function() {
          const windowWidget = this.getWindowWidget(),
            windowWidgetId = windowWidget && windowWidget.getUniqueIdentifier();
          return windowWidgetId || this._appHash || "_";
        },

        /**
         * Get the raw styles from VM
         * @returns {?string} the raw styles from VM
         */
        getRawStyles: function() {
          return this._rawStyles;
        },
        setApplicationStyles: function(styles) {
          this._rawStyles = styles;
          let i;
          const oldClasses = this._applicationStyles,
            oldlen = oldClasses ? oldClasses.length : 0,
            newClasses = styles && styles.split(SPACES_RE),
            newlen = newClasses ? newClasses.length : 0;
          for (i = 0; i < oldlen; i++) {
            if (!newClasses || newClasses.indexOf(oldClasses[i]) < 0) {
              this.removeClass("gbc_style_" + oldClasses[i]);
            }
          }
          for (i = 0; i < newlen; i++) {
            if (!oldClasses || oldClasses.indexOf(newClasses[i]) < 0) {
              this.addClass("gbc_style_" + newClasses[i]);
            }
          }
          this._applicationStyles = newClasses;
        },

        /**
         * Defines the parent widget
         * @param {classes.WidgetGroupBase} widget - the widget to use as parent
         * @param {Object=} options - possible options
         * @param {boolean=} options.noLayoutInvalidation - won't affect parent layout
         * @publicdoc
         */
        setParentWidget: function(widget, options) {
          options = options || {};
          this._parentWidget = widget;
          if (this._layoutEngine && !options.noLayoutInvalidation) {
            this._layoutEngine.invalidateMeasure();
          }
        },

        /**
         * Get the parent widget
         * @param {*?} type - class name to look for
         * @returns {classes.WidgetGroupBase} the parent widget
         * @publicdoc
         */
        getParentWidget: function(type) {
          let result = this._parentWidget;

          if (type) {
            while (result && !result.isInstanceOf(type)) {
              result = result.getParentWidget(type);
            }

          }

          return result;
        },

        /**
         * Get the UI widget related to the widget
         * @returns {classes.UserInterfaceWidget} UserInterfaceWidget
         * @publicdoc
         */
        getUserInterfaceWidget: function() {
          if (this._uiWidget === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.UserInterfaceWidget)) {
              result = result.getParentWidget();
            }
            this._uiWidget = result;
          }
          return this._uiWidget;
        },

        /**
         * Get Application Widget related to the widget
         * @returns {classes.ApplicationWidget} ApplicationWidget
         * @publicdoc
         */
        getApplicationWidget: function() {
          if (this._appWidget === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.ApplicationWidget)) {
              result = result.getParentWidget();
            }
            this._appWidget = result;
          }
          return this._appWidget;
        },

        /**
         * Get the Window Widget related to the widget
         * @returns {classes.WindowWidget} WindowWidget
         * @publicdoc
         */
        getWindowWidget: function() {
          if (this._windowWidget === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.WindowWidget)) {
              result = result.getParentWidget();
            }
            this._windowWidget = result;
          }
          return this._windowWidget;
        },

        /**
         * Get the Form Widget related to the widget
         * @returns {classes.FormWidget} FormWidget
         * @publicdoc
         */
        getFormWidget: function() {
          if (this._formWidget === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.FormWidget)) {
              result = result.getParentWidget();
            }
            this._formWidget = result;
          }
          return this._formWidget;
        },

        /**
         * Get the table Widget base class related to the widget
         * @returns {classes.TableWidgetBase} TableWidgetBase
         * @publicdoc
         */
        getTableWidgetBase: function() {
          if (this._tableWidgetBase === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.TableWidgetBase)) {
              result = result.getParentWidget();
            }
            this._tableWidgetBase = result;
          }
          return this._tableWidgetBase;
        },

        /**
         * Get the scrollgrid Widget class related to the widget
         * @returns {classes.ScrollGridWidget} ScrollGridWidget
         * @publicdoc
         */
        getScrollGridWidget: function() {
          if (this._scrollGridWidget === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.ScrollGridWidget)) {
              result = result.getParentWidget();
            }
            this._scrollGridWidget = result;
          }
          return this._scrollGridWidget;
        },

        /**
         * Get the stretchable scrollgrid Widget base class related to the widget
         * @returns {classes.StretchableScrollGridWidgetBase} StretchableScrollGridWidgetBase
         * @publicdoc
         */
        getStretchableScrollGridWidgetBase: function() {
          if (this._stretchableScrollGridWidgetBase === null) {
            let result = this;
            while (result && !result.isInstanceOf(gbc.classes.StretchableScrollGridWidgetBase)) {
              result = result.getParentWidget();
            }
            this._stretchableScrollGridWidgetBase = result;
          }
          return this._stretchableScrollGridWidgetBase;
        },

        /**
         * Check if this widget is a child of a given one
         * @param {classes.WidgetBase} parent the reference parent widget
         * @return {boolean} true if is a child, false otherwise
         * @publicdoc
         */
        isChildOf: function(parent) {
          let result = this.getParentWidget();
          while (result && result !== parent) {
            result = result.getParentWidget();
          }
          return Boolean(result);
        },

        /**
         * Replace the current widget with a given one
         * @param {classes.WidgetBase} widget the new widget
         * @publicdoc
         */
        replaceWith: function(widget) {
          if (this._parentWidget) {
            this._parentWidget.replaceChildWidget(this, widget);
          }
        },

        /**
         * Detach the widget from the dom
         * @publicdoc
         */
        detach: function() {
          if (this._element && this._element.parentNode) {
            this._element.parentNode.removeChild(this._element);
          } else {
            context.LogService.warn("Trying to detach a widget which is already outside of DOM " + this.__name);
          }
        },

        /**
         * Set widget current dialog type.
         * Can be Input, Input Array, Display, Display Array or Construct
         * @param {string} dialogType Dialog type
         * @publicdoc
         */
        setDialogType: function(dialogType) {
          this._dialogType = dialogType;
        },

        /**
         * return widget current dialog type
         * @returns {string} values can be : Input, InputArray, Display, DisplayArray or Construct
         * @publicdoc
         */
        getDialogType: function() {
          return this._dialogType;
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        setEnabled: function(enabled) {
          if (this._enabled !== Boolean(enabled)) {
            this._enabled = Boolean(enabled);
            if (this._enabled) {
              this.removeClass("disabled");
            } else {
              this.addClass("disabled");
            }
          }
        },

        /**
         * Check if widget is enabled
         * @returns {boolean} true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        isEnabled: function() {
          return this._enabled;
        },

        /**
         * Defines if the widget should be hidden or not
         * @param {boolean} hidden true if the widget is hidden, false otherwise
         * @publicdoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== Boolean(hidden)) {
            this._hidden = Boolean(hidden);
            if (this._element) {
              if (this._hidden) {
                this.addClass("hidden");
              } else {
                this.removeClass("hidden");
              }
            }
            // update replacer element visibility as well if existing
            if (this.hasReplacer()) {
              this.getReplacer().toggleClass("hidden", this._hidden);
            }
            if (this._layoutEngine) {
              this._layoutEngine.changeHidden(hidden);
            }
            this.emit(context.constants.widgetEvents.visibilityChange);
          }
        },

        /**
         * Check if the widget is hidden
         * @returns {boolean} true if the widget is hidden, false otherwise
         * @publicdoc
         */
        isHidden: function() {
          return this._hidden;
        },

        /**
         * Check if the widget is part of layout computing
         * @param {boolean} [deep] true to test against parent widgets as well
         * @returns {boolean} true if the widget is part of layout computing
         */
        isLayoutMeasureable: function(deep) {
          if (!deep) {
            return !this.isHidden();
          }
          if (this.isHidden()) {
            return false;
          }
          let parent = this;
          while (parent) {
            if (!parent.isLayoutMeasureable()) {
              return false;
            }
            if (parent.isLayoutTerminator() && parent.isLayoutMeasureable()) {
              return true;
            }
            parent = parent.getParentWidget();
          }
          return true;
        },

        /**
         * Check if the widget is visible
         * @return {boolean} true if visible, false otherwise
         * @publicdoc
         */
        isVisible: function() {
          return !this.isHidden();
        },

        /**
         * Check if widget or one of its parent is hidden
         * @return {boolean} true if hidden, false otherwise
         */
        isHiddenRecursively: function() {
          let parent = this;
          while (parent) {
            if (parent.isHidden()) {
              return true;
            }
            parent = parent.getParentWidget();
          }
          return false;
        },

        /**
         * Check if widget and all of its parent are visible
         * @return {boolean} true if visible, false otherwise
         */
        isVisibleRecursively: function() {
          let parent = this;
          while (parent) {
            if (!parent.isVisible()) {
              return false;
            }
            parent = parent.getParentWidget();
          }
          return true;
        },

        isLayoutTerminator: function() {
          return false;
        },

        /**
         * Remove or add borders to the widget
         * @param {boolean} noBorder - true if the widget has no border class, false otherwise
         * @publicdoc
         */
        setNoBorder: function(noBorder) {
          if (this._noBorder !== Boolean(noBorder)) {
            this._noBorder = Boolean(noBorder);
            if (this._noBorder) {
              this.addClass("gbc_NoBorder");
            } else {
              this.removeClass("gbc_NoBorder");
            }
          }
        },

        /**
         * Check if the widget is displayed without border
         * @returns {boolean} true if the widget has no border class, false otherwise
         * @publicdoc
         */
        isNoBorder: function() {
          return this._noBorder;
        },

        /**
         * Set the title of the widget
         * @param {string} title - the tooltip text
         * @publicdoc
         */
        setTitle: function(title) {
          if (this.getTitle() === title) {
            return;
          }

          if (title === "") {
            this._setElementAttribute("title", null);
            this.setAriaAttribute("label", null);
          } else {
            this._setElementAttribute("title", title);
            this.setAriaAttribute("label", title);
          }
        },

        /**
         * Get the title of the widget
         * @returns {string} the tooltip text
         * @publicdoc
         */
        getTitle: function() {
          return this._element.getAttribute("title");
        },

        /**
         * Called when widget obtains the focus
         * @param {boolean} [fromMouse] - true if focus comes from mouse event
         * @param {boolean} [stayOnSameWidget] - true if we want to set the focus to the current focused widget
         * @publicdoc
         */
        setFocus: function(fromMouse, stayOnSameWidget) {
          const userInterfaceWidget = this.getUserInterfaceWidget();
          if (userInterfaceWidget) {
            userInterfaceWidget.setFocusedWidget(this);
            // emit current view change (used for hbox splitview)
            userInterfaceWidget.emit(context.constants.widgetEvents.splitViewChange);
            this.setAriaSelection();
          }

          // rare case when we are going to focus a hidden widget. To avoid fallback focus to body, we focus userinterface widget instead.
          if (this.isHidden()) {
            const uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          }
        },

        /**
         * Called before setting VM focus to notify previous VM focused widget
         * @param {classes.WidgetBase} vmNewFocusedWidget - new widget which get the focus
         * @publicdoc
         */
        loseVMFocus: function(vmNewFocusedWidget = null) {
          // if widget which lost focus is in a value container
          // and widget which get the focus is not in the same container
          // call lostVMFocus function on its container

          // table
          let oldTableWidgetBase = this.getTableWidgetBase();
          let newTableWidgetBase = vmNewFocusedWidget.getTableWidgetBase();
          if (oldTableWidgetBase &&
            oldTableWidgetBase !== this &&
            oldTableWidgetBase !== newTableWidgetBase) {
            oldTableWidgetBase.loseVMFocus(vmNewFocusedWidget);
            return;
          }

          // stretchable scrollgrid
          let oldStretchableScrollGridBase = this.getStretchableScrollGridWidgetBase();
          let newStretchableScrollGridBase = vmNewFocusedWidget.getStretchableScrollGridWidgetBase();
          if (oldStretchableScrollGridBase &&
            oldStretchableScrollGridBase !== this &&
            oldStretchableScrollGridBase !== newStretchableScrollGridBase) {
            oldStretchableScrollGridBase.loseVMFocus(vmNewFocusedWidget);
          }
        },

        /**
         * Called before setFocus to notify previous focused widget
         * @publicdoc
         */
        loseFocus: function() {},

        /**
         * Check if widget node has VM focus
         * @returns {boolean} true if widget node has VM focus
         * @publicdoc
         */
        hasFocus: function() {
          const ui = this.getUserInterfaceWidget();
          return !ui || this === ui.getFocusedWidget();
        },

        /**
         * Checks if the widget element has the given class
         * @param {string} className - class to check
         * @publicdoc
         */
        hasClass: function(className) {
          return this._element.hasClass(className);
        },

        /**
         * Add the given class to element
         * @param {string} className - class to add
         * @publicdoc
         */
        addClass: function(className) {
          this._element.addClass(className);
        },

        /**
         * Remove the given class from element
         * @param {string} className - class to delete
         * @publicdoc
         */
        removeClass: function(className) {
          this._element.removeClass(className);
        },

        /**
         * Toggle the given class to element
         * @param {string} className - class to toggle
         * @param {string|boolean} className2 - class added if switcher is false
         * @param {boolean=} switcher forced new state
         * @publicdoc
         */
        toggleClass: function(className, className2, switcher) {
          this._element.toggleClass(className, className2, switcher);
        },

        /**
         * Add QA information to the widget
         * @param {string} name - AUI tree name
         * @param {string} value - AUI tree value
         */
        setQAInfo: function(name, value) {
          if (this._element) {
            this._setElementAttribute("data-gqa-" + name, value);
          }
        },

        /**
         * Defines the AUI tree name of the widget
         * @param {string} name the name
         */
        setAuiName: function(name) {
          if (this._element && (name !== this._auiName)) {
            this._auiName = name;
            this._setElementAttribute("data-aui-name", name);
          }
        },

        /**
         * Check if the widget is in a table
         * @param {classes.TableWidgetBase} table - specific table, if null just return if widget is in any table
         * @returns {boolean} true if the widget is in a table, false otherwise.
         * @publicdoc
         */
        isInTable: function(table = null) {
          return this._inTable && ((table === null) || (this.getTableWidgetBase() === table));
        },

        /**
         * Check if the widget is in a scrollGrid
         * @param {classes.WidgetBase} scrollGrid - specific scrollGrid, if null just return if widget is in any scrollGrid
         * @returns {boolean} true if the widget is in a table, false otherwise.
         * @publicdoc
         */
        isInScrollGrid: function(scrollGrid = null) {
          const inSpecificScrollGrid = this.getStretchableScrollGridWidgetBase() === scrollGrid || this.getScrollGridWidget() === scrollGrid;
          return this._inScrollGrid && ((scrollGrid === null) || inSpecificScrollGrid);
        },

        /**
         * Check if the widget is in a matrix
         * @returns {boolean} true if the widget is in a matrix, false otherwise.
         * @publicdoc
         */
        isInMatrix: function() {
          return this._inMatrix;
        },

        /**
         * Check if the widget is in an array (table, matrix or scrollgrid)
         * @returns {boolean} true if the widget is in an array, false otherwise.
         * @publicdoc
         */
        isInArray: function() {
          return this.isInTable() || this.isInMatrix() || this.isInScrollGrid();
        },

        /**
         * Does the widget ignore layouting
         * @returns {boolean} true if the widget ignore all layout.
         * @publicdoc
         */
        ignoreLayout: function() {
          return this._ignoreLayout;
        },

        /**
         * Set Arabic mode
         * @param {boolean} rtl - true if widget is right to left
         * @publicdoc
         */
        setReverse: function(rtl) {
          if (this._isReversed !== rtl) {
            this._isReversed = rtl;
            if (rtl) {
              this.addClass("reverse");
            } else {
              this.removeClass("reverse");
            }
          }
        },

        /**
         * Check if arabic mode is enabled
         * @return {boolean} true if enabled
         * @publicdoc
         */
        isReversed: function() {
          return this._isReversed;
        },

        /**
         * Get start (for reversed mode)
         * @return {string} start keyword for rtl
         * @publicdoc
         */
        getStart: function() {
          return this.isReversed() ? "right" : "left";
        },

        /**
         * Get end (for reversed mode)
         * @return {string} end keyword for rtl
         * @publicdoc
         */
        getEnd: function() {
          return this.isReversed() ? "left" : "right";
        },

        /**
         * Method called when the widget is attached/detached from the DOM
         * Override this in inherited widget if necessary
         */
        _setDOMAttachedOrDetached: function() {},

        /**
         * Returns if element is in the DOM
         * @return {boolean} true if element in the DOM
         */
        isElementInDOM: function() {
          return Boolean(this._element) && this._element.isInDOM();
        },

        /**
         * Add the widget in the DOM
         */
        addInDom: function() {
          if (!this.getElement().parentNode && this._replacerElement && this._replacerElement.parentNode) {
            this._replacerElement.parentNode.replaceChild(this.getElement(), this._replacerElement);
          }
        },

        /**
         * Remove widget from DOM and replace it by an empty DIV
         */
        removeFromDom: function() {
          if (this.getElement() && this.getElement().parentNode) {
            this.getElement().parentNode.replaceChild(this.getReplacer(), this.getElement());
            this.getReplacer().toggleClass("hidden", this.isHidden());
          }
        },

        /**
         * DOM node intended to replace a widget node temporarely
         * @returns {HTMLDivElement}
         */
        getReplacer: function() {
          if (!this._replacerElement) {
            this._replacerElement = document.createElement("div");
            this._replacerElement.setAttribute("tabindex", "0");
            this._replacerElement.classList.add("replacer");
          }
          return this._replacerElement;
        },

        /**
         * Returns true if widget has an existing replacer element
         * @returns {boolean}
         */
        hasReplacer: function() {
          return !!this._replacerElement;
        },

        /**
         * Could the widget get interrupt?
         * @param {boolean} interruptable - true if interruptable, false otherwise
         */
        setInterruptable: function(interruptable) {
          this._interruptable = interruptable;
          if (this._element) {
            this._setElementAttribute("interruptable", interruptable ? "interruptable" : null);
          }
        },
        /**
         * returns true if widget acts as an interruptable
         * @return {boolean} true if widget acts as an interruptable
         */
        isInterruptable: function() {
          return this._interruptable;
        },

        /**
         * Updates widget interruptable active
         * @param isActive is interruptable active?
         */
        setInterruptableActive: function(isActive) {
          if (this._element) {
            this._setElementAttribute("interruptable-active", isActive ? "interruptable-active" : null);
          }
        },

        /**
         * Make the widget flash (basically when some action are forbidden)
         * @param {Number?} duration - flash duration in ms (default 50ms)
         */
        flash: function(duration) {
          if (this.isEnabled()) {
            this.addClass("disabled");
            this._registerTimeout(function() {
              this.removeClass("disabled");
            }.bind(this), duration || 50);
          }
        },

        /**
         * Returns if widget has cursors
         * @return {boolean} true if widget has cursors
         */
        hasCursors: function() {
          // if widget has setCursors & getCursors functions defined -> it supports cursors
          return this.setCursors && this.getCursors;
        },

        /**
         * Manage clipboard on paste data to the widget
         * @param {string} text - pasted text
         */
        manageClipboardPaste: function(text) {
          // Do whatever with text data
        },

        /**
         * Manage data to be copied to the clipboard
         * @param {string} copiedText - is the text copied by clipboard
         * @returns {string} the modified text, default is unchanged
         */
        manageClipboardCopy: function(copiedText) {
          // Do whatever with text data you want to be added to the clipboard when copy
          return copiedText;
        },

        /**
         * Manage cut data to be copied to the clipboards
         * @param {Selection} selection - is the text cut by clipboard
         * @returns {string} the modified text, default is unchanged
         */
        manageClipboardCut: function(selection) {
          // Do whatever with text data you want to be added to the clipboard when cut
          return selection.toString();
        },

        /**
         * Manage key
         * @param {string} keyString - key string representation
         * @param {Object} domKeyEvent - key event from DOM
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isInTable()) {
            return this.getTableWidgetBase().manageKeyDown(keyString, domKeyEvent, repeat);
          }
          return false;
        },

        /**
         * Manage key before any action
         * @param {string} keyString - key string representation
         * @param {Object} domKeyEvent - key event from DOM
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isInTable()) {
            return this.getTableWidgetBase().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          } else if (this.isInScrollGrid()) {
            let scrollGridWidget = this.getScrollGridWidget() || this.getStretchableScrollGridWidgetBase();
            return scrollGridWidget.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return false;
        },

        /**
         * Manage key once released (on key up).
         * @param {string} keyString - keys string representation (can be a combinaison eg: shift+a)
         * @param {Object} domKeyEvent - key event from DOM
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          if (this.isInTable()) {
            this.getTableWidgetBase().manageKeyUp(keyString, domKeyEvent);
          }
        },

        /**
         * Manage mouse down
         * @param {*} domEvent - mouse down event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseDown: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse up
         * @param {*} domEvent - mouse up event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseUp: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse click
         * @param {*} domEvent - mouse click event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseClick: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse double click
         * @param {*} domEvent - mouse dblclick event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseDblClick: function(domEvent) {
          return true;
        },

        /**
         * Manage mouse right click
         * @param {*} domEvent - mouse click event from DOM
         * @returns {boolean} returns if event must be bubbled to parent DOM widget
         */
        manageMouseRightClick: function(domEvent) {

          if (domEvent.shiftKey) {
            return false; // don't show context menu if shift key is pressed
          }

          if (context.DebugService.isActive() && domEvent.ctrlKey) {
            domEvent.preventCancelableDefault();
            return false; // right click + CTRL is used to show debugTree
          }

          this._onRequestFocus(domEvent); // request focus

          if (this.shouldShowApplicationContextMenu()) {
            const appWidget = this.getApplicationWidget();
            if (domEvent.target.elementOrParent && appWidget && context.ThemeService.getValue("theme-disable-context-menu") === false) {
              if (!domEvent.target.elementOrParent("gbc_ContextMenuWidget")) { // if right-click is not on a contextmenu
                context.ClipboardService.getClipboardData().then(function() {
                  appWidget.showContextMenu(domEvent.data ? domEvent.data[0] : domEvent, this);
                }.bind(this));
                domEvent.preventCancelableDefault();
              } else {
                // If right-click on context menu item: use a regular click instead
                domEvent.preventCancelableDefault();
                this.manageMouseClick(domEvent);
              }
              return false; // if contextmenu is managed by this widget don't bubble
            }
          }
          return false;
        },

        /**
         * Manage input
         * @param {String} [dataString] - string with the inserted characters
         * @param {*} [event] - input event from DOM
         */
        manageInput: function(dataString = "", event = null) {},

        /**
         * Manage beforeinput
         * @param {String} [dataString] - string with the inserted characters
         * @param {*} [event] - beforeinput event from DOM
         * @return {boolean} returns true if ok, false if input is not allowed
         */
        manageBeforeInput: function(dataString = "", event = null) {
          return true;
        },

        /**
         * Define the aria role of this widget,
         * Mostly already defined in template
         * @param {string} roleName - aria role name to set
         */
        setAriaRole: function(roleName) {
          if (roleName && this._element) {
            this._setElementAttribute("role", roleName);
          }
        },

        /**
         * Set the aria attribute of this widget,
         * @param {string} attrName - aria attribute Name to set
         * @param {*} attrVal - aria attribute value to set
         */
        setAriaAttribute: function(attrName, attrVal) {
          if (this._element && attrName) {
            this._setElementAttribute("aria-" + attrName, attrVal);
          }
        },

        /**
         * Get the aria attribute of this widget,
         * @param {string} attrName - aria attribute Name to get
         * @return {*} aria attribute value
         */
        getAriaAttribute: function(attrName) {
          if (this._element && attrName) {
            return this._element.getAttribute("aria-" + attrName);
          }
        },

        /**
         * Set the aria-selected attribute to help screen-reader to know wich widget is the current one
         */
        setAriaSelection: function() {
          this.domAttributesMutator(function() {
            const currentSelected = document.querySelector('[aria-selected="true"]');
            if (currentSelected) {
              currentSelected.removeAttribute('aria-selected');
            }
          });
          this.setAriaAttribute('selected', "true");
        },

        /**
         * Set the widget has "expanded" for better accessibility
         * @param {Boolean} expanded - true if widget is expanded, false otherwise
         */
        setAriaExpanded: function(expanded) {
          this.setAriaAttribute("expanded", expanded);
        },

        /**
         * Get the value to put in the clipboard when copying
         * @param {boolean} ignoreSelection true to send the widget value
         * @return {?string|number}
         */
        getClipboardValue: function(ignoreSelection) {
          return null;
        },

        /**
         * Helper method to update attirbutes in DOM using buffering system
         * @param {string} attr the attribute name
         * @param {*} val the attribute new value
         * @param {string|Function} [elementSelector] a string identifier of this class member or a method returning the element to set the attributes value
         * @protected
         */
        _setElementAttribute: function(attr, val, elementSelector) {
          let target = null;
          if (elementSelector) {
            if (typeof elementSelector === "string") {
              target = this[elementSelector];
            } else if (typeof elementSelector === "function") {
              target = elementSelector(this);
            }
          } else {
            target = this._element;
          }
          if (target) {
            if (val === null || val === "" || typeof(val) === "undefined") {
              target.removeAttribute(attr);
            } else {
              target.setAttribute(attr, val.toString());
            }
          }
        },

        /**
         * Helper method to update textContent in DOM using buffering system
         * @param {string} text the new text
         * @param {string|function} [elementSelector] a string identifier of this class member or a method returning the element to set the textContent
         * @protected
         */
        _setTextContent: function(text, elementSelector) {
          this.domAttributesMutator(function(text, elementSelector) {
            let target = null;
            if (elementSelector) {
              if (typeof elementSelector === "string") {
                target = this[elementSelector];
              } else if (typeof elementSelector === "function") {
                target = elementSelector(this);
              }
            } else {
              target = this._element;
            }
            if (target) {
              target.textContent = text;
            }
          }.bind(this, text, elementSelector));
        },

        /**
         * Use this to update attributes of dom nodes using a buffering system
         * @param fn the function to bufferize - don't forget to bind to context
         */
        domAttributesMutator: function(fn) {
          const appWidget = this.getApplicationWidget();
          if (!appWidget || !appWidget.domAttributesMutationBuffer(fn, this)) {
            fn();
          }
        },

        /**
         * @param fn the function to bufferize - don't forget to bind to context
         */
        afterDomMutator: function(fn) {
          const appWidget = this.getApplicationWidget();
          if (!appWidget || !appWidget.afterDomMutationBuffer(fn, this)) {
            this._registerAnimationFrame(fn); // TODO why doing requestAnimationFrame in this case ?
          }
        },

        /**
         * True if the widget accept input when it is inside inactive windows
         * @return {boolean}
         */
        acceptEventWhenWindowInactive: function() {
          return this._acceptEventWhenWindowInactive;
        },

        /**
         * Set if the widget accept events inside inactive windows
         * @param acceptEvent
         */
        setAcceptEventWhenWindowInactive: function(acceptEvent) {
          this._acceptEventWhenWindowInactive = acceptEvent;
        },

        /**
         * Add a behaviour name to the applied behaviours
         * @param {string} name behaviour name
         */
        addAppliedBehavior: function(name) {
          this._applyedBehaviors.add(name);
        },

        /**
         * true if the behaviour wad already applied
         * @param {string} name behaviour name
         * @return {boolean}
         */
        isAppliedBehavior: function(name) {
          return this._applyedBehaviors.has(name);
        },

        /**
         * Get the clipboard authorized actions
         * @returns {object}
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: false,
            cut: false
          };
        }
      };
    });
  });
;

"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.widgetEvents = {
  activate: 'g_activate',
  afterLayout: 'g_afterLayout',
  blur: 'g_blur',
  change: 'g_change',
  click: 'g_click',
  close: 'g_close',
  copy: 'g_copy',
  contextMenu: 'g_contextMenu',
  created: 'g_created',
  disable: 'g_disable',
  displayChanged: "g_displayChanged",
  destroyed: 'g_destroyed',
  doubleClick: 'g_doubleClick',
  enter: 'g_enter',
  esc: 'g_esc',
  focus: 'g_focus',
  focusRestored: 'g_focusRestored',
  frozen: "g_frozen",
  gbcReady: "g_gbcReady",
  gbcQaReady: "g_gbcQaReady",
  gridInfoChanged: 'g_gridInfoChanged',
  iconChanged: "g_iconChanged",
  keyDown: 'g_keyDown',
  keyUp: 'g_keyUp',
  keyArrowDown: 'g_keyArrowDown',
  keyArrowLeft: 'g_keyArrowLeft',
  keyArrowRight: 'g_keyArrowRight',
  keyArrowUp: 'g_keyArrowUp',
  keyEnd: 'g_keyEnd',
  keyHome: 'g_keyHome',
  keyPageUp: 'g_keyPageUp',
  keyPageDown: 'g_keyPageDown',
  keySpace: 'g_keySpace',
  layout: 'g_layout',
  layoutApplied: 'g_layoutApplied',
  layoutInformationChanged: 'g_layoutInformationChanged',
  layoutRequest: 'g_layoutRequest',
  logStepDone: 'g_logStepDone',
  logForwardDone: 'g_logForwardDone',
  logPlayerError: 'g_logPlayerError',
  modalOut: 'g_modalOut',
  modalResize: "g_modalResize",
  mouseWheel: 'g_mouseWheel',
  offset: 'g_offset',
  onBeforeUnload: "g_onbeforeunload",
  onBlur: "g_onBlur",
  onUnload: "g_onunload",
  openDropDown: "g_openDropDown",
  pageSize: 'g_pageSize',
  pageVisibility: 'g_pageVisibility',
  ready: 'g_ready',
  requestFocus: 'g_requestFocus',
  restart: "g_restart",
  rightClick: 'g_rightClick',
  rowAction: 'g_rowAction',
  rowBoundMenu: 'g_rowBoundMenu',
  scroll: 'g_scroll',
  select: 'g_select',
  selectAll: 'g_selectAll',
  space: 'g_space',
  splitter: 'g_splitter',
  splitterStart: 'g_splitterStart',
  splitterEnd: 'g_splitterEnd',
  splitViewChange: 'g_splitViewChange',
  swipeStart: 'g_swipeStart',
  swipeEnd: 'g_swipeEnd',
  tableClickOnContainer: 'g_tableClickOnContainer',
  tableDragEnter: 'g_tableDragEnter',
  tableDragEnd: 'g_tableDragEnd',
  tableDragLeave: 'g_tableDragLeave',
  tableDragStart: 'g_tableDragStart',
  tableDrop: 'g_tableDrop',
  tableDragOver: 'g_tableDragOver',
  tableHeaderSort: 'g_tableHeaderSort',
  tableHeaderOrder: 'g_tableHeaderOrder',
  tableLeftFrozen: 'g_tableTableLeftFrozen',
  tableOrderColumn: 'g_tableOrderColumn',
  tableResetToDefault: 'g_tableResetToDefault',
  tableResizeCol: 'g_tableResizeCol',
  tableRightFrozen: 'g_tableTableRightFrozen',
  tableShowHideCol: 'g_tableShowHideCol',
  tableClick: 'g_tableClick',
  themeChange: 'g_themeChange',
  titleChanged: "g_titleChanged",
  toggleClick: "g_toggleClick",
  touchEnd: "g_touchEnd",
  touchMove: "g_touchMove",
  touchStart: "g_touchStart",
  unfrozen: "g_unfrozen",
  valueChanged: 'g_valueChanged',
  visibilityChange: "g_visibilityChange",
  webcomponentKeyDown: "g_webcomponentKeyDown",
  webcomponentClick: "g_webcomponentClick",
  webcomponentContextMenu: "g_webcomponentContextMenu",
};
;

"use strict";

modulum('WidgetFactory', ['Factory', 'LogService'],

  /**
   * @typedef {Object} WidgetFactoryId
   * @property {?string} parentIdentifier
   * @property {?string} parentStyle
   * @property {Object|?string} parentAttributes
   * @property {?string} identifier
   * @property {?string} style
   * @property {Object|?string} attributes
   * @property {number} weight
   * @property {number} attributesWeight
   * @property {number} parentAttributesWeight
   * @property {number} weight
   * @property {number} timestamp
   * @property {?Function} builder
   */

  function(context, cls) {
    /**
     * @namespace classes.WidgetFactory
     */
    cls.WidgetFactory = context.oo.StaticClass(function() {
      return /** @lends classes.WidgetFactory */ {

        /**
         * @private
         */
        _lastId: 0,

        /**
         * @const
         * @private
         */
        _selectorRegExp: /^\s*(?:([a-zA-Z]+)(?:\.([a-zA-Z0-9_-]+))?((?:\[[a-zA-Z0-9_-]+=[a-zA-Z0-9_\s-]+])+)?\s+)?([a-zA-Z]+)(?:\.([a-zA-Z0-9_-]+))?((?:\[[a-zA-Z0-9_-]+=[a-zA-Z0-9_\s-]+])+)?\s*$/,
        _selectorAttributesRegExp: /(?:\[([a-zA-Z0-9_-]+)=([a-zA-Z0-9_\s-]+)])/g,

        /**
         * @type {Object.<string, WidgetFactoryId>}
         * @private
         */
        _fabrics: {},

        /**
         * @type {Object.<string, WidgetFactoryId>}
         * @private
         */
        _themeFabrics: {},

        /**
         *
         * @param {string} selector Selector matcher as "[parentNode[.parentStyle]] id[.style]"
         * @param {Function} constructor constructor of the widget
         */
        registerBuilder: function(selector, constructor) {
          this._register(this._sanitizeId(selector), constructor);
        },

        /**
         * parse the fabric selector
         * @param {string} selector the selector
         * @private
         * @returns {WidgetFactoryId} the parsed id
         */
        _sanitizeId: function(selector) {
          const result = {
            parentIdentifier: "",
            parentStyle: "",
            parentAttributes: "",
            identifier: "",
            style: "",
            attributes: "",
            weight: 0,
            attributesWeight: 0,
            parentAttributesWeight: 0,
            timestamp: ++this._lastId,
            builder: null
          };
          const exec = this._selectorRegExp.exec(selector);
          if (exec) {
            let _attrs, curr, i = 0;
            result.parentIdentifier = exec[1] || "";
            result.parentStyle = exec[2] || "";
            result.parentAttributes = exec[3] || "";
            if (result.parentAttributes) {
              i = 0;
              _attrs = result.parentAttributes;
              result.parentAttributes = {};
              /*jshint -W084 */
              while (curr = this._selectorAttributesRegExp.exec(_attrs)) {
                result.parentAttributes[curr[1]] = curr[2];
                i++;
              }
            }
            result.parentAttributesWeight = i;
            result.identifier = exec[4];
            result.style = exec[5] || "";
            result.attributes = exec[6] || "";
            if (result.attributes) {
              i = 0;
              _attrs = result.attributes;
              result.attributes = {};
              while (curr = this._selectorAttributesRegExp.exec(_attrs)) {
                result.attributes[curr[1]] = curr[2];
                i++;
              }
            }
            result.attributesWeight = i;
            result.weight = (result.parentIdentifier ? 4 : 0) + (result.parentStyle ? 2 : 0) + (result.style ? 1 : 0);
          } else {
            context.LogService.warn("WidgetFactory - Trying to register widget with wrong selector: '" + selector + "'");
          }
          return result;
        },

        /**
         * register a widget fabric
         * @private
         * @param {WidgetFactoryId} id the fabric id
         * @param {Function?} constructor constructor of the widget
         * @param {boolean} [_fromTheme] internal param - true if register comes from a theme
         */
        _register: function(id, constructor, _fromTheme) {
          let fabrics = this._fabrics;
          if (_fromTheme) {
            fabrics = this._themeFabrics;
          }

          if (id.identifier) {
            id.builder = constructor;
            const store = (fabrics[id.identifier] = fabrics[id.identifier] || []);

            id.timestamp =
              store.push(id);
            store.sort(this._compareFabrics);
          }
        },

        _compareFabrics: function(a, b) {
          return (b.weight - a.weight) ||
            (b.parentAttributesWeight - a.parentAttributesWeight) ||
            (b.attributesWeight - a.attributesWeight) ||
            (b.timestamp - a.timestamp);
        },

        /**
         * @deprecated Use registerBuilder instead.
         * @param {string} id
         * @param {string|?Function} style style of the widget
         * @param {?Function} constructor constructor of the widget
         */
        register: function(id, style, constructor) {
          if (!constructor) {
            constructor = style;
            style = "";
          }
          this.registerBuilder(id + (style ? ("." + style) : ""), constructor);
        },

        /**
         *
         * @deprecated
         * @param {string} id
         * @param {string} [styles]
         * @returns {classes.WidgetBase}
         */
        create: function(id, styles, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
          let result = null;
          if (this._fabrics[id]) {
            if (!styles) {
              result = this._fabrics[id].filter(function(f) {
                return !f.weight && !f.attributesWeight && !f.parentAttributesWeight;
              })[0];
            } else {
              let pos = 0;
              const fabrics = this._fabrics[id].filter(function(f) {
                return f.weight <= 1 && !f.attributesWeight && !f.parentAttributesWeight;
              });
              while (!result && (pos < fabrics.length)) {
                const fabric = fabrics[pos];
                if (!fabric.style || styles.trim().split(cls.NodeBase.stylesSeparatorRegExp).indexOf(fabric.style)) {
                  result = fabric;
                }
                pos++;
              }
            }
          }
          if (result && result.builder) {
            const Fabric = result.builder;
            result = new Fabric(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
          }
          return result;
        },
        /**
         *
         * @param {string} id
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @return {?classes.WidgetBase}
         */
        createWidget: function(id, builderParameters, contextInstance) {
          let result = null;
          let Fabric = this._findFabric(id, builderParameters, contextInstance);
          const ThemeFabric = this._findFabric(id, builderParameters, contextInstance, true);
          if (ThemeFabric && (!Fabric || this._compareFabrics(Fabric, ThemeFabric) >= 0)) {
            Fabric = ThemeFabric;
          }
          if (Fabric) {
            Fabric = Fabric.builder;
            result = new Fabric(builderParameters);
          }
          return result;
        },
        /**
         *
         * @param {string} id
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @param {Boolean} [_fromTheme]
         * @return {?WidgetFactoryId}
         * @private
         */
        _findFabric: function(id, builderParameters, contextInstance, _fromTheme) {
          let fabrics = this._fabrics;
          if (_fromTheme) {
            fabrics = this._themeFabrics;
          }
          let result = null;
          if (fabrics[id]) {
            if (!contextInstance) {
              result = fabrics[id].filter(function(f) {
                return !f.weight && !f.attributesWeight && !f.parentAttributesWeight;
              })[0];
            } else {
              let pos = 0;
              while (!result && (pos < fabrics[id].length)) {
                if (this._matchFabric(fabrics[id][pos], builderParameters, contextInstance)) {
                  result = fabrics[id][pos];
                }
                pos++;
              }
            }
          }
          return result;
        },
        /**
         *
         * @param {WidgetFactoryId} fabric
         * @param {?*} [builderParameters]
         * @param {classes.NodeBase|classes.WidgetBase} [contextInstance]
         * @returns {boolean}
         * @private
         */
        _matchFabric: function(fabric, builderParameters, contextInstance) {
          let result = !fabric.parentIdentifier,
            contextInstanceLocal = contextInstance;
          if (fabric.parentIdentifier) {
            if (contextInstance && contextInstance.isInstanceOf && contextInstance.isInstanceOf(cls.NodeBase)) {
              result = contextInstance.getAncestorWithStyle(fabric.parentIdentifier, fabric.parentStyle);
            } else if (builderParameters &&
              typeof builderParameters.appHash === "number" &&
              typeof builderParameters.auiTag === "number") {
              const app = context.SessionService.getCurrent().getApplicationByHash(builderParameters.appHash);
              result = app && app.model.getNode(builderParameters.auiTag);
              contextInstanceLocal = result;
              result = result.getAncestorWithStyle(fabric.parentIdentifier, fabric.parentStyle);
            }
          }
          result = result && (!fabric.parentAttributesWeight || (result !== true && this._matchAttributes(fabric.parentAttributes,
            result._initialStyleAttributes)));
          result = result && (!fabric.style || (contextInstanceLocal._vmStyles.indexOf(fabric.style) >= 0));
          result = result && (!fabric.attributesWeight || this._matchAttributes(fabric.attributes, contextInstanceLocal
            ._initialStyleAttributes));
          return result;
        },

        _matchAttributes: function(neededAttributes, nodeAttributes) {
          let result = true;
          const keys = Object.keys(neededAttributes);
          let i = 0;
          const len = keys.length;

          while (result && i < len) {
            result = neededAttributes[keys[i]] === nodeAttributes[keys[i]];
            i++;
          }
          return result;
        },

        /**
         * set theme overrides
         * @param {Object<string, string>} overrides theme overrides definitions
         */
        registerThemeOverrides: function(overrides) {
          this._themeFabrics = {};
          let i = 0;
          const keys = overrides && Object.keys(overrides) || [],
            len = keys.length;
          for (; i < len; i++) {
            const selector = keys[i];
            let constructor = null;
            if (/^cls\./.test(overrides[selector])) {
              constructor = context.classes[overrides[selector].replace(/^cls\./, "")];
            }
            this._register(this._sanitizeId(selector), constructor);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WidgetGridLayoutBase', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class WidgetGridLayoutBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.WidgetGridLayoutBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.WidgetGridLayoutBase.prototype */ {
        __name: "WidgetGridLayoutBase",
        /**
         * Whether it is GridChildrenInParent or not
         * @type {!boolean}
         */
        _isGridChildrenInParent: null,
        _rerouteChildren: false,
        _owned: null,
        _scrolling: false,
        _wheelHandling: false,
        _wheelThrottleHandler: null,
        _wheelThrottleTimeout: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._wheelThrottleTimeout = cls.ScrollUIBehavior._throttleTimeout * 4;
          this._owned = [];
          this._element.addClass("g_Grid");
          this._containerElement.addClass("g_GridLayoutEngine");
        },

        /**
         * @inheritDoc
         */
        _initLayout: function(noLayoutEngine) {
          $super._initLayout.call(this);
          if (!noLayoutEngine) {
            this._layoutEngine = new cls.GridLayoutEngine(this);
          }
        },

        /**
         * @inheritDoc
         */
        _addChildWidgetToDom: function(widget, position) {
          this.getLayoutEngine().registerChild(widget);
          const widgetGridHost = document.createElement('div');
          widgetGridHost.addClass('g_GridElement');
          const info = widget.getLayoutInformation();
          if (info) {
            info.setHostElement(widgetGridHost);
          }
          if (widget instanceof cls.ScrollAreaWidget) {
            if (!this._wheelHandling) {
              this._wheelHandling = true;
              this._element.addEventListener("wheel", this._handleWheel.bind(this));
            }
            widgetGridHost.addClass('g_GridElement_scrollzone');
          } else {
            widgetGridHost.addClass('g_GridElement_scrollignore');
          }
          widgetGridHost.appendChild(widget._element);
          widgetGridHost.insertAt(position, this._containerElement);
        },

        /**
         * Manage mouseWheel event
         * @param {MouseEvent} event the event
         * @private
         */
        _handleWheel: function(event) {
          if (this._wheelHandling) {
            if (this._wheelThrottleHandler) {
              this._clearTimeout(this._wheelThrottleHandler);
            }
            if (!this._scrolling) {
              this._scrolling = true;
              this._element.addClass("g_scrolling");
            }
            this._wheelThrottleHandler = this._registerTimeout(function() {
              this._scrolling = false;
              this._wheelThrottleHandler = null;
              this._element.removeClass("g_scrolling");
            }.bind(this), this._wheelThrottleTimeout);
          }
        },

        /**
         * @inheritDoc
         */
        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          const info = widget.getLayoutInformation();
          let host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },
        /**
         * Is it GridChildrenInParent ?
         * @return {boolean} true if it is GridChildrenInParent
         */
        isGridChildrenInParent: function() {
          return this._isGridChildrenInParent;
        },
        /**
         * Set GridChildrenInParent state
         * @param {boolean} isGridChildrenInParent the wanted state
         */
        setGridChildrenInParent: function(isGridChildrenInParent) {
          if (this._isGridChildrenInParent !== isGridChildrenInParent) {
            this._isGridChildrenInParent = isGridChildrenInParent;
            if (this._isGridChildrenInParent) {
              this._moveOwnChildrenToParent();
            } else {
              this._moveOwnChildrenToSelf();
            }
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._rerouteChildren) {
            this._owned.push(widget);
            const layoutInfo = widget.getLayoutInformation();
            if (layoutInfo) {
              layoutInfo.setOwningGrid(this);
            }
            this.getParentWidget().addChildWidget(widget, options);
          } else {
            $super.addChildWidget.call(this, widget, options);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget, options) {
          if (this._rerouteChildren) {
            this.getParentWidget().removeChildWidget(widget, options);
            const layoutInfo = widget.getLayoutInformation();
            if (layoutInfo) {
              layoutInfo.setOwningGrid(null);
            }
          } else {
            $super.removeChildWidget.call(this, widget, options);
          }
        },

        /**
         * Get a copy of children list
         * @return {Array.<classes.WidgetBase>} a copy list of children
         * @private
         */
        _listChildrenToMoveWhenGridChildrenInParent: function() {
          return this._children.slice();
        },

        /**
         * Move self children to parent on GridChildrenInParent
         * @private
         */
        _moveOwnChildrenToParent: function() {
          const children = [];
          const childrenToMove = this._listChildrenToMoveWhenGridChildrenInParent();
          while (childrenToMove.length) {
            const child = childrenToMove.shift();
            this.removeChildWidget(child);
            children.push(child);
          }
          this._rerouteChildren = true;
          while (children.length) {
            this.addChildWidget(children.shift());
          }
        },
        /**
         * Move self children to itself on GridChildrenInParent
         * @private
         */
        _moveOwnChildrenToSelf: function() {
          const children = [];
          while (this._owned.length) {
            const child = this._owned[0];
            this.removeChildWidget(child);
            children.push(child);
          }
          this._rerouteChildren = false;
          while (children.length) {
            this.addChildWidget(children.shift());
          }
        }
      };
    });
  });
;

"use strict";

modulum('WidgetGroupBase', ['TextWidgetBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class WidgetGroupBase
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.WidgetGroupBase = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.WidgetGroupBase.prototype */ {
        __name: "WidgetGroupBase",
        __virtual: true,
        /**
         * the container element
         * @type HTMLElement
         * @protected
         */
        _containerElement: null,
        /**
         * the children widget
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _children: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._children = [];
          $super.constructor.call(this, opts);
        },
        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);
          this._initContainerElement();
        },

        /**
         * init the container element
         * @protected
         */
        _initContainerElement: function() {
          const elt = this._element;
          this._containerElement = elt.hasClass("containerElement") ? elt : elt.getElementsByClassName("containerElement")[0];
          if (!this._containerElement) {
            throw new Error("Widgets inheriting WidgetGroupBase must have one container with class containerElement in its template");
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._containerElement = null;
          if (this._children.length > 0) {
            gbc.error(this.__name + "(uuid: " + this.getUniqueIdentifier() + ") has been destroyed whereas it still has children");
          }
          $super.destroy.call(this);
        },

        /**
         * Destroy all children widgets
         */
        destroyChildren: function() {
          const children = this.getChildren();
          if (children) {
            for (let i = children.length - 1; i > -1; i--) {
              let currentChildren = children[i];
              currentChildren.destroy();
              currentChildren = null;
            }
          }
          this._children.length = 0;
        },

        /**
         * Get the container Element
         * @return {HTMLElement} the element
         * @publicdoc
         */
        getContainerElement: function() {
          return this._containerElement;
        },

        /**
         * Add a child widget to the widget
         * @param {classes.WidgetBase} widget the widget to add
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         * @publicdoc
         */
        addChildWidget: function(widget, options) {
          options = options || {};

          if (widget._parentWidget && widget._parentWidget !== this) {
            gbc.error(this.__name + "(uuid: " + this.getUniqueIdentifier() +
              ") addChildWidget cannot be executed if child has already a parent");
          }

          let position = Object.isNumber(options.position) ? options.position : (this._children.length);
          if (options.ordered) {
            if (this._children.length > 0) {
              for (let i = this._children.length; i > 0; i--) {
                if (widget.getAuiLinkedUniqueIdentifier() < this._children[i - 1].getAuiLinkedUniqueIdentifier()) {
                  position = i - 1;
                }
              }
            }
          }

          widget.setParentWidget(this, {
            noLayoutInvalidation: Boolean(options.noDOMInsert)
          });
          if (!options.noDOMInsert) {
            this._addChildWidgetToDom(widget, position);
            widget._setDOMAttachedOrDetached();
          }
          this._children.splice(position, 0, widget);
        },

        /**
         * Add a child widget which has already a parent to the widget
         * @param {classes.WidgetBase} widget the widget to add
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {boolean=} options.noLayoutInvalidation - won't refresh the layout
         * @param {number=} options.position - insert position
         * @param {string=} options.ordered - auto order item by unique auiID
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         * @publicdoc
         */
        adoptChildWidget: function(widget, options) {
          options = options || {};

          if (widget.getParentWidget()) {
            const children = widget.getParentWidget().getChildren();
            if (children) {
              children.remove(widget);
            }
          }

          let position = Object.isNumber(options.position) ? options.position : (this._children.length);

          if (options.ordered) {
            if (this._children.length > 0) {
              for (let i = this._children.length; i > 0; i--) {
                if (widget.getAuiLinkedUniqueIdentifier() < this._children[i - 1].getAuiLinkedUniqueIdentifier()) {
                  position = i - 1;
                }
              }
            }
          }
          if (!options.noDOMInsert) { // move DOM element
            this._addChildWidgetToDom(widget, position);
          } else { // just remove DOM element from previous location
            this._removeChildWidgetFromDom(widget);
          }
          widget.setParentWidget(this, {
            noLayoutInvalidation: Boolean(options.noDOMInsert) || Boolean(options.noLayoutInvalidation)
          });
          this._children.splice(position, 0, widget);

          widget._setDOMAttachedOrDetached();
        },

        /**
         * add child widget to dom
         * @param {classes.WidgetBase} widget the widget to add
         * @param {number} position where to add the widget
         * @protected
         */
        _addChildWidgetToDom: function(widget, position) {
          widget._element.insertAt(position, this._containerElement);
        },

        /**
         * Remove a child widget from this widget
         * @param {classes.WidgetBase} widget the widget to remove
         * @publicdoc
         */
        removeChildWidget: function(widget) {
          this._removeChildWidgetFromDom(widget);
          widget.setParentWidget(null);
          if (this._children) {
            this._children.remove(widget);
          }
          widget._setDOMAttachedOrDetached();
        },
        /**
         * remove child widget from dom
         * @param {classes.WidgetBase} widget the widget to remove
         * @protected
         */
        _removeChildWidgetFromDom: function(widget) {
          if (widget._element.parentNode === this._containerElement) {
            widget._element.remove();
          }
        },

        /**
         * Remove a child widget to use another widget instead
         * @param {classes.WidgetBase} oldWidget the widget to replace
         * @param {classes.WidgetBase} newWidget the widget to add
         * @publicdoc
         */
        replaceChildWidget: function(oldWidget, newWidget) {
          const index = this.getIndexOfChild(oldWidget);
          const layoutInfo = newWidget.getLayoutInformation();
          if (layoutInfo) {
            layoutInfo.setOwningGrid(oldWidget.getLayoutInformation() && oldWidget.getLayoutInformation().getOwningGrid());
          }
          this.removeChildWidget(oldWidget);
          this.addChildWidget(newWidget, {
            position: index,
            mode: "replace"
          });
        },

        /**
         * Remove all children
         * @publicdoc
         */
        empty: function() {
          const remove = this._children.slice();
          for (const element of remove) {
            this.removeChildWidget(element);
          }
        },

        /**
         * Get the child widget position
         * @param {classes.WidgetBase} widget the widget
         * @returns {number} widget position
         * @publicdoc
         */
        getIndexOfChild: function(widget) {
          return this._children.indexOf(widget);
        },

        /**
         * Get all children of this widget
         * @returns {classes.WidgetBase[]} the list of children of this widget group
         * @publicdoc
         */
        getChildren: function() {
          return this._children;
        },

        /**
         * Returns current widget (flagged with 'current' class)
         * @returns {?classes.WidgetBase} The current child
         * @publicdoc
         */
        getCurrentChildren: function() {
          for (const child of this._children) {
            if (child.getElement().hasClass("current")) {
              return child;
            }
          }
          return null;
        },

        /**
         * Returns visible children
         * @returns {classes.WidgetBase[]}
         */
        getVisibleChildren: function() {
          return this._children.filter(function(item) {
            return !item.isHidden();
          });
        },

        /**
         * Returns number of visible children
         * @returns {number}
         */
        getVisibleChildrenCount: function() {
          return this.getVisibleChildren().length;
        },

        /**
         * returns true if a WebComponent is contained in any sublevel child
         * @publicdoc
         * @returns {boolean} true if the widget has webcomponent, false otherwise
         */
        hasChildWebComponent: function() {
          return this._hasChildWebComponent; // Tell window that it has a Web Component
        },

        /**
         * Flag/unflag having child with WebComponent
         * @param {boolean} has - flag the widget as having a webcomponent
         */
        setHasChildWebComponent: function(has) {
          this._hasChildWebComponent = has;
        },

      };
    });
  });
;

"use strict";

modulum('WidgetPlaceholderBase', ['WidgetBase'],
  function(context, cls) {

    /**
     * Base for placeholder widget.
     * @class WidgetPlaceholderBase
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.WidgetPlaceholderBase = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.WidgetPlaceholderBase.prototype */ {
        __name: 'WidgetPlaceholderBase',

        /**
         * All the virtual widgets inside the placeholder
         * @type {Map}
         */
        _children: null,

        /**
         * Position of the placeholder in his parent
         * @type {number}
         */
        _positionInParent: null,

        /**
         * Current active parent id
         * @type {number}
         */
        _activeParentId: null,

        _appliedStyle: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._appliedStyle = new Map();
          this._children = new Map();
          this._positionInParent = 0;
          this._activeParentId = 0;

          $super.constructor.call(this, opts);
        },

        /**
         * Get the widget key for the children map
         * @param {number} parentId
         * @param {classes.WidgetBase} widget
         * @return {string}
         * @private
         */
        _getVirtualChildrenKey: function(parentId, widget) {
          return widget === null ? parentId + "-" :
            parentId + "-" + widget.getUniqueIdentifier();
        },

        /**
         * Append a widget in the placeholder
         * @param {number} parentId
         * @param {classes.WidgetBase} widget
         */
        appendVirtualChildWidget: function(parentId, widget) {
          this.addVirtualChildWidget(parentId, widget, this._children.size);
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this._appliedStyle.set('setDefaultTTFColor', color);
          this._children.forEach((info) => {
            if (info.widget.setDefaultTTFColor) {
              info.widget.setDefaultTTFColor(color);
            }
          });
        },

        /**
         * Add a virtual widget in the placeholder
         * @param {number} parentId
         * @param {classes.WidgetBase} widget virtual widget to add
         * @param {number} position position in the parent widget
         */
        addVirtualChildWidget: function(parentId, widget, position) {
          const childKey = this._getVirtualChildrenKey(parentId, widget);

          widget.getElement().setAttribute("placeholderId", this.getUniqueIdentifier());

          let posInParent = this._positionInParent;

          this._children.set(childKey, {
            widget: widget,
            position: position
          });

          widget.when(context.constants.widgetEvents.destroyed, (event, widget) => {
            const key = this._getVirtualChildrenKey(parentId, widget);
            if (this._children && this._children.has(key)) {
              this._children.delete(key);
            }
          });

          let parentWidget = this.getParentWidget();
          if (parentWidget instanceof cls.ChromeBarWidget) {
            parentWidget = this;
          }

          let options = {};
          options.position = posInParent + position;

          if (this._activeParentId === parentId) {
            parentWidget.addChildWidget(widget, options);
            parentWidget.getLayoutEngine().invalidateMeasure();
            parentWidget.getLayoutEngine().forceMeasurement();
          }

          this._layoutEngine.invalidateMeasure();
          this._layoutEngine.forceMeasurement();
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget) {
          const element = this._element;

          element.appendChild(widget.getElement());
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          widget._element.remove();
        },

        /**
         * Set placeholder the position in is parent widget
         * @param {number} position
         */
        setPositionInParent: function(position) {
          this._positionInParent = position;
        },

        /**
         * Set the active parent id (example: Menu id)
         * @param {number} parentId
         */
        setActiveParentId: function(parentId) {
          this._refreshChild(parentId);
        },

        /**
         * Get the current active parent id
         * @return {number}
         */
        getActiveParentId: function() {
          return this._activeParentId;
        },

        /**
         * Get the count of displayed widgets
         * @return {number}
         */
        getDisplayedWidgetCount: function() {
          let keyStart = this._getVirtualChildrenKey(this._activeParentId, null);
          let count = 0;
          for (let [key, info] of this._children) {
            if (key.startsWith(keyStart) /*&& !info.widget.isHidden()*/ ) {
              count++;
            }
          }

          return count;
        },

        /**
         * Refresh the DOM content of the placeholder
         * @param parentId the widgets of this parent are attached to the DOM
         * @param force
         * @private
         */
        _refreshChild: function(parentId, force) {
          if (this._activeParentId === parentId && !force) {
            return;
          }

          //Update placeholder content according to the new active widget
          let newKeyStart = this._getVirtualChildrenKey(parentId, null);
          let oldKeyStart = this._getVirtualChildrenKey(this._activeParentId, null);

          let parentWidget = this.getParentWidget();

          if (parentWidget instanceof cls.ChromeBarWidget) {
            parentWidget = this;
          }

          for (let [key, info] of this._children) {
            if (key.startsWith(oldKeyStart)) {
              parentWidget.removeChildWidget(info.widget);
            }
          }

          let posInParent = this._positionInParent;
          const options = {};
          for (let [key, info] of this._children) {
            if (key.startsWith(newKeyStart)) {
              options.position = posInParent + info.position;
              parentWidget.addChildWidget(info.widget, options);
            }
          }

          this._activeParentId = parentId;
        },

        /**
         * @inheritDoc
         */
        setFontSize: function(size) {
          this._appliedStyle.set('setFontSize', size);
          this._children.forEach((info) => {
            if (info.widget.setFontSize) {
              info.widget.setFontSize(size);
            }
          });
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          this._appliedStyle.set('setFontStyle', style);
          this._children.forEach((info) => {
            if (info.widget.setFontStyle) {
              info.widget.setFontStyle(style);
            }
          });
        },

        /**
         * @inheritDoc
         */
        setNoBorder: function(noBorder) {
          this._appliedStyle.set('setNoBorder', noBorder);
          this._children.forEach((info) => {
            if (info.widget.setNoBorder) {
              info.widget.setNoBorder(noBorder);
            }
          });
        },

        /**
         * @inheritDoc
         */
        setButtonType: function(buttonType) {
          this._appliedStyle.set('setButtonType', buttonType);
          this._children.forEach((info) => {
            if (info.widget.setButtonType) {
              info.widget.setButtonType(buttonType);
            }
          });
        },

        /**
         * @inheritDoc
         */
        setFontColor: function(color) {
          this._appliedStyle.set('setFontColor', color);
          this._children.forEach((info) => {
            if (info.widget.setFontColor) {
              info.widget.setFontColor(color);
            }
          });
        },

        /**
         * @inheritDoc
         */
        setWrapPolicy: function(format) {
          this._appliedStyle.set('setWrapPolicy', format);
          this._children.forEach((info) => {
            if (info.widget.setWrapPolicy) {
              info.widget.setWrapPolicy(format);
            }
          });
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this._appliedStyle.clear();
          this._appliedStyle = null;

          if (this._children) {
            this.destroyAllChildren();
            this._children = null;
          }

        },

        /**
         * Destroy all the known children
         */
        destroyAllChildren: function() {
          this._children.forEach((info) => {
            let w = info.widget,
              realWidget = w.getAUIWidget();

            if (realWidget.removeVirtualChildWidget) {
              realWidget.removeVirtualChildWidget(w);
            }

            info.widget.destroy();
          });

          this._children.clear();
        },

        /**
         * get Virtual widget corresponding to the real one
         * @param {classes.WidgetBase} realWidget
         * @return {null|classes.WidgetBase}
         */
        getVirtualWidget: function(realWidget) {
          for (let info of this._children.values()) {
            if (info.widget.getAUIWidget() === realWidget) {
              return info.widget;
            }
          }

          return null;
        },

        applyCommonStyleToWidget: function(widget) {
          this._appliedStyle.forEach((value, methode) => {
            widget[methode](value);
          });
        }
      };
    });
  });
;

"use strict";

modulum('MenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Menu widget.
     * @class MenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MenuWidget.prototype */ {
        __name: 'MenuWidget',

        /**
         * Element that hold the text
         * @protected
         * @type HTMLElement
         */
        _textElement: null,

        /** @type {?string} */
        _text: null,

        /**
         * Image of the menu
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * If menu is set as modal, it's stored here
         * @protected
         * @type {classes.ModalWidget}
         */
        _modalWidget: null,

        /**
         * Type of the menu
         * @protected
         * @type {?string}
         */
        _menuType: null,

        /**
         * last known menu panel position
         * @type {!string}
         */
        _menuPanelPosition: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._textElement = this._element.getElementsByClassName('gbc_MenuWidgetText')[0];

          // default orientation is vertical
          this._element.removeClass('gbc_MenuWidget_horizontal').addClass('gbc_MenuWidget_vertical');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.MenuLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._modalWidget) {
            this._modalWidget.hide();
            this._modalWidget.destroy();
            this._modalWidget = null;
          }

          if (this._image) {
            this._image.destroy();
            this._image = null;
          }

          this._textElement = null;

          $super.destroy.call(this);
        },

        /**
         * Set the text of the menu
         * @param {string} text - text to set
         */
        setText: function(text) {
          if (!this._chromeBar) {
            this._text = text;
            this._setTextContent(text, "_textElement");
            this.setAriaAttribute('label', this.getText());
          }
        },

        /**
         * Get the text of the menu
         * @return {string}
         */
        getText: function() {
          return this._text;
        },

        /**
         * Define the image of the menu
         * @param {classes.ImageWidget} image - img widget
         */
        setImage: function(image) {
          if (!this._image) {
            if (!image) {
              return;
            }
            this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
            this._element.getElementsByClassName('gbc_MenuWidgetTitle')[0].prependChild(this._image.getElement());
          }
          this._image.setSrc(image);
        },

        /**
         * Get image of the menu
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Set the tooltip of the menu
         * @param {string} title the tooltip text
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title of the menu
         * @returns {string} the tooltip text
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          if (this._modalWidget) {
            this._modalWidget.setBackgroundColor(color);
          }
        },

        /**
         * show the modal
         */
        showModal: function() {
          if (this.isEnabled() && this._modalWidget && (this.isModal() || this.isPopup())) {
            this._modalWidget.show();
          }
        },

        /**
         * Set the menu state
         * @param {boolean} enabled - true if the widget allows user interaction, false otherwise.
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          // if a menu get active and was previously hidden, it has to be displayed
          // And added to back to the dom if needed
          if (enabled) {
            this._appendToMenuContainer();
            if (this.isHidden()) {
              this.setHidden(false);
            }
          }
          // a modal or popup which gets disabled has to be hidden
          if (!enabled && this._modalWidget && this._modalWidget.isVisible() && (this.isModal() || this.isPopup())) {
            this._modalWidget.hide();
          }
        },

        /**
         * Change the orientation of the menu
         * @param {string} orientation  - layout orientation. 'vertical' or 'horizontal'.
         */
        setOrientation: function(orientation) {
          if (this.getOrientation() !== orientation) {
            this._element.toggleClass('gbc_MenuWidget_horizontal', orientation !== 'vertical');
            this._element.toggleClass('gbc_MenuWidget_vertical', orientation === 'vertical');
          }
        },

        /**
         * Get the orientation of the menu
         * @returns {string} 'vertical' or 'horizontal'.
         */
        getOrientation: function() {
          if (this._element.hasClass('gbc_MenuWidget_vertical')) {
            return 'vertical';
          }
          return 'horizontal';
        },

        /**
         * Set menu visibility
         * @param {boolean} hidden - hide the menu if set to true
         */
        setHidden: function(hidden) {
          if (this._hidden !== Boolean(hidden)) {
            this._hidden = Boolean(hidden);
            $super.setHidden.call(this, hidden);
            if (this._modalWidget) {
              if (this._hidden) {
                this._modalWidget.hide();
              } else {
                this._modalWidget.show();
              }
            }
          }
          if (this._chromeBar) {
            this._chromeBar.setMenuItemsHidden(hidden);
          }
        },

        /**
         * Know if menu is displayed as popup
         * @return {boolean}
         */
        isPopup: function() {
          return this._menuType === 'popup';
        },

        /**
         * Know if menu is displayed as a modal
         * @return {boolean}
         */
        isModal: function() {
          return this._menuType === 'dialog' || this._menuType === 'winmsg'; // winmsg = fgldialog
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isPopup() && this._modalWidget && this._modalWidget.isVisible()) {
            switch (keyString) {
              case "space":
              case "enter":
              case "return":
                if (this._modalWidget.getCurrentChildren()) {
                  this._modalWidget.getCurrentChildren().emit(context.constants.widgetEvents.click, null);
                  keyProcessed = true;
                }
                break;
            }

            if (!keyProcessed) {
              keyProcessed = this._modalWidget.managePriorityKeyDown(keyString, domKeyEvent, repeat);
            }
          }
          return keyProcessed;
        },

        /**
         * Defines the menu to be displayed as a modal one
         * @param {string} modalType - could be 'popup', 'dialog' or 'winmsg'
         */
        setAsModal: function(modalType) {
          this._menuType = modalType;
          const tabbedMode = context.SessionService.getCurrent().isInTabbedContainerMode();
          // DROPDOWN MENU
          if (this.isPopup()) {
            this._modalWidget = cls.WidgetFactory.createWidget('ChoiceDropDown', this.getBuildParameters());
            this._modalWidget.setParentWidget(this, {
              noLayoutInvalidation: true
            });
            this._modalWidget.getElement().addClass('menu');

            while (this.getChildren().length) {
              this._modalWidget.adoptChildWidget(this.getChildren().shift());
            }
            //Place it at the middle center of the screen if menu opens automatically
            this._modalWidget.x = context.WidgetService.cursorX || 'CENTER';
            this._modalWidget.y = context.WidgetService.cursorY || 'CENTER';

            this._modalWidget.when(cls.DropDownWidget.widgetEvents.dropDownClose, this._onClose.bind(this));

            this._onRequestFocus(); // request focus

            // display dropdown in animation frame because we need dropdown items (menuaction) to be measured before dropdown
            this.afterDomMutator(function() {
              this._modalWidget.show();
            }.bind(this));

            // MODAL MENU
          } else if (this.isModal()) {
            const parentWidget = tabbedMode ? this.getApplicationWidget() : this.getWindowWidget();

            if (!this._modalWidget) {
              this._modalWidget = cls.WidgetFactory.createWidget('Modal', this.getBuildParameters());
              let parentNode = parentWidget.getElement();
              if (parentWidget.isModal) {
                parentNode = parentWidget.getModal().getElement().parentNode;
              }
              parentNode.appendChild(this._modalWidget.getElement());
            }

            this._modalWidget.setHeader(this.getText());
            if (parentWidget.getModal) {
              const parentModal = parentWidget.getModal();
              if (parentModal) {
                parentModal.setClosable(false);
              }
            }

            this._modalWidget.setImage(this.getImage());
            this._modalWidget.setClosable(false);
            this._modalWidget.setContent(this.getTitle());
            this._modalWidget.setFooter(this.getElement());
            this._modalWidget.addClass('gbc_ModalMenuDialog');
            if (this._menuType === 'winmsg') {
              this._modalWidget.addClass('isWinMSG');
            }

            if (tabbedMode) {
              this._modalWidget.addClass('tabbedContainer_Modal');
            }
            this.setOrientation('horizontal');
            this._element.addClass('gbc_ModalMenu');
            this._modalWidget.setStyle('.mt-dialog-content', {
              'white-space': 'pre-wrap',
              'text-align': 'center'
            });
            this._modalWidget.setBackgroundColor(this._backgroundColor);

            this._modalWidget.show();
          }
        },

        /**
         * Will update the position if menu is in a modal
         * @private
         */
        _updateModalPosition: function() {
          if (this._modalWidget && this._modalWidget.resizeHandler) {
            this._modalWidget.resizeHandler();
          }
        },

        /**
         * Define this menu as a chromebar
         * @param chromeBar
         */
        setAsChromeBar: function(chromeBar) {
          this._chromeBar = chromeBar;
        },

        /**
         * Check if this menu is a chromebar
         * @return {boolean}
         */
        isChromeBar: function() {
          return Boolean(this._chromeBar);
        },

        /**
         * @inheritDoc
         */
        _onClose: function() {
          this.emit(context.constants.widgetEvents.close);
        },

        /**
         * Manage actionPanel position
         * actionPanelPosition (Dialog) + ringMenuPosition (Menu) 4ST attribute
         * @param position
         */
        setActionPanelPosition: function(position) {
          if (this._menuPanelPosition === position) {
            return;
          }

          if (!this._menuType) {
            this._menuPanelPosition = position;
            const isInWindowMenuContainer = this._appendToMenuContainer();
            if (!isInWindowMenuContainer) {
              this.setHidden(true);
            }
            this.getWindowWidget().getLayoutEngine().invalidateAllocatedSpace();
          }
        },

        /**
         * Append the menu to the menuContainer of the windowWidget
         * @returns {boolean} True, if the widget is in the windowMenuContainer, false otherwise
         * @private
         */
        _appendToMenuContainer: function() {
          const windowWidget = this.getWindowWidget();
          if (!windowWidget) {
            return false;
          }

          const windowMenuContainer = windowWidget.getMenuContainer(this._menuPanelPosition);
          if (!windowMenuContainer) {
            return false;
          }

          if (windowMenuContainer.firstChild !== this._element) {
            if (windowMenuContainer.firstChild) {
              windowMenuContainer.removeChild(windowMenuContainer.firstChild);
            }
            windowMenuContainer.appendChild(this._element);
          }
          this.domAttributesMutator(function(windowMenuContainer) {
            windowMenuContainer.removeClass('hidden');
          }.bind(this, windowMenuContainer));
          return true;
        },

        /**
         * @inheritDoc
         */
        hasFocus: function() {
          return true;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Menu', cls.MenuWidget);
    cls.WidgetFactory.registerBuilder('Dialog', cls.MenuWidget);
  });
;

"use strict";

modulum('StartMenuCommandWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuCommand widget.
     * @class StartMenuCommandWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     */
    cls.StartMenuCommandWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.StartMenuCommandWidget.prototype */ {
        __name: 'StartMenuCommandWidget',

        /**
         * Image of the startMenu command
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;

          }
          $super.destroy.call(this);
        },

        /**
         * Set the text of the command
         * @param {string} text
         */
        setText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName('gbc_startMenuCommandText')[0];
          }.bind(this));
        },

        /**
         * Get the text of the command
         * @return {string}
         */
        getText: function() {
          return this._element.getElementsByClassName('gbc_startMenuCommandText')[0].textContent;
        },

        /**
         * Set the title to appear as tooltip
         * @param {string} title
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title to appear as tooltip
         * @return {string}
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        },

        /**
         * Define the command image
         * @param {string} image
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._element.prependChild(this._image.getElement());
            }
            this._image.setSrc(image);
          }
        },

        /**
         * Get image of the command
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuCommand', cls.StartMenuCommandWidget);
  });
;

"use strict";

modulum('StartMenuGroupWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuGroup widget.
     * @class StartMenuGroupWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StartMenuGroupWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StartMenuGroupWidget.prototype */ {
        __name: 'StartMenuGroupWidget',

        /**
         * Image of the startMenu command
         * @protected
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;

          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.elementOrParent("gbc_startMenuGroupTitle") && this.isEnabled()) { // only click on group title are managed
            this._element.classList.toggle('gbc_open');
            if (this.getElement().parent("gbc_startMenuContainer")) {
              context.SessionService.getCurrent().getCurrentApplication().scheduler.layoutCommand({
                resize: true
              });
            }
          }
          gbc.HostService.updateDisplay(); // re-align everything in window
          return false;
        },

        /**
         * Set the text of the group
         * @param {string} text
         */
        setText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName('gbc_startMenuGroupTitleText')[0];
          }.bind(this));
        },

        /**
         * Get the text of the group
         * @return {string}
         */
        getText: function() {
          return this._element.getElementsByClassName('gbc_startMenuGroupTitleText')[0].textContent;
        },

        /**
         * Define the command image
         * @param {string} image
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._element.child('gbc_startMenuGroupTitle').prependChild(this._image.getElement());
            }
            this._image.setSrc(image);
          }
        },

        /**
         * Get image of the command
         * @return {?string} - source of the image, null if not set
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuGroup', cls.StartMenuGroupWidget);
  });
;

"use strict";

modulum('StartMenuSeparatorWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuSeparator widget.
     * @class StartMenuSeparatorWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     */
    cls.StartMenuSeparatorWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.StartMenuSeparatorWidget.prototype */ {
        __name: 'StartMenuSeparatorWidget'
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuSeparator', cls.StartMenuSeparatorWidget);
  });
;

"use strict";

modulum('StartMenuTopMenuWidget', ['TopMenuWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenuTopMenu widget.
     * @class StartMenuTopMenuWidget
     * @memberOf classes
     * @extends classes.TopMenuWidget
     */
    cls.StartMenuTopMenuWidget = context.oo.Class(cls.TopMenuWidget, function($super) {
      return /** @lends classes.StartMenuTopMenuWidget.prototype */ {
        __name: 'StartMenuTopMenuWidget',
        __templateName: 'TopMenuWidget',

        _allowInSidebar: false // StartMenu with topmenu rendering will never switch to the sidebar

      };
    });
    cls.WidgetFactory.registerBuilder('StartMenuTopMenu', cls.StartMenuTopMenuWidget);
  });
;

"use strict";

modulum('StartMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StartMenu widget.
     * @class StartMenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StartMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StartMenuWidget.prototype */ {
        __name: 'StartMenuWidget',
        /**
         * Element that hold the text
         * @type Element
         */
        _textElement: null,
        _resizerElement: null,
        _resizeHandle: null,
        _dragHandle: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._textElement = this._element.getElementsByClassName('gbc_StartMenuText')[0];

          this._currentSize = 100;
          this._resizerElement = this._element.getElementsByClassName("resizer")[0];
          this._panel = this._element.getElementsByClassName("panel")[0];
          this._dragHandle = this._resizerElement.getElementsByClassName("firefox_placekeeper")[0];
          this._resizerElement.setAttribute("draggable", "true");
          this._resizerElement.on("dragstart.ApplicationHostSidebarWidget", this._onDragStart.bind(this));
          this._resizerElement.on("dragend.ApplicationHostSidebarWidget", this._onDragEnd.bind(this));
          this._resizerElement.on("drag.ApplicationHostSidebarWidget", this._onDrag.throttle(5).bind(this));
          window.addEventListener("resize", this.updateResizeTimer.bind(this));

        },

        updateResizeTimer: function() {
          if (window.isMobile() && !window.isOrientationImplemented) {
            window.orientation = window.innerWidth > window.innerHeight ? 90 : 0;
          }
          // for mobiles, only relayout on screen orientation
          if (this._resizeHandle) {
            this._clearTimeout(this._resizeHandle);
            this._resizeHandle = null;
          }
          if (!window.isMobile() || this._screenOrientation !== window.orientation) {
            this._screenOrientation = window.orientation;

            this._resizeHandle = this._registerTimeout(this.updateResize.bind(this, null, false), 100);
          }
        },
        updateResize: function(deltaX, absolute) {
          const previousSize = this._currentSize;
          this._resizeHandle = null;

          let max = 400;
          if (absolute) {
            this._currentSize = deltaX;
          } else {
            this._currentSize = (Object.isNumber(this._origin) ? this._origin : this._currentSize) + (deltaX || 0);
            if (this._currentSize < 16) {
              this._currentSize = 16;
            }
          }
          if (this._currentSize > max) {
            this._currentSize = max;
          }

          this._panel.style.width = this._currentSize + 'px';
          // if sidebar size or visibility changed, we emit displayChanged
          if (this._currentSize !== previousSize) {
            // if sidebar size changed only, we update size
            this.setStyle({
              width: this._currentSize + "px"
            });
            // Save sidebar width into storedSettings
            gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
          }
          gbc.HostService.updateDisplay(); // re-align everything in window
          this._panel.querySelector(".wrapper").scrollLeft = 0;
          this.emit(context.constants.widgetEvents.displayChanged);
        },

        _onDragOver: function(evt) {
          this._pageX = evt.clientX || evt.screenX || evt.pageX;
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          document.body.on("dragover.ApplicationHostSidebarWidget", this._onDragOver.bind(this));
          this._isDragging = true;
          if (window.browserInfo.isFirefox) {
            evt.dataTransfer.setData('text', ''); // for Firefox compatibility
          }
          if (evt.dataTransfer.setDragImage) {
            evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
          }
          evt.dataTransfer.effectAllowed = "move";
          this._pageX = this._resizerDragX = evt.clientX || evt.screenX || evt.pageX;
          this._origin = this._currentSize;
        },
        _onDragEnd: function(evt) {
          document.body.off("dragover.ApplicationHostSidebarWidget");
          this._isDragging = false;
          this._origin = this._currentSize;
          // Save sidebar width into storedSettings
          gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            const deltaX = this._pageX - this._resizerDragX;
            this.updateResize(deltaX);

          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * Set the text of the group
         * @param {string} text
         */
        setText: function(text) {
          this._setElementAttribute('title', text, "_textElement");
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the group
         * @return {string}
         */
        getText: function() {
          return this._textElement.textContent;
        },
        setProcessing: function(isProcessing) {
          if (this.getElement()) {
            if (isProcessing) {
              this.getElement().setAttribute("processing", "processing");
            } else {
              this.getElement().removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StartMenu', cls.StartMenuWidget);
  });
;

"use strict";

modulum('ToolBarItemWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBarItem widget.
     * @class ToolBarItemWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc
     */
    cls.ToolBarItemWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.ToolBarItemWidget.prototype */ {
        __name: 'ToolBarItemWidget',

        /** @type {HTMLElement} */
        _textElement: null,
        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _imageContainer: null,
        /** @type {boolean} */
        _autoScale: false,
        /** @type {string|null} */
        _defaultTTFColor: null,

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);
          this._textElement = this._element.getElementsByTagName('span')[0];
          this._imageContainer = this._element.getElementsByClassName('gbc_imageContainer')[0];
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return true;
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this._defaultTTFColor = color;
          if (this._image) {
            this._image.setDefaultColor(color);
          }
        },

        /**
         * Set the text of the toolbar item
         * @param {string} text the text
         * @publicdoc
         */
        setText: function(text) {
          this._hasText = text.length > 0;
          this.toggleClass("hasText", this._hasText);
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the toolbar item
         * @return {string} the text of the item
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Define the toolbar item image
         * @param {string} image - image url to use
         * @publicdoc
         */
        setImage: function(image) {
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());
              this.setAutoScale(this._autoScale);
              this.setDefaultTTFColor(this._defaultTTFColor);
            }
            this._image.setSrc(image);
          } else if (this._image) {
            this._image.getElement().remove();
            this._image.destroy();
            this._image = null;
          }
          this.toggleClass("hasImage", !!this._image);
        },

        /**
         * Get image of the toolbar item
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Define autoScale or not for this item
         * @param {boolean} enabled autoscale state
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._autoScale = enabled;
          if (this._image) {
            this._image.setAutoScale(this._autoScale);
          }
          this._imageContainer.toggleClass('gbc_autoScale', this._autoScale);
        },

        setScaleIconValue: function(value) {
          if (this._image) {
            this._image.setScaleIconValue(value);
          }
        },

        /**
         * Set the title to appear as tooltip
         * @param {string} title - tooltip text
         * @publicdoc
         */
        setTitle: function(title) {
          this._element.setAttribute('title', title);
        },

        /**
         * Get the title to appear as tooltip
         * @return {string} the title
         * @publicdoc
         */
        getTitle: function() {
          return this._element.getAttribute('title');
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ToolBarItem', cls.ToolBarItemWidget);
  });
;

"use strict";

modulum('ToolBarPlaceholderWidget', ['WidgetPlaceholderBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBarPlaceholderWidget widget.
     * @class ToolBarPlaceholderWidget
     * @memberOf classes
     * @extends classes.WidgetPlaceholderBase
     * @publicdoc Widgets
     */
    cls.ToolBarPlaceholderWidget = context.oo.Class(cls.WidgetPlaceholderBase, function($super) {
      return /** @lends classes.ToolBarPlaceholderWidget.prototype */ {
        __name: 'ToolBarPlaceholderWidget',

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Define autoScale or not for this item
         * @param {boolean} enabled autoscale state
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._appliedStyle.set('setAutoScale', enabled);
          this._children.forEach((info) => {
            if (info.widget.setAutoScale) {
              info.widget.setAutoScale(enabled);
            }
          });
        },

        /**
         * Set autoscale value as nnnpx
         * @param {string} value - css string value with valid units
         * @publicdoc
         */
        setScaleIconValue: function(value) {
          this._appliedStyle.set('setScaleIconValue', value);
          this._children.forEach((info) => {
            if (info.widget.setScaleIconValue) {
              info.widget.setScaleIconValue(value);
            }
          });
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ToolBarPlaceholder', cls.ToolBarPlaceholderWidget);
  });
;

"use strict";

modulum('ToolBarSeparatorWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBarSeparator widget.
     * @class ToolBarSeparatorWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     * @publicdoc
     */
    cls.ToolBarSeparatorWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.ToolBarSeparatorWidget.prototype */ {
        __name: 'ToolBarSeparatorWidget',
        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ToolBarSeparator', cls.ToolBarSeparatorWidget);
  });
;

"use strict";

modulum('ToolBarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ToolBar widget.
     * @class ToolBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.ToolBarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ToolBarWidget.prototype */ {
        __name: 'ToolBarWidget',

        /**
         * Widget to use to scroll on toolbar
         * @type {classes.FlowDecoratorWidget}
         */
        _flowDecoratorWidget: null,

        /** @type {Element} **/
        _flowDecoratorContainer: null,

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,

        _resizeHandler: null,

        /** @type {classes.FormWidget} **/
        _formWidget: null,

        /** @type {string} **/
        _position: null,

        toolbarAspectChange: "g_toolbarAspectChange",

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._flowDecoratorWidget = cls.WidgetFactory.createWidget("FlowDecorator", this.getBuildParameters());
          this._flowDecoratorWidget.setParentWidget(this);
          this._flowDecoratorWidget.setOrientation("vertical");
          this._flowDecoratorWidget.setRendering("list");
          this._flowDecoratorContainer = this.getElement().querySelector(".mt-tab-flow");
          this._flowDecoratorContainer.appendChild(this._flowDecoratorWidget.getElement());
          this._resizeHandler = context.HostService.onScreenResize(this._onResize.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowLayoutEngine(this);
          this._layoutEngine.setFlowDecoratorWidget(this._flowDecoratorWidget);
        },

        /**
         * Handler called when screen is resized
         * @private
         */
        _onResize: function() {
          this._layoutEngine.forceMeasurement();
          this._layoutEngine.invalidateMeasure();
        },

        /**
         * Set Priority of this toolbar
         * @param {number} order the priority of this toolbar
         * @publicdoc
         */
        setOrder: function(order) {
          this.setStyle({
            order: order
          });
        },

        /**
         * Get Priority of this toolbar
         * @returns {number} priority of this toolbar
         * @publicdoc
         */
        getOrder: function() {
          return this.getStyle('order');
        },

        /**
         * Show/hide the text of the toolbar items
         * @param {boolean} state - true to display text under image, false to hide it
         * @publicdoc
         */
        setButtonTextHidden: function(state) {
          if (state) {
            this.getElement().addClass('buttonTextHidden');
          } else {
            this.getElement().removeClass('buttonTextHidden');
          }
        },

        /**
         * Set toolbar button size
         * @param {String} buttonSize - size of the buttons
         */
        setButtonSize: function(buttonSize) {
          this.removeClass("button-small");
          this.removeClass("button-large");
          this.addClass("button-" + buttonSize);

          // re-measure children
          this.getChildren().slice(1).forEach(item => {
            item.getLayoutEngine().forceMeasurement();
            item.getLayoutEngine().invalidateMeasure();
          });
          this._layoutEngine._refresh();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._flowDecoratorWidget) {
            this._flowDecoratorWidget.destroy();
            this._flowDecoratorWidget = null;
          }
          if (this._resizeHandler) {
            this._resizeHandler();
            this._resizeHandler = null;
          }
          if (this.isChromeBar()) {
            this._chromeBar = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Define this Toolbar as a ChromeBar part
         * @param {classes.ChromeBarWidget} chromeBar - widget to set
         */
        setAsChromeBar: function(chromeBar) {
          this._chromeBar = chromeBar;
        },

        /**
         * Check if this toolbar is a chromeBar part
         * @return {boolean} - true if widget is a chromebar, false otherwise
         */
        isChromeBar: function() {
          return Boolean(this._chromeBar);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.hasClass("gbc_FlowDecoratorWidget")) {
            this._flowDecoratorWidget.closeDropDown();
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (keyString === "esc") {
            //ESC key to close the dropdown of the continuous flow decorator
            if (this._flowDecoratorWidget && this._flowDecoratorWidget.isDropDownOpen()) {
              this._flowDecoratorWidget.closeDropDown();
              keyProcessed = true;
            }
          }
          return keyProcessed;
        },

        /**
         * Get the 3 dots real width
         * @return {number} width in px
         */
        getDecoratorWidth: function() {
          return this._flowDecoratorWidget.getLayoutInformation().getRawMeasure().getWidth();
        },

        /**
         *
         * @return {classes.FlowDecoratorWidget}
         */
        getFlowDecoratorWidget: function() {
          return this._flowDecoratorWidget;
        },

        /**
         * Define the form linked to this toolbar
         * Mainly used for layout calculation in modal window
         * @param {classes.FormWidget} widget - the form widget to link
         */
        setFormWidget: function(widget) {
          this._formWidget = widget;
        },

        /**
         * Define the Aspect of the Toolbar
         * @param {String} mode - could be "icon", "text" or "both" (default)
         */
        setAspect: function(mode) {
          this._aspect = mode;
          this._element.setAttribute("gbc_toolbaraspect", mode);
          this.emit(this.toolbarAspectChange, mode);
        },

        /**
         *
         * @param {String} size - could be "small", ""
         */
        setItemSize: function(size) {

        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          hidden = this._position === "none" || hidden;
          $super.setHidden.call(this, hidden);
        },

        /**
         * Set toolbar items alignment
         * @param {string} alignment : 'left' (default), 'right', 'center', 'justify'
         */
        setToolBarItemsAlignment: function(alignment) {
          if (this._itemsAlignment !== alignment) {
            if (this._itemsAlignment) {
              this.getContainerElement().removeClass(this._itemsAlignment);
            }
            this._itemsAlignment = alignment;
            if (this.getContainerElement()) {
              this.getContainerElement().addClass(alignment);
            }
          }
        },

        getPosition: function() {
          return this._position;
        },

        setPosition: function(position) {
          this._position = position;
        },
        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);

          if (this._chromeBar) {
            //If we are in a chromebar we must also add the new child to it
            this._chromeBar.addItemWidget(widget, options);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ToolBar', cls.ToolBarWidget);
  });
;

"use strict";

modulum('TopMenuCommandWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuCommand widget.
     * @class TopMenuCommandWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.TopMenuCommandWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.TopMenuCommandWidget.prototype */ {
        __name: 'TopMenuCommandWidget',
        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _anchorElement: null,
        /** @type {HTMLElement} */
        _commentContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);

          this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
          this._image.setAutoScale(true);
          this._element.prependChild(this._image.getElement());

          this._anchorElement = this._element.querySelector('span.anchor');
          this._commentContainer = this._element.querySelector('span.gbc-label-comment-container');

          this._element.on('mouseover.TopMenuCommandWidget', this._onMouseover.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._element) {
            this._element.off('mouseover.TopMenuCommandWidget');
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this.isEnabled() || this.isInterruptable()) {
            this.emit(context.constants.widgetEvents.click, domEvent);
          }
          // If the command widget is in sidebar, close it
          let sideBarTopmenu = this.getParentWidget(cls.RSidebarTopMenuWidget);
          if (sideBarTopmenu) {
            context.HostLeftSidebarService.showTopMenu(false);
            sideBarTopmenu.emit("close");
          }
          return true;
        },

        /**
         * Hide previous sub menu displayed from a same level topmenugroup
         * @param event
         * @private
         */
        _onMouseover: function(event) {
          cls.DropDownWidget.hideAll(event.target);
        },

        /**
         * Set the text of the command item
         * @param {string} text - text to display
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_anchorElement");
        },

        /**
         * Set a comment for the Command item
         * @param {string} comment - accelerator name
         * @publicdoc
         */
        setComment: function(comment) {
          const regex = /([^A-Za-z]*\+|\-)([A-Za-z])$/g;
          if (window.browserInfo.isSafari) {
            comment = comment.replace(/control/ig, "⌘")
              .replace(regex, function(match) {
                return match.toUpperCase();
              })
              .replace("-", " ");
          } else {
            comment = comment.replace("-", "+")
              .replace(/control/ig, "Ctrl")
              .replace(regex, function(match) {
                return match.toUpperCase();
              });
          }
          this._commentContainer.textContent = comment;
        },

        /**
         * Get the text of the command item
         * @return {string} - text of the command item
         * @publicdoc
         */
        getText: function() {
          return this._anchorElement.textContent;
        },

        /**
         * Define the topmenu command image
         * @param {string} image - url source of the image
         * @publicdoc
         */
        setImage: function(image) {
          this._image.setSrc(image);
        },

        /**
         * Get image of the topmenu command
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this.setStyle(".gbc_ImageWidget svg", {
            'fill': color
          });
        },
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuCommand', cls.TopMenuCommandWidget);
  });
;

"use strict";

modulum('TopMenuGroupWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuGroup widget.
     * @class TopMenuGroupWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.TopMenuGroupWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TopMenuGroupWidget.prototype */ {
        __name: 'TopMenuGroupWidget',

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {classes.DropDownWidget} */
        _dropDown: null,
        /** @type {HTMLElement} */
        _textElement: null,
        /**
         * Top div element used as main container to disable pointer events on topmenu opening
         * @type {HTMLElement}
         */
        _mainContainerWidget: null,
        /**
         * Indicates if topmenugroup is a sub menu (child of another topmenugroup) or not
         * @type {?boolean}
         */
        _isSubMenu: null,

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._mainContainerWidget = window.document.getElementsByClassName("gbc_MainContainerWidget")[0];

          this._textElement = this._element.getElementsByTagName('span')[0];

          this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
          this._image.setAutoScale(true);
          this._element.prependChild(this._image.getElement());

          this._responsiveMenuWidget = this.getParentWidget() && this.getParentWidget()._responsiveMenuWidget;
          this._dropDown = cls.WidgetFactory.createWidget('ChoiceDropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.setBackgroundColor(this.getBackgroundColor());

          // on dropdown opening we set 'current' class for top level topmenugroup item
          this._dropDown.onOpen(function() {
            if (!this.isSubMenu()) {
              this.addClass("current");
              this.getParentWidget().addClass("open");
            }
          }.bind(this));
          // on dropdown close we remove 'current' class for top level topmenugroup item
          this._dropDown.onClose(function() {
            if (!this.isSubMenu()) {
              if (this.getElement()) {
                this.removeClass("current");
              }
              if (this.getParentWidget()) {
                this.getParentWidget().removeClass("open");
              }
            }
          }.bind(this));

          if (!window.isMobile()) {
            this._element.on('mouseover.TopMenuGroupWidget', this._displayTopMenuDropDown.bind(this));
          } else { // for mobile, topmenus are being displayed on touch
            // when a topmenu dropdown is displayed, and we press on another sibling topmenugroup, we need to cancel close of current menu to be able to display other one right after press
            this._dropDown.shouldClose = function(targetElement) {
              return !targetElement.isElementOrChildOf(this.getParentWidget().getElement());
            }.bind(this);
          }
        },

        //provide topmenu widget to this group (should be the parent, but not in case of sidebar tm)
        setTopMenuWidget: function(tmWidget) {
          this._topMenuWidget = tmWidget;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (!window.isMobile()) {
            this._element.off('mouseover.TopMenuGroupWidget');
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
          this._dropDown.destroy();
          this._dropDown = null;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (!this.isEnabled()) {
            return false;
          }

          let keyProcessed = false;

          if (this.isVisible()) {
            const currentChild = this._dropDown.getCurrentChildren();
            const parent = this.getParentWidget();
            keyProcessed = true;
            switch (keyString) {
              case "esc":
                this._dropDown.hide();
                break;
              case this.getStart():
                if (!this.isSubMenu()) { // navigate between topmenu groups
                  const previousMenu = parent.getPreviousMenu(this);
                  if (previousMenu) {
                    this.removeClass("current");
                    if (previousMenu.getName().endsWith("TopMenuGroupWidget")) {
                      previousMenu._displayTopMenuDropDown(null);
                    }
                  }
                } else { // hide sub menu
                  this._dropDown.remove();
                }
                break;
              case this.getEnd():
                if (currentChild && currentChild.getName().endsWith("TopMenuGroupWidget")) {
                  // display sub menu
                  currentChild._displayTopMenuDropDown(null);
                } else {
                  if (!this.isSubMenu()) { // navigate between topmenu groups
                    const nextMenu = parent.getNextMenu(this);
                    if (nextMenu) {
                      this.removeClass("current");
                      if (nextMenu.getName().endsWith("TopMenuGroupWidget")) {
                        nextMenu._displayTopMenuDropDown(null);
                      }
                    }
                  }
                }
                break;
              case "enter":
              case "return":
                if (currentChild) {
                  if (currentChild.getName().endsWith("TopMenuGroupWidget")) {
                    // display sub menu
                    currentChild._displayTopMenuDropDown(null);
                  } else if (currentChild.getName().endsWith("TopMenuCommandWidget")) {
                    if (currentChild.getAUIWidget()) {
                      //Send event to the real widget
                      currentChild.getAUIWidget().emit(context.constants.widgetEvents.click);
                    } else {
                      currentChild.emit(context.constants.widgetEvents.click);
                    }
                  }
                }
                break;
              default:
                keyProcessed = false;
            }
          }
          if (keyProcessed) {
            return true;
          } else {
            return this._dropDown.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this.isEnabled()) {
            return true;
          }

          // in sideBar?
          if (this.isInSidebar()) {
            const sideBarTopmenu = this._topMenuWidget._responsiveMenuWidget;
            sideBarTopmenu.displayNext(this);
            return false;
          } else {
            let children = this._dropDown.getChildren().slice();
            if (children.length > 0 && children[0].getElement().parentElement !== this._dropDown.getContainerElement()) {
              //children are always attached to the side menu, so we attached them to the dropdown
              children.forEach((child, idx) => {
                this._dropDown.adoptChildWidget(child, {
                  position: idx
                });
              });
            }
          }

          if (!this.isSubMenu()) {
            this._dropDown.toggle();
            return false;
          } else if (window.isMobile()) { // for mobile, execute mouseover logic on click
            this._displayTopMenuDropDown();
          }
          return true;
        },

        /**
         * Display topmenu or submenus dropdown (only if it was initially displayed using a click)
         * @param {?object} [event] - source event handler. If null we take current topmenu element as target element
         * @protected
         */
        _displayTopMenuDropDown: function(event) {
          if (!this.isEnabled()) {
            return;
          }

          if (!this.isInSidebar()) {
            // not in sidebar re-attach children
            this._dropDown.getChildren().slice().forEach((child, idx) => {
              this._dropDown.adoptChildWidget(child, {
                position: idx
              });
            });
          }

          if (cls.DropDownWidget.hasAnyVisible()) {
            // 1. eventually hide previous sub menu
            const element = event ? event.target : this.getElement();
            const lastDropDown = cls.DropDownWidget.getActiveDropDowns().last();

            // don't re display if same dropdown
            if (lastDropDown.getParentWidget() !== this) {

              cls.DropDownWidget.hideAll(element);

              // 2. display new sub menu
              if (this.isSubMenu()) {
                const parentRect = this.getElement().getBoundingClientRect();
                this._dropDown.x = parentRect.right;
                this._dropDown.y = parentRect.top;
              }
              this._dropDown.show(this.isSubMenu());
            }
          }
        },

        /**
         * Check if current topmenugroup is a child of another topmenugroup
         * @returns {boolean} true if current topmenugroup is a child of another topmenugroup
         */
        isSubMenu: function() {
          if (this._isSubMenu === null && this.getParentWidget()) {
            // usage of endsWidth to manage startmenu names
            this._isSubMenu = !this.getParentWidget().getName().endsWith("TopMenuWidget");
          }
          return this._isSubMenu;
        },

        /**
         * Check if topmenugroup is in sidebar
         * @returns {boolean} true if topmenu is in sidebar
         */
        isInSidebar: function() {
          // if responsive has children, it is in sidebar
          return this._topMenuWidget && this._topMenuWidget.isRenderedInSidebar();
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          this._dropDown.adoptChildWidget(widget, options);
        },
        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          this._dropDown.removeChildWidget(widget);
        },

        /**
         * Get all children of TopMenuGroup DropDown
         * @returns {classes.WidgetBase[]} the list of children being added in dropDown
         * @publicdoc
         */
        getChildren: function() {
          return this._dropDown.getChildren();
        },

        /**
         * Set the text of the group item
         * @param {string} text - Text to display
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_textElement");
        },

        /**
         * Get the text of the group item
         * @return {string} - Text displayed
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Define the group item image
         * @param {string} image - image source url
         * @publicdoc
         */
        setImage: function(image) {
          this._image.setSrc(image);
          this._image.toggleClass("hidden", !this.isSubMenu() && !image);
        },

        /**
         * Get image of the group item
         * @return {?string} - source of the image, null if not set
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          if (this._dropDown) {
            this._dropDown.setBackgroundColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          $super.setColor.call(this, color);
          if (this._dropDown) {
            this._dropDown.setColor(color);
          }
        },

        /**
         * Always true to be able to have dropdown associated with topmenugroup
         * @return {boolean} - always true
         */
        hasFocus: function() {
          return true;
        },

        /**
         * get the dropdown widget
         * @return {classes.DropDownWidget}
         */
        getDropDown: function() {
          return this._dropDown;
        },
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuGroup', cls.TopMenuGroupWidget);
  });
;

"use strict";

modulum('TopMenuPlaceholderWidget', ['WidgetPlaceholderBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuPlaceholderWidget widget.
     * @class TopMenuPlaceholderWidget
     * @memberOf classes
     * @extends classes.WidgetPlaceholderBase
     * @publicdoc Widgets
     */
    cls.TopMenuPlaceholderWidget = context.oo.Class(cls.WidgetPlaceholderBase, function($super) {
      return /** @lends classes.TopMenuPlaceholderWidget.prototype */ {
        __name: 'TopMenuPlaceholderWidget',

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          this._ignoreLayout = true;
          $super._initElement.call(this, initialInformation);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuPlaceholder', cls.TopMenuPlaceholderWidget);
  });
;

"use strict";

modulum('TopMenuSeparatorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenuSeparator widget.
     * @class TopMenuSeparatorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.TopMenuSeparatorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TopMenuSeparatorWidget.prototype */ {
        __name: 'TopMenuSeparatorWidget',

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._parentWidget && this._parentWidget.isInstanceOf(cls.DropDownWidget)) {
            this._parentWidget.getParentWidget().removeChildWidget(this);
          }
          $super.destroy.call(this);
        },

        isEnabled: function() {
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenuSeparator', cls.TopMenuSeparatorWidget);
  });
;

"use strict";

modulum('TopMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenu widget.
     * @class TopMenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.TopMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TopMenuWidget.prototype */ {
        __name: 'TopMenuWidget',

        /** @type {Boolean} */
        _allowInSidebar: true,
        _renderedInSidebar: false,
        _responsiveMenuWidget: false,
        /** @type {Boolean} */
        _globalTopmenu: false,

        _renderInSidebar: false,

        /** @type {Boolean} */
        _isStartMenu: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.TopmenuService.addTopMenu(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._responsiveMenuWidget = context.HostLeftSidebarService.getResponsiveMenu();
          this._responsiveMenuWidget.bindTopmenuWidget(this); //attach to responsive one
          this.render(this._renderedInSidebar);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          if (this._renderedInSidebar) {
            this._responsiveMenuWidget.adoptChildWidget(widget);
          }
        },

        /**
         * Define this topMenu as global one
         * @param {Boolean} isGlobal - true to set as global TM
         */
        setGlobal: function(isGlobal) {
          this._globalTopmenu = isGlobal;
        },

        /**
         * Check if TM is set as Global
         * @return {Boolean} true if global, false otherwise
         */
        isGlobal: function() {
          return this._globalTopmenu;
        },

        /**
         * Define the topmenu to be rendered in sidebar or not
         */
        setRenderInSideBar: function() {
          if (this.isStartMenu()) {
            return;
          }
          this._renderInSidebar = true;
          this.render({
            hidden: this.isHidden()
          });
        },

        /**
         * Set Topmenu as startMenu
         * @param {Boolean} isStartMenu - true to set it as startmenu
         */
        setIsStartMenu: function(isStartMenu) {
          this._isStartMenu = isStartMenu;
        },

        /**
         * Check if Topmenu is a StartMenu
         * @return {boolean} - true if is a StartMenu
         */
        isStartMenu: function() {
          return this._isStartMenu;
        },

        /**
         * Set the rendering of this topmenu
         */
        render: function(options = {}) {
          if (!this._renderInSidebar) {
            // not in sidebar:move or keep children in normal topmenu and close the sidebar
            gbc.HostLeftSidebarService.hideSidebar();
          } else {
            if ("hidden" in options) {
              this.setHidden(options.hidden);
            }
          }

          this._renderedInSidebar = this._responsiveMenuWidget.renderTopmenu(this, this._renderInSidebar);
          gbc.HostLeftSidebarService.setHasTopMenu(true, this._renderedInSidebar);
        },

        /**
         * Check if rendered in sidebar
         * @return {Boolean} - true if is in sidebar
         */
        isRenderedInSidebar: function() {
          return this._renderedInSidebar;
        },

        /**
         * Priority of this menu
         * @param {number} order the priority of this menu
         * @publicdoc
         */
        setOrder: function(order) {
          this.setStyle({
            order: order
          });
        },

        /**
         * Get priority of this menu
         * @returns {number} priority of this menu
         * @publicdoc
         */
        getOrder: function() {
          return this.getStyle('order');
        },

        /**
         * Get previous topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns previous topmenugroup
         * @publicdoc
         */
        getPreviousMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) - 1];
        },

        /**
         * Get next topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns next topmenugroup
         * @publicdoc
         */
        getNextMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) + 1];
        },

        destroy: function() {
          context.TopmenuService.removeTopmenu(this);
          this._responsiveMenuWidget.empty();
          $super.destroy.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('TopMenu', cls.TopMenuWidget);
  });
;

"use strict";

modulum('ApplicationWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Main container widget for an application
     * @class ApplicationWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.ApplicationWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationWidget.prototype */ {
        __name: "ApplicationWidget",
        _waiter: null,
        /**
         * the contextmenu widget
         * @type {classes.ContextMenuWidget}
         */
        _contextMenu: null,

        /**
         * the RowBound menu widget
         * @type {classes.ContextMenuWidget}
         */
        _rowBoundMenu: null,

        _handlers: null,
        _uiWidget: null,

        /** @type {Array} */
        _domAttributesMutationBuffer: null,

        /** @type {Array} */
        _afterDomMutationBuffer: null,

        /** @type {boolean} */
        _isBuffering: false,

        /** @type {boolean} */
        _isDomMutating: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          opts.appWidget = this;
          $super.constructor.call(this, opts);
          this._domAttributesMutationBuffer = [];
          this._afterDomMutationBuffer = [];
          this._handlers = [];
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._handlers) {
            for (const element of this._handlers) {
              element();
            }
            this._handlers.length = 0;
          }
          if (this._waiter) {
            this._waiter.destroy();
            this._waiter = null;
          }
          context.styler.removeStyleSheet(this._appHash);

          if (this._contextMenu) {
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          if (this._rowBoundMenu) {
            this._rowBoundMenu.destroy();
            this._rowBoundMenu = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._waiter = cls.WidgetFactory.createWidget("Waiting", this.getBuildParameters());
          this._element.appendChild(this._waiter.getElement());

          this._contextMenu = cls.WidgetFactory.createWidget("ContextMenu", this.getBuildParameters());
          this._contextMenu.setParentWidget(this);

          this._rowBoundMenu = cls.WidgetFactory.createWidget("ContextMenu", this.getBuildParameters());
          this._rowBoundMenu.setParentWidget(this);

        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.getContextMenu() && this.getContextMenu().isVisible()) {
            switch (keyString) {
              case "space":
                const currentChild = this.getContextMenu().getCurrentChildren();
                if (currentChild._onClick) { // TODO review this
                  currentChild._onClick(null);
                } else {
                  this.getContextMenu()._onClick(null, this.getCurrentChildren());
                }
                keyProcessed = true;
                break;
              default:
                break;
            }
            if (!keyProcessed) {
              keyProcessed = this.getContextMenu().managePriorityKeyDown(keyString, domKeyEvent, repeat);
            }
          }
          return keyProcessed;
        },

        /**
         * Show context menu and show it
         * @param evt
         * @param widget
         */
        showContextMenu: function(evt, widget) {

          this._contextMenu.setColor(this.getColor());
          this._contextMenu.setBackgroundColor(this.getBackgroundColor());

          evt.preventCancelableDefault();
          evt.stopImmediatePropagation();
          evt.stopPropagation();

          this._contextMenu.x = evt.clientX;
          this._contextMenu.y = evt.clientY;

          if (this._contextMenu.isVisible()) {
            this._contextMenu.hide(); // hide it before display it, to be sure it is in the correct position
          }

          // once VM gave focus to widget, show the contextMenu
          const app = context.SessionService.getCurrent().getCurrentApplication();
          app.scheduler.callbackCommand(function() {
            if (this._contextMenu && !this._contextMenu.isDestroyed()) {
              // Extra actions defines by widgets in buildExtraContextMenuActions function
              this._contextMenu.removeAndDestroyActions(true);
              let focusNode = context.SessionService.getCurrent().getCurrentApplication().getFocusedVMNode();
              if (focusNode.getCurrentValueNode) {
                let valueNode = focusNode.getCurrentValueNode();
                if (valueNode) {
                  focusNode = valueNode;
                }
              }
              const controller = focusNode ? focusNode.getController() : null;
              const newVmFocusWidget = controller ? controller.getWidget() : null;

              widget.buildExtraContextMenuActions(this._contextMenu);
              if (this._contextMenu.hasVisibleAction()) {
                this._contextMenu.show();
              }
            }
          }.bind(this));
        },

        /**
         * Returns contextMenu widget
         * @returns {classes.ContextMenuWidget} contextMenu widget
         */
        getContextMenu: function() {
          return this._contextMenu;
        },

        /**
         * Returns rowBound menu widget
         * @returns {classes.ContextMenuWidget} rowBound menu widget
         */
        getRowBoundMenu: function() {
          return this._rowBoundMenu;
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         */
        addChildWidget: function(widget, options) {
          this._uiWidget = widget;
          $super.addChildWidget.call(this, widget, options);
        },
        /**
         * Set application hash
         * @param {string} applicationHash
         */
        setApplicationHash: function(applicationHash) {
          this._appHash = applicationHash;
        },
        /**
         * Hide waiter
         */
        hideWaiter: function() {
          this._waiter.getElement().remove();
        },
        /**
         * Activate application
         */
        activate: function() {
          this.emit(context.constants.widgetEvents.activate);
          if (this._uiWidget) {
            this._uiWidget.emit(context.constants.widgetEvents.activate);
          }
        },
        /**
         * Bind a handler executed when application is activated
         * @param {Hook} hook
         * @returns {HandleRegistration} return handler reference
         */
        onActivate: function(hook) {
          this._handlers.push(this.when(context.constants.widgetEvents.activate, hook));
          return this._handlers[this._handlers.length - 1];
        },
        /**
         * Disable application
         */
        disable: function() {
          this.emit(context.constants.widgetEvents.disable);
          if (this._uiWidget) {
            this._uiWidget.emit(context.constants.widgetEvents.disable);
          }
        },
        /**
         * Emit a request to relayout application
         */
        layoutRequest: function() {
          this.emit(context.constants.widgetEvents.layoutRequest);
        },
        /**
         * Bind a handler executed when layout is requested
         * @param hook
         * @returns {Function} return handler reference
         */
        onLayoutRequest: function(hook) {
          this._handlers.push(this.when(context.constants.widgetEvents.layoutRequest, hook));
          return this._handlers[this._handlers.length - 1];
        },

        /**
         * @inheritDoc
         */
        flash: function(duration) {
          this.addClass("flash");
          this._registerTimeout(function() {
            this.removeClass("flash");
          }.bind(this), duration || 50);
        },

        /**
         * register function to run when not buffering. Executed directly if not buffering.
         * @param {Function} fn function to run when not buffering
         * @param {classes.WidgetBase} ctx a widget context - used to check is this context is destroyed or not when executing
         * @returns {boolean} whether or not the function zas buffered
         */
        domAttributesMutationBuffer: function(fn, ctx) {
          if (this._isBuffering) {
            this._domAttributesMutationBuffer.push([fn, ctx]);
            return true;
          }
          return false;
        },

        /**
         * register function to run when not buffering. Executed directly if not buffering.
         * @param {Function} fn function to run when not buffering
         * @param {classes.WidgetBase} context a widget context - used to check is this context is destroyed or not when executing
         * @returns {boolean} whether or not the function zas buffered
         */
        afterDomMutationBuffer: function(fn, context) {
          if (this._isBuffering || this._isDomMutating) {
            this._afterDomMutationBuffer.push([fn, context]);
            return true;
          }
          return false;
        },

        /**
         * Set buffering state
         * @param {boolean} buffering the new buffering state
         */
        bufferizeDom: function(buffering) {
          if (buffering) {
            this._isBuffering = true;
          } else {
            this._isDomMutating = true;
            this._isBuffering = false;
            const domAttributesMutationBuffer = this._domAttributesMutationBuffer;
            this._domAttributesMutationBuffer = [];
            const afterDomMutationBuffer = this._afterDomMutationBuffer;
            this._afterDomMutationBuffer = [];
            domAttributesMutationBuffer.forEach(function(item) {
              if (!item[1] || !item[1].isDestroyed()) {
                item[0]();
              }
            });
            context.styler.bufferize();
            afterDomMutationBuffer.forEach(function(item) {
              if (!item[1] || !item[1].isDestroyed()) {
                item[0]();
              }
            });
            context.styler.flush();
            this._isDomMutating = false;
          }
        },

        /**
         * @inheritDoc
         */
        hasChildWebComponent: function() {
          return (Boolean(this._uiWidget) && this._uiWidget.hasChildWebComponent()) ||
            $super.hasChildWebComponent.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Application', cls.ApplicationWidget);
  });
;

"use strict";

modulum('SessionEndRedirectWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget displayed at the end of a session
     * @class SessionEndRedirectWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionEndRedirectWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionEndRedirectWidget.prototype */ {
        __name: "SessionEndRedirectWidget",

        _initLayout: function() {
          // no layout
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionEndRedirect', cls.SessionEndRedirectWidget);
  });
;

"use strict";

modulum('SessionEndWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget displayed at the end of a session
     * @class SessionEndWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.SessionEndWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionEndWidget.prototype */ {
        __name: "SessionEndWidget",
        _closeApplicationEnd: null,
        _restartApp: null,
        /** @type {HTMLElement} */
        _getGbcLog: null,

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,
        _htmlFilter: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._closeApplicationEnd = this._element.getElementsByClassName("closeApplicationEnd")[0];
          if (gbc.HostService.isUR()) {
            this._closeApplicationEnd.classList.add("hidden");
          }
          this._restartApp = this._element.getElementsByClassName("restartApp")[0];
          this._getGbcLog = this._element.querySelector(".gbcLogLink");
          const chromeBarOpt = this.getBuildParameters();
          chromeBarOpt.lightmode = true;
          this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", chromeBarOpt);
          this._element.prependChild(this._chromeBar.getElement());
          this._chromeBar.setLightMode(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._closeApplicationEnd = null;
          this._restartApp = null;
          this._getGbcLog = null;
          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }
          if (this._chromeBar) {
            this._chromeBar.destroy();
            this._chromeBar = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const target = domEvent.target;
          if (target.isElementOrChildOf(this._closeApplicationEnd)) {
            this.emit(context.constants.widgetEvents.close);
          } else if (target.isElementOrChildOf(this._restartApp)) {
            this.emit(context.constants.widgetEvents.restart);
            context.LogService.checkMemoryLogs({
              clearHeader: false,
              clearImages: false,
              clearContent: true
            });
          } else if (target.isElementOrChildOf(this._getGbcLog)) {
            gbc.LogService.download();
            gbc.LogService.clearLog({
              clearHeader: false,
              clearImages: false,
              clearContent: true
            });
          }
          return true;
        },

        /**
         * Show all session actions
         * VM logs, Proxy logs
         * @publicdoc
         */
        showSessionActions: function() {
          const elements = this._element.getElementsByClassName('from-session') || [];
          for (const element of elements) {
            element.removeClass('hidden');
          }
          if (gbc.LogService.isRecordingEnabled()) {
            this._getGbcLog.removeClass('hidden');
          }
        },

        /**
         * Show user actions
         * restart, quit ...
         * @publicdoc
         */
        showUAActions: function() {
          this._element.getElementsByClassName('from-ua')[0].removeClass('hidden');
        },

        /**
         * Defines header message
         * @param {string} header the header content
         * @publicdoc
         */
        setHeader: function(header) {
          this._element.getElementsByClassName('mt-card-header-text')[0].innerText = header;
        },

        /**
         * Defines message to display at the end of the session
         * @param {string} message - text to display
         * @publicdoc
         */
        setMessage: function(message) {
          const messageElt = this._element.getElementsByClassName('message')[0];
          messageElt.removeClass('hidden');
          if (!this._htmlFilter) {
            this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
          }
          messageElt.innerHTML = this._htmlFilter.sanitize(message);
        },

        /**
         * Set the session id
         * @param {number} id - identifier of the session
         * @publicdoc
         */
        setSessionID: function(id) {
          this._element.getElementsByClassName('session')[0].removeClass('hidden');
          this._element.getElementsByClassName('sessionID')[0].textContent = id;
        },

        /**
         * Set the links of the session
         * @param {string} base - url base (hostname)
         * @param {string|number} session - identifier for this session
         * @publicdoc
         */
        setSessionLinks: function(base, session) {
          this._element.querySelector('.uaLink>a').setAttribute('href', base + '/monitor/log/uaproxy-' + session);
          this._element.querySelector('.vmLink>a').setAttribute('href', base + '/monitor/log/vm-' + session);
          if (!context.DebugService.isActive()) {
            this._element.querySelector('.uaLink').style.display = 'none';
            this._element.querySelector('.vmLink').style.display = 'none';
          }
        },

        /**
         * Defines the aui log url
         * @param {string|number} session - identifier for this session
         * @param file
         */
        setAuiLogUrl: function(session, file) {
          this._element.querySelector('.auiLink>a').setAttribute('download', 'auiLog-' + session + '.log');
          this._element.querySelector('.auiLink>a').setAttribute('href', 'file');
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionEnd', cls.SessionEndWidget);
  });
;

"use strict";

modulum('SessionLogPromptWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionLogPromptWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionLogPromptWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionLogPromptWidget.prototype */ {
        __name: "SessionLogPromptWidget",

        /** @type Element */
        _button: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._button = this._element.getElementsByClassName("mt-button")[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._button = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this._button || domEvent.target.parent("mt-button") === this._button) {
            this.emit(context.constants.widgetEvents.click);
          }
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionLogPrompt', cls.SessionLogPromptWidget);
  });
;

"use strict";

modulum('SessionWaitingEndWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionWaitingEndWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionWaitingEndWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionWaitingEndWidget.prototype */ {
        __name: "SessionWaitingEndWidget",

        _htmlFilter: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * Defines header message
         * @param {string} message the header content
         * @publicdoc
         */
        setHeader: function(message) {
          this._element.getElementsByClassName("mt-card-header-text")[0].innerText = message;
        },

        /**
         * Defines message to display at the end of the session
         * @param {string} message - text to display
         * @publicdoc
         */
        setMessage: function(message) {
          const messageElt = this._element.getElementsByClassName("message")[0];
          messageElt.removeClass("hidden");
          if (!this._htmlFilter) {
            this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
          }
          messageElt.innerHTML = this._htmlFilter.sanitize(message);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }
          $super.destroy.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('SessionWaitingEnd', cls.SessionWaitingEndWidget);
  });
;

"use strict";

modulum('SessionWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionWidget.prototype */ {
        __name: "SessionWidget",
        _waiter: null,
        /** @type {classes.SessionEndWidget} */
        _endWidget: null,
        /** @type {classes.SessionEndRedirectWidget} */
        _endRedirectWidget: null,
        /** @type {classes.SessionWaitingEndWidget} */
        _waitingEndWidget: null,
        __zIndex: 0,
        _currentWidget: null,
        _currentWidgetStack: null,
        _tabbedContainerWidget: null,
        _session: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._currentWidgetStack = [];
          this._session = opts.session;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._session = null;
          if (this._tabbedContainerWidget) {
            this._tabbedContainerWidget.destroy();
            this._tabbedContainerWidget = null;
          }
          if (this._endRedirectWidget) {
            this._endRedirectWidget.destroy();
            this._endRedirectWidget = null;
          }
          if (this._endWidget) {
            this._endWidget.destroy();
            this._endWidget = null;
          }
          if (this._waitingEndWidget) {
            this._waitingEndWidget.destroy();
            this._waitingEndWidget = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._endWidget = cls.WidgetFactory.createWidget('SessionEnd', this.getBuildParameters());
          this._endWidget.setHidden(true);
          this._element.appendChild(this._endWidget.getElement());
          this._endRedirectWidget = cls.WidgetFactory.createWidget('SessionEndRedirect', this.getBuildParameters());
          this._endRedirectWidget.setHidden(true);
          this._element.appendChild(this._endRedirectWidget.getElement());
          this._waitingEndWidget = cls.WidgetFactory.createWidget('SessionWaitingEnd', this.getBuildParameters());
          this._waitingEndWidget.setHidden(true);
          this._element.appendChild(this._waitingEndWidget.getElement());
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         * @param widget
         * @param options
         */
        addChildWidget: function(widget, options) {
          options = options || {};
          options.noDOMInsert = (options.noDOMInsert !== false);
          $super.addChildWidget.call(this, widget, options);
        },

        _getNextApplication: function(previousWidget) {
          let nextApp = null;
          if (this._currentWidgetStack.length) {
            nextApp = this._currentWidgetStack[this._currentWidgetStack.length - 1];
            if (nextApp === previousWidget && this._currentWidgetStack.length > 1) {
              nextApp = this._currentWidgetStack[this._currentWidgetStack.length - 2];
            }
          }
          return nextApp;
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          const displayedWidget = null;
          if (widget instanceof cls.ApplicationWidget) {
            this._currentWidgetStack.remove(widget);
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         *
         * @param {classes.ApplicationWidget} widget
         */
        setCurrentWidget: function(widget) {
          if (this._currentWidget !== widget && (!this._tabbedContainerHostWidget || this._tabbedContainerHostWidget !== widget)) {
            if (widget) {
              const isBuffering = context.styler.isBuffering();
              if (!isBuffering) {
                context.styler.bufferize();
              }
              const previousWidget = this.getCurrentWidget();

              if (this._tabbedContainerWidget) {
                if (previousWidget) {
                  previousWidget.disable();
                }
                this._tabbedContainerWidget.setCurrentPage(widget._tabbedPage);
              } else {
                // REWORKED AND SIMPLIFIED ALGORITHM
                if (previousWidget) {
                  // if contains WebComponent or is under creation (happens when switching app during typeahead), then only hide the application
                  if (!previousWidget.isDestroyed() && (previousWidget.hasChildWebComponent() || !previousWidget._uiWidget)) {
                    previousWidget.addClass("gbc_out_of_view");
                  } else {
                    // otherwise remove the application from the dom (optimization)
                    if (this.getContainerElement() && previousWidget.getElement()) {
                      this.getContainerElement().removeChild(previousWidget.getElement());
                    }
                  }
                  previousWidget.disable();
                }
                // if widget contains this class (has webcomponent or was being added during its creation), just remove it
                if (widget.hasClass("gbc_out_of_view")) {
                  widget.removeClass("gbc_out_of_view");
                }
                // if widget is not in DOM, add it
                if (this.getContainerElement() && widget.getElement() && !widget.getElement().isInDOM()) {
                  this.getContainerElement().appendChild(widget.getElement());
                }
              }
              if (!this._currentWidgetStack.contains(widget)) {
                this._currentWidgetStack.push(widget);
              }
              widget.activate();
              if (!isBuffering) {
                context.styler.flush();
              }
            }
            this._currentWidget = widget;
          }
        },
        getCurrentWidget: function() {
          return this._currentWidget;
        },
        showWaitingEnd: function() {
          this._waitingEndWidget.setHidden(false);
        },
        showEnd: function() {
          this._waitingEndWidget.setHidden(true);
          this._endWidget.setHidden(false);
          this.emit(context.constants.widgetEvents.titleChanged, "");
          //A          context.HostService.setCurrentTitle();
          //A          context.HostService.setCurrentIcon();
        },
        showRedirectEnd: function() {
          this._waitingEndWidget.setHidden(true);
          this._endRedirectWidget.setHidden(false);
          this.emit(context.constants.widgetEvents.titleChanged, "");
          //A          context.HostService.setCurrentTitle();
          //A          context.HostService.setCurrentIcon();
        },
        getEndWidget: function() {
          return this._endWidget;
        },
        getWaitingEndWidget: function() {
          return this._waitingEndWidget;
        },

        setTabbedContainer: function(tabbedContainerWidget) {
          this._tabbedContainerWidget = tabbedContainerWidget;
        },

        setTabbedContainerHost: function(widget) {
          this._tabbedContainerHostWidget = widget;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Session', cls.SessionWidget);
  });
;

"use strict";

modulum('WaitingWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class WaitingWidget, used for direct connection
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.WaitingWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.WaitingWidget.prototype */ {
        __name: "WaitingWidget"
      };
    });
    cls.WidgetFactory.registerBuilder('Waiting', cls.WaitingWidget);
  });
;

"use strict";

modulum('ApplicationHostSettingsWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * GBC Settings modal container
     * @class ApplicationHostSettingsWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.ApplicationHostSettingsWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.ApplicationHostSettingsWidget.prototype */ {
        __name: "ApplicationHostSettingsWidget",
        __templateName: "ModalWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._element.addClass("mt-dialog-about");
          const dialogContents = document.createElement("div");

          const headerTitleDom = document.createElement('span');
          headerTitleDom.innerHTML = '<i class="zmdi zmdi-cog"></i> ' + i18next.t("gwc.settings");
          this.setHeader(headerTitleDom);

          this.setClosable(true, true);
          this.setContent(dialogContents);

          this._settings = cls.WidgetFactory.createWidget("Settings", this.getBuildParameters());
          dialogContents.appendChild(this._settings.getElement());
          this._settings.setParentWidget(this);
        },

        /**
         * @inheritDoc
         */
        show: function() {
          $super.show.call(this);
          if (!this._systemModal) {
            this._gbcSystemModal();
          }
        },

        destroy: function() {
          this._settings.destroy();
          this._settings = null;
          $super.destroy.call(this);
        },

        hide: function() {
          if (this._settings) {
            this._settings._restoreDefaultButton();
          }
          $super.hide.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSettings', cls.ApplicationHostSettingsWidget);
  });
;

"use strict";

modulum('ApplicationHostWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationHostWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationHostWidget.prototype */ {
        __name: "ApplicationHostWidget",
        /**
         * left css position of the container
         * @type {?number}
         */
        _position: null,
        /**
         * @type {HTMLElement}
         */
        _centralContainer: null,
        _launcher: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._centralContainer = this._element.firstElementChild;
          this._launcher = cls.WidgetFactory.createWidget('ApplicationLauncher', this.getBuildParameters());
          this._launcher.setHidden(true);
          this.addChildWidget(this._launcher);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._launcher.destroy();
          this._centralContainer = null;
          $super.destroy.call(this);
        },
        getLauncher: function() {
          return this._launcher;
        },

        /**
         *
         * @returns {classes.ApplicationHostSidebarWidget}
         */
        getCentralContainer: function() {
          return this._centralContainer;
        },
        getCentralContainerPosition: function() {
          return this._position;
        },
        /**
         *
         * @param position
         * @returns {boolean} true if position has changed
         */
        setCentralContainerPosition: function(position) {
          if (position !== this._position) {
            this._position = position;
            this._centralContainer.style.left = position + "px";
            return true;
          }
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHost', cls.ApplicationHostWidget);
  });
;

"use strict";

modulum('ApplicationInformationWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationInformationWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationInformationWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationInformationWidget.prototype */ {
        __name: "ApplicationInformationWidget",
        /**
         * @type Element
         */
        _currentUARElement: null,
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._currentUARElement = this._element.getElementsByClassName("applicationUAR")[0];
        },
        _initLayout: function() {
          // no layout
        },
        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this._currentUARElement) {
            this._currentUARElement.selectText();
            return false;
          }
          return true;
        },
        getCurrentUAR: function() {
          return this._currentUARElement.value;
        },
        setCurrentUAR: function(uar) {
          this._currentUARElement.value = uar;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationInformation', cls.ApplicationInformationWidget);
  });
;

"use strict";

modulum('ChromeBarItemBackButtonWidget', ['ButtonWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * About button in ChromeBar
     * @class ChromeBarItemBackButtonWidget
     * @memberOf classes
     * @extends classes.ButtonWidget
     */
    cls.ChromeBarItemBackButtonWidget = context.oo.Class(cls.ButtonWidget, function($super) {
      return /** @lends classes.ChromeBarItemAboutWidget.prototype */ {
        __name: "ChromeBarItemBackButtonWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setTitle(i18next.t('gwc.main.chromebar.backButton'));
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          context.SessionService.getCurrent().getNavigationManager().goBackToLastActiveWindow();
          return false;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemBackButton', cls.ChromeBarItemBackButtonWidget);
  });
;

"use strict";

modulum('ChromeBarItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Item to add to the topbar (Use as a base class as well for GBC items)
     * @class ChromeBarItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ChromeBarItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ChromeBarItemWidget.prototype */ {
        __name: "ChromeBarItemWidget",

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {Element} */
        _textElement: null,
        /** @type {Element} */
        _imageContainer: null,
        /** @type {string} */
        _itemType: "",

        /** @function */
        _afterLayoutHandler: null,

        /** @type {string|null} */
        _defaultTTFColor: null,

        /** @type {boolean} */
        _forceOverflow: false,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ChromeBarItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          $super._initElement.call(this, initialInformation);
          this._textElement = this._element.getElementsByTagName('span')[0];
          this._imageContainer = this._element.getElementsByClassName('gbc_imageContainer')[0];
        },

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("item"); // item type by default (could be item or gbcItem)
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Click on any item should close the right bar
          if (this.getParentWidget().closeRightBar) {
            this.getParentWidget().closeRightBar();
          } else {
            this.getParentWidget().hide();
          }
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true; // bubble
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.isEnabled()) {
            if (keyString === "space" || keyString === "enter" || keyString === "return") {
              this.emit(context.constants.widgetEvents.click, domKeyEvent);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this._defaultTTFColor = color;
          this.setStyle(".zmdi", {
            'color': color
          });
        },

        /**
         * Set the text of the chromebar item
         * @param {string} text - the text
         * @publicdoc
         */
        setText: function(text) {
          this._setTextContent(text, "_textElement");
          this._layoutEngine.invalidateMeasure();
          this._layoutEngine.forceMeasurement();
          if (gbc.qaMode && ['qa_dialog_ready', 'qa_menu_ready'].indexOf(text) >= 0) {
            gbc.QAService.bindQAReadyButton(this);
          }
        },

        /**
         * Get the text of the chromebar item
         * @return {?string}
         */
        getText: function() {
          return this._textElement ? this._textElement.textContent : null;
        },

        /**
         * Define the chromebar item image
         * @param {string} image - image url to use
         * @publicdoc
         */
        setImage: function(image) {
          if (image && image.length !== 0) {
            this.addClass("hasImage");
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget(image.startsWith('zmdi-') ? 'GbcImage' : 'ImageWidget', this
                .getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());
            } else if (this._image.isInstanceOf(cls.GbcImageWidget) && !image.startsWith('zmdi-')) {
              // Case where image is override to be something else than zmdi
              this._image.destroy();
              this._image = null;
              this.setImage(image);
            }
            if (this._defaultTTFColor) {
              this._image.setDefaultColor(this._defaultTTFColor);
            }
            this._image.setSrc(image);
            this._image.toggleClass("svg", image.indexOf(".svg?") >= 0);
            this._image.setErrorHandler(function() {
              this._removeImage();
              //We are outside the GBC engine, so we must run the layout engine
              this.getApplicationWidget().layoutRequest();
            }.bind(this));
          } else if (this._image) {
            this._removeImage();
          }
          this._layoutEngine.invalidateMeasure();
        },

        /**
         * Remove the DOM image element
         * @private
         */
        _removeImage: function() {
          this.removeClass("hasImage");
          this._image.getElement().remove();
          this._image.destroy();
          this._image = null;

          this._layoutEngine.invalidateMeasure();
          this._layoutEngine.forceMeasurement();
        },

        /**
         * Get the chromebar item Image
         * @return {?string}
         */
        getImage: function() {
          return this._image ? this._image.getSrc() : null;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * Get the item type
         * @return {string} the item type could be item (default) or gbcItem (for gbc Actions) or overflowItem (for item you want to be in overflow panel)
         */
        getItemType: function() {
          return this._itemType;
        },

        /**
         * True if the item can be an element of the right menu
         * @return {boolean}
         */
        canBeInTheOverFlowMenu: function() {
          return true;
        },

        /**
         * Set the item type
         * @param {string} type - the item type could be item (default) or gbcItem (for gbc Actions)
         */
        setItemType: function(type) {
          // GBC items are forced to flow if the theme says so
          if (type === "gbcItem" && context.ThemeService.getValue('gbc-ChromeBarWidget-flow-gbc-items')) {
            this.forceOverflow(true);
          }
          this._itemType = type;
          this.getElement().setAttribute("chromebar-itemtype", type);
        },

        /**
         * Force item to be in right sidebar
         * @param {Boolean} overflow - true to put it in right sidebar, false otherwise
         */
        forceOverflow: function(overflow) {
          this._forceOverflow = overflow;
        },

        /**
         * Get the forceOverflow status
         * @return {boolean} - true if forced to overflow, false otherwise
         */
        getForceOverflowStatus: function() {
          return this._forceOverflow;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItem', cls.ChromeBarItemWidget);
  });
;

"use strict";

modulum('ChromeBarPlaceholderWidget', ['WidgetPlaceholderBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ChromeBarPlaceholderWidget widget.
     * @class TopMenuPlaceholderWidget
     * @memberOf classes
     * @extends classes.WidgetPlaceholderBase
     * @publicdoc Widgets
     */
    cls.ChromeBarPlaceholderWidget = context.oo.Class(cls.WidgetPlaceholderBase, function($super) {
      return /** @lends classes.ChromeBarPlaceholderWidget.prototype */ {
        __name: 'ChromeBarPlaceholderWidget',

        /** @type {string} */
        _itemType: "",

        /** @type {boolean} */
        _forceOverflow: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("item"); // item type by default (could be item or gbcItem)
        },

        /**
         * @inheritDoc
         */
        _initElement: function(initialInformation) {
          $super._initElement.call(this, initialInformation);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Get the item type
         * @return {string} the item type could be item (default) or gbcItem (for gbc Actions) or overflowItem (for item you want to be in overflow panel)
         */
        getItemType: function() {
          return this._itemType;
        },

        /**
         * Set the item type
         * @param {string} type - the item type could be item (default) or gbcItem (for gbc Actions)
         */
        setItemType: function(type) {
          // GBC items are forced to flow if the theme says so
          if (type === "gbcItem" && context.ThemeService.getValue('gbc-ChromeBarWidget-flow-gbc-items')) {
            this.forceOverflow(true);
          }
          this._itemType = type;
          this.getElement().setAttribute("chromebar-itemtype", type);
        },

        /**
         * Force item to be in right sidebar
         * @param {Boolean} overflow - true to put it in right sidebar, false otherwise
         */
        forceOverflow: function(overflow) {
          this._forceOverflow = overflow;
        },

        /**
         * Get the forceOverflow status
         * @return {boolean} - true if forced to overflow, false otherwise
         */
        getForceOverflowStatus: function() {
          return this._forceOverflow;
        },

        /**
         * True if the item can be an element of the right menu
         * @return {boolean}
         */
        canBeInTheOverFlowMenu: function() {
          return true;
        },

        /**
         * @inheritDoc
         */
        applyCommonStyleToWidget: function(widget) {}
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarPlaceholder', cls.ChromeBarPlaceholderWidget);
  });
;

"use strict";

modulum('ChromeBarTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ChromeBarTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ChromeBarTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ChromeBarTitleWidget.prototype */ {
        __name: "ChromeBarTitleWidget",
        _windowTitle: null,
        //_windowIcon: null,
        _listIcon: null,
        //_image: null,
        _visibility: true,

        _dropDownAvailable: false,
        _currentContent: null,
        /**
         * Dropdown widget which contains the current application stack
         * @type {classes.DropDownWidget}
         */
        _dropDown: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._windowTitle = this._element.getElementsByClassName("windowTitle")[0];

          this._listIcon = this._element.getElementsByClassName("windowListIcon")[0];

          this._dropDown = cls.WidgetFactory.createWidget('DropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);

          this.setAcceptEventWhenWindowInactive(true);
        },

        onDropDownBeforeOpen: function(hook) {
          return this._dropDown.onBeforeOpen(hook);
        },

        onDropDownClose: function(hook) {
          return this._dropDown.onClose(hook);
        },

        /**
         *
         * @param {classes.WidgetBase} content
         */
        setDropDownContent: function(content) {
          if (this._currentContent) {
            this._dropDown.getElement().removeChild(this._currentContent.getElement());
            this._currentContent = null;
          }
          if (content) {
            this._currentContent = content;
            this._dropDown.getElement().appendChild(this._currentContent.getElement());

            this._currentContent.getChildren().forEach((application) => {
              application.getChildren().forEach((window) => {
                if (window.isVisible()) {
                  window.getElement().toggleClass("current", true);
                  this._currentContent.setCurrentElement(window.getElement());
                } else {
                  window.getElement().toggleClass("current", false);
                }
              });
            });
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          if (this._dropDownAvailable) {
            this._dropDown.show();
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }
          this._windowTitle = null;

          this._listIcon = null;
          $super.destroy.call(this);
        },

        setWindowTitle: function(text, app) {
          this._windowTitle.textContent = text;
          this._windowTitle.setAttribute("title", text);
          context.HostService.setDocumentTitle(text, app);
        },

        getWindowTitle: function() {
          return this._windowTitle.textContent;
        },

        setIcon: function(image) {
          //Design not definitively defined
          /*if (!this._image) {
            this._image = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._windowIcon.prependChild(this._image.getElement());
          }
          this._image.setHidden(true);
          if (image && image !== "") {
            this._image.setSrc(image);
            this._image.setHidden(false);
          }*/
        },

        setListingVisibility: function(visibility) {
          this._visibility = visibility;
        },

        setListingVisible: function(visible) {
          visible = this._visibility && visible;
          this._dropDownAvailable = visible;
          this._listIcon.toggleClass("hidden", !visible);
        }
      };
    });
    cls.WidgetFactory.registerBuilder("ChromeBarTitle", cls.ChromeBarTitleWidget);
  });
;

"use strict";

modulum('ChromeBarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Main entry point for chrome Menu
     * Top bar used with mobile devices
     * In order, it adds:
     *  - UI Toolbar
     *  - Window Toolbar
     *  - Action Panel / Ring Menu
     *  - GBC centric actions
     * @class ChromeBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ChromeBarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ChromeBarWidget.prototype */ {
        __name: "ChromeBarWidget",

        /** @type {Element} */
        _toggleRightBarElement: null,

        /** @type {string} **/
        _defaultTitle: "Genero Browser Client",

        /** @type {classes.ChromeRightBarWidget} */
        _rightBarWidget: null,

        /** @type {Element} */
        _titleContainerElement: null,

        /** @type {Element} */
        _titleElement: null,

        /** @type {classes.ChromeBarTitleWidget} */
        _titleWidget: null,

        /** @type {Object} */
        _refreshConditions: null,

        /** @type {Boolean} **/
        _hasWindowIcon: false,

        /** @type {classes.ImageWidget} **/
        _windowIconImage: null,

        /** @type {Boolean} **/
        _lightMode: false,

        _aboutMenuItem: null,
        _settingsMenuItem: null,
        _uploadStatusMenuItem: null,
        _runtimeStatusMenuItem: null,
        _closeMenuItem: null,
        _debugMenuItem: null,
        _proxyLogMenuItem: null,
        _VMLogMenuItem: null,
        _runInGDCMenuItem: null,

        /** @type {classes.ChromeBarItemFilterWidget} **/
        _filterMenuItem: null,

        /** @type {string|null} */
        _defaultTTFColor: null,

        /** @type {HTMLElement} */
        _backButtonContainer: null,
        /** @type {classes.ChromeBarItemBackButtonWidget} */
        _backButtonWidget: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          // Handle items of both rightbar and topchromebar
          this._refreshConditions = {
            childrenNumber: 0,
            windowWidth: window.innerWidth,
          };

          $super.constructor.call(this, opts);

          if (opts.lightmode) {
            this.setLightMode(true);
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ChromeBarLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.clearActions();

          // Destroy GBC menu items
          if (this._aboutMenuItem) {
            this._aboutMenuItem.destroy();
            this._aboutMenuItem = null;
          }
          if (this._debugMenuItem) {
            this._debugMenuItem.destroy();
            this._debugMenuItem = null;
          }
          if (this._proxyLogMenuItem) {
            this._proxyLogMenuItem.destroy();
            this._proxyLogMenuItem = null;
          }
          if (this._VMLogMenuItem) {
            this._VMLogMenuItem.destroy();
            this._VMLogMenuItem = null;
          }
          if (this._runInGDCMenuItem) {
            this._runInGDCMenuItem.destroy();
            this._runInGDCMenuItem = null;
          }
          if (this._settingsMenuItem) {
            this._settingsMenuItem.destroy();
            this._settingsMenuItem = null;
          }
          if (this._closeMenuItem) {
            this._closeMenuItem.destroy();
            this._closeMenuItem = null;
          }
          if (this._uploadStatusMenuItem) {
            this._uploadStatusMenuItem.destroy();
            this._uploadStatusMenuItem = null;
          }
          if (this._runtimeStatusMenuItem) {
            this._runtimeStatusMenuItem.destroy();
            this._runtimeStatusMenuItem = null;
          }
          if (this._filterMenuItem) {
            this._filterMenuItem.destroy();
            this._filterMenuItem = null;
          }

          // Destroy remaining things
          this._toggleRightBarElement = null;
          this._rightBarWidget.destroy();
          this._rightBarWidget = null;
          this._titleContainerElement = null;
          this._titleElement = null;
          if (this._windowIconImage) {
            this._windowIconImage.destroy();
            this._windowIconImage = null;
          }

          if (gbc.LogService.isRecordingEnabled() && this._logRecordWidget) {
            this._logRecordWidget.destroy();
            this._logRecordWidget = null;
          }

          this._backButtonWidget.destroy();
          this._backButtonWidget = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // All those are not needed in light mode
          if (!this._lightMode) {
            this._rightBarWidget = cls.WidgetFactory.createWidget('ChromeRightBar', this.getBuildParameters());
            this._rightBarWidget.setParentWidget(this);
            this._toggleRightBarElement = this._element.getElementsByClassName("mt-sidebar-action-toggle")[0];

            this._titleContainerElement = this.getElement().querySelector(".mt-toolbar-title");
            this._titleElement = this._titleContainerElement.querySelector(".currentDisplayedWindow");

            this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];
          }

          if (gbc.LogService.isRecordingEnabled() && !this._lightMode) {
            this._logRecordWidget = cls.WidgetFactory.createWidget("LogRecorder", this.getBuildParameters());
            this._element.querySelector(".mt-toolbar-title").appendChild(this._logRecordWidget.getElement());
          }

          this._backButtonContainer = this._element.child("mt-goto-active-window");
          this._backButtonWidget = cls.WidgetFactory.createWidget("ChromeBarItemBackButton", this.getBuildParameters());
          this._backButtonContainer.appendChild(this._backButtonWidget.getElement());
        },

        /**
         * Show/hide filter item
         * @param {boolean} visible - true if item must be visible
         * @param {String} [filterValue] - initial filter value
         */
        showFilterMenuItem: function(visible, filterValue) {
          this._filterMenuItem.setFilterValue(filterValue);
          this._filterMenuItem.setHidden(!visible);
        },

        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);

          this._filterMenuItem = cls.WidgetFactory.createWidget("ChromeBarItemFilter", this.getBuildParameters());
          this._filterMenuItem.setHidden(true);
          this.addItemWidget(this._filterMenuItem);

          let gbcItems = [];
          // If we want a simple chromebar (not many items and so)
          if (this._lightMode) {
            gbcItems = ["settings"];
          } else {
            gbcItems = gbc.ThemeService.getValue("gbc-ChromeBarWidget-visible-items").split(" ");

          }
          if (gbc.DebugService.isActive()) {
            gbcItems = gbcItems.concat(["debug", "proxyLog", "VMLog"]);
            if (!window.isMobile()) {
              gbcItems.push("runInGDC");
            }
          }
          gbcItems.push("close"); // Close button should not be removed!
          this._createGBCMenuItems(gbcItems); // prepare gbcItem widgets
        },

        /**
         * Create all the GBC menu item (about, settings and so...)
         * Note that it doesn't add them to the dom! see _addGBCMenuItems for that
         * @param {String[]} gbcItems - list of items to create
         * @private
         */
        _createGBCMenuItems: function(gbcItems) {
          // Create all the gbc items
          gbcItems.forEach(function(item) {
            const widgetName = 'ChromeBarItem' + item.substr(0, 1).toUpperCase() + item.substr(1);
            this["_" + item + "MenuItem"] = cls.WidgetFactory.createWidget(widgetName, this.getBuildParameters());
          }.bind(this));
          this._addGBCMenuItems();
        },

        /**
         * Add the GBC menu item to the chromebar (let the chromebar moving it to the rightbar if needed)
         * @private
         */
        _addGBCMenuItems: function() {
          // About processing item
          this.addItemWidget(this._uploadStatusMenuItem);
          // About Menu item
          this.addItemWidget(this._aboutMenuItem);

          // *** Debug/Dev entries ***
          // Debug Menu item
          this.addItemWidget(this._debugMenuItem);
          // Run in GDC Menu item
          this.addItemWidget(this._runInGDCMenuItem);
          // Proxy Logs Menu item
          this.addItemWidget(this._proxyLogMenuItem);
          // VM Logs Menu item
          this.addItemWidget(this._VMLogMenuItem);

          // Settings Menu item
          this.addItemWidget(this._settingsMenuItem);
          // Close Window
          this.addItemWidget(this._closeMenuItem);
        },

        /**
         * Get a GBC menu item by its name
         * @param name
         */
        getGbcMenuItem: function(name) {
          return this["_" + name + "MenuItem"];
        },

        /**
         * Get the associated rightBar
         * @return {classes.ChromeRightBarWidget}
         */
        getRightBarWidget: function() {
          return this._rightBarWidget;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Click on the burger to open left Sidebar
          if (domEvent.target.isElementOrChildOf(this._sidebarToggle) || this._sidebarToggle.isElementOrChildOf(domEvent.target)) {
            this.closeRightBar();
            this.emit(context.constants.widgetEvents.toggleClick);
            gbc.HostLeftSidebarService.toggleTopMenu(); // will show top menu if any

          }

          // Click on the 3 dots top right
          if (domEvent.target.isElementOrChildOf(this._toggleRightBarElement)) {
            if (this._rightBarWidget) {
              this._rightBarWidget.toggle();
            }
          }

          return true; // bubble
        },

        /**
         * Close the right bar
         */
        closeRightBar: function() {
          if (this._rightBarWidget) {
            this._rightBarWidget.hide();
          }
        },

        /**
         * Add a toolbar to the chromeBar
         * @param {classes.ToolBarWidget} toolbarWidget - item to add
         * @param {number} order
         */
        addToolBar: function(toolbarWidget, order) {
          this._hasToolBar = true;
          toolbarWidget.setAsChromeBar(this);
          const children = toolbarWidget.getChildren().slice(); // copy object for safe foreach

          this._toolBarWidgets = [];
          children.forEach(function(child) {
            child.addClass("toolbarItem");
            this.addItemWidget(child); // Add it to chrome TopBar first for layout measurement
          }.bind(this));
        },

        /**
         * Add a menu to the chromeBar (Menu or Dialog)
         * @param {classes.MenuWidget} menuWidget - widget to add
         */
        addMenu: function(menuWidget) {
          this._hasMenu = true;
          menuWidget.setAsChromeBar(this);
          const children = menuWidget.getChildren().slice(); // copy object for safe foreach
          children.forEach(function(child) {
            child.addClass("menuItem");
            this.addItemWidget(child);
          }.bind(this));
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          if (color === this._defaultTTFColor) {
            return;
          }

          this.setStyle(".zmdi", {
            'color': color
          });

          this._defaultTTFColor = color;
          const children = this.getChildren();

          for (const element of children) {
            const item = element;
            const fnDefaultTTF = item.setDefaultColor || item.setDefaultTTFColor;
            (fnDefaultTTF.bind(item))(color);
          }
        },

        /**
         * Handler called when layout notify changes
         * @param {Boolean} force - force a refresh
         */
        refresh: function(force) {
          // Add timeout to that to throttle
          if (this._timeoutHandler) {
            this._clearTimeout(this._timeoutHandler);
          }
          this._timeoutHandler = this._registerTimeout(function() {
            this._refresh(force);
            this._containerElement.style.opacity = "1";
          }.bind(this), 100);
        },

        /**
         * Throttled Handler called when layout notify changes
         * @param {Boolean} force - force a refresh
         * @private
         */
        _refresh: function(force) {
          if (force || this.needRefresh()) { // Check if a refresh is really needed
            let sortedItemList = this._sortChromeBarItems();
            let filterHasFocus = false;

            if (sortedItemList.length > 0) {
              filterHasFocus = this._filterMenuItem && this._filterMenuItem.hasFocusOnInput();

              sortedItemList.forEach(function(c) {
                this._removeChildWidgetFromDom(c);
              }.bind(this));

              sortedItemList.forEach(function(item) {
                this.adoptChildWidget(item, {
                  noLayoutInvalidation: true
                });
              }.bind(this));

              if (filterHasFocus) {
                this._filterMenuItem.setFocusOnInput();
              }

              sortedItemList = null; // cleanup
            }

            // Flow Items if necessary
            let topBarFull = false;
            const children = this.getChildren().slice(0); // copy children array to avoid list alteration while processing

            if (children) {
              // Now we choose, who should stay in topbar, or who shouldn't
              this._toggleRightBarElement.removeClass("hidden");
              const availableSpace = this.getContainerElement().getBoundingClientRect().width;
              let currentUsedWidth = 0;
              let childWidth = 0;

              for (const itemWidget of children) {
                if (!topBarFull) {
                  // Hidden item take zero Width, otherwise get width from layout measure
                  //childWidth = element.isHidden() ? 0 : element.getLayoutInformation().getRawMeasure().getWidth();
                  childWidth = itemWidget.isHidden() ? 0 : itemWidget.getElement().clientWidth;
                  // Add total size
                  currentUsedWidth = currentUsedWidth + childWidth;
                  // TopBar is full if children take more space than container
                  topBarFull = currentUsedWidth > availableSpace;
                }
                // Check again, since it might have changed
                // If the chromebar has a toolbar/topmenu, only display those items
                // If no item are visible in the toolbar/topmenu, display the gbcItem
                const visibleCount = this.getVisibleChildren().length;
                if (topBarFull ||
                  (itemWidget.getItemType() === "gbcItem" && (this._hasToolBar || this._hasMenu) && (visibleCount > 0)) ||
                  itemWidget.getItemType() === "overflowItem" ||
                  itemWidget.getForceOverflowStatus()) {
                  // test if at least 1 visible item
                  if (itemWidget.canBeInTheOverFlowMenu && itemWidget.canBeInTheOverFlowMenu()) {
                    this._rightBarWidget.adoptChildWidget(itemWidget); // Add it to the sidebar instead of topbar
                  }
                }
              }
            }

            // Show/hide right '3 dots' button if there are children in the right bar
            if (this._rightBarWidget.getChildren().length === 0) {
              this._toggleRightBarElement.addClasses("hidden");
            } else {
              this._toggleRightBarElement.removeClass("hidden");
            }
          }

        },

        /**
         * Method to check if calling a refresh is necessary
         * @return {boolean} - true if necessary false otherwise
         */
        needRefresh: function() {
          const children = this.getChildren().slice(0); // copy children array to avoid list alteration while processing
          let childrenOverflow = false,
            changedUsedWidth = false,
            childrenPosChanged = false;

          if (children) {
            // availableSpace is containerElement width ( all widget - decoration)
            const availableSpace = this.getLayoutInformation().getRawMeasure().getWidth() - this.getLayoutInformation()
              .getDecorating()
              .getWidth();

            const sortedItemList = this._sortChromeBarItems();
            let currentUsedWidth = 0;
            for (let i = 0; i < children.length; i++) {
              if (children[i].getLayoutInformation().getRawMeasure().getWidth()) {
                currentUsedWidth = currentUsedWidth + children[i].getLayoutInformation().getRawMeasure()
                  .getWidth(); // get item layout engine
              }

              // Compare the children position to the sorted children position: if changed, need a refresh
              if (!childrenPosChanged && sortedItemList[i] !== children[i]) {
                childrenPosChanged = true;
              }
            }

            childrenOverflow = currentUsedWidth > availableSpace;
            if (this._currentUsedWidth !== currentUsedWidth) {
              changedUsedWidth = true;
              this._currentUsedWidth = currentUsedWidth;
            }
          }

          return childrenOverflow || changedUsedWidth || childrenPosChanged ||
            this._refreshConditions.windowWidth !== window.innerWidth ||
            this._refreshConditions.forceRefresh;
        },

        /**
         * Sort the items in chrome
         * @return {T[]} the Array of sorted items
         * @private
         */
        _sortChromeBarItems: function() {
          const rbChildren = this._rightBarWidget.getChildren("item").slice(0);
          const rbGbcChildren = this._rightBarWidget.getChildren("gbcItem").slice(0);
          // Sort items by *UniqueId*
          const sortedItemList = this.getChildren("item").concat(rbChildren).slice(0).sort(function(a, b) {
            return a.getAuiLinkedUniqueIdentifier() - b.getAuiLinkedUniqueIdentifier();
          });
          // Sort gbcItems by *_uuid*
          const sortedGbcItemList = this.getChildren("gbcItem").concat(rbGbcChildren).slice(0).sort(function(a, b) {
            return a._uuid - b._uuid;
          });
          return sortedItemList.concat(sortedGbcItemList);
        },

        /**
         * Add an item as a child or as a chromebar child
         * @param {classes.ChromeBarItemWidget} widget - item to add
         * @param {Object=} options - possible options
         * @param {boolean=} options.noDOMInsert - won't add child to DOM
         * @param {number=} options.position - insert position
         * @param {string=} options.ordered - auto order item by unique auiID
         * @param {string=} options.tag - context tag
         * @param {string=} options.mode - context mode : null|"replace"
         */
        addItemWidget: function(widget, options) {
          options = options || {};

          if (widget && !widget.isDestroyed() && !(widget instanceof cls.ToolBarSeparatorWidget)) {
            this._containerElement.style.opacity = "0"; // 'Hide' style for flickering issues
            this.adoptChildWidget(widget, options);
          }
        },

        /**
         * Remove dom actions
         */
        clearActions: function() {
          while (this.getContainerElement() && this.getContainerElement().firstChild) {
            this.getContainerElement().removeChild(this.getContainerElement().firstChild);
          }
          if (this._rightBarWidget) {
            while (this._rightBarWidget.getContainerElement() && this._rightBarWidget.getContainerElement().firstChild) {
              this._rightBarWidget.getContainerElement().removeChild(this._rightBarWidget.getContainerElement().firstChild);
            }
          }
        },

        /**
         * Define the title displayed in the chromeBar
         * @param {String} title - title displayed
         * @param {classes.Application} app - app
         */
        setTitle: function(title, app) {
          if (!this.isDestroyed()) {
            if (this._titleWidget && this._titleWidget !== title) {
              try {
                this._titleContainerElement.removeChild(this._titleWidget.getElement());
              } catch (e) {}
            }

            if (title && title.isInstanceOf && title.isInstanceOf(cls.ChromeBarTitleWidget)) {
              if (this._titleWidget !== title) {
                this._titleContainerElement.appendChild(title.getElement());
              }
              this._titleWidget = title;
              this._titleContainerElement.removeClass("mt-toolbar-title-text");
            } else {
              this._titleWidget = null;
              this._titleContainerElement.addClass("mt-toolbar-title-text");
              if (typeof title === "string") {
                this._titleElement.innerText = title;
              } else {
                this._titleElement.innerText = this._defaultTitle;
              }
              context.HostService.setDocumentTitle(this._titleElement.innerText, app);
            }
          }
        },

        /**
         * Define the icon displayed at the burger place
         * @param image
         * @param appIcon
         */
        setIcon: function(image, appIcon) {
          if (image && image !== "") {
            if (!appIcon) { // set global icon using app icon only if not previously set with window icon
              this._hasWindowIcon = true;
            } else if (this._hasWindowIcon === true) {
              return;
            }
            if (!this._windowIconImage) {
              this._windowIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._windowIconImage.addClass("appIcon");
              this._sidebarToggle.appendChild(this._windowIconImage.getElement());
              this.addClass("has-window-icon");
            }
            this._windowIconImage.setSrc(image);
            this._windowIconImage.setAlignment("verticalCenter", "horizontalCenter");
            this._windowIconImage.setHidden(false);
          } else {
            if (this._windowIconImage) {
              this._windowIconImage.setHidden(true);
            }
          }
        },

        /**
         * Set menu items as hidden to Handle 4ST actionPanelPosition:none
         * @param {Boolean} hidden - true if it must be hidden
         */
        setMenuItemsHidden: function(hidden) {
          this.toggleClass("menuHidden", hidden);
        },

        /**
         * Get all visible children  with filtering options
         * @param {('item'|'gbcItem'|'overflowItem'|null)} itemType - filter result on a given itemType: gbcItem or item
         * @returns {classes.ChromeBarItemWidget[]} the list of visible children of this widget group
         */
        getVisibleChildren: function(itemType) {
          const children = this.getChildren("item");
          return children.filter(c => c.isVisible());
        },

        /**
         * Get all children of this widget with filtering options
         * @param {('item'|'gbcItem'|'overflowItem'|null)} itemType - filter result on a given itemType: gbcItem or item
         * @returns {classes.ChromeBarItemWidget[]} the list of children of this widget group
         */
        getChildren: function(itemType) {
          if (!itemType) {
            // Default
            return $super.getChildren.call(this);
          } else {
            // Filtering
            return this._children.filter(function(child) {
              return child.getItemType && child.getItemType() === itemType;
            });
          }
        },

        /**
         * Allows one to create a Chromebar without all the items (i.e: session end, logPlayer ...)
         * @param {Boolean} enable - true to enable this mode, false otherwise
         */
        setLightMode: function(enable) {
          this._lightMode = enable;
          this.toggleClass("lightmode", enable);
          if (enable) {
            this.setTitle(this._defaultTitle);
            if (this._logRecordWidget) {
              this._logRecordWidget.destroy();
              this._logRecordWidget = null;
            }
          }
        },

        /**
         * Set the current linked window
         * @param {classes.WindowWidget} window - to link to the chromebar
         */
        setLinkedWindow: function(window) {
          this._closeMenuItem.setLinkedWindow(window);
          this._currentLinkedWindow = window;
        },

        /**
         * Emit the close event of the current window
         */
        closeCurrentWindow: function() {
          this._closeMenuItem.close();
        },

        /**
         * Get the back button widget
         * @return {classes.ChromeBarItemBackButtonWidget}
         */
        getBackButton: function() {
          return this._backButtonWidget;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBar', cls.ChromeBarWidget);
  });
;

"use strict";

modulum('ChromeRightBarWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SideBar for devices with style 'chromeBar' enabled
     * This widget will display all actions/toolbar that doesn't fit in the chromeTopBar
     * @class ChromeRightBarWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ChromeRightBarWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ChromeRightBarWidget.prototype */ {
        __name: "ChromeRightBarWidget",
        __templateName: "ChromeRightBarWidget",

        /** @type {Boolean} */
        _firstItemSelected: false, // flag to keep track of first item (for styling)

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          // Setup of the DropDown
          this.reverseX = true;

        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // Swipe to Right on opened sidebar to close it
          this.getElement().onSwipe("ChromeRightBarWidget", this.hide.bind(this), {
            direction: ["right"]
          });
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Close the chromebar on click on any part of it
          this.hide();
          return true;
        },

        /**
         * Overrided to allow one to click on items of the top chromebar in one click
         * @inheritDoc
         */
        shouldClose: function(targetElement) {
          const topChromeBar = this.getParentWidget();
          return !targetElement.isElementOrChildOf(topChromeBar.getElement());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.getElement().offSwipe("ChromeRightBarWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          // Force a text (aui name) if not defined
          if (widget.getText && widget.getText().length <= 0) {
            widget.setText(widget._auiName);
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @inheritDoc
         */
        adoptChildWidget: function(widget) {
          $super.adoptChildWidget.call(this, widget);

          // Select the first item of the type gbcItem to add some decoration
          if (!this._firstItemSelected && this.getChildren("gbcItem").length > 0) {
            this.getChildren("gbcItem")[0].addClass("chromebar-firstGbcItem");
            this._firstItemSelected = true;
          }
        },

        /**
         * @inheritDoc
         */
        show: function(multiple) {
          // Adding some sliding effect
          $super.show.call(this, multiple);

        },

        /**
         * Get all children of this widget with filtering options
         * @param {string?} itemType - filter result on a given itemType
         * @returns {classes.WidgetBase[]} the list of children of this widget group
         * @publicdoc
         */
        getChildren: function(itemType) {
          if (!itemType) {
            return $super.getChildren.call(this);
          } else {
            return this._children.filter(function(child) {
              if (child.isInstanceOf(cls.ToolBarSeparatorWidget) || !child.getItemType) {
                return false;
              }
              return child.getItemType() === itemType;
            });
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeRightBar', cls.ChromeRightBarWidget);
  });
;

"use strict";

modulum('ChromeBarItemCloseWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Close Button in ChromeBar
     * @class ChromeBarItemCloseWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemCloseWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemCloseWidget.prototype */ {
        __name: "ChromeBarItemCloseWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.close'));
          this.setTitle(i18next.t('gwc.main.chromebar.close'));
          this.setImage("zmdi-close-circle");
          $super.setHidden.call(this, true);
          $super.setAuiName.call(this, "close");
          $super.setQAInfo.call(this, "name", "close");
        },

        /**
         *
         * @param {Boolean} active
         * @param {classes.WindowWidget} windowWidget
         */
        setActive: function(active, windowWidget) {
          this._currentLinkedWindow = windowWidget;
          this._active = active;
          if (!this._destroyed) {
            if (this._element && (window.isIOS() || !context.__wrapper.isNative())) {
              this._element.toggleClass("gbc_Invisible", !active);
            } else {
              this._element.addClass("gbc_Invisible");
            }
          }
        },

        /**
         * @inheritDoc
         */
        canBeInTheOverFlowMenu: function() {
          return window.isIOS() || !context.__wrapper.isNative();
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._active && this.isVisible() && this._currentLinkedWindow.isClosable()) {
            this.close();
          }
          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Emit the close
         */
        close: function() {
          if (!this._processing && this._currentLinkedWindow) {

            this._currentLinkedWindow._emitClose();
          }

        },

        /**
         * Attach a callback when button is clicked
         * @param hook
         * @return {*|Function}
         */
        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);

        },

        /**
         * Set the current linked window
         * @param {classes.WindowWidget} window - to link to the close button
         */
        setLinkedWindow: function(window) {
          this._currentLinkedWindow = window;
        },

        /**
         * Defines if the widget should be hidden or not
         * @param {boolean} hidden true if the widget is hidden, false otherwise
         * @param {?classes.WindowWidget} windowWidget - get info on the window widget to hide or not if tabbed mode
         * @publicdoc
         */
        setHidden: function(hidden, windowWidget) {
          if (!(windowWidget && windowWidget._tabbedContainerWidget)) {
            $super.setHidden.call(this, hidden);
          }
        },

        /**
         *
         * @param processing
         * @private
         */
        _setProcessingStyle: function(processing) {
          this._processing = Boolean(processing);
          if (this._element) {
            if (this._processing) {
              this.domAttributesMutator(() => this._element.setAttribute("processing", "processing"));
            } else {
              this.domAttributesMutator(() => this._element.removeAttribute("processing"));
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemClose', cls.ChromeBarItemCloseWidget);
  });
;

"use strict";

modulum('ChromeBarItemDebugWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Open AUI tree debug in chromeBar
     * @class ChromeBarItemDebugWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemDebugWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemDebugWidget.prototype */ {
        __name: "ChromeBarItemDebugWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.debugTools'));
          this.setTitle("[Debug] AUI tree");
          this.setImage("zmdi-memory");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          context.DebugService.show();
          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemDebug', cls.ChromeBarItemDebugWidget);
  });
;

"use strict";

modulum('ChromeBarItemFilterWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Filter button in ChromeBar
     * @class ChromeBarItemFilterWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemFilterWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemFilterWidget.prototype */ {
        __name: "ChromeBarItemFilterWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type {Element} */
        _filter: null,
        /** @type {Element} */
        _input: null,
        /** @type {Element} */
        _back: null,
        /** @type {Element} */
        _clear: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          this.setItemType("item");
          this.setText(i18next.t('gwc.main.chromebar.filter'));
          this.setTitle(i18next.t('gwc.main.chromebar.filter'));
          this.setImage("zmdi-filter-variant");

          this._filter = document.createElement("span");
          this._filter.addClass("gbc_Filter");

          this._input = document.createElement("input");
          this._input.addClass("gbc_FilterInput");
          this._input.setAttribute("type", "text");
          this._input.setAttribute("placeholder", i18next.t('gwc.main.chromebar.filter'));

          this._back = document.createElement("i");
          this._back.addClasses("zmdi", "zmdi-arrow-left");

          this._clear = document.createElement("i");
          this._clear.addClasses("zmdi", "zmdi-close", "filter-clear");

          this._filter.appendChild(this._back);
          this._filter.appendChild(this._input);
          this._filter.appendChild(this._clear);

          this._input.on('keydown', function(evt) {
            evt.stopPropagation();
            if (evt.key.toLowerCase() === "enter") {
              this.getUserInterfaceWidget().getFocusedWidget().setFocus();
            }
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          this._input.off("keydown");

          this._filter = null;
          this._input = null;
          this._back = null;
          this._clear = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          this.updateFilter();
        },

        /**
         * Update and send filter value to DVM
         */
        updateFilter: function() {
          const app = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
          const focusedNode = app.getFocusedVMNodeAndValue(true);
          const event = new cls.VMConfigureEvent(focusedNode.getId(), {
            filter: this._input.value
          });
          app.scheduler.eventVMCommand(event, focusedNode);
        },

        /**
         * Set filter value in the input element
         * @param {String} value - filter value
         */
        setFilterValue: function(value) {
          this._input.value = value;
        },

        /**
         * Say if we have the focus
         * @returns {boolean}
         */
        hasFocusOnInput: function() {
          return this._filter.isInDOM() && this._input === document.activeElement;
        },

        /**
         * Put the focus to the input filter
         */
        setFocusOnInput: function() {
          if (this._filter.isInDOM()) {
            this._input.domFocus();
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          // click on input filter does nothing
          if (domEvent.target.isElementOrChildOf(this._input)) {
            return false;
          }

          // click on clear button, just clear the input
          if (domEvent.target.isElementOrChildOf(this._clear)) {
            this._input.value = "";
            this.updateFilter();
            this._input.domFocus();
            return false;
          }

          // hide or show input filter
          if (this._filter.isInDOM()) {
            this._image.setHidden(false);
            this._filter.remove();
          } else {
            this._image.setHidden(true);
            this._element.appendChild(this._filter);
            this._input.domFocus();
          }

          return false;
        },

        /**
         * @inheritDoc
         */
        canBeInTheOverFlowMenu: function() {
          return false;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemFilter', cls.ChromeBarItemFilterWidget);
  });
;

"use strict";

modulum('ChromeBarItemProxyLogWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open proxy logs
     * @class ChromeBarItemProxyLogWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemProxyLogWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemProxyLogWidget.prototype */ {
        __name: "ChromeBarItemProxyLogWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.proxyLog'));
          this.setTitle(i18next.t('gwc.main.chromebar.proxyLog'));
          this.setImage("zmdi-file-document");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const session = context.SessionService.getCurrent();
          const connector = session.getConnector();
          const sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/uaproxy-" + sessionId);

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemProxyLog', cls.ChromeBarItemProxyLogWidget);
  });
;

"use strict";

modulum('ChromeBarItemRunInGDCWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open the app in GDC
     * @class ChromeBarItemRunInGDCWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemRunInGDCWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemRunInGDCWidget.prototype */ {
        __name: "ChromeBarItemRunInGDCWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.runInGDC'));
          this.setTitle(i18next.t('gwc.main.chromebar.runInGDC'));
          this.setImage("zmdi-play");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const url = new URL(window.location.href);
          const name = url.pathname.substring(url.pathname.lastIndexOf('/') + 1);
          const shortcut = '<?xml version="1.0" encoding="utf-8"?>\n' +
            '<fjs configVersion="2" product="Genero Desktop Client">\n' +
            ' <Shortcuts>\n' +
            '  <Shortcut ' +
            'name="' + name + '" ' +
            'authenticationMode="standard" ' +
            'type="http" ' +
            'proxyType="monitor" ' +
            'url="' + window.location.href + '" ' +
            '/>\n' +
            ' </Shortcuts>\n' +
            '</fjs>';

          const shortcutFile = new Blob([shortcut], {
            type: "application/genero-gdc"
          });
          //for microsoft IE
          const fileName = name + ".gdc";
          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(shortcutFile, fileName);
          } else { //other browsers
            const a = document.createElement("a");
            a.style.display = "none";
            // firefox needs to have element in DOM
            document.body.appendChild(a);
            a.href = window.URL.createObjectURL(shortcutFile);
            a.download = fileName;
            a.click();
            document.body.removeChild(a);
          }

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemRunInGDC', cls.ChromeBarItemRunInGDCWidget);
  });
;

"use strict";

modulum('ChromeBarItemRuntimeStatusWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Runtime Status in ChromeBar
     * Note: not added to dom, since it's handled by loading bar
     * @class ChromeBarItemRuntimeStatusWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemRuntimeStatusWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemRuntimeStatusWidget.prototype */ {
        __name: "ChromeBarItemRuntimeStatusWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,
        _count: 0,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setTitle(i18next.t('gwc.file.upload.processing'));
          this.setImage("zmdi-upload");
        },

        /**
         * Change style when idle
         */
        setIdle: function() {
          this._count--;
          if (this._count === 0) {
            this.removeClass("processing");

          }
        },

        /**
         * Change style when processing
         */
        setProcessing: function() {
          this._count++;
          this.addClass("processing");
        },

        /**
         * @inheritDoc
         */
        canBeInTheOverFlowMenu: function() {
          return false;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemRuntimeStatus', cls.ChromeBarItemRuntimeStatusWidget);
  });
;

"use strict";

modulum('ChromeBarItemSettingsWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open GBC settings modal
     * @class ChromeBarItemSettingsWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemSettingsWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemSettingsWidget.prototype */ {
        __name: "ChromeBarItemSettingsWidget",
        __templateName: "ChromeBarItemWidget",

        /** @type {classes.ApplicationHostSettingsWidget} */
        _settingsModal: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.settings'));
          this.setTitle(i18next.t('gwc.main.chromebar.settings'));
          this.setImage("zmdi-cog");

          // Add info about browser storage full
          if (gbc.LocalSettingsService._quotaExceededError) {
            this.addClass("error");
          }
          gbc.LocalSettingsService._eventListener.when("QuotaExceededError", function() {
            this.addClass("error");
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._settingsModal) {
            this._settingsModal.destroy();
            this._settingsModal = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._settingsModal === null) {
            this._settingsModal = cls.WidgetFactory.createWidget('ApplicationHostSettings', this.getBuildParameters());
            document.body.appendChild(this._settingsModal.getElement());
            this._settingsModal.when(context.constants.widgetEvents.close, function() {
              if (this._settingsModal) {
                this._settingsModal.destroy();
                this._settingsModal = null;
              }
            }.bind(this), true);
          }
          this._settingsModal.show();

          return $super.manageMouseClick.call(this, domEvent);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemSettings', cls.ChromeBarItemSettingsWidget);
  });
;

"use strict";

modulum('ChromeBarItemUploadStatusWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Close Button in ChromeBar
     * @class ChromeBarItemUploadStatusWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemUploadStatusWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemUploadStatusWidget.prototype */ {
        __name: "ChromeBarItemUploadStatusWidget",
        __templateName: "ChromeBarItemWidget",

        _active: false,
        _count: 0,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setItemType("gbcItem");
          this.setTitle(i18next.t('gwc.file.upload.processing'));
          this.setImage("zmdi-upload");
        },

        /**
         * Change style when idle
         */
        setIdle: function() {
          this._count--;
          if (this._count === 0) {
            this.removeClass("processing");

          }
        },

        /**
         * Change style when processing
         */
        setProcessing: function() {
          this._count++;
          this.addClass("processing");
        },

        /**
         * Handle file upload progress
         * @param {Object} progress object info
         * @param {number} progress.loaded amount already uploaded
         * @param {number} progress.total total amount of data
         */
        setProgress: function(progress) {
          const percent = Math.round(progress.loaded * 100 / progress.total);
          this.setText(percent + "%");
          this.setImage();
          const loadingBar = document.querySelector(".loading-bar");
          loadingBar.setAttribute("percent", percent.toString());
          loadingBar.style.width = percent.toString() + "%";
          if (percent === 100) {
            loadingBar.removeAttribute("percent");
            loadingBar.style.width = "100%";
          }
          this.setTitle(i18next.t('gwc.file.upload.processing') + " (" + this.formatFileSize(progress.loaded) + "/" + this.formatFileSize(
            progress.total) + ")");
        },

        /**
         * Display human-readable value
         * @param {Number} bytes
         * @param {Number?} decimalPoint - length of the decimal part
         * @return {string} human readable value
         */
        formatFileSize: function(bytes, decimalPoint) {
          if (bytes === 0) {
            return '0 Bytes';
          }
          const k = 1000,
            dm = decimalPoint || 2,
            sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'],
            i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        },

        /**
         * @inheritDoc
         */
        canBeInTheOverFlowMenu: function() {
          return false;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemUploadStatus', cls.ChromeBarItemUploadStatusWidget);
  });
;

"use strict";

modulum('ChromeBarItemVMLogWidget', ['ChromeBarItemWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button in chromeBar to open VM logs
     * @class ChromeBarItemVMLogWidget
     * @memberOf classes
     * @extends classes.ChromeBarItemWidget
     */
    cls.ChromeBarItemVMLogWidget = context.oo.Class(cls.ChromeBarItemWidget, function($super) {
      return /** @lends classes.ChromeBarItemVMLogWidget.prototype */ {
        __name: "ChromeBarItemVMLogWidget",
        __templateName: "ChromeBarItemWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          context.DebugService.registerDebugUi(this);
          this.setItemType("gbcItem");
          this.setText(i18next.t('gwc.main.chromebar.vmLog'));
          this.setTitle(i18next.t('gwc.main.chromebar.vmLog'));
          this.setImage("zmdi-file-outline");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          context.DebugService.unregisterDebugUi(this);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const session = context.SessionService.getCurrent();
          const connector = session.getConnector();
          const sessionId = session.getSessionId();
          window.open(connector + "/monitor/log/vm-" + sessionId);

          return $super.manageMouseClick.call(this, domEvent);
        },

        /**
         * Called by Debug service to tell UI that it's ready
         * @param active
         */
        activate: function(active) {
          this._element.toggleClass("debugActivated", active);
        },

        /**
         * @inheritDoc
         */
        isHidden: function() {
          // If debug mode is not active, this item is supposed to be hidden
          return !gbc.DebugService.isActive() ? true : $super.isHidden.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ChromeBarItemVMLog', cls.ChromeBarItemVMLogWidget);
  });
;

"use strict";

modulum('LogLevelSelectorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogLevelSelectorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogLevelSelectorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogLevelSelectorWidget.prototype */ {
        __name: "LogLevelSelectorWidget",

        _currentItem: null,

        _initElement: function() {
          $super._initElement.call(this);
          this.setCurrent(context.LogService.getCurrentLevel());
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.dataset.loglevel) {
            this.setCurrent(domEvent.target.dataset.loglevel);
            this.emit("loglevel", domEvent.target.dataset.loglevel);
          }
          return true;
        },

        setCurrent: function(level) {
          if (this._currentItem) {
            this._currentItem.removeClass("active");
          }
          this._currentItem = this._element.querySelector("." + level);
          if (!this._currentItem) {
            this._currentItem = this._element.querySelector(".none");
          }
          this._currentItem.addClass("active");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('LogLevelSelector', cls.LogLevelSelectorWidget);
  });
;

"use strict";

modulum('LogInfoWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Display useful info about a log (GBC log only)
     * @class LogInfoWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.LogInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogInfoWidget.prototype */ {
        __name: "LogInfoWidget",

        _infoGBCElement: null,
        _infoBrowserElement: null,
        _infoThemeElement: null,
        _infosettingsElement: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._infoGBCElement = this.getElement().querySelector(".loginfo-gbc");
          this._infoBrowserElement = this.getElement().querySelector(".loginfo-browser");
          this._infoThemeElement = this.getElement().querySelector(".loginfo-theme");
          this._infosettingsElement = this.getElement().querySelector(".loginfo-settings");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Define the GBC related info
         * @param {Object} gbcInfo
         */
        setGBCInfo: function(gbcInfo) {
          const themes = gbcInfo.availableThemes.map(function(t) {
            return t.name;
          });
          const sideBarInfo = gbcInfo.isSideBarVisible ? "Yes: " + gbcInfo.sideBarSize + "px" : 'No';
          let body = "<ul>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.version') + ": </span><span class='value'>" +
            gbcInfo.version + "-" + gbcInfo.build +
            "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.platform') + ": </span><span class='value'>" +
            gbcInfo.platformName + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.protocol') + ": </span><span class='value'>" +
            gbcInfo.protocolType + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.theme') + ": </span><span class='value'>" +
            gbcInfo.activeTheme + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.availableThemes') +
            ": </span><span class='value'>" + themes + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.sidebar') + ": </span><span class='value'>" +
            sideBarInfo + "</span></li>";
          body += "</ul>";
          this._infoGBCElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Define the Browser related info
         * @param {Object} browserInfo
         */
        setBrowserInfo: function(browserInfo) {
          let body = "<ul>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.userAgent') + ":</span><span class='value'>" +
            browserInfo.userAgent + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.os') + ": </span><span class='value'>" +
            browserInfo.os + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.lang') + ": </span><span class='value'>" +
            browserInfo.activeLanguage + "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.availableLang') +
            ": </span><span class='value'> " + browserInfo.availableLanguages +
            "</span></li>";
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.dimension') + ": </span><span class='value'>" +
            browserInfo.dimension.width + 'x' +
            browserInfo.dimension.height + '</span></li>';
          body += "<li><span class='title'>- " + i18next.t('gwc.logPlayer.logInfo.url') + ": </span><span class='value'>" +
            browserInfo.url + "</span></li>";
          body += "</ul>";
          this._infoBrowserElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Display the themes variables
         * @param {Object} theme
         */
        setTheme: function(theme) {
          const themeEntries = Object.keys(theme);
          let body = "<ul>";

          for (const element of themeEntries) {
            body += "<li><span class='title'>$" + element + "</span> = <span class='value'>" + theme[element] +
              "</span></li>";
          }
          body += "</ul>";

          this._infoThemeElement.querySelector(".panel-body").innerHTML = body;
        },

        /**
         * Display the StoredSettings
         * @param {Object} settings
         */
        setSettings: function(settings) {
          const body = JSON.stringify(settings, "\n", 2);
          this._infosettingsElement.querySelector(".panel-body").innerHTML = "<pre>" + body + "</pre>";
        },

      };
    });
    cls.WidgetFactory.registerBuilder('LogInfo', cls.LogInfoWidget);
  });
;

"use strict";

modulum('LogPlayerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget used to replay logs from VM, GBC, GDC and so
     * @class LogPlayerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.LogPlayerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.LogPlayerWidget.prototype */ {
        __name: "LogPlayerWidget",

        /** @type {Element} **/
        _fileInput: null,
        /** @type {Element} **/
        _delayInput: null,
        /** @type {Element} **/
        _delayFromLogElement: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _delayFromLogWidget: null,
        /** @type {Element} **/
        _showHelpersElement: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _showHelpersWidget: null,
        /** @type {Element} **/
        _resetButton: null,
        /** @type {Element} **/
        _nextStepButton: null,
        /** @type {Element} **/
        _playAllButton: null,
        /** @type {Element} **/
        _pauseButton: null,
        /** @type {Element} **/
        _forwardInput: null,
        /** @type {Element} **/
        _forwardButton: null,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _statsCheckWidget: null,
        /** @type {Element} **/
        _statsElement: null,
        /** @type {Array} **/
        _log: null,
        /** @type {Map} **/
        _appProcIds: null,
        /** @type {Number} **/
        _currentLogLine: 0,
        /** @type {Number} **/
        _currentDvmOrder: 0,
        /** @type {Number} **/
        _numberOfDvmOrdersToProcess: 0,
        /** @type {Number} **/
        _processedDvmOrders: 0,
        /** @type {Number} **/
        _startTime: null,
        /** @type {Number} **/
        _maxNumberOfElements: null,
        /** @type {Number} **/
        _maxNumberOfWidgets: null,
        /** @type {Element} **/
        _debugCursorElement: null,
        /** @type {Element} **/
        _keyPressedElement: null,
        /** @type {Element} **/
        _mousePressedElement: null,
        /** @type {Element} **/
        _headerElement: null,
        /** @type {Object} **/
        _gbcBrowserInfo: null,
        /** @type {classes.LogInfoWidget} **/
        _logInfoWidget: null,
        /** @type {Boolean} **/
        _isPaused: false,
        /** @type {Object} **/
        _userInteractionElement: null,
        /** @type {Boolean} **/
        _userInteractionAllowed: false,
        /** @type {classes.ToggleCheckBoxWidget} **/
        _userInteractionWidget: null,

        /** @type {Element} **/
        _customStyle: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          window._logplayer = this;

          // Enable Debug Helpers when using logPlayer (even if not in debugMode)
          gbc.classes.DebugHelper.activateDebugHelpers();

          const root = this.getElement();

          this._fileInput = root.querySelector(".logplayer-fileinput");
          this._fileInput.on('change.LogPlayerWidget', this.loadFile.bind(this));

          this._headerElement = root.querySelector("header");
          this._resetButton = root.querySelector(".logplayer-reset");
          this._nextStepButton = root.querySelector(".logplayer-step");
          this._playAllButton = root.querySelector(".logplayer-play");
          this._pauseButton = root.querySelector(".logplayer-pause");
          this._forwardInput = root.querySelector(".logplayer-forward-count");
          this._forwardButton = root.querySelector(".logplayer-forward");
          this._delayInput = root.querySelector(".logplayer-delay");
          this._delayFromLogElement = root.querySelector(".logplayer-delayfromlog");
          this._statsElement = root.querySelector(".logplayer-stats");
          this._showHelpersElement = root.querySelector(".logplayer-showHelpers");
          this._debugCursorElement = root.querySelector(".logplayer-cursor");
          this._keyPressedElement = root.querySelector(".logplayer-keypressed");
          this._mousePressedElement = root.querySelector(".logplayer-mousepressed");
          this._userInteractionElement = root.querySelector(".logplayer-userInteraction");

          // Default value
          this.setDelayInputValue(500);

          this._gbcTitle = document.querySelector(".mt-toolbar-title");

          this.setButtonEnabled(this._resetButton, false);
          this.setButtonEnabled(this._nextStepButton, false);
          this.setButtonEnabled(this._playAllButton, false);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._forwardButton, false);

          this._statsCheckWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._statsCheckWidget.setEnabled(true);
          this._statsCheckWidget.setText(i18next.t("gwc.logPlayer.topBar.statistics"));
          this._statsCheckWidget.setTitle(i18next.t("gwc.logPlayer.topBar.statisticsTitle"));
          this._statsCheckWidget.setValue(false);
          this._statsElement.appendChild(this._statsCheckWidget.getElement());

          this._delayFromLogWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._delayFromLogWidget.setEnabled(true);
          this._delayFromLogWidget.setText(i18next.t("gwc.logPlayer.topBar.delayFromLog"));
          this._delayFromLogWidget.setValue(false);
          this._delayFromLogElement.appendChild(this._delayFromLogWidget.getElement());

          this._showHelpersWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
          this._showHelpersWidget.setEnabled(true);
          this._showHelpersWidget.setText(i18next.t("gwc.logPlayer.topBar.showHelpers"));
          this._showHelpersWidget.setTitle(i18next.t("gwc.logPlayer.topBar.showHelpersTitle"));
          this._showHelpersWidget.setValue(true);
          this._showHelpersElement.appendChild(this._showHelpersWidget.getElement());

          if (gbc.DebugService.isActive()) {
            this._userInteractionWidget = cls.WidgetFactory.createWidget("ToggleCheckBox", this.getBuildParameters());
            this._userInteractionWidget.setEnabled(true);
            this._userInteractionWidget.setText("User Interaction");
            this._userInteractionWidget.setValue(false);
            this._userInteractionWidget.when(context.constants.widgetEvents.valueChanged, function() {
              this.addOverlay(!this._userInteractionWidget.getValue(), false, true);
            }.bind(this));
            this._userInteractionElement.appendChild(this._userInteractionWidget.getElement());
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._statsCheckWidget) {
            this._statsCheckWidget.destroy();
            this._statsCheckWidget = null;
          }
          if (this._delayFromLogWidget) {
            this._delayFromLogWidget.destroy();
            this._delayFromLogWidget = null;
            this._delayFromLogElement = null;
          }
          if (this._showHelpersWidget) {
            this._showHelpersWidget.destroy();
            this._showHelpersWidget = null;
          }
          if (this._logInfoWidget) {
            this._logInfoWidget.destroy();
            this._logInfoWidget = null;
          }
          if (this._customStyle) {
            document.getElementsByTagName('head')[0].removeChild(this._customStyle);
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const target = domEvent.target;
          if (target.isElementOrChildOf(this._resetButton)) {
            this.reset();
          } else if (target.isElementOrChildOf(this._nextStepButton)) {
            this.nextStep();
          } else if (target.isElementOrChildOf(this._playAllButton)) {
            this.play();
          } else if (target.isElementOrChildOf(this._forwardButton)) {
            this.forward();
          } else if (target.isElementOrChildOf(this._pauseButton)) {
            this.pause();
          }
          return true;
        },

        /**
         * Define a delay between orders
         * @param {Number} value - value in ms
         */
        setDelayInputValue: function(value) {
          this._delayInput.value = value;
        },

        /**
         * Define the step to go forward to
         * @param {Number} value - step number to go to
         */
        setForwardInputValue: function(value) {
          this._forwardInput.value = value;
        },

        /**
         * Method called when content is read from a log file
         * @param {String|String[]} content
         */
        loadContent: function(content) {
          this._nextStepButton.removeAttribute('disabled');
          this._playAllButton.removeAttribute('disabled');
          this._log = null;
          this._appProcIds = new Map();
          this.reset();
          const rawContent = content;

          content = content.split('\n').map(function(line) {
            return line.trim();
          });
          if (content.length > 0) {
            if (rawContent.indexOf('gbcLog') < 0 && this._logInfoWidget) {
              this._logInfoWidget.destroy();
            }
            const firstLine = content[0];
            if (firstLine === 'LOGVERSION=2') {
              this.parseGdcLog(content);
            } else if (firstLine.substring(0, 5) === 'om 0 ') {
              this.parseFglLog(content);
            } else if (firstLine === 'guilog v2') {
              this.parseFglLogV2(content);
            } else if (firstLine === '#Version: 1.0') {
              this.parseUaproxyLog(content);
            } else if (rawContent.indexOf('gbcLog') >= 0) {
              this.parseGbcLog(JSON.parse(rawContent));
            }
            this.setButtonEnabled(this._resetButton, true);
            this.setButtonEnabled(this._nextStepButton, true);
            this.setButtonEnabled(this._playAllButton, true);
            this.setButtonEnabled(this._forwardButton, true);
          }
        },

        /**
         * Method called when a file has been inputted
         * @param event
         */
        loadFile: function(event) {
          if (event.target.files.length > 0) {
            context.LogPlayerService.cleanApplications(); //Reset all current applications
            this._fileInput.setAttribute("title", event.target.files[0].name + " loaded");
            this._gbcTitle = document.querySelector(".mt-toolbar-title");
            this._gbcTitle.innerHTML = "<b>Log Player : </b> " + event.target.files[0].name;

            const reader = new FileReader();
            reader.onload = function(fEvent) {
              this.loadContent(fEvent.target.result);
            }.bind(this);
            reader.readAsText(event.target.files[0]);
          }
        },

        /**
         * Reset logPlayer at first instruction
         */
        reset: function() {
          // Current app reset
          if (gbc.SessionService.getCurrent()) {
            gbc.SessionService.getCurrent().closeSession();
            gbc.SessionService.getCurrent().destroy();
          }
          if (this._logInfoWidget) {
            this._logInfoWidget.setHidden(false);
          }

          this.setButtonEnabled(this._resetButton, true);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._forwardButton, true);
          this.addOverlay(false, true);

          this._currentLogLine = 0;
          this._currentDvmOrder = 0;
          this._numberOfDvmOrdersToProcess = 0;
          this._processedDvmOrders = 0;

          gbc.LogPlayerService.cleanApplications();
          const appElement = document.querySelector(".gbc_ApplicationWidget");
          if (appElement) {
            appElement.innerHTML = "";
          }
          if (this._gbcTitle) {
            this._gbcTitle.parent("gbc_ApplicationLauncherWidget").removeClass("hidden");
          }
          this._cleanDebugHelper();
          this.setButtonEnabled(this._fileInput, true);

        },

        /**
         * Parse a GDC formatted log
         * @param log
         */
        parseGdcLog: function(log) {
          this._log = [];
          for (let i = 0; i < log.length; ++i) {
            if (i !== 0) {
              const line = log[i];
              if (line.length > 0) {
                const appEnd = line.indexOf(':');
                const senderEnd = line.indexOf(':', appEnd + 1);
                const delayEnd = line.indexOf(':', senderEnd + 1);

                const entry = {};
                entry.app = line.substring(0, appEnd);
                entry.sender = line.substring(appEnd + 1, senderEnd);
                entry.delay = line.substring(senderEnd + 1, delayEnd);
                entry.content = context.LogPlayerService.mockOrderResources(line.substring(delayEnd + 1));

                this._log.push(entry);
              }
            }
          }
        },

        /**
         * Parse a GBC formatted Log
         * @param {Object} log - json Formated log
         */
        parseGbcLog: function(log) {
          this._currentLogType = log.logType;
          this._delayFromLogWidget.setValue(false);
          this.setDelayInputValue(5); // if gbcLog: put some small value in this field
          this._log = [];
          let lastKnownTimestamp = 0;
          const style = 'color: #007da0'; // console style

          this._gbcBrowserInfo = log.browserInfos;
          // Show info in the page when parsing log
          if (this._logInfoWidget) {
            this._logInfoWidget.destroy();
          }
          this._logInfoWidget = cls.WidgetFactory.createWidget("LogInfo", this.getBuildParameters());
          window.document.querySelector(".gbc_ApplicationLauncherWidget>.containerElement").appendChild(this._logInfoWidget.getElement());
          this._logInfoWidget.setGBCInfo(log.gbcInfos);
          this._logInfoWidget.setBrowserInfo(log.browserInfos);
          this._logInfoWidget.setTheme(log.themeVariables);
          this._logInfoWidget.setSettings(log.storedSettings);

          this._customStyle = document.createElement('style');
          this._customStyle.type = 'text/css';
          document.getElementsByTagName('head')[0].appendChild(this._customStyle);

          // Ensure messages are well positioned
          context.HostService.onScreenResize(function() {
            const margin = document.body.clientWidth - log.browserInfos.dimension.width;
            this._customStyle.innerHTML = '.gbc_ApplicationHostWidget .mt-centralcontainer{ left: 0px!important}\n';
            this._customStyle.innerHTML += '.gbc_MessageWidget.bottom-right, .gbc_MessageWidget.top-right{ margin-right: ' +
              margin + 'px }\n';
          }.bind(this));

          let margin = document.body.clientWidth - log.browserInfos.dimension.width;
          this._customStyle.innerHTML = '.gbc_MessageWidget.bottom-right, .gbc_MessageWidget.top-right{ margin-right: ' + margin +
            'px; }\n';
          this._customStyle.innerHTML +=
            '.gbc_ChromeBarWidget.mt-toolbar .mt-sidebar-toggle, .gbc_ApplicationHostSidebarWidget .mt-sidebar-toggle { display:inherit!important; pointer-events:all!important;}\n';

          // If log specifically said: no sidebar
          if (!log.gbcInfos.isSideBarVisible) {
            const st = document.createElement('style');
            st.type = 'text/css';
            st.innerHTML = '.mt-sidebar:not(.mt-sidebar-unavailable){ left: -100%; }';
            document.getElementsByTagName('head')[0].appendChild(st);
            context.HostLeftSidebarService.hideSidebar();
            this._customStyle.innerHTML += ".gbc_ApplicationHostWidget .mt-centralcontainer{ left: 0px!important}";
          }
          // Header part in console
          console.log('%c ~~~~~~~~~~~~~~~~~~~   Starting GBC log   ~~~~~~~~~~~~~~~~~~~', style);
          console.log('%c Recorded date : ', style, new Date(log.runDate));
          console.log('%c GBC ' + log.gbcInfos.version + '-' + log.gbcInfos.build + ' - Platform: ' + log.gbcInfos.platformName +
            ' - Protocol: ' + log.gbcInfos.protocolType, style);
          console.log('%c   - Theme: ' + log.gbcInfos.activeTheme, style);
          console.log('%c   - Available themes: ', style, log.gbcInfos.availableThemes);
          console.log('%c BROWSER ', style);
          console.log('%c   - User Agent: ', style, log.browserInfos.userAgent);
          console.log('%c   - OS: ', style, log.browserInfos.os);
          console.log('%c   - Language: ', style, log.browserInfos.activeLanguage, log.browserInfos.availableLanguages);
          console.log('%c   - Dimension: ', style, log.browserInfos.dimension);
          console.log('%c   - URL: ', style, log.browserInfos.url);
          console.log('%c THEME VARIABLES: ', style, log.themeVariables);
          console.log('%c STORED SETTINGS: ', style, log.storedSettings);

          // Activate debug mode if log has been recorded with it
          if (log.gbcInfos.debugMode) {
            gbc.DebugService.activate(true);
          }

          let line = null,
            entry = {};

          // Pre-Process every log when parsing
          for (let i = 1; i < log.logs.length; ++i) { // start at 1 since 0 is "gbclog"
            line = log.logs[i];
            entry = {};
            entry.delay = 0;
            entry.app = "" + line.appId;

            // Get info about timestamp
            lastKnownTimestamp = line.t ? line.t : lastKnownTimestamp;
            entry.timestamp = lastKnownTimestamp;

            // Timestamp / delay calculation
            if (this._log.length >= 1) {
              if (lastKnownTimestamp !== this._log[this._log.length - 1].timestamp) {
                if (this._log[this._log.length - 1].timestamp > 0) {
                  entry.delay = lastKnownTimestamp - this._log[this._log.length - 1].timestamp;
                }
              }
            }

            // In this case, it should be treated as a DVM RESPONSE
            if (line.provider === "[NETWORK]") {
              if (line.httpType === "HTTP RESPONSE") {
                entry.sender = "DVM";
                entry.app = "" + line.appId;
                entry.content = context.LogPlayerService.mockOrderResources(line.data, log.images);
                this._log.push(entry);
              } else if (line.httpType === "HTTP REQUEST") {
                entry.sender = "GBC-NETWORK";
                entry.content = line.type;
                if (line.uaDetails === "auiOrder") {
                  entry.content = line.data;
                } else {
                  entry.app = "?";
                }

                this._log.push(entry);
              }
            } else if (line.provider === "[MOUSE]") {
              // Add a move entry delay 500ms before the click
              entry.sender = "GBC";
              entry.data = line;
              entry.data.move = true;
              entry.data.click = false;
              const entryClick = JSON.parse(JSON.stringify(entry)); // deep copy the first entry
              entry.data.rightClick = false;
              this._log.push(entry);
              // Add the click entry
              entryClick.data.move = false;
              entryClick.data.click = true;
              this._log.push(entryClick);
            } else {
              entry.sender = "GBC";
              entry.data = line;
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse a FGL formatted log
         * @param log
         */
        parseFglLog: function(log) {
          this._log = [];
          for (const line of log) {
            if (line.length > 0) {
              const entry = {};
              entry.app = "0";
              entry.delay = 1000;
              if (line[0] === '#') {
                if (line.substr(0, 7) === '#event ') {
                  entry.sender = "FE";
                } else {
                  entry.sender = "COMMENT";
                }
                entry.content = context.LogPlayerService.mockOrderResources(line.substring(1));
              } else {
                entry.sender = "DVM";
                entry.content = context.LogPlayerService.mockOrderResources(line);
              }
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse a FGL with new log format
         * @param log
         */
        parseFglLogV2: function(log) {
          this._log = [];
          let lastOrderTime = 0;
          for (let i = 1; i < log.length; ++i) {
            const line = log[i];
            if (line.length > 0) {
              const colonIndex = line.indexOf(':');
              const info = line.substr(0, colonIndex).split(' ');
              const entry = {};
              entry.app = info[0];
              const timestamp = parseInt(info[1]);
              entry.delay = timestamp - lastOrderTime;
              lastOrderTime = timestamp;
              entry.sender = info[2] === 'i' ? "FE" : "DVM";
              entry.content = context.LogPlayerService.mockOrderResources(line.substr(colonIndex + 1));
              this._log.push(entry);
            }
          }
        },

        /**
         * Parse UA proxy formatted log
         * @param log
         */
        parseUaproxyLog: function(log) {
          this._log = [];
          let fieldsCount = null;
          let relativeTimeFieldIndex = null;
          let contextsFieldIndex = null;
          let eventTypeFieldIndex = null;
          let eventParamsFieldIndex = null;
          let timeSinceLastDvmOrder = 0;

          for (const line of log) {
            if (line.length !== 0) {
              if (line[0] === '#') {
                if (line.substr(0, 9) === '#Fields: ') {
                  const fields = line.substr(9).split(' ');
                  fieldsCount = fields.length;
                  relativeTimeFieldIndex = fields.indexOf('relative-time');
                  contextsFieldIndex = fields.indexOf('contexts');
                  eventTypeFieldIndex = fields.indexOf('event-type');
                  eventParamsFieldIndex = fields.indexOf('event-params');
                  if (relativeTimeFieldIndex === -1 || contextsFieldIndex === -1 || eventTypeFieldIndex === -1 ||
                    eventParamsFieldIndex === -1) {
                    this.addLog(" ", '<b>Log fields missing. Enable "ALL DEBUG" categories</b>');
                    return;
                  }
                }
              } else {
                let sectionStart = -1;
                const sections = [];
                for (let j = 0; j < line.length; ++j) {
                  const c = line[j];
                  if (c === ' ') {
                    sections.push(line.substring(sectionStart + 1, j));
                    sectionStart = j;
                  } else if (c === '"') {
                    j = line.indexOf('"', j + 1);
                  }
                  if (sections.length === fieldsCount - 1) {
                    sections.push(line.substr(j + 1));
                    break;
                  }
                }
                timeSinceLastDvmOrder += parseFloat(sections[relativeTimeFieldIndex]);
                const contexts = sections[contextsFieldIndex];
                const eventType = sections[eventTypeFieldIndex];
                const eventParams = sections[eventParamsFieldIndex];
                const vmIdIndex = contexts.indexOf('VM=');
                let vmId = null;
                if (vmIdIndex !== -1) {
                  let semiColonIndex = contexts.indexOf(';', vmIdIndex);
                  if (semiColonIndex === -1) {
                    semiColonIndex = undefined;
                  }
                  vmId = contexts.substring(vmIdIndex + 3, semiColonIndex);
                }
                if (vmId !== null) {
                  if (eventType === '"Sending VM"' || eventType === '"Sending UA"') {
                    if ((eventParams.indexOf("meta Connection") === 0 || eventParams.indexOf("om") === 0 || eventParams.indexOf(
                        "event _om") === 0)) {
                      const sender = eventType === '"Sending UA"' ? "DVM" : "FE";
                      let orders = eventParams;
                      let crIndex = -1;
                      do {
                        crIndex = orders.indexOf('\\n', crIndex + 1);
                        if (crIndex > 1 && orders[crIndex - 1] !== '\\') {
                          orders = orders.substr(0, crIndex) + '\n' + orders.substr(crIndex + 2);
                        }
                      } while (crIndex !== -1);
                      let order = this.detachString(orders);
                      order = order.replace(/([^\\])\\t/g, '$1\t');
                      order = order.replace(/\\\\n/g, '\\n');
                      order = order.replace(/\\\\\\\\/g, '//');
                      order = order.replace(/\\\\"/g, '\\"');
                      order = order.replace(/\\r/g, '');
                      order = order.replace(/%/g, "%25");
                      order = decodeURIComponent(order.replace(/\\x/g, "%"));
                      order = context.LogPlayerService.mockOrderResources(order);

                      if (order !== '-') { // '-' marks the DVM deconection
                        const entry = {};
                        entry.app = this.detachString(vmId);
                        entry.sender = sender;
                        entry.content = order;
                        entry.delay = sender === 'DVM' ? Math.round(timeSinceLastDvmOrder * 1000) : 0;
                        timeSinceLastDvmOrder = 0;
                        this._log.push(entry);
                      }
                    } else if (/X-FourJs-Closed: true/.test(line)) {
                      const closeEntry = {};
                      closeEntry.app = this.detachString(vmId);
                      closeEntry.sender = "";
                      closeEntry.content = "";
                      closeEntry.close = true;
                      closeEntry.delay = 0;
                      timeSinceLastDvmOrder = 0;
                      this._log.push(closeEntry);

                    }
                  }
                }
              }
            }
          }
        },

        /**
         * Go to the next step
         */
        nextStep: function() {
          if (this._log) {
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = 1;
            this.run();
          }
        },

        /**
         * Play the log at current step
         */
        play: function() {
          if (this._log) {
            this._startTime = performance.now();
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = this._log.length;
            this.run();
          }
        },

        /**
         * Pause the log execution
         */
        pause: function() {
          this._isPaused = true;
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._resetButton, true);
          this.addOverlay(false);
        },

        /**
         * FastForward at a given step
         * @see this.setForwardInputValue method
         */
        forward: function() {
          if (this._log) {
            this._processedDvmOrders = 0;
            this._numberOfDvmOrdersToProcess = this._forwardInput.value;
            this.run();
          }
        },

        /**
         * Rework an entry to add some extra info in case of gbcLog
         * @param {Object} entry - log entry to re-format
         * @return {Object} return the modified entry
         * @private
         */
        _handleGBCLog: function(entry) {
          const entryData = entry.data;
          if (entryData) {
            // get category
            const mouseMatch = entryData.provider.match(/\[MOUSE\]/);
            const keyboardMatch = entryData.provider.match(/\[KEYBOARD\]/);
            const uiMatch = entryData.provider.match(/\[UI\]/);
            let outstr = "";

            // Anything MOUSE related
            if (mouseMatch) {
              const x = entryData.clientX - 16; // 16px is the half of the cursor image
              const y = entryData.clientY + this._headerElement.clientHeight - 16;

              let action = entryData.click ? "click" : "move";
              action = entryData.rightClick ? "rightClick" : action;

              outstr = action + ' at x:' + x + ' y:' + y;
              console.log('%c ' + outstr + ' on', 'color: #007da0', entryData.itemId, entryData.auiId, entryData.itemElement);

              const clickDelay = action === "click" ? entry.delay : 100;
              entry.delay = action === "move" ? 0 : entry.delay;

              this.setDebugMouse(x, y, action, clickDelay);
              // Anything KEYBOARD related
            } else if (keyboardMatch) {
              outstr = 'Keyboard key pressed: ';
              console.log('%c ' + outstr, 'color: #007da0', entryData.eventKey || entryData.bufferedKey);
              if (entryData.bufferedKey && entryData.eventKey && entryData.type === "onKeyDown") {
                this.setDebugKeyboardKey(entryData.bufferedKey);
              }
              // Anything UI related
            } else if (uiMatch) {
              if (entryData.type === "sidebar") {
                if (entryData.status) {
                  context.HostLeftSidebarService.showSidebar();
                } else {
                  context.HostLeftSidebarService.hideSidebar();
                }
              } else if (entryData.type === "dropdown") {
                if (entryData.name === "ChromeRightBarWidget") {
                  console.log("chromebar open");
                  const rb = gbc.SessionService.getCurrent().getCurrentApplication().getChromeBar().getRightBarWidget();
                  if (entryData.status) {
                    rb.show();
                  } else {
                    rb.hide();
                  }
                } else if (entryData.name === "ContextMenuWidget") {
                  if (entryData.data.parentName === "TableColumnTitleWidget") {
                    const tbColumn = window.gbcWidget(entryData.data.auiTag);
                    const titleWidget = tbColumn.getTitleWidget();
                    if (entryData.status) {
                      titleWidget.showContextMenu(entryData.data.x);
                    } else if (titleWidget._contextMenu) {
                      titleWidget._contextMenu.hide();
                    }
                  }
                }
              }
            }
          }
          if (entry.content && entry.content.substr(0, 4) === "om 0") {
            entry.dimension = this._gbcBrowserInfo.dimension;
          }
          return entry;
        },

        /**
         * Run the Log player
         */
        run: function() {
          this.addOverlay(true);
          // Set the control button accordingly
          if (!this._isPaused) {
            this.setButtonEnabled(this._resetButton, false);
          }
          this.setButtonEnabled(this._nextStepButton, this._isPaused);
          this.setButtonEnabled(this._playAllButton, this._isPaused);
          this.setButtonEnabled(this._pauseButton, !this._isPaused);
          this.setButtonEnabled(this._forwardButton, false);

          // Prevent file upload while processing
          this.setButtonEnabled(this._fileInput, false);

          // While there are instruction to process
          while (this._currentLogLine < this._log.length) {
            if (window.__jsErrors && window.__jsErrors.length) {
              window.critical.display(window.__jsErrors[0]);
              this.emit(context.constants.widgetEvents.logPlayerError);
              throw window.__jsErrors[0];
            }
            if (this._isPaused) {
              this._isPaused = false;
              return;
            }
            let entry = this._log[this._currentLogLine];
            ++this._currentLogLine;
            const isDvm = entry.sender === 'DVM' && entry.content.substr(0, 5) !== 'meta ';
            const isDVMmetaClient = entry.sender === 'DVM' && entry.content.substr(0, 15) === 'meta Connection';
            const isOm0 = entry.sender === 'DVM' && entry.content.substr(0, 4) === 'om 0';
            const om0Content = isOm0 ? cls.AuiProtocolReader.translate(entry.content) : null;
            let app = context.LogPlayerService.getApplication(0, entry.app, isOm0 ? om0Content[0].operations[0].node.attributes.procId : null,
              entry.sender !== 'DVM');
            if (this._currentLogType === "gbcLog") {
              entry = this._handleGBCLog(entry);
            }
            if (app) {
              if (isDVMmetaClient) {
                //Application has already received meta connection info
                if (app.info() && app.info().procId) {
                  //A new application is starting with the same id must remove the existing one
                  context.LogPlayerService.removeApplication(0, entry.app);

                  app = context.LogPlayerService.getApplication(0, entry.app, isOm0 ? om0Content[0].operations[0].node.attributes.procId :
                    null,
                    entry.sender !== 'DVM');
                }

                const msg = cls.AuiProtocolReader.translate(entry.content);
                this._appProcIds.set(entry.app, msg[0].attributes.procId);
                app.info().procId = msg[0].attributes.procId;
                app.info().connectionInfo = msg[0].attributes;
                app.getSession().getNavigationManager().updateApplicationInformation(app);
              } else if (isOm0 && !app.info().connectionInfo) {
                const msg = cls.AuiProtocolReader.translate(entry.content);
                app.info().procId = msg[0].operations[0].node.attributes.procId;
                app.info().connectionInfo = {
                  procId: msg[0].operations[0].node.attributes.procId
                };
                app.getSession().getNavigationManager().updateApplicationInformation(app);
              }
            }
            // Handle delay from log if option is activated
            if (!this._delayFromLogWidget.getValue()) {
              entry.delay = isDvm ? parseInt(this._delayInput.value, 10) : 5;
            }
            if (entry.content) {
              this.addLog(entry.app + ':' + entry.sender, entry.content, isDvm);
              if (isDvm && entry.content !== "filetransfer") {
                this.setForwardInputValue(this._currentDvmOrder);
                ++this._processedDvmOrders;
                ++this._currentDvmOrder;

                let callback = null;
                if (this._processedDvmOrders < this._numberOfDvmOrdersToProcess && this._currentLogLine < this._log.length) {
                  callback = this._delayRunner(entry.delay);
                } else {
                  callback = this._setPlayerEnabled.bind(this);
                  this.emit(context.constants.widgetEvents.logForwardDone);
                }

                context.LogPlayerService.setVisibleApplication(app);
                app.dvm.manageAuiOrders(entry.content, callback);
                // Entry provides a dimension: use it to change the app width!
                if (entry.dimension) {
                  document.querySelector(".gbc_ApplicationWidget").style.width = entry.dimension.width + "px";
                  document.querySelector(".gbc_ApplicationWidget").style.height = entry.dimension.height + "px";
                  document.querySelector(".gbc_SessionWidget").style.overflow = "auto"; // allow scrolling
                }
                this.emit(context.constants.widgetEvents.logStepDone, this._processedDvmOrders);
                break;
              } else if (entry.close) {
                const closeApp = context.LogPlayerService.getApplication(0, entry.app);
                if (closeApp) {
                  closeApp.setEnding();
                  closeApp.stop();
                  context.LogPlayerService.removeApplication(0, entry.app);
                }
              } else {
                this._delayRunner(entry.delay)();
                break;
              }
            } else if (entry.data && entry.data.click && entry.data.auiId) {
              const widget = window.gbcWidget(entry.data.auiId);
              if (widget && widget instanceof cls.PageWidget) {
                const pageTitleWidget = widget.getTitleWidget();
                const domEvent = {
                  clientX: entry.data.clientX,
                  clientY: entry.data.clientY,
                  target: pageTitleWidget.getElement()
                };
                this._registerTimeout(function() {
                  context.MouseService._onClick(domEvent, null, false);
                }.bind(this), entry.delay);
              }
              this._delayRunner(entry.delay)();
              break;
            } else {
              this._delayRunner(entry.delay)();
              break; // no entry
            }
          }

          // Update the statistics widget
          if (this._statsCheckWidget.getValue()) {
            const elementNumber = document.getElementsByTagName('*').length;
            if (this._maxNumberOfElements === null || elementNumber > this._maxNumberOfElements) {
              this._maxNumberOfElements = elementNumber;
            }
            const widgetNumber = gbc.WidgetService.getAllWidgetsCount();
            if (this._maxNumberOfWidgets === null || widgetNumber > this._maxNumberOfWidgets) {
              this._maxNumberOfWidgets = widgetNumber;
            }
          }

          // End of the log
          if (this._currentLogLine >= this._log.length) {
            // Generate the log report
            let reportTime = "";
            if (this._startTime !== null) {
              const t1 = performance.now();
              reportTime = "Duration: " + parseInt(t1 - this._startTime) + " milliseconds.";
              this.addLog(" ", reportTime);
              this._startTime = null;
            }
            let reportDOM = "";
            if (this._maxNumberOfElements !== null) {
              reportDOM = "Max number of DOM elements: " + this._maxNumberOfElements;
              this.addLog(" ", reportDOM);
              this._maxNumberOfElements = null;
            }
            let reportWidget = "";
            if (this._maxNumberOfWidgets !== null) {
              reportWidget = "Max number of widgets: " + this._maxNumberOfWidgets;
              this.addLog(" ", reportDOM);
              this._maxNumberOfWidgets = null;
            }
            if (!gbc.qaMode && (reportDOM !== "" || reportTime !== "")) {
              gbc.alert(reportTime + "\n" + reportDOM + "\n" + reportWidget, "LogPlayer", function() {
                this.addOverlay(false);
              }.bind(this));

              if (this._logInfoWidget) {
                this._logInfoWidget.setHidden(true);
              }

            }

            // End of log, set the button accordingly
            this.setButtonEnabled(this._resetButton, true);
            this.setButtonEnabled(this._nextStepButton, false);
            this.setButtonEnabled(this._playAllButton, false);
            this.setButtonEnabled(this._pauseButton, false);
            this.setButtonEnabled(this._forwardButton, false);
            this.setButtonEnabled(this._fileInput, true);
            this.log = [];

            let session = context.SessionService.getCurrent();
            if (session) {
              session.closeSession();
            }
            this.addLog(" ", '<b>== LOG FINISHED ==</b>');
            context.LogPlayerService.cleanApplications();
            this._cleanDebugHelper();
            this.emit(context.constants.widgetEvents.ready);
          }
        },

        /**
         * Wrapper to delay the logPlayer instructions
         * @param {Number} delay - in ms
         * @return {function} callback
         * @private
         */
        _delayRunner: function(delay) {
          return function() {
            this._registerTimeout(function() {
              this.run();
            }.bind(this), delay || this._delayInput.value);
          }.bind(this);
        },

        /**
         * Set player enabled
         * @private
         */
        _setPlayerEnabled: function() {
          this.setButtonEnabled(this._resetButton, true);
          this.setButtonEnabled(this._nextStepButton, true);
          this.setButtonEnabled(this._playAllButton, true);
          this.setButtonEnabled(this._pauseButton, false);
          this.setButtonEnabled(this._forwardButton, true);
          this.setButtonEnabled(this._fileInput, false);
        },

        /**
         * Display a log in the console
         * @param context
         * @param content
         * @param withOrderNumber
         */
        addLog: function(context, content, withOrderNumber) {
          const orderNr = withOrderNumber ? this._currentDvmOrder : ' ';
          console.log("LOGPLAYER", orderNr, context, content);
        },

        /**
         * Change the state of a given button
         * @param {Element} button - button element to change
         * @param {Boolean} enabled - true to activate the button, false otherwise
         */
        setButtonEnabled: function(button, enabled) {
          if (enabled) {
            button.removeClass("disabled");
            button.removeAttribute("disabled");
            if (button === this._fileInput) {
              this._fileInput.querySelector("input").removeAttribute("disabled");
            }
          } else {
            button.addClass("disabled");
            button.setAttribute("disabled", "disabled");
            if (button === this._fileInput) {
              this._fileInput.querySelector("input").setAttribute("disabled", "disabled");
            }
          }
        },

        /**
         * Detaches the huge uaproxy log string from chunks we really need for memory optimi
         * @param {string} s
         * @return {string}
         */
        detachString: function(s) {
          return (' ' + s).slice(1);
        },

        /**
         * Method to put a visual mouse pointer at a given position
         * @param {Number|Boolean} x - horizontal position or false to hide it
         * @param {Number?} y - vertical position
         * @param {String?} action - click or move
         * @param {Number?} clickDelay - delay the click effect (in ms)
         */
        setDebugMouse: function(x, y, action, clickDelay) {
          if (this._showHelpersWidget.getValue()) {
            this._cleanDebugHelper();
            if (x && y) {
              this._debugCursorElement.removeClass("hidden");
              if (action === "move") {
                this._debugCursorElement.style.top = y + "px";
                this._debugCursorElement.style.left = x + "px";
              }
              if (action.toLowerCase().indexOf("click") >= 0) {
                this._mousePressedElement.removeClass("hidden");
                const left = this._mousePressedElement.querySelector(".key-left");
                const right = this._mousePressedElement.querySelector(".key-right");

                this._registerTimeout(function() {
                  this._debugCursorElement.addClass("highlight");
                  if (action === "click") {
                    left.addClasses("pressed");
                  } else if (action === "rightClick") {
                    right.addClasses("pressed");
                  }
                  this._registerTimeout(function() {
                    this._debugCursorElement.removeClass("highlight");
                    left.removeClass("pressed");
                    right.removeClass("pressed");
                  }.bind(this), 500);
                }.bind(this), clickDelay);
              }
            } else {
              this._mousePressedElement.addClass("hidden");
              this._debugCursorElement.addClass("hidden");
            }
          }
        },

        /**
         * Method to add a visual info about pressed key
         * @param {String} key - key to display
         */
        setDebugKeyboardKey: function(key) {
          if (this._showHelpersWidget.getValue()) {
            this._cleanDebugHelper();
            this._keyPressedElement.removeClass("hidden");
            const keyletter = this._keyPressedElement.querySelector(".key-letter");
            const keymod = this._keyPressedElement.querySelector(".key-modifier");

            const keyMatch = key.match(/(ctrl|alt|mod|shift)*\+*(.*)/);

            if (keyMatch[1]) { // has modifier
              keymod.innerHTML = "<span>" + keyMatch[1] + "</span>";
              keymod.addClass("pressed");
              keymod.removeClass("hidden");
              key = keyMatch[2];
            } else {
              key = keyMatch[2];
              keymod.addClass("hidden");
            }
            switch (key) {
              case "up":
                key = "⬆";
                break;
              case "down":
                key = "⬇";
                break;
              case "left":
                key = "⬅";
                break;
              case "right":
                key = "⮕";
                break;
              default:
                break;
            }

            keyletter.innerHTML = "<span>" + key + "</span>";
            keyletter.addClass("pressed");

            this._registerTimeout(function() {
              keymod.removeClass("pressed");
              keyletter.removeClass("pressed");
            }, 500);
          }
        },

        /**
         * Clear screen of mouse and keyboard info
         * @private
         */
        _cleanDebugHelper: function() {
          this._keyPressedElement.addClass("hidden");
          this._debugCursorElement.addClass("hidden");
          this._mousePressedElement.addClass("hidden");
        },

        /**
         * Add / remove an overlay to prevent any user interaction while playing a log
         * @param {Boolean} overlay - true to prevent user interaction, false otherwise
         * @param {Boolean} [force] - true to force the given value without check
         */
        addOverlay: function(overlay, force) {
          // Only if overlay status is not forced
          if (!force) {
            if (this._userInteractionWidget) {
              overlay = !this._userInteractionWidget.getValue();
            } else {
              overlay = true;
            }
          }
          gbc.OverlayService.setCursor("logplayer", "not-allowed");

          if (overlay) {
            this.addClass("running");
            gbc.OverlayService.enable("logplayer", this.getContainerElement());
          } else {
            this.removeClass("running");
            gbc.OverlayService.disable("logplayer");
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('LogPlayer', cls.LogPlayerWidget);
  });
;

"use strict";

modulum('LogRecorderWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogPlayerWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogRecorderWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogRecorderWidget.prototype */ {
        __name: "LogRecorderWidget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setTitle(i18next.t('gwc.main.chromebar.getRecordedLog'));
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(dom) {
          gbc.LogService.download();
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('LogRecorder', cls.LogRecorderWidget);
  });
;

"use strict";

modulum('LogTypesSelectorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class LogTypesSelectorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.LogTypesSelectorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.LogTypesSelectorWidget.prototype */ {
        __name: "LogTypesSelectorWidget",

        /**
         * @type {Array<{name:string, label:string}>}
         */
        _types: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setTypes(context.LogService.getTypes());
          this.setCurrentTypes(context.LogService.getActiveLogTypes());
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.dataset.logtype) {
            this.emit("logtype", domEvent.target.dataset.logtype);
          }
          return true;
        },

        /**
         *
         * @param {Array<{name:string, label:string}>} types
         */
        setTypes: function(types) {
          this._types = types;
          this._element.empty();
          for (const element of types) {
            this._element.innerHTML += '<div data-logtype="' + element.name + '" class="active">' + element.label + '</div>';
          }
        },
        /**
         *
         * @param {Array<string>} types name of activated loggers
         */
        setCurrentTypes: function(types) {
          const matcher = function(val) {
            return function(i) {
              return i === val;
            };
          };
          for (const element of this._types) {
            const val = element.name,
              item = this._element.querySelector('[data-logtype="' + val + '"]');
            if (item) {
              item.toggleClass("active", !types || Boolean(types.find(matcher(val))));
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('LogTypesSelector', cls.LogTypesSelectorWidget);
  });
;

"use strict";

modulum('MainContainerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MainContainerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MainContainerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MainContainerWidget.prototype */ {
        __name: "MainContainerWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MainContainer', cls.MainContainerWidget);
  });
;

"use strict";

modulum('MonitorDebugLayoutInfoWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugLayoutInfoWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorDebugLayoutInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MonitorDebugLayoutInfoWidget.prototype */ {
        __name: "MonitorDebugLayoutInfoWidget",
        _layoutEngineName: null,
        _posX: null,
        _posY: null,
        _gridWidth: null,
        _gridHeight: null,
        _width: null,
        _height: null,
        _measuredHasSize: null,
        _measuredWidth: null,
        _measuredHeight: null,
        _minimalHasSize: null,
        _minimalWidth: null,
        _minimalHeight: null,
        _maximalHasSize: null,
        _maximalWidth: null,
        _maximalHeight: null,
        _availableHasSize: null,
        _availableWidth: null,
        _availableHeight: null,
        _allocatedHasSize: null,
        _allocatedWidth: null,
        _allocatedHeight: null,
        _preferredHasSize: null,
        _preferredWidth: null,
        _preferredHeight: null,
        _decoratingHasSize: null,
        _decoratingWidth: null,
        _decoratingHeight: null,
        _decoratingoffsetHasSize: null,
        _decoratingoffsetWidth: null,
        _decoratingoffsetHeight: null,
        _stretchX: null,
        _stretchY: null,
        _childrenStretchX: null,
        _childrenStretchY: null,
        _invalidatedMeasure: null,
        _invalidatedAllocatedSpace: null,
        _initElement: function() {
          $super._initElement.call(this);
          this._layoutEngineName = this._element.getElementsByClassName("value_layoutEngineName")[0];
          this._posX = this._element.getElementsByClassName("value_posX")[0];
          this._posY = this._element.getElementsByClassName("value_posY")[0];
          this._gridWidth = this._element.getElementsByClassName("value_gridWidth")[0];
          this._gridHeight = this._element.getElementsByClassName("value_gridHeight")[0];
          this._width = this._element.getElementsByClassName("value_width")[0];
          this._height = this._element.getElementsByClassName("value_height")[0];
          this._measuredHasSize = this._element.getElementsByClassName("value_measured_hasSize")[0];
          this._measuredWidth = this._element.getElementsByClassName("value_measured_width")[0];
          this._measuredHeight = this._element.getElementsByClassName("value_measured_height")[0];
          this._minimalHasSize = this._element.getElementsByClassName("value_minimal_hasSize")[0];
          this._minimalWidth = this._element.getElementsByClassName("value_minimal_width")[0];
          this._minimalHeight = this._element.getElementsByClassName("value_minimal_height")[0];
          this._maximalHasSize = this._element.getElementsByClassName("value_maximal_hasSize")[0];
          this._maximalWidth = this._element.getElementsByClassName("value_maximal_width")[0];
          this._maximalHeight = this._element.getElementsByClassName("value_maximal_height")[0];
          this._availableHasSize = this._element.getElementsByClassName("value_available_hasSize")[0];
          this._availableWidth = this._element.getElementsByClassName("value_available_width")[0];
          this._availableHeight = this._element.getElementsByClassName("value_available_height")[0];
          this._allocatedHasSize = this._element.getElementsByClassName("value_allocated_hasSize")[0];
          this._allocatedWidth = this._element.getElementsByClassName("value_allocated_width")[0];
          this._allocatedHeight = this._element.getElementsByClassName("value_allocated_height")[0];
          this._preferredHasSize = this._element.getElementsByClassName("value_preferred_hasSize")[0];
          this._preferredWidth = this._element.getElementsByClassName("value_preferred_width")[0];
          this._preferredHeight = this._element.getElementsByClassName("value_preferred_height")[0];
          this._decoratingHasSize = this._element.getElementsByClassName("value_decorating_hasSize")[0];
          this._decoratingWidth = this._element.getElementsByClassName("value_decorating_width")[0];
          this._decoratingHeight = this._element.getElementsByClassName("value_decorating_height")[0];
          this._decoratingoffsetHasSize = this._element.getElementsByClassName("value_decoratingoffset_hasSize")[0];
          this._decoratingoffsetWidth = this._element.getElementsByClassName("value_decoratingoffset_width")[0];
          this._decoratingoffsetHeight = this._element.getElementsByClassName("value_decoratingoffset_height")[0];
          this._stretchX = this._element.getElementsByClassName("value_stretch_x")[0];
          this._stretchY = this._element.getElementsByClassName("value_stretch_y")[0];
          this._childrenStretchX = this._element.getElementsByClassName("value_stretch_children_x")[0];
          this._childrenStretchY = this._element.getElementsByClassName("value_stretch_children_y")[0];
          this._invalidatedMeasure = this._element.getElementsByClassName("value_invalidated_measure")[0];
          this._invalidatedAllocatedSpace = this._element.getElementsByClassName("value_invalidated_allocatedspace")[0];

        },
        setLayoutEngineName: function(value) {
          this._layoutEngineName.textContent = value;
        },
        setPosX: function(value) {
          this._posX.textContent = value;
        },
        setPosY: function(value) {
          this._posY.textContent = value;
        },
        setGridWidth: function(value) {
          this._gridWidth.textContent = value;
        },
        setGridHeight: function(value) {
          this._gridHeight.textContent = value;
        },
        setWidth: function(value) {
          this._width.textContent = value;
        },
        setHeight: function(value) {
          this._height.textContent = value;
        },
        setMeasuredHasSize: function(value) {
          this._measuredHasSize.textContent = value;
        },
        setMeasuredWidth: function(value) {
          this._measuredWidth.textContent = value;
        },
        setMeasuredHeight: function(value) {
          this._measuredHeight.textContent = value;
        },
        setMinimalHasSize: function(value) {
          this._minimalHasSize.textContent = value;
        },
        setMinimalWidth: function(value) {
          this._minimalWidth.textContent = value;
        },
        setMinimalHeight: function(value) {
          this._minimalHeight.textContent = value;
        },
        setMaximalHasSize: function(value) {
          this._maximalHasSize.textContent = value;
        },
        setMaximalWidth: function(value) {
          this._maximalWidth.textContent = value;
        },
        setMaximalHeight: function(value) {
          this._maximalHeight.textContent = value;
        },
        setAvailableHasSize: function(value) {
          this._availableHasSize.textContent = value;
        },
        setAvailableWidth: function(value) {
          this._availableWidth.textContent = value;
        },
        setAvailableHeight: function(value) {
          this._availableHeight.textContent = value;
        },
        setAllocatedHasSize: function(value) {
          this._allocatedHasSize.textContent = value;
        },
        setAllocatedWidth: function(value) {
          this._allocatedWidth.textContent = value;
        },
        setAllocatedHeight: function(value) {
          this._allocatedHeight.textContent = value;
        },
        setPreferredHasSize: function(value) {
          this._preferredHasSize.textContent = value;
        },
        setPreferredWidth: function(value) {
          this._preferredWidth.textContent = value;
        },
        setPreferredHeight: function(value) {
          this._preferredHeight.textContent = value;
        },
        setDecoratingHasSize: function(value) {
          this._decoratingHasSize.textContent = value;
        },
        setDecoratingWidth: function(value) {
          this._decoratingWidth.textContent = value;
        },
        setDecoratingHeight: function(value) {
          this._decoratingHeight.textContent = value;
        },
        setDecoratingoffsetHasSize: function(value) {
          this._decoratingoffsetHasSize.textContent = value;
        },
        setDecoratingoffsetWidth: function(value) {
          this._decoratingoffsetWidth.textContent = value;
        },
        setDecoratingoffsetHeight: function(value) {
          this._decoratingoffsetHeight.textContent = value;
        },
        setStretchX: function(value) {
          this._stretchX.textContent = value;
        },
        setStretchY: function(value) {
          this._stretchY.textContent = value;
        },
        setChildrenStretchX: function(value) {
          this._childrenStretchX.textContent = value;
        },
        setChildrenStretchY: function(value) {
          this._childrenStretchY.textContent = value;
        },
        setInvalidatedMeasure: function(value) {
          this._invalidatedMeasure.textContent = value;
        },
        setInvalidatedAllocatedSpace: function(value) {
          this._invalidatedAllocatedSpace.textContent = value;
        },
        /**
         * Remove the layout panel and add a message instead
         */
        setNoLayout: function() {
          this.setLayoutEngineName("No layout information");
          this._element.querySelector(".aui").addClass("hidden");
          this._element.querySelector(".measures").addClass("hidden");
          this._element.querySelector(".stretch").addClass("hidden");
          this._element.querySelector("h6").addClass("hidden");

        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugLayoutInfo', cls.MonitorDebugLayoutInfoWidget);
  });
;

"use strict";

modulum('MonitorDebugNodeInfoWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugNodeInfoWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorDebugNodeInfoWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.MonitorDebugNodeInfoWidget.prototype */ {
        __name: "MonitorDebugNodeInfoWidget",
        _propertiesContainer: null,
        _initElement: function() {
          $super._initElement.call(this);
          this._propertiesContainer = this._element.querySelector("table>tbody");
          this._element.on("click", "table>thead>tr", this._onClick.bind(this));
        },
        _onClick: function(e) {
          const table = this._element.childTag("table");
          if (table) {
            let i = 0;
            const cats = table.querySelectorAll(".category"),
              len = cats.length;
            for (; i < len; i++) {
              context.DebugService.auiview[".cat_" + cats[i].textContent] = true;
              gbc.DebugService.catClicked(cats[i].textContent, true);
            }
          }
          e.stopPropagation();
        },
        getPropertiesContainer: function() {
          return this._propertiesContainer;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugNodeInfo', cls.MonitorDebugNodeInfoWidget);
  });
;

"use strict";

modulum('MonitorDebugTreeItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugTreeItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MonitorDebugTreeItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorDebugTreeItemWidget.prototype */ {
        __name: "MonitorDebugTreeItemWidget",
        _container: null,
        _label: null,
        _idRefElement: null,
        _idRef: null,
        _collapsed: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._container = this._element.child("description");
          this._label = this._container.child("label");
          this._idRefElement = this._container.child("idRef");
          this._container
            .on("click.MonitorDebugTreeItemWidget", this._onClick.bind(this))
            .on("dblclick.MonitorDebugTreeItemWidget", this._onDoubleClick.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._container
            .off("click.MonitorDebugTreeItemWidget")
            .off("dblclick.MonitorDebugTreeItemWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onClick: function(e) {
          this.emit(gbc.constants.widgetEvents.click);
          e.stopPropagation();
        },

        /**
         * @inheritDoc
         */
        _onDoubleClick: function(event) {
          this._toggleCollapsed();
          event.stopPropagation();
        },

        /**
         * Define the label of the item in the tree view
         * @param {string} label - text to display
         */
        setLabel: function(label) {
          this._label.textContent = label;
        },

        /**
         * Define the VM idRef of the item in the tree view
         * @param {string} idRef - idRef to set
         */
        setIdRef: function(idRef) {
          this._idRef = idRef;
          this._idRefElement.textContent = idRef;
        },

        /**
         * Get the VM idRef of the item
         * @return {null}
         */
        getIdRef: function() {
          return this._idRef;
        },

        /**
         * Define the color of the icon
         * @param {string} color - CSS compliant color
         */
        setIconColor: function(color) {
          this.setStyle('>.description>.icon', {
            "background-color": color
          });
        },

        /**
         * Expand / collapse a tree part
         * @param {boolean} collapsed - true if collapsed, false otherwise
         */
        setCollapsed: function(collapsed) {
          this._toggleCollapsed(Boolean(collapsed));
        },

        /**
         * Expand / collapse a tree part
         * @param {boolean} collapsed - true if collapsed, false otherwise
         * @private
         */
        _toggleCollapsed: function(collapsed) {
          if (collapsed === true) {
            if (!this._collapsed) {
              this._collapsed = true;
              this._containerElement.remove();
            }
          } else if (collapsed === false) {
            if (this._collapsed) {
              this._collapsed = false;
              this._element.appendChild(this._containerElement);
            }
          } else {
            this._collapsed = !this._collapsed;
            if (this._collapsed) {
              this._containerElement.remove();
            } else {
              this._element.appendChild(this._containerElement);
            }
          }
          this._element.toggleClass("collapsed", Boolean(this._collapsed));
        },

        /**
         * Set item as highlighted
         * @param {boolean} highlighted - true if highlighted, false otherwise
         */
        setHighlighted: function(highlighted) {
          this._element.toggleClass("highlighted", highlighted);
          if (highlighted) {
            let p = this.getParentWidget();
            while (p instanceof cls.MonitorDebugTreeItemWidget) {
              p.setCollapsed(false);
              p = p.getParentWidget();
            }
          }
        },

        setFocused: function(focused) {
          this._element.toggleClass("vmFocusedNode", focused);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugTreeItem', cls.MonitorDebugTreeItemWidget);
  });
;

"use strict";

modulum('MonitorDebugTreeWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorDebugTreeWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.MonitorDebugTreeWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorDebugTreeWidget.prototype */ {
        __name: "MonitorDebugTreeWidget",
        _nodeDebug: null,
        _layoutInfo: null,
        _vmFocusedWidgetId: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._nodeDebug = this._element.getElementsByClassName('nodeDebug')[0];
          this._layoutInfo = this._element.getElementsByClassName('layoutInfo')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._nodeDebug.innerHTML = "";
          this._layoutInfo.innerHTML = "";
          $super.destroy.call(this);
        },

        /**
         * Set the content of the right part of the debugger (AUI attributes)
         * @param content
         */
        setNodeDebugContent: function(content) {
          this._nodeDebug.innerHTML = "";
          this._nodeDebug.appendChild(content);
        },

        /**
         * Set the content of the layout part of the debugger (AUI layout attributes)
         * @param content
         */
        setLayoutInfoContent: function(content) {
          this._layoutInfo.innerHTML = "";
          this._layoutInfo.appendChild(content);
        },

        /**
         * Set the selected item in the debugger
         * @param {number} id - id of the selected widget
         * @param {Array} items - children of the item
         * @return {*}
         */
        setSelectedItem: function(id, items) {
          let matchingItem = null;
          if (items === undefined) {
            matchingItem = this.setSelectedItem(id, this.getChildren());
            if (matchingItem) {
              const view = this._element.child('part');
              const itemRect = matchingItem._container.getBoundingClientRect();
              const viewRect = view.getBoundingClientRect();
              if (itemRect.bottom > viewRect.height || itemRect.top < 0) {
                view.scrollTop += itemRect.top - viewRect.height / 2;
              }
            }
          } else {
            for (const element of items) {
              const item = element;
              const match = item.getIdRef() === id;
              item.setHighlighted(match);
              item.setFocused(item.getIdRef() === this._vmFocusedWidgetId);
              const childMatchingItem = this.setSelectedItem(id, item.getChildren());
              if (match) {
                matchingItem = item;
              } else if (!matchingItem) {
                matchingItem = childMatchingItem;
              }
            }
          }
          return matchingItem;
        },

        /**
         * Highlight the VM focused Widget
         * @param {number} id - id of the focused widget
         */
        setFocusedWidget: function(id) {
          this._vmFocusedWidgetId = id;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('MonitorDebugTree', cls.MonitorDebugTreeWidget);
  });
;

"use strict";

modulum('MonitorWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class MonitorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.MonitorWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.MonitorWidget.prototype */ {
        __name: "MonitorWidget",
        _initElement: function() {
          $super._initElement.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Monitor', cls.MonitorWidget);
  });
;

"use strict";

modulum('SettingsWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SettingsWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SettingsWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SettingsWidget.prototype */ {
        __name: "SettingsWidget",

        _lngWidget: null,
        _lngDefaultWidget: null,
        _themeWidget: null,
        _themeSchemeWidget: null,
        _themeHandleRegistration: null,
        _enableWidget: null,
        _resetWidget: null,
        _msgWidget: null,
        _latencyWidget: null,
        _loglevelWidget: null,
        _logtypesWidget: null,

        _lngElement: null,
        _themeElement: null,
        _enableElement: null,
        _resetElement: null,
        _resetConfirm: false,

        _storeSettingsEnabled: false,

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._storeSettingsEnabled = gbc.StoredSettingsService.areEnabled();

          //Language widget
          this._lngDefaultWidget = cls.WidgetFactory.createWidget("CheckBoxWidget", this.getBuildParameters());
          this._lngDefaultWidget.setEnabled(true);
          this._lngDefaultWidget.setText(i18next.t("gwc.storedSettings.defaultLng"));
          const isDefault = Boolean(gbc.StoredSettingsService.getSettings("gwc.app.defaultLocale"));
          this._lngDefaultWidget.setValue(isDefault);

          this._lngWidget = cls.WidgetFactory.createWidget("ComboBoxWidget", this.getBuildParameters());
          this._lngWidget.setNotNull(true);
          this._lngWidget.setEnabled(!isDefault);

          const allLng = gbc.I18NService.getAllLng();
          this._lngWidget.setItems(allLng.map((lng) => {
            return {
              text: lng.language,
              value: lng.locale
            };
          }));
          this._lngWidget.setValue(context.StoredSettingsService.getLanguage());

          this._lngWidget.when(context.constants.widgetEvents.click, () => {
            this._lngWidget.openDropDown();
          });
          this._lngWidget.when(context.constants.widgetEvents.valueChanged, () => {
            const lng = this._lngWidget.getValue();
            this.setLanguage(lng);
            this._updateThemeList();
          });

          this._lngDefaultWidget.when(context.constants.widgetEvents.click, () => {
            gbc.StoredSettingsService.setSettings("gwc.app.defaultLocale", this._lngDefaultWidget.getValue() === true);
            this._lngWidget.setEnabled(!this._lngDefaultWidget.getValue());

            if (this._lngDefaultWidget.getValue()) {
              this.setLanguage(gbc.I18NService.getBrowserLanguage());
            } else {
              this._lngWidget.emit(context.constants.widgetEvents.valueChanged, this._lngWidget.getValue());
            }
          });

          // Theme widget
          this._themeSchemeWidget = cls.WidgetFactory.createWidget("CheckBoxWidget", this.getBuildParameters());
          this._themeSchemeWidget.setText(i18next.t("gwc.storedSettings.darkMode"));
          const currentTheme = context.ThemeService.getCurrentTheme();
          this._themeSchemeWidget.setValue(context.ThemeService.isDarkScheme(currentTheme));
          // Disable if no other scheme available for the current theme
          this._themeSchemeWidget.setEnabled(context.ThemeService.hasMultipleSchemes(currentTheme));

          this._themeWidget = cls.WidgetFactory.createWidget("ComboBoxWidget", this.getBuildParameters());
          this._themeWidget.setNotNull(true);
          this._updateThemeList();
          this._themeHandleRegistration = context.ThemeService.whenThemeChanged(() => {
            this._themeWidget.setValue(context.ThemeService.getLightSchemeName(context.ThemeService.getCurrentTheme()), true);
          });
          this._themeWidget.when(context.constants.widgetEvents.click, () => {
            this._themeWidget.openDropDown();
          });
          this._themeWidget.when(context.constants.widgetEvents.valueChanged, () => {
            let theme = this._themeWidget.getValue();
            if (this._themeSchemeWidget.getValue()) {
              // Keep dark theme if checked
              theme = context.ThemeService.getDarkSchemeName(theme);
            }
            context.ThemeService.loadTheme(theme, function() {});
            this._themeSchemeWidget.setValue(context.ThemeService.isDarkScheme(theme));
            this._themeSchemeWidget.setEnabled(context.ThemeService.hasMultipleSchemes(theme));
          });
          this._themeSchemeWidget.when(context.constants.widgetEvents.click, () => {
            if (this._themeSchemeWidget.getValue()) {
              // Checked = load dark theme
              context.ThemeService.loadTheme(context.ThemeService.getDarkSchemeName(context.ThemeService.getCurrentTheme()));
            } else {
              context.ThemeService.loadTheme(context.ThemeService.getLightSchemeName(context.ThemeService.getCurrentTheme()));
            }
          });

          // Enable StoredSettings button
          this._enableWidget = cls.WidgetFactory.createWidget("CheckBoxWidget", this.getBuildParameters());
          this._enableWidget.setEnabled(true);
          this._enableWidget.setText(i18next.t("gwc.storedSettings.enable"));
          this.enableStoredSettings(this._storeSettingsEnabled);
          this._enableWidget.when(context.constants.widgetEvents.click, () => {
            this.toggleStoredSettings();
          });

          // Reset StoredSettings button
          this._resetWidget = cls.WidgetFactory.createWidget("ButtonWidget", this.getBuildParameters());
          this._resetWidget.setText(i18next.t("gwc.storedSettings.reset"));
          this._resetWidget.when(context.constants.widgetEvents.click, () => {
            this.resetStoredSettings(this._resetConfirm);
          });

          // Get containers for each widget
          this._lngElement = this._element.getElementsByClassName("lngSettings")[0];
          this._themeElement = this._element.getElementsByClassName("themeSettings")[0];
          this._storedSettingsElement = this._element.getElementsByClassName("storedSettings")[0];
          this._aboutElement = this._element.getElementsByClassName("aboutSettings")[0];

          // Add widgets in each container
          this._lngElement.appendChild(this._lngWidget.getElement());
          this._lngElement.appendChild(this._lngDefaultWidget.getElement());
          this._themeElement.appendChild(this._themeWidget.getElement());
          this._themeElement.appendChild(this._themeSchemeWidget.getElement());
          this._storedSettingsElement.appendChild(this._resetWidget.getElement());
          this._storedSettingsElement.appendChild(this._enableWidget.getElement());

          this._msgWidget = this._element.querySelector(".message");

          if (gbc.LocalSettingsService._quotaExceededError) {
            this._msgWidget.removeClass("hidden");
          }
          gbc.LocalSettingsService._eventListener.when("QuotaExceededError", () => {
            this._msgWidget.removeClass("hidden");
          });

          // Debug & QA
          if (context.DebugService.isActive()) {
            this._latencyWidget = cls.WidgetFactory.createWidget("EditWidget", this.getBuildParameters());
            this._latencyWidget.setEnabled(true);
            this._latencyWidget.setType("number");
            const minDuration = gbc.SessionService.getCurrent() &&
              gbc.SessionService.getCurrent().getCurrentApplication() &&
              gbc.SessionService.getCurrent().getCurrentApplication().protocolInterface.getNetworkDelay() || 0;
            this._latencyWidget.setValue("" + minDuration);
            this._latencyWidget.getInputElement().on('input', () => {
              const val = parseInt(this._latencyWidget.getValue(), 10);
              if (val > 0) {
                gbc.SessionService.getCurrent().getCurrentApplication().protocolInterface.setNetworkDelay(val);
              }
            });

            this._element.getElementsByClassName("debugTopic")[0].removeClass("hidden");
            this._debugLatencyElement = this._element.getElementsByClassName("latency")[0];
            this._debugLatencyElement.appendChild(this._latencyWidget.getElement());

            this._loglevelWidget = cls.WidgetFactory.createWidget("LogLevelSelector", this.getBuildParameters());
            this._loglevelWidget.when("loglevel", (evt, src, level) => {
              context.LogService.changeLevel(level);
              context.StoredSettingsService.setLoglevel(level);
            });
            this._debugLoglevelElement = this._element.getElementsByClassName("loglevel")[0];
            this._debugLoglevelElement.appendChild(this._loglevelWidget.getElement());

            this._logtypesWidget = cls.WidgetFactory.createWidget("LogTypesSelector", this.getBuildParameters());
            this._logtypesWidget.when("logtype", (evt, src, type) => {
              context.LogService.toggleType(type);
              const currentTypes = context.LogService.getActiveLogTypes();
              context.StoredSettingsService.setLogtypes(currentTypes);
              this._logtypesWidget.setCurrentTypes(currentTypes);
            });
            this._debugLogtypesElement = this._element.getElementsByClassName("logtypes")[0];
            this._debugLogtypesElement.appendChild(this._logtypesWidget.getElement());
          }

          // Display GBC information
          const versionElement = this._element.getElementsByClassName("field_version")[0];
          versionElement.textContent = context.version;

          const copyrightYearElement = this._element.getElementsByClassName("copyright_year")[0];
          copyrightYearElement.textContent = " " + context.copyrightYear;

          const buildElement = this._element.getElementsByClassName("field_build")[0];
          buildElement.textContent = context.build + (context.dirtyFlag || "");

          if (context.tag === "dev-snapshot") {
            const tagElement = this._element.getElementsByClassName("field_tag")[0];
            tagElement.textContent = "(dev-snapshot)";
          }

          const logoElement = this._element.getElementsByClassName("field_logo")[0];
          logoElement.setAttribute("src", context.ThemeService.getResource("img/logo.png"));
          logoElement.setAttribute("alt", "Genero Browser Client");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._themeHandleRegistration) {
            this._themeHandleRegistration();
            this._themeHandleRegistration = null;
          }
          if (this._lngWidget) {
            this._lngWidget.destroy();
            this._lngWidget = null;
          }
          if (this._lngDefaultWidget) {
            this._lngDefaultWidget.destroy();
            this._lngDefaultWidget = null;
          }
          if (this._themeWidget) {
            this._themeWidget.destroy();
            this._themeWidget = null;
          }
          if (this._themeSchemeWidget) {
            this._themeSchemeWidget.destroy();
            this._themeSchemeWidget = null;
          }
          if (this._enableWidget) {
            this._enableWidget.destroy();
            this._enableWidget = null;
          }
          if (this._resetWidget) {
            this._resetWidget.destroy();
            this._resetWidget = null;
          }
          if (this._latencyWidget) {
            this._latencyWidget.destroy();
            this._latencyWidget = null;
          }
          if (this._loglevelWidget) {
            this._loglevelWidget.destroy();
            this._loglevelWidget = null;
          }
          if (this._logtypesWidget) {
            this._logtypesWidget.destroy();
            this._logtypesWidget = null;
          }

          this._msgWidget = null;
          $super.destroy.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        _restoreDefaultButton: function() {
          // Restore default button
          this._resetConfirm = false;
          this._resetWidget.setText(i18next.t("gwc.storedSettings.reset"));
          this._resetWidget.setEnabled(true);
          this._resetWidget.setBackgroundColor(null);
          this._resetWidget.setColor(null);
        },

        setLanguage: function(lng) {
          gbc.StoredSettingsService.setLanguage(lng);
          this.getParentWidget().setFooter(i18next.t("gwc.storedSettings.changed"));
        },

        toggleStoredSettings: function() {
          if (this._storeSettingsEnabled) {
            this.enableStoredSettings(false);
          } else {
            this.enableStoredSettings(true);
          }
        },

        /**
         *
         * @param status
         */
        enableStoredSettings: function(status) {
          this._enableWidget.setValue(status ? this._enableWidget._checkedValue : this._enableWidget._uncheckedValue);
          this._storeSettingsEnabled = status;
          gbc.StoredSettingsService.enable(status);

        },
        /**
         *
         * @param force if not true, will ask for confirmation
         */
        resetStoredSettings: function(force) {
          // Ask for confirmation first
          if (!force) {
            this._resetWidget.setBackgroundColor(context.ThemeService.getValue("mt-red-200"));
            this._resetWidget.setColor(context.ThemeService.getValue("theme-secondary-color"));
            this._resetWidget.setText(i18next.t("gwc.storedSettings.confirm"));
            this._resetConfirm = true;
          } else { // Reset once confirmed
            gbc.StoredSettingsService.reset();
            this._resetConfirm = false;
            this._resetWidget.setText(i18next.t("gwc.storedSettings.done"));
            this._resetWidget.setEnabled(false);
            this._resetWidget.setBackgroundColor(context.ThemeService.getValue("mt-green-200"));
            this._resetWidget.setColor(context.ThemeService.getValue("theme-secondary-color"));
            this._registerTimeout(() => {
              this._restoreDefaultButton();
            }, 2000);
          }
        },

        _updateThemeList: function() {
          const filteredThemes = context.ThemeService.getAvailableThemes().filter((theme) => {
            return !context.ThemeService.isDarkScheme(theme.name) || !context.ThemeService.hasMultipleSchemes(theme.name);
          });
          this._themeWidget.setItems(filteredThemes.map((theme) => {
            let titleKey = "gwc.main.theme." + theme.title;
            let localizedTitle = i18next.t("gwc.main.theme." + theme.title, {
              lng: window.i18next.language,
              lngs: [window.i18next.language]
            });
            return {
              text: localizedTitle === titleKey ? theme.title : localizedTitle,
              value: theme.name
            };
          }));
          this._themeWidget.setValue(context.ThemeService.getLightSchemeName(context.ThemeService.getCurrentTheme()), true);
          this._themeWidget.setEnabled(filteredThemes.length > 1);

        }
      };
    });
    cls.WidgetFactory.registerBuilder('Settings', cls.SettingsWidget);
  });
;

"use strict";

modulum('ApplicationHostSidebarBackdropWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostSidebarBackdropWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.ApplicationHostSidebarBackdropWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ApplicationHostSidebarBackdropWidget.prototype */ {
        __name: "ApplicationHostSidebarBackdropWidget",

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        setDisplayed: function(displayed) {
          this.getElement().toggleClass("mt-sidebar-displayed", Boolean(displayed));
        },

        setUnavailable: function(unavailable) {

          context.HostService.getApplicationHostWidget().toggleClass("mt-sidebar-unavailable", Boolean(unavailable));
        },

        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSidebarBackdrop', cls.ApplicationHostSidebarBackdropWidget);
  });
;

"use strict";

modulum('ApplicationHostSidebarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationHostSidebarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationHostSidebarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationHostSidebarWidget.prototype */ {
        __name: "ApplicationHostSidebarWidget",
        _resizerElement: null,
        _dragHandle: null,
        _sidebarToggle: null,
        /**
         * For mobile only
         */
        _screenOrientation: null,
        /**
         * @type ?number
         */
        _resizeHandle: null,
        _origin: null,
        _contentElement: null,
        _sidebarContentElement: null,
        _alternateContentWidget: null,
        _titleElement: null,
        _titleTextElement: null,
        _unavailable: false,
        /**
         * @type ?number
         */
        _currentSize: null,

        _initElement: function() {
          this._ignoreLayout = true;
          this._currentSize = cls.Size.translate(context.ThemeService.getValue("theme-sidebar-default-width"));
          $super._initElement.call(this);
          this._contentElement = this._element.getElementsByClassName("mt-content")[0];
          this._sidebarContentElement = this._element.getElementsByClassName("mt-sidebar-content")[0];
          this._titleElement = this._element.getElementsByClassName("mt-sidebar-title")[0];
          this._titleTextElement = this._element.getElementsByClassName("mt-sidebar-title-text")[0];

          this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];

          this._element.on("transitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("oTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("webkitTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));

          this._resizerElement = this._element.getElementsByClassName("resizer")[0];
          this._dragHandle = this._resizerElement.getElementsByClassName("firefox_placekeeper")[0];
          this._resizerElement.setAttribute("draggable", "true");
          this._resizerElement.on("dragstart.ApplicationHostSidebarWidget", this._onDragStart.bind(this));
          this._resizerElement.on("dragend.ApplicationHostSidebarWidget", this._onDragEnd.bind(this));
          this._resizerElement.on("drag.ApplicationHostSidebarWidget", this._onDrag.throttle(5).bind(this));
          window.addEventListener("resize", this.updateResizeTimer.bind(this));

          this._element.onSwipe('ApplicationHostSidebarWidget', this._onSwipe.bind(this), {
            direction: ["left"],
            ignore: this._resizerElement
          });

        },
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          // TODO
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const target = domEvent.target;
          if (target.isElementOrChildOf(this._sidebarToggle)) {
            this.emit(context.constants.widgetEvents.toggleClick);
          }
          return true;
        },

        updateResizeTimer: function() {
          if (window.isMobile() && !window.isOrientationImplemented) {
            window.orientation = window.innerWidth > window.innerHeight ? 90 : 0;
          }
          // for mobiles, only relayout on screen orientation
          if (!window.isMobile() || this._screenOrientation !== window.orientation) {
            this._screenOrientation = window.orientation;
            if (this._resizeHandle) {
              this._clearTimeout(this._resizeHandle);
              this._resizeHandle = null;
            }
            this._resizeHandle = this._registerTimeout(this.updateResize.bind(this, null, false), 100);
          }
        },
        updateResize: function(deltaX, absolute) {
          const previousSize = this._currentSize;
          this._resizeHandle = null;

          const max = cls.Size.translate(context.ThemeService.getValue("theme-sidebar-max-width"));
          if (absolute) {
            this._currentSize = deltaX;
          } else {
            this._currentSize = (Object.isNumber(this._origin) ? this._origin : this._currentSize) + (deltaX || 0);
            if (this._currentSize < 16) {
              this._currentSize = 16;
            }
          }
          if (this._currentSize > max) {
            this._currentSize = max;
          }
          if (!this.isAlwaysVisible()) {
            this.getParentWidget().setCentralContainerPosition(0);
          } else {
            this.getParentWidget().setCentralContainerPosition(this._currentSize);
          }
          // if sidebar size or visibility changed, we emit displayChanged
          if (this._currentSize !== previousSize) {
            // if sidebar size changed only, we update size
            this.setStyle({
              width: this._currentSize + "px"
            });
            // Save sidebar width into storedSettings
            gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
          }
          this.emit(context.constants.widgetEvents.displayChanged);
        },
        /**
         *
         * @returns {classes.ApplicationHostWidget}
         */
        getParentWidget: function() {
          return $super.getParentWidget.call(this);
        },
        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          const sidebarwidth = gbc.StoredSettingsService.getSideBarwidth();
          if (sidebarwidth) {
            this._origin = this._origin ? this._origin : sidebarwidth;
            this.updateResize(sidebarwidth, true);
          }
        },

        setDisplayed: function(displayed) {
          this.getElement().toggleClass("mt-sidebar-displayed", Boolean(displayed));
        },
        isDisplayed: function() {
          return this.getElement().hasClass("mt-sidebar-displayed");
        },

        isUnavailable: function() {
          return this._unavailable;
        },
        setUnavailable: function(unavailable) {
          this._unavailable = Boolean(unavailable);
          this.getElement().toggleClass("mt-sidebar-unavailable", Boolean(unavailable));
        },

        _onTransitionEnd: function(evt) {
          if (evt.target.hasClass("mt-sidebar")) {
            const positionUpdated = this.getParentWidget().setCentralContainerPosition(!this.isAlwaysVisible() ? 0 : this
              ._currentSize);
            if (positionUpdated) {
              this.emit(context.constants.widgetEvents.displayChanged);
            }
          }
        },
        getCurrentSize: function() {
          return this._currentSize;
        },
        getTitle: function() {
          return this._titleTextElement.textContent;
        },
        setTitle: function(title) {
          this._titleTextElement.textContent = title;
        },
        onDisplayChanged: function(hook) {
          return this.when(context.constants.widgetEvents.displayChanged, hook);
        },

        _onDragOver: function(evt) {
          this._pageX = evt.clientX || evt.screenX || evt.pageX;
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          document.body.on("dragover.ApplicationHostSidebarWidget", this._onDragOver.bind(this));
          this._isDragging = true;
          if (window.browserInfo.isFirefox) {
            evt.dataTransfer.setData('text', ''); // for Firefox compatibility
          }
          if (evt.dataTransfer.setDragImage) {
            evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
          }
          evt.dataTransfer.effectAllowed = "move";
          this._pageX = this._resizerDragX = evt.clientX || evt.screenX || evt.pageX;
          this._origin = this._currentSize;
        },
        _onDragEnd: function(evt) {
          document.body.off("dragover.ApplicationHostSidebarWidget");
          this._isDragging = false;
          this._origin = this._currentSize;
          // Save sidebar width into storedSettings
          gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            const deltaX = this._pageX - this._resizerDragX;
            this.updateResize(deltaX);

          }
        },
        isAlwaysVisible: function() {
          return true;

        },

        setTitleText: function(text) {
          if (this._titleTextElement) {
            this._titleTextElement.textContent = text;
          }
        },

        _onSwipe: function(evt, distance) {
          this.emit(context.constants.widgetEvents.toggleClick);
        },
        setSidebarContent: function(widget) {
          if (this._alternateContentWidget && this._alternateContentWidget.getElement() &&
            this._alternateContentWidget.getElement().parent("mt-sidebar") === this.getElement()) {
            this._alternateContentWidget.getElement().remove();
          }
          if (widget) {
            this._contentElement.style.display = "none";
            this._titleElement.style.display = "none";
            this._sidebarContentElement.appendChild(widget.getElement());
          } else {
            this._contentElement.style.display = "";
            this._titleElement.style.display = "";
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationHostSidebar', cls.ApplicationHostSidebarWidget);
  });
;

"use strict";

modulum('SessionSidebarApplicationItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarApplicationItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionSidebarApplicationItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionSidebarApplicationItemWidget.prototype */ {
        __name: "SessionSidebarApplicationItemWidget",
        _applicationName: null,
        _applicationIconImage: null,
        /**
         * @type {classes.ApplicationWidget}
         */
        _applicationWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._applicationName = this._element.getElementsByClassName("applicationName")[0];
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._applicationWidget = null;
          if (this._applicationIconImage) {
            this._applicationIconImage.destroy();
            this._applicationIconImage = null;
          }
          this._applicationName = null;
          $super.destroy.call(this);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _addChildWidgetToDom: function(widget) {
          const itemHost = document.createElement('li');
          itemHost.addClass('mt-action');
          widget.getLayoutInformation().setHostElement(itemHost);
          this._containerElement.appendChild(itemHost);
          itemHost.appendChild(widget._element);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _removeChildWidgetFromDom: function(widget) {
          const info = widget.getLayoutInformation();
          let host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },
        setApplicationName: function(text) {
          this._applicationName.textContent = text;
          this._applicationName.setAttribute("title", text);
        },
        getApplicationName: function() {
          return this._applicationName.textContent;
        },
        setApplicationWidget: function(widget) {
          this._applicationWidget = widget;
        },
        setApplicationIcon: function(image) {
          if (!this._applicationIconImage) {
            this._applicationIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._element.getElementsByClassName("applicationIcon")[0].prependChild(this._applicationIconImage.getElement());
          }
          this._applicationIconImage.setHidden(true);
          if (image && image !== "") {
            this._applicationIconImage.setSrc(image);
            this._applicationIconImage.setHidden(false);
            context.HostService.setCurrentIcon(image, true);
          }
        },
        closeSidebar: function() {
          context.HostLeftSidebarService.hideSidebar();
        },
        unfreeze: function() {

        },
        freeze: function() {

        },
        setProcessing: function(isProcessing) {
          if (isProcessing) {
            this.domAttributesMutator(() => this.getElement().setAttribute("processing", "processing"));
          } else {
            this.domAttributesMutator(() => this.getElement().removeAttribute("processing"));
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebarApplicationItem', cls.SessionSidebarApplicationItemWidget);
  });
;

"use strict";

modulum('SessionSidebarApplicationStackItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarApplicationStackItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionSidebarApplicationStackItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionSidebarApplicationStackItemWidget.prototype */ {
        __name: "SessionSidebarApplicationStackItemWidget",
        _title: null,
        _icon: null,
        _image: null,

        /**
         * @type {Map<String, classes.WidgetBase>}
         */
        _virtualWidgetList: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._virtualWidgetList = new Map();
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._title = this._element.getElementsByClassName("applicationStackTitle")[0];
          this._icon = this._element.getElementsByClassName("applicationStackIcon")[0];
          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._virtualWidgetList.length > 0) {
            context.LogService.warn("Virtual widget list not empty for " + this.__name);
          }

          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          this._title = null;
          this._icon = null;
          $super.destroy.call(this);
        },

        /**
         * Set the tooltip of item in the sidebar
         * @param {String?} title - title of the app, null to remove
         */
        setApplicationTitle: function(title) {
          this._title.textContent = title;
          this._title.setAttribute("title", title);
          if (this._image) {
            this._image.setTitle(title);
          }
          this.addClass("has-title");

          this._virtualWidgetList.forEach((widget) => {
            widget.setText(title);
          });
        },

        getTitle: function() {
          return this._title.textContent;
        },

        setVisible: function(visible) {
          this._element.toggleClass("visible", visible);
          if (visible) {
            this._element.scrollIntoView();
          }
        },

        setIcon: function(image) {
          if (!this._image) {
            this._image = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._image.setAcceptEventWhenWindowInactive(true);
            this._icon.prependChild(this._image.getElement());
          }
          this._image.setHidden(true);
          if (image && image !== "") {
            this._image.setSrc(image);
            this._image.setAutoScale(true);
            this._image.setHidden(false);
            this._image.setTitle(this.getTitle());
            this.addClass("has-icon");

            this._virtualWidgetList.forEach((widget) => {
              widget.setImage(image);
            });
          }
        },

        closeSidebar: function() {
          context.HostLeftSidebarService.hideSidebar();
        },

        /**
         * Get the image URL
         * @returns {null|string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         */
        getIcon: function() {
          if (!this._image) {
            return null;
          }

          return this._image.getImage();
        },

        /**
         * Add an virtual widget
         * @param {classes.WidgetBase} widget
         */
        addVirtualChildWidget: function(widget) {
          this._virtualWidgetList.set(widget.getUniqueIdentifier(), widget);
        },

        /**
         * Remove the virtual widget
         * @param {classes.WidgetBase} widget
         */
        removeVirtualChildWidget: function(widget) {
          this._virtualWidgetList.delete(widget.getUniqueIdentifier());
        },
      };
    });
    cls.WidgetFactory.registerBuilder("SessionSidebarApplicationStackItem", cls.SessionSidebarApplicationStackItemWidget);
  });
;

"use strict";

modulum('SessionSidebarApplicationStackListWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarApplicationStackListWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionSidebarApplicationStackListWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionSidebarApplicationStackListWidget.prototype */ {
        __name: "SessionSidebarApplicationStackListWidget",

        /**
         * @type classes.WidgetBase
         */
        _currentElement: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _addChildWidgetToDom: function(widget) {
          const itemHost = document.createElement('li');
          itemHost.addClass('mt-action');
          widget.getLayoutInformation().setHostElement(itemHost);
          this._containerElement.appendChild(itemHost);
          itemHost.appendChild(widget._element);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _removeChildWidgetFromDom: function(widget) {
          const info = widget.getLayoutInformation();
          let host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },

        closeSidebar: function() {
          context.HostLeftSidebarService.hideSidebar();
        },

        /**
         * @inheritDoc
         */
        _afterInitElement: function() {
          $super._afterInitElement.call(this);

          if (!window.isMobile()) {
            this._containerElement.on('mouseover.SessionSidebarApplicationStackListWidget', this._onMouseover.bind(this));
          }
        },
        /**
         * Mouse over handler used to highlight current item.
         * @param event
         * @private
         */
        _onMouseover: function(event) {
          const element = event.target;
          if (element) {
            const widgetElement = element.hasClass("gbc_WidgetBase") ? element : element.parent("gbc_WidgetBase");
            if (widgetElement) {
              this.setCurrentElement(widgetElement);
            }
          }
        },

        /**
         * Define element as the current element of the list
         * @param {classes.WidgetBase} element
         */
        setCurrentElement: function(element) {
          if (this._currentElement) {
            this._currentElement.toggleClass("current", false);
          }

          this._currentElement = element;
          this._currentElement.toggleClass("current", true);
        }
      };
    });
    cls.WidgetFactory.registerBuilder("SessionSidebarApplicationStackList", cls.SessionSidebarApplicationStackListWidget);
  });
;

"use strict";

modulum('SessionSidebarWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.SessionSidebarWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.SessionSidebarWidget.prototype */ {
        __name: "SessionSidebarWidget",

        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        _initLayout: function() {
          // no layout
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _addChildWidgetToDom: function(widget) {
          const itemHost = document.createElement('li');
          itemHost.addClass('mt-action');
          widget.getLayoutInformation().setHostElement(itemHost);
          this._containerElement.appendChild(itemHost);
          itemHost.appendChild(widget._element);
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        _removeChildWidgetFromDom: function(widget) {
          if (widget) {
            const info = widget.getLayoutInformation();
            let host = info && info.getHostElement();
            if (host && host.parentNode === this._containerElement) {
              widget._element.remove();
              host.remove();
              host = null;
            }
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebar', cls.SessionSidebarWidget);
  });
;

"use strict";

modulum('SessionSidebarWindowItemWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class SessionSidebarWindowItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SessionSidebarWindowItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SessionSidebarWindowItemWidget.prototype */ {
        __name: "SessionSidebarWindowItemWidget",

        /** @type {Element} */
        _windowNameElement: null,
        /** @type {classes.ImageWidget} */
        _windowIconImage: null,
        /** @type {classes.WindowWidget} */
        _windowWidget: null,

        /**
         * @type {Map<String, classes.WidgetBase>}
         */
        _virtualWidgetList: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._virtualWidgetList = new Map();
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._windowNameElement = this._element.getElementsByClassName("windowName")[0];

          this._windowIconImage = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
          this._windowIconImage.setAutoScale(true);
          this._element.getElementsByClassName("windowIcon")[0].prependChild(this._windowIconImage.getElement());

          this.setAcceptEventWhenWindowInactive(true);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click);
          return false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._windowWidget = null;
          this._windowNameElement = null;
          if (this._windowIconImage) {
            this._windowIconImage.destroy();
            this._windowIconImage = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Set window's name
         * @param {String} name - window's name
         * @publicdoc
         */
        setWindowName: function(name) {
          this._windowNameElement.textContent = name;
          this._windowNameElement.setAttribute("title", name);

          this._virtualWidgetList.forEach((widget) => {
            widget.setText(name);
          });
        },

        /**
         * Get window's name
         * @return {string} window's name
         * @publicdoc
         */
        getWindowName: function() {
          return this._windowNameElement.textContent;
        },

        /**
         * Change the image icon
         * @param {String} image - image path
         * @publicdoc
         */
        setWindowIcon: function(image) {
          if (image && image !== "") {
            this._windowIconImage.setSrc(image);

            this._virtualWidgetList.forEach((widget) => {
              widget.setImage(image);
            });
          }
        },

        /**
         * Set the corresponding window widget
         * @param {classes.WindowWidget} widget - window
         */
        setWindowWidget: function(widget) {
          this._windowWidget = widget;
        },

        /**
         * Set window froze or not
         * @param {boolean} frozen - true if window is frozen
         */
        setFrozen: function(frozen) {
          this._element.toggleClass("frozenWindow", Boolean(frozen));
        },

        /**
         * Get the icon path
         * @return {string|null}
         */
        getWindowIcon: function() {
          if (this._windowIconImage && !this._windowIconImage.isHidden()) {
            return this._windowIconImage.getSrc();
          }

          return null;
        },

        /**
         * Add an virtual widget
         * @param {classes.WidgetBase} widget
         */
        addVirtualChildWidget: function(widget) {
          this._virtualWidgetList.set(widget.getUniqueIdentifier(), widget);
        },

        /**
         * Remove the virtual widget
         * @param {classes.WidgetBase} widget
         */
        removeVirtualChildWidget: function(widget) {
          this._virtualWidgetList.delete(widget.getUniqueIdentifier());
        },

        /**
         * True if this is the active window
         * @return {boolean}
         */
        isActive: function() {
          return this._element.hasClass("activeWindow");
        },

        /**
         * True if this is the visible window
         * @return {boolean}
         */
        isVisible: function() {
          return this._element.hasClass("visibleWindow");
        }

      };
    });
    cls.WidgetFactory.registerBuilder('SessionSidebarWindowItem', cls.SessionSidebarWindowItemWidget);
  });
;

"use strict";

modulum('ApplicationLauncherWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class ApplicationLauncherWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ApplicationLauncherWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ApplicationLauncherWidget.prototype */ {
        __name: "ApplicationLauncherWidget",

        /** @type {classes.ChromeBarWidget} **/
        _chromeBar: null,

        /**
         * @inheritDoc
         * @param opts
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          const chromeBarOpt = this.getBuildParameters();
          chromeBarOpt.lightmode = true;
          this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", chromeBarOpt);
          this._element.prependChild(this._chromeBar.getElement());
          this._chromeBar.setLightMode(true);

          const logoElement = this._element.getElementsByClassName("logo")[0];
          logoElement.setAttribute("src", context.ThemeService.getResource("img/logo.png"));
          logoElement.setAttribute("alt", "Genero Browser Client");

          // Display GBC version and build number
          const versionElement = this._element.getElementsByClassName("field_version")[0];
          versionElement.textContent = context.version;

          const buildElement = this._element.getElementsByClassName("field_build")[0];
          buildElement.textContent = context.build + (context.dirtyFlag || "");
        },

        /**
         * @inheritDoc
         * @param hidden
         */
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden);
          gbc.HostLeftSidebarService.enableSidebar(hidden);
        },

        /**
         * @inheritDoc
         * @param {classes.ApplicationHostWidget} widget
         * @param {Object=} options - possible options
         * @param {boolean=} options.noLayoutInvalidation - won't affect parent layout
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          gbc.HostLeftSidebarService.enableSidebar(!this.isVisible());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ApplicationLauncher', cls.ApplicationLauncherWidget);
  });
;

"use strict";

modulum('CanvasAbstractWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Abstract class for canvas element widget.
     * @class CanvasAbstractWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.CanvasAbstractWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.CanvasAbstractWidget.prototype */ {
        __name: "CanvasAbstractWidget",

        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          // can't refactorise these 2 events into MouseService because of __virtual attribute causing this widget to behave differently
          // we should probably make all Canvas related widgets inherit from this Abstract widget to be able to do something with MouseService
          this._element.on('click.CanvasAbstractWidget', this._onClick.bind(this));
          this._element.on('contextmenu.CanvasAbstractWidget', this._onContextMenu.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off("click.CanvasAbstractWidget");
          this._element.off("contextmenu.CanvasAbstractWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onClick: function(event) {
          event.stopPropagation();
          event.preventCancelableDefault();
          this.emit(context.constants.widgetEvents.click, event);
        },

        /**
         * Handle contextmenu event
         * @param {*} event
         */
        _onContextMenu: function(event) {
          event.stopPropagation();
          event.preventCancelableDefault();
          this.emit(context.constants.widgetEvents.rightClick, event);
        },

        setColor: function(color) {
          this._element.setAttribute('fill', color);
        }
      };
    });
  }
);
;

"use strict";

modulum('CanvasArcWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * CanvasArc widget.
     * @class CanvasArcWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasArcWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasArcWidget.prototype */ {
        __name: "CanvasArcWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "path");
          $super._initElement.call(this);
        },

        setParameters: function(startX, startY, diameter, startDegrees, extentDegrees) {
          const startAngle = (extentDegrees >= 0 ? startDegrees : startDegrees + extentDegrees) * Math.PI / 180;
          const endAngle = (extentDegrees >= 0 ? startDegrees + extentDegrees : startDegrees) * Math.PI / 180;

          const d2 = diameter / 2;
          const r = Math.abs(d2);
          const cx = startX + d2;
          const cy = startY - d2;

          const x1 = cx + r * Math.cos(startAngle);
          const y1 = cy + r * Math.sin(startAngle);
          const x2 = cx + r * Math.cos(endAngle);
          const y2 = cy + r * Math.sin(endAngle);

          const largeArcFlag = Math.abs(extentDegrees) < 180 ? 0 : 1;

          const d = "M " + cx + " " + cy + " " +
            "L " + x1 + " " + y1 + " " +
            "A " + r + " " + r + " 0 " + largeArcFlag + " 1 " + x2 + " " + y2 + " " +
            "Z";

          this._element.setAttribute('d', d);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasArc', cls.CanvasArcWidget);
  }
);
;

"use strict";

modulum('CanvasCircleWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasCircleWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasCircleWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasCircleWidget.prototype */ {
        __name: "CanvasCircleWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          $super._initElement.call(this);
        },

        setParameters: function(cx, cy, r) {
          this._element.setAttribute('cx', cx);
          this._element.setAttribute('cy', cy);
          this._element.setAttribute('r', r);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasCircle', cls.CanvasCircleWidget);
  }
);
;

"use strict";

modulum('CanvasLineWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasLineWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasLineWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasLineWidget.prototype */ {
        __name: "CanvasLineWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "line");
          this._element.setAttribute('stroke-width', "2px");
          $super._initElement.call(this);
        },

        setParameters: function(x1, y1, x2, y2) {
          this._element.setAttribute('x1', x1);
          this._element.setAttribute('y1', y1);
          this._element.setAttribute('x2', x2);
          this._element.setAttribute('y2', y2);
        },

        setColor: function(color) {
          this._element.setAttribute('stroke', color);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasLine', cls.CanvasLineWidget);
  }
);
;

"use strict";

modulum('CanvasOvalWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasOvalWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasOvalWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasOvalWidget.prototype */ {
        __name: "CanvasOvalWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
          $super._initElement.call(this);
        },

        setParameters: function(cx, cy, rx, ry) {
          this._element.setAttribute('cx', cx);
          this._element.setAttribute('cy', cy);
          this._element.setAttribute('rx', rx);
          this._element.setAttribute('ry', ry);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasOval', cls.CanvasOvalWidget);
  }
);
;

"use strict";

modulum('CanvasPolygonWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasPolygonWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasPolygonWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasPolygonWidget.prototype */ {
        __name: "CanvasPolygonWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
          $super._initElement.call(this);
        },

        setParameters: function(points) {
          let pointsStr = "";
          for (let i = 0; i < points.length; i = i + 2) {
            if (i !== 0) {
              pointsStr += ' ';
            }
            pointsStr += points[i + 1] + ',' + points[i];
          }
          this._element.setAttribute('points', pointsStr);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasPolygon', cls.CanvasPolygonWidget);
  }
);
;

"use strict";

modulum('CanvasRectangleWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasRectangleWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasRectangleWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasRectangleWidget.prototype */ {
        __name: "CanvasRectangleWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          $super._initElement.call(this);
        },

        setParameters: function(x, y, width, height) {
          this._element.setAttribute('x', x);
          this._element.setAttribute('y', y);
          this._element.setAttribute('width', width);
          this._element.setAttribute('height', height);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasRectangle', cls.CanvasRectangleWidget);
  }
);
;

"use strict";

modulum('CanvasTextWidget', ['CanvasAbstractWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasTextWidget
     * @memberOf classes
     * @extends classes.CanvasAbstractWidget
     */
    cls.CanvasTextWidget = context.oo.Class(cls.CanvasAbstractWidget, function($super) {
      return /** @lends classes.CanvasTextWidget.prototype */ {
        __name: "CanvasTextWidget",

        _initElement: function() {
          this._element = document.createElementNS("http://www.w3.org/2000/svg", "text");
          $super._initElement.call(this);
        },

        setParameters: function(canvasWidth, canvasHeight, x, y, xTextAnchor, yTextAnchor, text) {
          this._element.setAttribute('x', '0');
          switch (yTextAnchor) {
            case 'start':
              this._element.setAttribute('y', '1.25ex');
              break;
            case 'middle':
              this._element.setAttribute('y', '.5ex');
              break;
            case 'end':
              this._element.setAttribute('y', '-.25ex');
              break;
          }
          this._element.setAttribute('text-anchor', xTextAnchor);
          this._element.textContent = text;
          const sx = canvasWidth !== 0 ? 1000 / canvasWidth : 0;
          const sy = canvasHeight !== 0 ? -1000 / canvasHeight : 0;
          this._element.setAttribute("transform", "matrix(" + sx + " 0 0 " + sy + " " + x + " " + y + ")");
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CanvasText', cls.CanvasTextWidget);
  }
);
;

"use strict";

modulum('CanvasWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class CanvasWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.CanvasWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.CanvasWidget.prototype */ {
        __name: "CanvasWidget",

        _svgElement: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.CanvasLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this._layoutInformation.getSizePolicyConfig()._defaultMode = 'fixed';
          this._layoutInformation.getSizePolicyConfig().setMode('fixed');
          this._layoutInformation.forcedMinimalHeight = 20;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this._svgElement.setAttribute("class", "gbc-label-text-container gbc_" + this.__name);
          this._svgElement.setAttribute("preserveAspectRatio", "none");
          this._svgElement.setAttribute("viewBox", "0 0 1000 1000");
          this._svgElement.setAttribute("width", "100%");
          this._svgElement.setAttribute("height", "100%");
          this._svgElement.setAttribute("overflow", "hidden");
          this._containerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
          this._containerElement.setAttribute("class", "containerElement");
          this._containerElement.setAttribute("transform", "matrix(1 0 0 -1 0 1000)");
          this._svgElement.appendChild(this._containerElement);
          this._element.appendChild(this._svgElement);
        },

        /**
         * @inheritDoc
         */
        manageMouseRightClick: function(domEvent) {
          domEvent.preventCancelableDefault();
          return false;
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {},

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._svgElement = null;
          $super.destroy.call(this);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Canvas', cls.CanvasWidget);
  }
);
;

"use strict";

modulum('AccordionFolderWidget', ['FolderWidgetBase'],
  function(context, cls) {

    /**
     * Accordion Folder widget.
     * @class AccordionFolderWidget
     * @memberOf classes
     * @extends classes.FolderWidgetBase
     * @publicdoc Widgets
     */
    cls.AccordionFolderWidget = context.oo.Class(cls.FolderWidgetBase, function($super) {
      return /** @lends classes.AccordionFolderWidget.prototype */ {
        __name: "AccordionFolderWidget",

        /** @function */
        _pageVisibilityHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._pageVisibilityHandler = this.when(gbc.constants.widgetEvents.pageVisibility, this.forceRelayout.bind(this));
          // Set the default value of the collapsers to the theme definition
          this.setCollapserPosition(gbc.ThemeService.getValue("gbc-AccordionFolderWidget-collapser-position"));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._pageVisibilityHandler) {
            this._pageVisibilityHandler();
            this._pageVisibilityHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.AccordionFolderLayoutEngine(this);

          $super._initLayout.call(this);

        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          options = options || {};
          options.noDOMInsert = true;

          /** @type classes.PageWidget */
          const pageWidget = widget;

          const titleWidget = pageWidget.getTitleWidget();

          const accordionElement = document.createElement("div");
          accordionElement.addClass("gbc_AccordionElement");
          accordionElement.addClass("g_measurable");

          const accordionPage = document.createElement("div");
          accordionPage.addClass("gbc_AccordionPage");
          accordionPage.addClass("g_measurable");

          accordionElement.appendChild(titleWidget.getElement());
          accordionPage.appendChild(pageWidget.getElement());
          accordionElement.appendChild(accordionPage);

          this.getContainerElement().appendChild(accordionElement);

          this.forceRelayout();

          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          const accordionPage = widget.getElement().parentNode;
          // only current page is in DOM
          if (accordionPage) {
            const accordionElement = accordionPage.parentNode;
            accordionPage.remove();
            if (accordionElement) {
              accordionElement.remove();
            }
          }

          $super.removeChildWidget.call(this, widget);
        },

        /**
         * Force relayout of widget
         */
        forceRelayout: function() {
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * @inheritDoc
         */
        setCurrentPage: function(page, executeAction, fromUserAction = false) {
          let accordionElement = null;
          let accordionPage = null;
          if (this._currentPage && this._currentPage !== page) {
            // remove currentPage class from previous current accordion page
            accordionPage = this._currentPage.getElement().parentNode;
            accordionElement = accordionPage.parentNode;
            accordionPage.removeClass("currentPage");
            accordionElement.removeClass("currentPage");
          }
          const modified = $super.setCurrentPage.call(this, page, executeAction, fromUserAction);
          if (modified) {
            // add currentPage class to new current accordion page
            accordionPage = this._currentPage.getElement().parentNode;
            accordionElement = accordionPage.parentNode;
            accordionPage.addClass("currentPage");
            accordionElement.addClass("currentPage");
          }
          return modified;
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.removeClass("collapser-position-left");
          this.removeClass("collapser-position-right");
          this.addClass("collapser-position-" + pos);
        }

      };
    });
    cls.WidgetFactory.registerBuilder("Folder[position=accordion]", cls.AccordionFolderWidget);
  });
;

"use strict";

modulum('BoxWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Box Widget
     * @publicdoc Widgets
     * @class BoxWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.BoxWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.BoxWidget.prototype */ {
        __name: "BoxWidget",
        /** @type {?Boolean} */
        _canHaveSplitter: null,
        _splitters: null,
        _splitterIdentifier: null,
        _ignoreStoredSettings: false,
        /** @type {String} */
        _orientation: "",
        /** @type {Boolean} */
        _isSplit: false,
        /** @type {?Boolean} */
        _noSwipe: null,
        /** @type {Boolean} */
        _splitViewEnabled: false,
        /** @type {Boolean} */
        _navigationArrows: false,
        /** @type {Boolean} */
        _navigationDots: false,
        /** @type {Boolean} */
        _navigationDotSetByUser: false,
        /** @type {Boolean} */
        _isPacked: false,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._splitters = [];
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._isSplit = false;
          if (this._splitters) {
            for (let i = this._splitters.length - 1; i > -1; i--) {
              let currentChildren = this._splitters[i].widget;
              currentChildren.destroy();
              currentChildren = null;
            }
            this._splitters.length = 0;
          }
          this._noSwipe = null;
          this.disableSwipe();
          if (this._gesture) {
            this._gesture.destroy();
            this._gesture = null;
          }
          if (this._focusRestoredHandler) {
            this._focusRestoredHandler();
            this._focusRestoredHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (!(widget instanceof cls.SplitterWidget)) {
            options = options || {
              position: ((this._children.length || -1) + 1) / 2
            };
            if (Object.isNumber(options.position)) {
              options.position = options.position * 2;
            }
            if (options.position) {
              const splitter = this._createSplitter();
              splitter.activateSplitter(this._canHaveSplitter);
              const onSplit = splitter.when(context.constants.widgetEvents.splitter, this._onSplit.bind(this));
              const onSplitStart = splitter.when(context.constants.widgetEvents.splitterStart, this._onSplitStart.bind(this));
              const onSplitEnd = splitter.when(context.constants.widgetEvents.splitterEnd, this._onSplitEnd.bind(this));
              this.addChildWidget(splitter, {
                position: options.position - 1
              });
              this._splitters.splice(options.position / 2, 0, {
                widget: splitter,
                onSplit: onSplit,
                onSplitStart: onSplitStart,
                onSplitEnd: onSplitEnd
              });
            }
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * Create a splitter widget
         * @return {classes.HVBoxSplitterWidget} the created splitter widget
         * @protected
         */
        _createSplitter: function() {

          const splitter = cls.WidgetFactory.createWidget("HVBoxSplitter", this.getBuildParameters());
          splitter.setOrientation(this._orientation);
          return splitter;
        },

        /**
         * Get Box orientation
         * @returns {string}
         */
        getOrientation: function() {
          return this._orientation;
        },

        /**
         * _onSplit
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @param {*} delta the delta value
         * @private
         */
        _onSplit: function(event, sender, delta) {
          this._layoutEngine.splitting(delta);
          this.emit(context.constants.widgetEvents.splitter);
        },

        /**
         * _onSplitStart
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @private
         */
        _onSplitStart: function(event, sender) {
          this._layoutEngine.startSplitting((this._children.indexOf(sender) - 1) / 2);
        },

        /**
         * _onSplitEnd
         * @param {classes.Event} event the event
         * @param {classes.EventListener} sender the sender
         * @private
         */
        _onSplitEnd: function(event, sender) {
          this._layoutEngine.stopSplitting();
          if (!this._ignoreStoredSettings) {
            context.StoredSettingsService.setSplitter(this._splitterIdentifier.formName,
              this._splitterIdentifier.id, this._layoutEngine._referenceSplitHints);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            const pos = this._children.indexOf(widget) - 1;
            if (pos > 0) {
              this._children[pos].destroy();
            }
          } else {
            const item = this._splitters.find(function(splitter) {
              return splitter.widget === widget;
            });
            if (item) {
              item.onSplit();
              item.onSplitStart();
              item.onSplitEnd();
              this._splitters.remove(item);
            }
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        _addChildWidgetToDom: function(widget, position) {
          this.getLayoutEngine().registerChild(widget, position);
          const widgetHost = document.createElement('div');
          widgetHost.addClass('g_BoxElement');
          widget.getLayoutInformation().setHostElement(widgetHost);
          widgetHost.appendChild(widget._element);
          widgetHost.insertAt(position, this._containerElement);
        },

        /**
         * @inheritDoc
         */
        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          const info = widget.getLayoutInformation();
          let host = info && info.getHostElement();
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },

        /**
         * getIndexOfChild
         * @param {classes.WidgetBase} widget the widget
         * @return {number} the index
         */
        getIndexOfChild: function(widget) {
          const rawIndex = this._children.indexOf(widget);
          return rawIndex / (widget instanceof cls.SplitterWidget ? 1 : 2);
        },

        /**
         * ignoreStoredSettings
         * @param {boolean} ignore ignore stored settings
         */
        ignoreStoredSettings: function(ignore) {
          this._ignoreStoredSettings = Boolean(ignore);
        },

        /**
         * Initialize splitter layout engine hints
         */
        initSplitterLayoutEngine: function() {
          if (!this._ignoreStoredSettings) {
            if (this._layoutEngine.initSplitHints) {
              this._layoutEngine.initSplitHints(context.StoredSettingsService.getSplitter(
                this._splitterIdentifier.formName, this._splitterIdentifier.id));
            }
          }
        },

        /**
         * switchSplitters
         * @param {boolean} canSplit can split
         * @param {*} splitterId splitter id
         */
        switchSplitters: function(canSplit, splitterId) {
          if (this._canHaveSplitter !== canSplit) {
            this._splitterIdentifier = splitterId;

            this.initSplitterLayoutEngine();

            this._canHaveSplitter = canSplit;
            for (let i = 0; i < this._splitters.length; i++) {
              this._splitters[i].widget.activateSplitter(this._canHaveSplitter);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          //Default is vertical, might change after
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.HVBoxLayoutEngine(this);
          this._element.addClass("g_VBoxLayoutEngine");
        },

        /**
         * Set the box orientation
         * @param {String} orientation could be horizontal or vertical
         */
        setOrientation: function(orientation) {
          this._orientation = orientation || this.getDefaultOrientation();

          this._refreshSplit();

          if (this._layoutEngine.setOrientation) {
            this._layoutEngine.setOrientation(this._orientation);

            this._splitters.forEach((splitter) => {
              splitter.widget.setOrientation(this._orientation);
            });
          }

        },

        /**
         * Get default orientation
         * @return {string} - horizontal if HBOX, vertical if VBOX or not known
         */
        getDefaultOrientation: function() {
          return "vertical";
        },

        /**
         * Set packed 4ST attribute on HBOX and VBOX. By default, is false. If true, HBOX/VBOX will be left/top centered
         * @param packed
         */
        setPacked: function(packed) {
          this._isPacked = packed;
        },

        /**
         * Returns true if HBOX/VBOX is packed
         * @returns {Boolean}
         */
        isPacked: function() {
          return this._isPacked;
        },

        // SPLIT & SWIPE

        /**
         * Set Split VM attribute and enable/disable split view
         */
        setSplit: function(isSplit) {
          if (this._isSplit !== isSplit) {
            this._isSplit = isSplit;
            this._refreshSplit();
          }
        },

        /**
         * Enable/disable split depending of orientation updates and current split value
         * @private
         */
        _refreshSplit: function() {
          if (this._isSplit && this.getOrientation() === "horizontal") {
            this.enableSplitView();
          } else {
            this.disableSplitView();
          }
        },

        /**
         * Enable/disable navigation Arrows 4ST attribute
         * @param active
         */
        setNavigationArrows: function(active) {
          this._navigationArrows = active;
          if (this._gesture) {
            if (active) {
              this._gesture.addArrows();
            } else {
              this._gesture.removeArrows();
            }
          }
        },

        /**
         * Enable/disable navigation dots 4ST attribute
         * @param active
         */
        setNavigationDots: function(active) {
          this._navigationDots = active;
          this._navigationDotSetByUser = true;
          if (this._gesture) {
            if (active) {
              this._gesture.addDots();
            } else {
              this._gesture.removeDots();
            }
          }
        },

        /**
         * Enable Split view layout of HBOX or VBOX orientation horizontal
         */
        enableSplitView: function() {
          if (!this._splitViewEnabled) {
            this._splitViewEnabled = true;
            const oldEngine = this._layoutEngine;
            this.addClass("splitView");
            this._layoutEngine = new cls.SplitLayoutEngine(this);
            this._layoutInformation.getStretched().setDefaultX(true);
            this._layoutInformation.getStretched().setDefaultY(true);

            // enable swipe gesture
            this.enableSwipe();

            for (const element of this.getChildren()) {
              const child = element;
              if (child instanceof cls.SplitterWidget) { // hide splitter in splitview
                child.setHidden(true);
              } else if (!child.isHidden()) {
                oldEngine.unregisterChild(child);
                this._layoutEngine.registerChild(child);
              }
              if (child.isHidden()) {
                if (child.getElement().parentNode) {
                  child.getElement().parentNode.addClass("hidden");
                }
              }

              this._listenToGroupVisibilityChange(child);
            }

            // if the navigation dot not set by user then add it (yes = default value)
            if (!this._navigationDotSetByUser && !this._gesture.hasDots()) {
              this._gesture.addDots();
            }

            if (!this._focusRestoredHandler) {
              this._focusRestoredHandler = context.SessionService.getCurrent().getCurrentApplication().focus.when(context.constants
                .widgetEvents.focusRestored,
                function() {
                  this._focusRestoredHandler = null;
                  this._layoutEngine.refreshLayout();
                }.bind(this), true);
            }
          }
        },

        /**
         * Disable Split view layout of HBOX or VBOX orientation horizontal
         */
        disableSplitView: function() {
          if (this._splitViewEnabled) {
            this._splitViewEnabled = false;

            if (this._focusRestoredHandler) {
              this._focusRestoredHandler();
              this._focusRestoredHandler = null;
            }

            const oldEngine = this._layoutEngine;
            this.removeClass("splitView");
            this._layoutEngine = new cls.HVBoxLayoutEngine(this);
            this._layoutInformation.getStretched().setDefaultX(false);
            this._layoutInformation.getStretched().setDefaultY(false);

            this.disableSwipe();

            for (let i = this.getChildren().length - 1; i >= 0; i--) {
              const child = this.getChildren()[i];
              if (child.isHidden()) {
                if (child.getElement().parentNode) {
                  child.getElement().parentNode.removeClass("hidden");
                }
              }
              if (child instanceof cls.SplitterWidget) { // show splitter in splitview
                child.setHidden(false);
              }
              oldEngine.unregisterChild(child);
              this._layoutEngine.registerChild(child);

              this._stopListeningToGroupVisibilityChange(child);
            }

            this._layoutEngine.setOrientation(this.getOrientation(), true);

          }

        },

        /**
         * Listen to group visibility change to be able to add/remove it from swipeable element
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _listenToGroupVisibilityChange: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            widget.detachVisibilityChangeListener = widget.when(context.constants.widgetEvents.visibilityChange, this._addRemoveGroup.bind(
              this, widget));
            // each child group need to listen to focus to display. Mostly needed for folder pages.
            if (this._gesture) {
              widget.detachSplitViewChangeListener = widget.when(context.constants.widgetEvents.splitViewChange, this._gesture.swipeTo.bind(
                this._gesture, widget, {
                  smoothEffect: false
                }));
            }
          }
        },

        /**
         * Stop to listen to group visibility change
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _stopListeningToGroupVisibilityChange: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            if (widget.detachVisibilityChangeListener) {
              widget.detachVisibilityChangeListener();
              delete widget.detachVisibilityChangeListener;
            }
            if (widget.detachSplitViewChangeListener) {
              widget.detachSplitViewChangeListener();
              delete widget.detachSplitViewChangeListener;
            }
          }
        },

        /**
         * Add or remove a group in the list of swipeable groups of the HBox SplitView depending on group visibility
         * @param {classes.WidgetBase} widget - SplitView child group
         * @private
         */
        _addRemoveGroup: function(widget) {
          if (widget.isHidden()) {
            this._layoutEngine.unregisterChild(widget);
            widget.getElement().parentNode.addClass("hidden");
          } else {
            this._layoutEngine.registerChild(widget);
            widget.getElement().parentNode.removeClass("hidden");
          }

        },

        // SWIPE

        /**
         * Set NoSwipe attribute value and enable/disable swipe gestures
         * @param noSwipe
         */
        setNoSwipe: function(noSwipe) {
          if (this._noSwipe !== noSwipe) {
            this._noSwipe = noSwipe;
            if (this.isSwipeable()) { // if we can swipe, then enable it
              this.enableSwipe();
            } else {
              this.disableSwipe();
            }
          }
        },

        /**
         * Determine if swipe gestures are supported on current device
         * @returns {*}
         */
        isSwipeable: function() {
          return this._isSplit && !this._noSwipe && window.isTouchDevice() && this.getOrientation() === "horizontal";
        },

        /**
         * Enable swipe functionality on folder pages
         */
        enableSwipe: function() {
          if (!this._gesture) {
            const params = {
              noSwipe: !this.isSwipeable(),
              arrows: this._navigationArrows,
              dots: this._navigationDots
            };
            this._gesture = new cls.GestureService(this, params);
          } else {
            this._gesture.addTouch();
          }
        },

        /**
         * Disable swipe functionality on folder pages
         */
        disableSwipe: function() {
          if (this._isSplit && this.getOrientation() ===
            "horizontal") { // Both SPLIT and NOSWIPE enabled. Add dots to be able to switch of view
            if (this._gesture) {
              this._gesture.removeTouch();
              if (!this._gesture.hasArrows() && !this._gesture.hasDots()) {
                this._gesture.addDots();
              }
            }
          } else { // can delete all instance of gesture
            if (this._gesture) {
              this._gesture.destroy();
              this._gesture = null;
            }
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Box', cls.BoxWidget);
  });
;

"use strict";

modulum('ChoiceDropDownWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Choice DropDown widget.
     * @class ChoiceDropDownWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ChoiceDropDownWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ChoiceDropDownWidget.prototype */ {
        $static: {
          widgetEvents: {
            currentChildrenChange: "currentChildrenChange",
          }
        },
        __name: "ChoiceDropDownWidget",
        __templateName: "DropDownWidget",
        /**
         * Indicated if dropdown can handle a multiple' items selection. In this case dropdown isn't closed on item click
         * @type {boolean}
         */
        _allowMultipleChoices: false,
        /**
         * Current highlighted & selected element
         * @type {HTMLElement}
         */
        _currentElement: null,

        /**
         * Value validate by a user action
         * @type {boolean}
         *
         */
        _userValidationAction: false,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          // on dropdown close reset current children selected
          this.onClose(function() {
            this.setCurrentPosition(null);
          }.bind(this));

          this.onOpen(this._addHoverBindings.bind(this));
          this.onClose(this._removeHoverBindings.bind(this));
        },

        /**
         * Bind dropdown items hover styling events
         * @private
         */
        _addHoverBindings: function() {
          if (!window.isMobile()) {
            this._element.on('mouseover.ChoiceDropDownWidget', this._onHover.bind(this));
          } else {
            this._element.on('touchstart.ChoiceDropDownWidget', this._onHover.bind(this));
          }
        },

        /**
         * Remove dropdown items hover styling events
         * @private
         */
        _removeHoverBindings: function() {
          if (!window.isMobile()) {
            this._element.off('mouseover.ChoiceDropDownWidget');
          } else {
            this._element.off('touchstart.ChoiceDropDownWidget');
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._removeHoverBindings();

          if (this.getChildren() && this.getChildren().length > 0) {
            console.warn("We are destroying " + this.getParentWidget().__name +
              " DropDown whereas it still has children. We will automatically destroy children. Please verify how DropDown has been implemented as this may be a side effect."
            );
            this.destroyChildren();
          }

          $super.destroy.call(this);
        },

        /**
         * Mouse/touch handler used to highlight current item.
         * We can't use css :hover otherwise there will be duplicated highlights with keyboard navigation
         * @param event
         * @private
         */
        _onHover: function(event) {
          const element = event.target;
          if (element) {
            const widgetElement = element.hasClass("gbc_WidgetBase") ? element : element.parent("gbc_WidgetBase");
            this._highlightCurrentItem(widgetElement);
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isVisible()) {
            keyProcessed = true;
            const app = context.SessionService.getCurrent().getCurrentApplication();
            switch (keyString) {
              case "enter":
              case "return":
                app.scheduler.callbackCommand(this._onClick.bind(this, null, this.getCurrentChildren()));
                break;
              case "up":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, -1));
                break;
              case "down":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, 1));
                break;
              case "pageup":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, -10));
                break;
              case "pagedown":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, 10));
                break;
              case "home":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, Number.NEGATIVE_INFINITY));
                break;
              case "end":
                app.scheduler.callbackCommand(this.navigateTo.bind(this, Number.POSITIVE_INFINITY));
                break;
              default:
                keyProcessed = false;
            }
          }
          keyProcessed = $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat) || keyProcessed;
          return keyProcessed;
        },

        /**
         * Navigate through a dropdown item using step number. Main method used in keyboard navigation
         * @param {number} pos - position of the item to select
         * @publicdoc
         */
        navigateTo: function(pos) {
          if (this.getParentWidget() && !this.getParentWidget().isDestroyed()) {
            let nextChild = null;
            // get new item position
            let newPos = this.getIndexOfChild(this.getCurrentChildren()) + pos;
            // if new item position if outside of limits
            if (newPos < 0 || newPos > (this.getChildren().length - 1)) {
              // we fall back to first or last item
              if (newPos < 0) {
                newPos = 0;
              } else {
                newPos = this.getChildren().length - 1;
              }
              nextChild = this.getChildren()[newPos];
              // if first or last item isn't focusable, then we end the navigation
              if (!nextChild.isEnabled() || nextChild.isHidden()) {
                return;
              }
            } else {
              // get new item
              nextChild = this.getChildren()[newPos];
            }
            // if new item isn't focusable, we continue navigation
            if (!nextChild.isEnabled() || nextChild.isHidden()) {
              return this.navigateTo(pos < 0 ? pos - 1 : pos + 1);
            }

            // new item validated
            this.setCurrentPosition(nextChild);
            if (!this.isVisible()) {
              this.emit(context.constants.widgetEvents.select, this.getCurrentValue());
            }
          }
        },

        /**
         * Update selected item (highlight + position update + childrenChange emit)
         * @param {classes.WidgetBase} currentChildren - children to set position at
         * @publicdoc
         */
        setCurrentPosition: function(currentChildren) {
          if (currentChildren !== null) {
            this._highlightCurrentItem(currentChildren.getElement());
            this.scrollItemIntoView(currentChildren.getElement());
            this.getParentWidget().emit(cls.ChoiceDropDownWidget.widgetEvents.currentChildrenChange, currentChildren);
          } else {
            this._highlightCurrentItem(null);
          }
        },

        /**
         * Highlight current item of the dropdown
         * @param widgetElement
         * @private
         */
        _highlightCurrentItem: function(widgetElement) {
          if (this._currentElement && this._currentElement !== widgetElement) {
            this._currentElement.removeClass("current");
          }
          this._currentElement = widgetElement;
          if (this._currentElement &&
            !this._currentElement.hasClass("current") &&
            !this._currentElement.hasClass("hidden") &&
            (!this._currentElement.hasClass("disabled") || this._currentElement.hasAttribute("interruptable-active"))) {
            this._currentElement.addClass("current");
          }
        },

        /**
         * Returns current widget element being selected (flagged with 'current' class)
         * @returns {?HTMLElement} The current child DOM element
         * @publicdoc
         */
        getCurrentElement: function() {
          return this._currentElement;
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          this._userValidationAction = false;
        },

        /**
         * Hide all displayed dropdowns
         * @publicdoc
         */
        hide: function() {
          $super.hide.call(this);
        },

        /**
         * Scroll to element if needed
         * @param {HTMLElement} element element
         * @publicdoc
         */
        scrollItemIntoView: function(element) {
          const elemTop = element.offsetTop;
          const elemHeight = element.offsetHeight;
          const parentContainer = this.getElement();
          const containerTop = parentContainer.scrollTop;
          const containerHeight = parentContainer.offsetHeight;
          if (containerTop > elemTop) {
            element.scrollIntoView();
          } else if (containerTop + containerHeight < elemTop + elemHeight) {
            element.scrollIntoView(false);
          }
        },

        /**
         * Returns position of value in dropdown choices list
         * @param {*} value - value to check index
         * @returns {number} - the index of the value in list
         * @publicdoc
         */
        getValueIndex: function(value) {
          const children = this.getChildren();
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.getValue && child.getValue() === value) {
              return i;
            }
          }
          return -1;
        },

        /**
         * Bind handler which is executed each time a dropdown item is selected
         * @param {Hook} hook - method to bind when item change
         * @returns {HandleRegistration} bound handler
         * @publicdoc
         */
        onCurrentChildrenChange: function(hook) {
          return this.getParentWidget().when(cls.ChoiceDropDownWidget.widgetEvents.currentChildrenChange, hook);
        },

        /**
         * On click handler raised when selecting an item in the dropdown :
         * Parent widget get value of clicked item and dropdown is closed.
         * @param event
         * @param sender
         * @param domEvent
         * @private
         */
        _onClick: function(event, sender, domEvent) {
          const parentWidget = this.getParentWidget();
          if (parentWidget && !parentWidget.isDestroyed()) {
            if (sender && sender.getValue) {
              const value = sender.getValue();
              if (parentWidget.setEditing) {
                parentWidget.setEditing(true);
                if (parentWidget._setMultiValue) {
                  parentWidget._setMultiValue(value);
                } else if (parentWidget.setValue) {
                  parentWidget.setValue(value);
                  this._userValidationAction = true;
                  parentWidget.emit(context.constants.widgetEvents.valueChanged, parentWidget.getValue());
                }
              }
            }
            if (domEvent) {
              domEvent.stopPropagation();
            }
            if (!this._allowMultipleChoices) {
              this.hide();
            }

            parentWidget.emit(context.constants.widgetEvents.focus, event);
            if (sender && sender.ddOnClickCallback) {
              sender.ddOnClickCallback();
            }
          }
        },

        /**
         * Returns true if current dropdown action / value change is done but a user action such as click/enter
         * @returns {boolean}
         */
        isUserAction: function() {
          return this._userValidationAction;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          this._bindClickToItem(widget, options);
        },

        /**
         * @inheritDoc
         */
        adoptChildWidget: function(widget, options) {
          $super.adoptChildWidget.call(this, widget, options);
          this._bindClickToItem(widget, options);
        },

        /**
         * Bind clicks handlers to dropdown item widget and flag it as being inside dropdown
         * @param {classes.WidgetBase} widget - item widget
         * @param {object} options - addChildWidget/adoptChildWidget option paramaters
         * @private
         */
        _bindClickToItem: function(widget, options) {
          widget.isInDropDown = true;
          widget.ddOnClickCallback = options && options.clickCallback;
          widget._clickHandlerFromChoiceDropDown = widget.when(context.constants.widgetEvents.click, function(event, sender,
            domEvent) {
            this._onClick.call(this, event, widget, domEvent);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          if (widget) {
            if (widget._clickHandlerFromChoiceDropDown) {
              widget._clickHandlerFromChoiceDropDown();
              widget._clickHandlerFromChoiceDropDown = null;
            }
            widget.ddOnClickCallback = null;
            widget.isInDropDown = false;
          }
          $super.removeChildWidget.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        show: function(multiple) {
          if (this._userValidationAction) {
            this._userValidationAction = false;
            return;
          }

          if (this.getParentWidget() && !this.getParentWidget().isDestroyed()) {
            if (this.getChildren().length > 0) {
              $super.show.call(this, multiple);
              if (this.getParentWidget().getValue) {
                const defaultValue = this.getParentWidget().getValue();
                const index = this.getValueIndex(defaultValue);
                if (index !== -1) {
                  this.setCurrentPosition(this.getChildren()[index]);
                }
              }
            }
          }
        },

        /**
         * Set whether this list will accept multiple values or not
         * @param {boolean} allow allow
         * @publicdoc
         */
        allowMultipleChoices: function(allow) {
          this._allowMultipleChoices = allow;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ChoiceDropDown', cls.ChoiceDropDownWidget);
  });
;

"use strict";

modulum('CompleterWidget', ['ChoiceDropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Manages a dropdown attached to an edit to provide predefined choices
     * @class CompleterWidget
     * @memberOf classes
     * @extends classes.ChoiceDropDownWidget
     * @publicdoc Widgets
     */
    cls.CompleterWidget = context.oo.Class(cls.ChoiceDropDownWidget, function($super) {
      return /** @lends classes.CompleterWidget.prototype */ {
        __name: "CompleterWidget",
        /**
         * Completer size
         * @type {number}
         */
        _size: 0,
        /**
         * Completer delay in ms to display its results
         * @type {number}
         */
        _completerDelay: 50,

        _completerlinked: false,

        /**
         * Add a completer to the parent widget
         * @param {classes.WidgetBase} parentWidget to which is attached completer
         * @publicdoc
         */
        addCompleterWidget: function(parentWidget) {
          if (!this._completerlinked) {
            this._completerlinked = true;
            this.setParentWidget(parentWidget);
            this.autoSize = true;
            this.setCanOverlay(false);

            // set edit input of parent widget as parent element
            this.parentElement = parentWidget.getElement().getElementsByTagName("input")[0].parentElement;
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          switch (keyString) {
            case "esc":
            case "enter":
            case "return":
            case "up":
            case "down":
            case "pageup":
            case "pagedown":
              // if existing, emit the change value event, which is being delayed (300ms), immediately before managing dropdown navigation keys
              if (keyString !== "esc") {
                if (this.getParentWidget().cancelCompleterValueChangedDelayer()) {
                  this.getParentWidget().emit(context.constants.widgetEvents.valueChanged, this.getParentWidget().getValue()); // send value
                }
              }
              keyProcessed = $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
              break;
            case "tab":
            case "shift+tab":
              if (this.isVisible()) {
                this.hideDropDown();
              }
              break;
          }

          return keyProcessed;
        },

        /**
         * Bind handler which is executed each time a completer item is selected
         * @param {Hook} hook - function to execute each time a completer item is selected (we pass item value in parameter of the hook)
         * @returns {HandleRegistration} bound handler
         * @publicdoc
         */
        onCurrentChildrenChange: function(hook) {
          return $super.onCurrentChildrenChange.call(this, function(evt, parent, children) {
            hook(children.getValue());
          });
        },

        /**
         * Add item label in dropdown
         * @param {string} choice - item label to be displayed
         * @publicdoc
         */
        addChoice: function(choice) {
          const label = cls.WidgetFactory.createWidget("Label", this.getBuildParameters());
          label.setValue(choice);
          this.addChildWidget(label, {
            clickCallback: function() {
              this.getParentWidget().setFocus();
            }.bind(this)
          });
        },

        /**
         * Remove all items from dropdown
         * @publicdoc
         */
        clearChoices: function() {
          this.destroyChildren();
        },

        /**
         * Set completer items size
         * @param {number} size - size of the completer
         * @publicdoc
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Return completer items size
         * @returns {number} completer size
         * @publicdoc
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Returns completer current input value
         * @returns {string} completer value
         * @publicdoc
         */
        getValue: function() {
          return this.getParentWidget().getValue();
        },

        /**
         * Set current completer input value
         * @param {string} value - value to set in completer
         * @param {boolean} fromVM - indicates if we set value from VM order or not
         * @publicdoc
         */
        setValue: function(value, fromVM) {
          this.getParentWidget().setValue(value, fromVM);
        },

        /**
         * @inheritDoc
         */
        setEditing: function(b) {
          this.getParentWidget().setEditing(b);
        },

        /**
         * @return {boolean} true if we can trigger the autonext
         */
        canAutoNext: function() {
          // if autonext is enabled, we execute it on dropdown item click
          return this.isUserAction();
        },

        /**
         * @inheritDoc
         */
        hasFocus: function() {
          const parent = this.getParentWidget();
          return parent.hasFocus() || parent.getParentWidget().hasFocus();
        },

        /**
         * Show completer results
         * @publicdoc
         */
        showDropDown: function() {
          this._show(true);
        },

        /**
         * Hide completer results
         * @publicdoc
         */
        hideDropDown: function() {
          this._show(false);
        },

        /**
         * Internal method to show/hide completer results
         * @param visibility
         * @private
         */
        _show: function(visibility) {
          if (this._completerlinked) {
            if (visibility === true) {
              if (!this.hasFocus()) {
                return;
              }
              const element = this.getParentWidget().getElement();
              if (element) {
                this.x = element.getBoundingClientRect().left;
                this.width = element.getBoundingClientRect().width;
              }
              this.show(true); //true to stay open if already open
            } else {
              this.hide();
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Completer', cls.CompleterWidget);
  });
;

"use strict";

modulum('ContextMenuWidget', ['ChoiceDropDownWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ContextMenu DropDown widget.
     * @class ContextMenuWidget
     * @memberOf classes
     * @extends classes.ChoiceDropDownWidget
     */
    cls.ContextMenuWidget = context.oo.Class(cls.ChoiceDropDownWidget, function($super) {
      /** @lends classes.ContextMenuWidget.prototype */
      return {
        __name: "ContextMenuWidget",
        __templateName: "DropDownWidget",

        /** @type {Map<string, classes.MenuLabelWidget|classes.HLineWidget>} */
        _actionWidgets: null,
        /** @type {Map<string, classes.MenuLabelWidget|classes.HLineWidget>} */
        _extraActionWidgets: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._actionWidgets = new Map();
          this._extraActionWidgets = new Map();

          this.allowMultipleChoices(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this.removeAndDestroyActions();
          this._actionWidgets = null;
          this._extraActionWidgets = null;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.elementOrParent("gbc_CheckBoxWidget")) { // if click is not on a checkbox
            this.hide(); // hide context menu
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isVisible()) {
            switch (keyString) {
              case "tab":
              case "shift+tab":
                this.hide();
                break;
              case "space":
                const currentChild = this.getCurrentChildren();
                if (currentChild.getName() === "CheckBoxWidget") {
                  currentChild.manageMouseClick(null);
                } else {
                  this._onClick(null, currentChild);
                }
                keyProcessed = true;
                break;
            }
          }

          if (!keyProcessed) {
            keyProcessed = $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * Remove and destroy all actions widgets
         * @param {boolean} [onlyExtra] - if true remove only extra actions else remove all
         */
        removeAndDestroyActions: function(onlyExtra) {

          // remove extra actions widgets
          this._extraActionWidgets.forEach(function(value, key) {
            this.removeAndDestroyAction(key, true);
          }.bind(this));
          this._extraActionWidgets.clear();

          if (!onlyExtra) {
            // remove other actions widgets
            this._actionWidgets.forEach(function(value, key) {
              this.removeAndDestroyAction(key, false);
            }.bind(this));
            this._actionWidgets.clear();
          }
        },

        /**
         * Remove and destroy one action widget
         * @param {string} actionName - name of the action
         * @param {boolean} extra - is action in the extra actions ?
         */
        removeAndDestroyAction: function(actionName, extra) {
          let widgets = this._actionWidgets;
          if (extra) {
            widgets = this._extraActionWidgets;
          }

          const actionWidget = widgets.get(actionName);
          if (!actionWidget) {
            return;
          }

          if (!actionWidget._destroyed) {
            actionWidget.destroy();
          }
          widgets.delete(actionName);
          this.emit("onActionChange", null);
        },

        /**
         * Add one action in the contextmenu
         * @param {string} actionName - name
         * @param {string} actionText - text
         * @param {string} actionImage - image
         * @param {string} actionAccelerator - accelerator of the action
         * @param {Object} opts - actions options
         * @param {boolean} extra - is it an extra actions ?
         */
        addAction: function(actionName, actionText, actionImage, actionAccelerator, opts, extra) {
          opts = opts || {};

          if (actionText.length === 0) {
            return;
          }

          let widgets = this._actionWidgets;
          if (extra) {
            widgets = this._extraActionWidgets;
            opts.order = 9000; // extra actions must be after all other actions
            if (this._extraActionWidgets.size === 0 && this.hasVisibleAction()) {
              // before the first extra action add a separator
              this.addSeparator(extra, opts);
            }
          }

          let actionWidget = widgets.get(actionName);
          if (!actionWidget) {
            actionWidget = cls.WidgetFactory.createWidget("MenuLabel", this.getBuildParameters());
            actionWidget.getElement().setAttribute("data-aui-name", actionName);
            widgets.set(actionName, actionWidget);
            this.addChildWidget(actionWidget, opts);
          }

          this.updateAction(actionWidget, actionText, actionImage, actionAccelerator, opts);
        },

        /**
         * Update one action in the contextmenu
         * @param {object|string} action
         * @param {string} actionText - text
         * @param {string} actionImage - image
         * @param {string} actionAccelerator - accelerator of the action
         * @param {Object} opts - actions options
         */
        updateAction: function(action, actionText, actionImage, actionAccelerator, opts) {
          let actionWidget = action;
          opts = opts || {};
          if (typeof action === "string") {
            actionWidget = this._actionWidgets.get(action);
          }
          if (actionWidget) {
            actionWidget.setText(actionText);
            if (actionImage) {
              actionWidget.setImage(actionImage);
            }
            if (actionAccelerator && !window.isMobile()) { // don't show accelerator on mobile devices
              if (window.browserInfo.isSafari) {
                actionAccelerator.replace("Control", "⌘")
                  .replace("-", "");
              } else {
                actionAccelerator.replace("-", "+")
                  .replace("Control", "Ctrl");
              }
              actionWidget.setComment(actionAccelerator);
            }
            actionWidget.setEnabled(!opts.disabled);
            actionWidget.setHidden(!!opts.hidden);

            if (opts.order) {
              actionWidget.setStyle({
                "order": opts.order
              });
            }
            this.emit("onActionChange", actionWidget);
          }
        },

        /**
         * @inheritDoc
         */
        hide: function() {
          $super.hide.call(this);

          //restore focus
          const application = context.SessionService.getCurrent().getCurrentApplication();
          if (application) {
            const node = application.getFocusedVMNodeAndValue(true);
            const ctrl = node ? node.getController() : null;
            if (ctrl) {
              ctrl.setFocus();
            }
          }
        },

        /**
         * Returns if there is at least one visible action
         * @returns {boolean} true if there is at least one visible actions
         */
        hasVisibleAction: function() {
          let visible = false;
          for (const element of this.getChildren()) {
            if (element.isVisible()) {
              visible = true;
              break;
            }
          }
          return visible;
        },

        /**
         * Add separator
         * @param {boolean} extra - add it in extra action list
         * @param {Object} opts - separator options
         */
        addSeparator: function(extra = false, opts = {}) {
          let line = cls.WidgetFactory.createWidget("HLine", this.getBuildParameters());
          line.setEnabled(false);
          if (extra) {
            this._extraActionWidgets.set(line.getRootClassName(), line);
          }

          if (opts.order) {
            line.setStyle({
              "order": opts.order
            });
          }

          this.addChildWidget(line);
        },

        /**
         * Return the map of action widgets
         * @return {Map<string, classes.MenuLabelWidget|classes.HLineWidget>} - action widgets
         */
        getActionWidgets: function() {
          return this._actionWidgets;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ContextMenu', cls.ContextMenuWidget);
  });
;

"use strict";

modulum('DropDownWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DropDown widget.
     * @class DropDownWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.DropDownWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.DropDownWidget.prototype */ {
        __name: "DropDownWidget",

        $static: {
          widgetEvents: {
            dropDownBeforeOpen: "dropDownBeforeOpen",
            dropDownOpen: "dropDownOpen",
            dropDownClose: "dropDownClose"
          },
          /**
           * Static list of current dropdowns instances being displayed
           * @type {Array}
           */
          displayedDropDowns: [],
          /**
           * Returns true if at least one dropdown is being displayed
           * @returns {boolean}
           * @publicdoc
           */
          hasAnyVisible: function() {
            return cls.DropDownWidget.displayedDropDowns.length > 0;
          },
          /**
           * Return active dropdowns
           * @returns {classes.DropDownWidget}
           * @publicdoc
           */
          getActiveDropDowns: function() {
            return cls.DropDownWidget.displayedDropDowns;
          },
          /**
           * Hide and remove all active dropdowns from DOM
           * @param {HTMLElement} elementToExclude - exclude dropdowns containing specified element from being hidden
           */
          hideAll: function(elementToExclude) {
            while (cls.DropDownWidget.displayedDropDowns.length) {
              if (!cls.DropDownWidget.displayedDropDowns.last().getElement().contains(elementToExclude)) {
                cls.DropDownWidget.displayedDropDowns.pop().remove();
              } else {
                // all remaining dropdowns are part of elementToExclude
                return;
              }
            }
          },
          /**
           * Returns true if targeted element is contained in one of the current displayed dropdowns
           * @param {HTMLElement} targetElement
           * @returns {boolean}
           * @publicdoc
           */
          isChildOfDropDown: function(targetElement) {
            let inDropDown = false;
            for (const dropdown of cls.DropDownWidget.displayedDropDowns) {
              if (dropdown.getElement().contains(targetElement) || !dropdown.shouldClose(targetElement)) {
                inDropDown = true;
                break;
              }
            }
            return inDropDown;
          },
          /**
           * Returns true if targeted element is contained in one of the current displayed dropdowns or is dropdown associated widget element
           * @param {HTMLElement} targetElement
           * @returns {boolean}
           * @publicdoc
           */
          isChildOrParentOfDropDown: function(targetElement) {
            for (const dropdown of cls.DropDownWidget.displayedDropDowns) {
              const parentWidget = dropdown.getParentWidget();
              const grandParentWidget = parentWidget.getParentWidget();

              if (dropdown.getElement().contains(targetElement) || parentWidget.getElement().contains(targetElement) ||
                (grandParentWidget instanceof cls.ButtonEditWidget && grandParentWidget.getElement().contains(targetElement)) ||
                !dropdown.shouldClose(targetElement)) {
                return true;
              }
            }

            return false;
          }
        },
        /**
         * Flag to indicate if dropdown should size accordingly to its parent element (parent element width aligned) with a maximum allowed height (afterward dropdown is vertically scrollable)
         * By default no.
         * @type {boolean}
         * @publicdoc
         */
        autoSize: false,
        /**
         * Default min width of the dropdown
         * @type {number}
         */
        _defaultMinWidth: 0,
        /**
         * Default max height of the dropdown
         * @type {number}
         */
        _defaultMaxHeight: 0,
        /**
         * Flag to position dropdown using right-to-left basis (ex: arabic).
         * Take note that to have a full right-to-left mode the parent widget need to be set as reversed using setReverse method
         * By default its left-to-right positioned.
         * @type {boolean}
         * @publicdoc
         */
        reverseX: false,
        /**
         * Flag to position dropdown below its corresponding widget or above it.
         * By default, it's positioned below it.
         * @type {boolean}
         * @publicdoc
         */
        reverseY: false,
        /**
         * Private flag set to true if we detected a need to reverse horizontal dropdown position (because of an overflow or if public reverseX attribute is set to true)
         * @type {boolean}
         * @private
         */
        __reverseX: false,
        /**
         * Private flag set to true if we detected a need to reverse vertical dropdown position (because of an overflow or if public reverseY attribute is set to true)
         * @type {boolean}
         * @private
         */
        __reverseY: false,
        /**
         * Horizontal absolute position.
         * It replace default widget relative positioning if not null.
         * @type {?number}
         * @publicdoc
         */
        x: null,
        /**
         * Vertical absolute position of the dropdown.
         * It replaces default widget relative positioning if not null.
         * @type {?number}
         * @publicdoc
         */
        y: null,
        /**
         * Set no height
         */
        _fullHeight: false,
        /**
         * Minimum width of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        minWidth: null,
        /**
         * Maximum width of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        maxWidth: null,
        /**
         * Maximum height of the dropdown to use if not null.
         * @type {?number}
         * @publicdoc
         */
        maxHeight: null,
        /**
         * Parent element to use to measure and position DropDown instead of default one (default one is parent widget element).
         * @type {HTMLElement}
         * @publicdoc
         */
        parentElement: null,
        /**
         * Custom rendering function to use instead of integrated one to measure and render the dropdown.
         * The function is null by default.
         * @type {Function}
         * @publicdoc
         */
        renderFunction: null,
        /**
         * Dropdown open/close bound handlers
         * @function
         */
        _handlers: null,

        /**
         * Dropdown container
         * @type {HTMLElement}
         */
        _container: null,

        /**
         * Flags current class as being a dropdown. Can be useful to know if a parent widget is dropdown
         * @type {boolean}
         * @publicdoc
         */
        isDropDown: true,

        /**
         * True if the dropdown can overlay the widget
         * @type {boolean}
         */
        _widgetOverlay: true,

        /** @type {boolean} */
        _isVisible: false,

        _stylingContext: "widget",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._defaultMinWidth = parseFloat(window.gbc.ThemeService.getValue("gbc-DropDownWidget-min-width"));
          this._defaultMaxHeight = parseFloat(window.gbc.ThemeService.getValue("gbc-DropDownWidget-max-height"));
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._handlers = [];
          this._widgetOverlay = true;

          this._container = window.document.getElementsByClassName("gbc_DropDownContainerWidget")[0];

          // on window close we emit dropdown close event
          this._handlers.push(this.when(context.constants.widgetEvents.close, this.closeRequest.bind(this)));

          // update aria selection on dropdown open/close
          this.onOpen(function() {
            this.setAriaSelection();
          }.bind(this));

          this.onClose(function() {
            this._parentWidget.setAriaSelection();
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.hide();

          if (this._handlers) {
            for (const element of this._handlers) {
              element();
            }
            this._handlers.length = 0;
          }
          this.unbindListeners();

          if (this._parentWidget && this._parentWidget.removeChildWidget) {
            this._parentWidget.removeChildWidget(this);
          }
          this._parentWidget = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.isVisible()) {
            // if dropdown is open, all keys are prevented (no accelerator can be executed during dropdown display)
            switch (keyString) {
              case "enter":
              case "return":
              case "esc":
                this.hide();
                keyProcessed = true;
                break;

            }
          }

          return keyProcessed;
        },

        /**
         * Bind a handler executed when dropdown is displayed
         * @param {Hook} hook the hook to fire
         * @returns {HandleRegistration} return handler to unbind reference
         */
        onOpen: function(hook) {
          this._handlers.push(this.when(cls.DropDownWidget.widgetEvents.dropDownOpen, hook));
          return this._handlers[this._handlers.length - 1];
        },

        /**
         * Bind a handler executed before dropdown is displayed
         * @param {Hook} hook the hook to fire
         * @returns {HandleRegistration} return handler to unbind reference
         */
        onBeforeOpen: function(hook) {
          this._handlers.push(this.when(cls.DropDownWidget.widgetEvents.dropDownBeforeOpen, hook));
          return this._handlers[this._handlers.length - 1];
        },

        /**
         * Bind a handler executed when dropdown is closed
         * @param {Hook} hook the hook to fire
         * @returns {HandleRegistration} return handler to unbind reference
         */
        onClose: function(hook) {
          this._handlers.push(this.when(cls.DropDownWidget.widgetEvents.dropDownClose, hook));
          return this._handlers[this._handlers.length - 1];
        },

        beforeOpenRequest: function() {
          this.emit(cls.DropDownWidget.widgetEvents.dropDownBeforeOpen);
        },

        openRequest: function() {
          this.emit(cls.DropDownWidget.widgetEvents.dropDownOpen);
        },

        closeRequest: function() {
          this.emit(cls.DropDownWidget.widgetEvents.dropDownClose);
        },

        /**
         * Let dropdown hide on click (if outside of dropdown and widget), scroll events or dragAndDrop events.
         * Setting this method to null will cancel auto hide of the dropdown
         * @publicdoc
         */
        bindListeners: function() {

          if (this._hideHandler) {
            this._hideHandler(); // removeEventListener
            this._hideHandler = null;
          }
          if (!window.isMobile()) {
            this._hideHandler = context.HostService.onScreenResize(this.hide.bind(this));
          } else {
            this._hideHandler = context.HostService.onOrientationChange(this.hide.bind(this));
          }
        },

        /**
         * Unbind events and listeneners used to auto hide dropdown
         * @publicdoc
         */
        unbindListeners: function() {
          if (this._hideHandler && !cls.DropDownWidget.hasAnyVisible()) {
            this._hideHandler(); // removeEventListener
            this._hideHandler = null;
          }
        },

        /**
         * Hide all displayed dropdowns
         * @publicdoc
         */
        hide: function() {
          cls.DropDownWidget.hideAll();
        },

        /**
         * Remove current dropdown from DOM. Use hide method to close dropdown instead as much as possible
         */
        remove: function() {
          // first thing to do is update active dropdowns list which is checked and used in following methods
          cls.DropDownWidget.displayedDropDowns.remove(this);
          this._setVisible(false);

          // unbind handlers & remove overlay when no more dropdowns are visible
          if (!cls.DropDownWidget.hasAnyVisible()) {
            context.OverlayService.disable("dropdown");
            this.unbindListeners();
          }

          this.removeDropDown();
          this.closeRequest();

          // update widget with current dropdown being activated
          const activeDropDown = cls.DropDownWidget.getActiveDropDowns().last();
          const session = context.SessionService.getCurrent();
          if (session) {
            const app = session.getCurrentApplication();
            if (app) {
              app.focus.setActiveDropDownWidget(activeDropDown ? activeDropDown.getParentWidget() : null);
            }
          }
          this.getParentWidget().emit(context.constants.widgetEvents.close);
        },

        /**
         * Show the widget dropdown
         * @param {boolean} [multiple] - if true we do not hide previous displayed dropdowns (ex: sub menus).
         * @publicdoc
         */
        show: function(multiple = false) {
          if (!this.isVisible()) {
            if (!multiple) {
              this.hide();
            }
            // set visible (remove parent class hidden) before dropdown measuring
            this._setVisible(true);

            // bind handlers & add overlay on first dropdown display
            if (!cls.DropDownWidget.hasAnyVisible()) {
              const currentWindow = context.HostService.getCurrentWindowWidget();
              const windowContainer = currentWindow ? currentWindow.getWindowMiddleContainer() : null;
              context.OverlayService.enable("dropdown", windowContainer);
              this.bindListeners();
            }
            // dropdown rendering (measure & positioning method)
            this.beforeOpenRequest();
            this.addDropDown();
            this.openRequest();

            cls.DropDownWidget.displayedDropDowns.push(this);

            // update widget with current dropdown being activated
            const session = context.SessionService.getCurrent();
            if (session) {
              const app = session.getCurrentApplication();
              if (app) {
                app.focus.setActiveDropDownWidget(this.getParentWidget());
              }
            }
          }
        },

        /**
         * Toggle dropdown display
         * @param {boolean} show - force display if set to true, hide if set to false
         * @returns {boolean} returns dropdown visibility
         * @publicdoc
         */
        toggle: function(show) {
          if (this.isVisible() || show === false) {
            this.hide();
          } else if (!this.isVisible() || show === true) {
            this.show();
          }
        },

        /**
         * Check & update main dropdown container visibility on dropdown display/hide
         * @param {boolean} visible - wanted visibility
         * @private
         */
        _setVisible: function(visible) {
          if (this._container) {
            if (visible) {
              if (this._container.hasClass("hidden")) {
                this._container.removeClass("hidden");
              }
            } else {
              // only hide dropdowns container is we removed last dropdown child from it
              if (!cls.DropDownWidget.hasAnyVisible() && !this._container.hasClass("hidden")) {
                this._container.addClass("hidden");
              }
            }
          }
          this._isVisible = visible;
          // flag widget as expanded for aria attribute
          this.getParentWidget().setAriaAttribute("expanded", visible.toString());
          // emit a visibility change notification on the dropdown
          this.emit(context.constants.widgetEvents.visibilityChange, visible);
          gbc.LogService.ui.log("DropDown open", visible, this.__name, this);
        },

        /**
         * Indicate if dropdown is currently visible or not
         * @returns {boolean} true if dropdown is currently visible
         * @publicdoc
         */
        isVisible: function() {
          return this._isVisible;
        },

        /**
         * Explicitly focus dropdown element
         * @publicdoc
         */
        focus: function() {
          this._element.focus();
        },

        /**
         * Set content of the dropdown
         * @param {HTMLElement} content - element to add in the dropdown
         * @param {WidgetBase} parentWidget - if defined, set the widget as parent widget of the dropdown (optional)
         * @publicdoc
         */
        setContent: function(content, parentWidget) {
          this.getElement().appendChild(content);
          if (parentWidget) {
            this.setParentWidget(parentWidget);
          }
        },

        /**
         * Override this method if you want a custom check during dropdown hiding.
         * This method is executed when you click on corresponding dropdown widget (usually parent widget of dropdown) and determines if it should close dropdown in that case.
         * By default, it's set to yes.
         * @param {HTMLElement} targetElement - source element which raise blur event
         * @returns {boolean} if false we cancel dropdown closing
         */
        shouldClose: function(targetElement) {
          return true;
        },

        /**
         * Remove the content of the dropdown
         * @param {HTMLElement} content - element to remove from the dropdown
         * @publicdoc
         */
        removeContent: function(content) {
          this.getElement().removeChild(content);
        },

        /**
         * Enable or disable/hide the dropdown.
         * @param {boolean} enabled - true if dropdown is active
         * @publicdoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this.hide();
        },

        /**
         * Force the dropdown to take full height
         */
        setFullHeight: function() {
          this._fullHeight = true;
        },

        /**
         * Remove the dropdown from the DOM
         * @publicdoc
         */
        removeDropDown: function() {
          this.getElement().remove();
          this._container.removeClass("dd_" + this.getParentWidget().getName());
        },

        /**
         * Add dropdown in DOM and set its position & size
         * @publicdoc
         */
        addDropDown: function() {
          this._container.addClass("dd_" + this.getParentWidget().getName());
          // we insert dropdown in DOM before measuring it to be able to get its generated height
          this._container.appendChild(this.getElement());

          // measure and render dropdown
          // if  custom rendering function is defined we use it else use default one
          if (this.renderFunction && typeof this.renderFunction === "function") {
            this.renderFunction();
          } else {
            this.renderDropDown();
          }
        },

        /**
         * Render the dropdown. Measure its width, height and calculate its top and left position and sets them.
         * By default, dropdown will :
         *  - take width of its corresponding widget.
         *  - be positioned right under the corresponding widget and left aligned with it.
         * @publicdoc
         */
        renderDropDown: function() {
          // 0 - Initialization
          // need parent widget size + sidebar size in our measure process
          const parentSize = (this.parentElement ? this.parentElement : this.getParentWidget().getElement()).getBoundingClientRect();
          const sidebarWidth = context.HostLeftSidebarService.getSidebarWidth();

          const ddSize = {};
          // Flags used to reverse dropdown position if case of overflow measurements.
          // These flags can be updated in next methods.
          this.__reverseX = false;
          this.__reverseY = false;

          // 1 - Min & max width calculation
          const ddWidth = this._widthMeasure(parentSize, sidebarWidth);
          // typeof is string if value is "unset"
          ddSize["min-width"] = ddSize["max-width"] = this._getSizeUnit(ddWidth);

          // 2 - Horizontal positioning
          const x = this._horizontalMeasure(ddWidth, parentSize, sidebarWidth);
          ddSize[this.__reverseX ? "right" : "left"] = this._getSizeUnit(x);
          ddSize[this.__reverseX ? "left" : "right"] = "unset"; // reset other flag which could have been used before

          // 3 - Vertical positioning
          const y = this._verticalMeasure(parentSize);
          ddSize[this.__reverseY ? "bottom" : "top"] = this._getSizeUnit(y);
          ddSize[this.__reverseY ? "top" : "bottom"] = this._fullHeight ? 0 :
            "unset"; // reset other flag which could have been used before

          // 4 - Max height calculation
          const ddHeight = this._maxHeightMeasure(y);
          ddSize["max-height"] = this._fullHeight ? "inherit" : this._getSizeUnit(ddHeight);

          this.setStyle(ddSize);

          this.__reverseX = false;
          this.__reverseY = false;
        },

        /**
         * Return value with its corresponding unit
         * @param value
         * @returns {string} value
         * @private
         */
        _getSizeUnit: function(value) {
          if (value === "unset") {
            return null;
          }
          return typeof value === "string" ? value : (value + "px");
        },

        /**
         * We calculate horizontal position (by default using left attribute) of the dropdown depending on its width and client width
         * @param {number} dropDownWidth - dropDown calculated width
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {number} left (or right if reversed) position in pixels
         * @private
         */
        _horizontalMeasure: function(dropDownWidth, parentSize, sidebarWidth) {
          let x = 0;

          if (this.getParentWidget().isReversed()) {
            this.addClass("reverse");
          }

          this.__reverseX = this.reverseX || this.getParentWidget().isReversed();
          // if dropDownWidth is "unset" we take scrollWidth
          const ddWidth = dropDownWidth === "unset" ? this._element.scrollWidth : dropDownWidth;

          // 1. Get X positioning depending on provided attributes
          if (this.x) { // widget knows left location to use
            // CENTER means middle of the current window
            x = (this.x === "CENTER" ? (window.innerWidth - ddWidth + sidebarWidth) / 2 : this.x);
          } else if (!this.__reverseX) {
            x = Math.max(0, (parentSize.left + document.body.scrollLeft), sidebarWidth);
          }

          // 2. Adjust X positioning if horizontally overflowed
          // 2.1 dropdown is going to be overflowed by screen size limit, we flag it as reverse to inverse positioning
          if (!this.__reverseX && (x + ddWidth > document.body.clientWidth)) {
            this.__reverseX = true;
          }

          // 2.2 substract provided X or parentElement right position to clientWidth
          if (this.__reverseX) {
            if (this.x) {
              // if dropdown width can be fully visible on screen we position dropdown to the left of the filled x coordinate.
              // Otherwise, if dropdown width is higher and is going to be overflowed, we position it at the maximum right position of the screen.
              //x = x > ddWidth ? Math.max(0, document.body.clientWidth - x) : 0;
              x = x > ddWidth ? Math.max(0, document.body.clientWidth - x + parentSize.width) : 0;
              // screen too small for a reversed display as well: dropdown aligned with screen left limit
              if ((x + ddWidth) > document.body.clientWidth) {
                this.__reverseX = false;
                x = 0;
              }
            } else {
              x = Math.max(0, (document.body.clientWidth - document.body.scrollLeft - parentSize.right));
            }
          }

          return x;
        },

        /**
         * Calculate the top position of the dropdown depending on the display mode
         * @param {ClientRect} parentSize - corresponding widget size
         * @returns {number} top (or bottom if reversed) position in pixels
         * @private
         */
        _verticalMeasure: function(parentSize) {
          if (this._widgetOverlay) {
            return this._verticalMeasureCombo(parentSize);
          }

          return this._verticalMeasureCompleter(parentSize);
        },

        /**
         * Completer : the widget must stay visible so the dropdown must below or above the input widget
         * @param {ClientRect} parentSize - corresponding widget size
         * @returns {number} top (or bottom if reversed) position in pixels
         * @private
         */
        _verticalMeasureCompleter: function(parentSize) {
          const bottomAbsPos = Math.max(0, parentSize.bottom + window.scrollY);
          const centralContainerRect = document.getElementsByClassName("mt-centralcontainer")[0].getBoundingClientRect();
          // Taking care of container position (case of customization sample demo)
          const formHeight = centralContainerRect.height + centralContainerRect.top + (document.body.getBoundingClientRect().height -
            centralContainerRect.bottom);

          //Below space > Above space
          if (formHeight - bottomAbsPos > parentSize.top) {
            //Put the dropdown below the input widget
            return parentSize.bottom + window.scrollY;
          } else {
            //Put the dropdown above the input widget
            //var dropDownheight = this.maxHeight ? this.maxHeight : this._defaultMaxHeight;
            this.__reverseY = true;
            return formHeight - parentSize.top - window.scrollY + 1;
          }
        },

        /**
         * We calculate vertical position (by default using top attribute) of the dropdown depending on its height and client height
         * @param {ClientRect} parentSize - corresponding widget size
         * @returns {number} top (or bottom if reversed) position in pixels
         * @private
         */
        _verticalMeasureCombo: function(parentSize) {
          let y = 0;
          this.__reverseY = this.reverseY;
          // 1. Get Y positioning depending on provided attributes
          if (this.y) { // widget knowns top location to use
            // CENTER means middle of the current window
            y = (this.y === "CENTER" ? (window.innerHeight - this._element.scrollHeight) / 2 : this.y);
          } else {
            // Try to position dropdown right under widget if enough space available otherwise position dropdown below it
            y = Math.max(0, (parentSize.bottom + document.body.scrollTop));
          }

          // 2. Adjust dropdown Y positioning by comparing dropdown height with remaining viewport height
          const height = this.maxHeight ? this.maxHeight : Math.min(this._element.scrollHeight, this._defaultMaxHeight);
          // screen size limit : we need to adjust vertical position
          if (y + height > document.body.clientHeight) { // unsufficiant size below widget, check to position dropdown above it
            // try to position dropdown using above widget
            // 2px for box-shadow
            y = Math.max(0, document.body.clientHeight - (this.y ? this.y : parentSize.top) - document.body.scrollTop + 2);
            // if no space available either to position dropdown above widget, we place it at the top of the screen
            if (y + height > document.body.clientHeight) { // place dropdown at top of the screen
              y = 2;
            } else { // place above widget (usage of bottom attribute)
              this.__reverseY = true;
            }
          }
          return y;
        },

        /**
         * We calculate width of the dropdown. We take in consideration sidebar and menu panel which can overflow widget content (scrollbars may then appear)
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {string|number} width to use as a number or "unset" string if no width is required
         * @private
         */
        _widthMeasure: function(parentSize, sidebarWidth) {
          let w = 0;
          if (this.minWidth) {
            w = this.minWidth;
          } else if (this.autoSize) {
            // Take larger width between parent widget, dropdown content and default min width.
            // Check if visible area is smaller that this width (dropdown or parent widget overflowed by horizontal scrollbars) and take visible area as width if it's the case
            w = Math.min(Math.max(parentSize.width, (this.width ? this.width : 0), this._defaultMinWidth), this
              ._visibleAreaWidthMeasure(
                parentSize, sidebarWidth));
          } else if (this.maxWidth) {
            w = this.maxWidth;
          } else {
            // if element is larger than available screen width we limit dropdown width to screen width
            if (this._element.scrollWidth > document.body.clientWidth - 2) {
              w = document.body.clientWidth - 2;
            } else {
              w = "unset";
            }
          }
          return w;
        },

        /**
         * Calculate width of the middle visible area (we subtract menu panel and sidebar from clientWidth)
         * @param {ClientRect} parentSize - corresponding widget size
         * @param {number} sidebarWidth - sidebar width
         * @returns {number} returns width of the middle visible area (we subtract menu panel and sidebar from clientWidth)
         * @private
         */
        _visibleAreaWidthMeasure: function(parentSize, sidebarWidth) {
          let w = document.body.clientWidth;
          if (this.autoSize) {
            // horizontal scrollbars & overflow issue with right action panel in case of too large dropdown widget
            // we need to subtract the overflowed width of the dropdown
            // possible overflow are sidebar & right menu panel
            const currentWindow = this.getWindowWidget();
            if (currentWindow) {
              const menuRightWidth = currentWindow.getWindowMenuContainerRight().getBoundingClientRect();
              if ((menuRightWidth.width > 0 || sidebarWidth > 0) && parentSize.width > 0) {
                w = menuRightWidth.left - Math.max(0, parentSize.left, sidebarWidth);
              }
            }
          }
          return w;
        },

        /**
         * The dropdown can overlay the widget
         * @param {boolean} canOverlay true : the dropdown can overlay the widget
         */
        setCanOverlay: function(canOverlay) {
          this._widgetOverlay = canOverlay;
        },

        /**
         * Calculate the max height depending on the display mode
         * @param {number} ddVerticalPosition - vertical (y) position of the dropdown. Basically top position.
         * @returns {number} max height to use in pixels
         * @private
         */
        _maxHeightMeasure: function(ddVerticalPosition) {
          if (this._widgetOverlay) {
            return this._maxHeightMeasureCombo(ddVerticalPosition);
          }

          return this._maxHeightMeasureCompleter(ddVerticalPosition);
        },

        /**
         * Completer : The dropdown must not overlay the input widget
         * @param {number} ddVerticalPosition - vertical (y) position of the dropdown. Basically top position.
         * @returns {number} max height to use in pixels
         * @private
         */
        _maxHeightMeasureCompleter: function(ddVerticalPosition) {
          const parentElement = this.parentElement ? this.parentElement : this.getParentWidget().getElement();
          const parentSize = parentElement.getBoundingClientRect();
          const belowWidget = Math.max(0, (parentSize.bottom + window.scrollY));
          const formHeight = document.getElementsByClassName("mt-centralcontainer")[0].getBoundingClientRect().height;

          let h = 0;
          if (this.maxHeight) {
            h = this.maxHeight;
          } else if (this.autoSize) {
            h = this._defaultMaxHeight;
          } else { // by default fit content height
            h = this._element.scrollHeight + 3; // 3 for border
          }

          //Below space > Above space
          if (formHeight - belowWidget > belowWidget - parentSize.height) {
            return Math.min(document.body.clientHeight - ddVerticalPosition, h) - 3; // 3 To not touch the browser border
          } else {
            return Math.min(parentSize.top - 3, h);
          }
        },

        /**
         * We calculate max height of the dropdown. Then vertical scrollbars will be added in dropdown.
         * @param {number} ddVerticalPosition - vertical (y) position of the dropdown. Basically top position.
         * @returns {number} max height to use in pixels
         * @private
         */
        _maxHeightMeasureCombo: function(ddVerticalPosition) {
          let h = 0;
          if (this.maxHeight) {
            h = this.maxHeight;
          } else if (this.autoSize) {
            h = this._defaultMaxHeight;
          } else { // by default fit content height
            h = this._element.scrollHeight + 3; // 3 for border
          }
          // case when screen height is smaller that dropdown height
          if (Math.min(h, this._defaultMaxHeight) > document.body.clientHeight) { // dropdown take whole screen height
            h = document.body.clientHeight - 5;
          } else if ((h + ddVerticalPosition) > document.body.clientHeight) {
            // case when dropdown has big height and is being overflowed by screen
            h = document.body.clientHeight - ddVerticalPosition - 5;
          }
          return h;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DropDown', cls.DropDownWidget);
  });
;

"use strict";

modulum('FolderWidget', ['FolderWidgetBase'],
  function(context, cls) {

    /**
     * Folder widget.
     * @class FolderWidget
     * @memberOf classes
     * @extends classes.FolderWidgetBase
     * @publicdoc Widgets
     */
    cls.FolderWidget = context.oo.Class(cls.FolderWidgetBase, function($super) {
      return /** @lends classes.FolderWidget.prototype */ {
        __name: "FolderWidget",

        /** @type {Element} */
        _tabsTitlesHostElement: null,
        /** @type {Element} */
        _tabsTitlesElement: null,
        /** @type {Element} */
        _tabsItemsContainer: null,
        /** @type {String} */
        _tabsPosition: "top",
        /** @type {classes.ScrollTabDecorator} */
        _scroller: null,
        /** @type {classes.GestureService} */
        _gesture: null,
        /** @type {Element} */
        _tabIndicator: null,
        /** @type {Function} */
        _swipeEndHandler: null,
        /** @type {Number} */
        _lastPos: 0,
        /** @type {?Boolean} */
        _noSwipe: null,
        /** @type {Boolean} */
        _navigationArrows: false,
        /** @type {Boolean} */
        _navigationDots: false,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.FolderLayoutInformation(this);
          this._layoutEngine = new cls.FolderLayoutEngine(this);

          $super._initLayout.call(this);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._tabsTitlesHostElement = this._element.getElementsByClassName("mt-tab-titles")[0];
          this._tabsTitlesElement = this._element.getElementsByClassName("mt-tab-titles-container")[0];
          this._tabsItemsContainer = this._element.getElementsByClassName("mt-tab-items-container")[0];
          this._tabIndicator = this._element.getElementsByClassName("tab-current-indicator")[0];

          this._scroller = new cls.ScrollTabDecorator(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._noSwipe = null;
          if (this._swipeEndHandler) {
            this._swipeEndHandler();
            this._swipeEndHandler = null;
          }
          if (this._onParentActivationHandler) {
            this._onParentActivationHandler();
            this._onParentActivationHandler = null;
          }
          if (this._gesture) {
            this._gesture.destroy();
            this._gesture = null;
          }

          if (this._scroller) {
            this._scroller.destroy();
            this._scroller = null;
          }
          if (this._tabsTitlesHostElement) {
            this._tabsTitlesHostElement = null;
          }
          if (this._tabsTitlesElement) {
            this._tabsTitlesElement = null;
          }
          if (this._tabIndicator) {
            this._tabIndicator = null;
          }
          this._lastPos = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          /** @type classes.PageWidget */
          const pageWidget = widget;

          const titleWidget = pageWidget.getTitleWidget();
          this._tabsTitlesElement.appendChild(titleWidget.getElement());

          $super.addChildWidget.call(this, pageWidget, options);
        },

        /**
         * @inheritDoc
         */
        _afterLayout: function() {
          $super._afterLayout.call(this);
          // update page title underline indicator
          this._updateCurrentTabIndicator(this.getCurrentPage().getTitleWidget());
          if (this._gesture) {
            // scroll to corresponding page without any delay
            this._gesture.swipeTo(this.getCurrentPage(), {
              smoothEffect: false,
              noDelay: true
            });
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          const oldPage = this.getCurrentPage();
          $super.removeChildWidget.call(this, widget);
          // Update indicator when current page doesn't change or when there is no more page.
          // In all cases indicator has already been updated during new page being set
          if (!this._children.length) { // no more page and indicator to display
            this._updateCurrentTabIndicator(null);
          } else if (this.getCurrentPage() === oldPage) { // current page didn't change but its position did so does the indicator
            this._updateCurrentTabIndicator(this.getCurrentPage().getTitleWidget());
          }
        },

        /**
         * @inheritDoc
         */
        setCurrentPage: function(page, executeAction, fromUserAction = false) {
          const modified = $super.setCurrentPage.call(this, page, executeAction, fromUserAction);
          if (modified) {
            this.scrollTo(this._currentPage);

            this._lastIndex = page.getPageIndex();
            // update page title underline indicator
            this._updateCurrentTabIndicator(page.getTitleWidget());

            if (this._gesture) {
              // scroll to corresponding page
              this._gesture.swipeTo(page, {
                smoothEffect: false
              });
            }
          }

          return modified;
        },

        /**
         * Gets the tabs titles host element
         * @returns {Element} the element
         */
        getTabsTitlesHostElement: function() {
          return this._tabsTitlesHostElement;
        },

        /**
         * Get tabs position
         * @return {string} tabs pos: top, right, bottom, left
         * @publicdoc
         */
        getTabsPosition: function() {
          return this._tabsPosition;
        },

        /**
         * Gets the tab scroller
         * @returns {classes.ScrollTabDecorator} the element
         */
        getScroller: function() {
          return this._scroller;
        },

        /**
         * Set the tabs position
         * @param {string} position - could be top, right, bottom or left
         * @publicdoc
         */
        setTabPosition: function(position) {
          if (["top", "bottom", "left", "right"].indexOf(position) < 0) {
            position = "top";
          }
          this._element.setAttribute("__FolderWidget", position);
          this._scroller.updatePosition("__FolderWidget", position);

          this._tabsPosition = position;
        },

        /**
         * Go to the given page
         * @param {classes.PageWidget} page - page to navigate to
         * @publicdoc
         */
        scrollTo: function(page) {
          const title = page && page.getTitleWidget();
          if (title) {
            this._scroller.scrollTo(title.getElement());
          }
          this._scroller.refreshScrollers();
        },

        /**
         * Update visibility of scrollers
         */
        updateScrollersVisibility: function() {
          const isVertical = ["left", "right"].indexOf(this._tabsPosition) >= 0;
          const isHorizontal = ["top", "bottom"].indexOf(this._tabsPosition) >= 0;
          const sizeAttr = isVertical ? "height" : isHorizontal ? "width" : false;
          const info = this.getLayoutInformation();

          if (sizeAttr && this._scroller) {
            // Check if there is space enough to display the full bar or need scrolling
            const tabsTitlesSize = this.getChildren().map(function(item) {
              return item.isHidden() ? 0 :
                item.getLayoutInformation()[isHorizontal ? "getTitleMeasureWidth" : "getTitleMeasureHeight"]();
            }).reduce(function(next, prev) {
              return next + prev;
            }, 0);
            const tabsTitlesHostSize = this._getAllocatedSize(isHorizontal) -
              info[isHorizontal ? "getTitlesContainerDeltaWidth" : "getTitlesContainerDeltaHeight"]();

            if (tabsTitlesHostSize <= tabsTitlesSize) {
              this._scroller.showScroller(true);
            } else {
              this._scroller.showScroller(false);
            }
          }
        },

        /**
         * get the corrent allocated size
         * @param isHorizontal is horizontal
         * @returns {number}
         * @protected
         */
        _getAllocatedSize: function(isHorizontal) {
          const info = this.getLayoutInformation();
          return info.getAllocated()[isHorizontal ? "getWidth" : "getHeight"]();
        },

        /**
         * Update current page title underline indicator
         * @param pageTitle
         * @param distance
         * @param index
         * @private
         */
        _updateCurrentTabIndicator: function(pageTitle, distance, index) {
          if (this._tabIndicator) {
            this.afterDomMutator(function(pageTitle, distance, index) {
              if (this._tabIndicator) {
                if ((!pageTitle && distance === undefined) || !this.getVisibleChildren().length || !this.getCurrentPage()) {
                  this._tabIndicator.style.setProperty("--height", 'auto');
                  this._tabIndicator.style.setProperty("--width", 'auto');
                } else {
                  let scrollRatio = distance / this.getContainerElement().offsetWidth;
                  if (this.isReversed()) { // manage RTL mode
                    scrollRatio *= -1;
                  }
                  let nextTitleToFocus = null;
                  let startingPos = null;
                  let nextPos = null;

                  const nextPageTryingToFocus = this.getVisibleChildren()[this.getCurrentPage().getPageIndex() + index];
                  if (nextPageTryingToFocus) {
                    nextTitleToFocus = nextPageTryingToFocus.getTitleWidget();
                  }

                  if (this.getTabsPosition() === "left" || this.getTabsPosition() === "right") {
                    if (pageTitle) { // update indicator position according to new focused page title
                      this._tabIndicator.style.setProperty("--top", pageTitle.getElement().offsetTop + 'px');
                      this._tabIndicator.style.setProperty("--height", pageTitle.getElement().offsetHeight + 'px');
                      this._tabIndicator.style.setProperty("--left", 'auto');
                      this._tabIndicator.style.setProperty("--width", '2px');
                    } else { // update indicator position depending of scroll ratio (updated during scroll)
                      if (nextTitleToFocus) {
                        startingPos = this.getCurrentPage().getTitleWidget().getElement().offsetTop;
                        nextPos = Math.round(startingPos + (scrollRatio * Math.abs(startingPos - nextTitleToFocus.getElement()
                          .offsetTop)));
                        if (this._lastPos !== nextPos) {
                          this._tabIndicator.style.setProperty("--top", nextPos + 'px');
                          this._lastPos = nextPos;
                        }
                      }
                    }
                  } else {
                    if (pageTitle) { // update indicator position according to new focused page title
                      this._tabIndicator.style.setProperty("--top", 'auto');
                      this._tabIndicator.style.setProperty("--height", '2px');
                      this._tabIndicator.style.setProperty("--width", pageTitle.getElement().offsetWidth + 'px');
                      this._tabIndicator.style.setProperty("--left", pageTitle.getElement().offsetLeft + 'px');
                    } else { // update indicator position depending of scroll ratio (updated during scroll)
                      if (nextTitleToFocus) {
                        startingPos = this.getCurrentPage().getTitleWidget().getElement().offsetLeft;
                        nextPos = Math.round(startingPos + (scrollRatio * Math.abs(startingPos - nextTitleToFocus.getElement()
                          .offsetLeft)));
                        if (this._lastPos !== nextPos) {
                          this._tabIndicator.style.setProperty("--left", nextPos + 'px');
                          this._lastPos = nextPos;
                        }
                      }
                    }
                  }
                }
              }
            }.bind(this, pageTitle, distance, index));
          }
        },

        // SWIPE

        /**
         * Set NoSwipe attribute value and enable/disable swipe gestures
         * @param noSwipe
         */
        setNoSwipe: function(noSwipe) {
          if (this._noSwipe !== noSwipe) {
            this._noSwipe = noSwipe;
            const canSwipe = this.isSwipeable();
            if (this._gesture && !canSwipe) {
              this._gesture.removeTouch();
            } else {
              this.enableSwipe();
            }
          }
        },

        /**
         * Enable/disable navigation Arrows 4ST attribute
         * @param active
         */
        setNavigationArrows: function(active) {
          this._navigationArrows = active;
          if (this._gesture) {
            if (active) {
              this._gesture.addArrows();
            } else {
              this._gesture.removeArrows();
            }
          }
        },

        /**
         * Enable/disable navigation dots 4ST attribute
         * @param active
         */
        setNavigationDots: function(active) {
          this._navigationDots = active;
          if (this._gesture) {
            if (active) {
              this._gesture.addDots();
            } else {
              this._gesture.removeDots();
            }
          }
        },

        /**
         * Determine if swipe gestures are supported on current device
         * @returns {*}
         */
        isSwipeable: function() {
          return window.isTouchDevice() && !this._noSwipe;
        },

        /**
         * Enable swipe functionality on folder pages
         */
        enableSwipe: function() {
          if (!this._gesture) {
            this._parentPage = this.getParentPage();
            if (this._parentPage) {
              this._onParentActivationHandler = this._parentPage.onActivate(this._initSwipe.bind(this));
            } else {
              this._initSwipe();
            }

            this._swipeEndHandler = this.when(context.constants.widgetEvents.swipeEnd, function(event, domEvent, index) {
              if (this._lastIndex !== index) {
                const newPage = this.getVisibleChildren()[index];
                newPage.emit(context.constants.widgetEvents.click, event);

                this.onTitleClick(newPage);

              }
            }.bind(this));
          } else {
            this._gesture.addTouch();
          }
        },

        /**
         * Disable swipe functionality on folder pages
         */
        disableSwipe: function() {
          if (this._gesture) {
            this._gesture.removeTouch();
          }
        },

        /**
         * Create a new swipe instance using GestureService
         * @private
         */
        _initSwipe: function() {
          if (this._onParentActivationHandler) {
            this._onParentActivationHandler();
            this._onParentActivationHandler = null;
          }
          const params = {
            noSwipe: !this.isSwipeable(),
            arrows: this._navigationArrows,
            dots: this._navigationDots,
            virtualDom: true,
            moveCallback: this._updateCurrentTabIndicator
          };
          this._gesture = new cls.GestureService(this, params);
        },

        /**
         * Set rendering mode.
         * By default, we load and measure all folder pages.
         * If lateRendering is true then we only load and measure current page.
         * @param lateRendering
         */
        setLateRendering: function(lateRendering) {
          this._isLateRendering = lateRendering;
          if (this._isLateRendering) {
            this.isMinified = true;
          }
        },

        /**
         * Get the widget gesture service
         * @return {classes.GestureService}
         */
        getGestureService: function() {
          return this._gesture;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Folder', cls.FolderWidget);
  });
;

"use strict";

modulum('FolderWidgetBase', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Folder widget base class.
     * @class FolderWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.FolderWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.FolderWidgetBase.prototype */ {
        __name: "FolderWidgetBase",

        /** @type {boolean} */
        __virtual: true,

        /** @type {String} */
        __dataContentPlaceholderSelector: ".containerElement",

        /**
         * @type {classes.PageWidget}
         */
        _currentPage: null,
        /**
         * @type {Function}
         */
        _onLayoutUnbindHandler: null,
        /**
         * is true if folder only contains current page in DOM
         * @type {boolean}
         */
        isMinified: false,
        /**
         * @type {Boolean}
         */
        _isLateRendering: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this.isMinified && this._layoutEngine) {
            this._onLayoutUnbindHandler = this._layoutEngine.onLayoutApplied(this._afterLayout.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._onLayoutUnbindHandler) {
            this._onLayoutUnbindHandler();
            this._onLayoutUnbindHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         *  @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (!widget.isInstanceOf(cls.PageWidget)) {
            throw new Error("Only PageWidgets can be added in FolderWidgetBase");
          }
          options = options || {};
          options.noDOMInsert = options.noDOMInsert || this.isMinified;
          $super.addChildWidget.call(this, widget, options);
          /** @type classes.PageWidget */
          const pageWidget = widget;
          if (this.isMinified) {
            this.getContainerElement().appendChild(pageWidget.getReplacer());
          }

          if (this._children.length === 1) {
            // First page to be added, set it as current, false to prevent action on initial rendering
            this.setCurrentPage(pageWidget, false);
          }
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          /** @type classes.PageWidget */
          const pageWidget = widget;

          let nextCurrentIndex = -1;

          if (pageWidget === this.getCurrentPage()) {
            this._currentPage = null;
            nextCurrentIndex = this._children.indexOf(pageWidget);
            if (nextCurrentIndex >= this._children.length - 1) {
              nextCurrentIndex = this._children.length - 2;
            }
          }
          if (pageWidget.getTitleWidget()) {
            pageWidget.getTitleWidget().getElement().remove();
          }

          pageWidget.getElement().remove();

          $super.removeChildWidget.call(this, pageWidget);

          if (this._children.length && nextCurrentIndex !== -1) {
            this.setCurrentPage(this._children[nextCurrentIndex], false);
          }
        },

        /**
         * Insert all folder pages in DOM
         */
        addPagesInDom: function() {
          if (!this._isLateRendering) {
            for (const page of this.getChildren()) {
              if (page !== this.getCurrentPage() && !page.hasChildWebComponent()) {
                page.addInDom();
              }
            }
            this.isMinified = false;
          }
        },

        _afterLayout: function() {
          // todo replace 3s timer with hook which listen to all Image currently being loading and remove pages from dom once all child images are loaded
          this._registerTimeout(this.removePagesFromDom.bind(this), 2000);
        },

        removePagesFromDom: function() {
          if (!this._isLateRendering) {
            if (!this.isMinified) {
              for (const page of this.getChildren()) {
                if (page !== this.getCurrentPage() && !page.hasChildWebComponent()) {
                  page.removeFromDom();
                }
              }
            }
            this.isMinified = true;
          }
        },

        /**
         *  Click on title handler.
         *  @param {classes.PageWidget} page - page corresponding to the title
         */
        onTitleClick: function(page) {
          // False parameter to prevent action (will be triggered on page click)
          if (this.setCurrentPage(page, false, true)) {
            this.emit(context.constants.widgetEvents.requestFocus);
          }
        },

        /**
         * Get the current page
         * @returns {classes.PageWidget} the current page
         * @publicdoc
         */
        getCurrentPage: function() {
          return this._currentPage;
        },

        /**
         * Defines the current displayed page
         * @param {classes.PageWidget} page - the new current page
         * @param {boolean} [executeAction] - execute action of page
         * @param {boolean} [fromUserAction] - true if page change comes from a user action (mouse click for ex)
         * @return {boolean} true if the page has changed
         * @publicdoc
         */
        setCurrentPage: function(page, executeAction = false, fromUserAction = false) {
          // TODO - ensuring not to set hidden page as current page might break huge screens
          // TODO - has to deal with VisibleIdVMBehavior order in apply behaviors
          if (this._currentPage !== page /* && !page.isHidden()*/ ) {
            for (const child of this._children) {
              child.getTitleWidget().setCurrent(child === page);
            }
            if (this._currentPage) {
              // do not remove page from dom if not measured yet or if it contains a WebComponent
              if (this.isMinified && !this._currentPage.hasChildWebComponent()) {
                this._currentPage.removeFromDom();
              }
              this._currentPage.removeClass("currentPage");
              this._currentPage.disable();
            }
            this._currentPage = page;
            if (!this._currentPage.getLayoutEngine().needMeasure()) {
              this._currentPage.addClass("currentPage");
            }
            if (this.isMinified && !this._currentPage.hasChildWebComponent()) {
              this._currentPage.addInDom();
            }

            this._currentPage.activate();
            if (page) {
              this.getLayoutEngine().invalidateAllocatedSpace();
            }

            this.emit(context.constants.widgetEvents.change, page, executeAction, fromUserAction);

            return true;
          }
          return false;
        },

        /**
         * Refresh the current page using VM focused widget or using first visible page otherwise
         * @publicdoc
         */
        updateCurrentPage: function() {
          const focusedWidget = this.getUserInterfaceWidget().getFocusedWidget();
          const focusedWidgetIsPage = Boolean(focusedWidget) && focusedWidget instanceof cls.PageWidget;
          if (focusedWidgetIsPage && !focusedWidget.isHidden()) {
            this.setCurrentPage(focusedWidget);
          } else {
            let firstVisiblePage = null;
            if (this._children) {
              for (const page of this._children) {
                if (!page.isHidden()) {
                  if (!firstVisiblePage) {
                    firstVisiblePage = page;
                  }
                  if (focusedWidget && !focusedWidgetIsPage && focusedWidget.isChildOf(page)) {
                    this.setCurrentPage(page);
                    firstVisiblePage = null;
                    break;
                  }
                }
              }
            }
            if (firstVisiblePage) {
              // false parameter to not execute action in this case
              this.setCurrentPage(firstVisiblePage, false);
            }
          }
        },

        /**
         * Returns the number of page in the folder
         * @return {number} page count
         * @publicdoc
         */
        getPageCount: function() {
          return this._children.length;
        },

        /**
         * Returns the number of visible page in the folder
         * @return {number} visible page count
         * @publicdoc
         */
        getVisiblePageCount: function() {
          let count = 0;
          for (const page of this._children) {
            if (!page.isHidden()) {
              count++;
            }
          }
          return count;
        },

        /**
         * Look for a parent page widget
         * @returns {classes.PageWidget} page widget
         * @publicdoc
         */
        getParentPage: function() {
          let result = this.getParentWidget();
          while (result) {
            if (result.isInstanceOf(gbc.classes.PageWidget)) {
              return result;
            }
            result = result.getParentWidget();
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== Boolean(hidden)) {
            $super.setHidden.call(this, hidden);
            const parent = this.getParentWidget();
            if (parent && parent.getGestureService && parent.getGestureService()) {
              const gestureService = parent.getGestureService();
              if (gestureService.hasDots()) {
                gestureService.refreshDots();
              }
              if (gestureService.hasArrows()) {
                gestureService.refreshArrows();
              }
            }
          }
        }

      };
    });
  });
;

"use strict";

modulum('FormWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Form widget.
     * @class FormWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.FormWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.FormWidget.prototype */ {
        __name: "FormWidget",
        /**
         * title of the current form
         * @type {?string}
         */
        _text: null,
        _scrollValues: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.FormLayoutInformation(this);
          this._layoutEngine = new cls.FormLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw new Error("A form can only contain a single child");
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @param {string} text title of the current form
         */
        setText: function(text) {
          this._text = text;
        },

        /**
         * @returns {string} title of the current form
         */
        getText: function() {
          return this._text;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Form', cls.FormWidget);
  });
;

"use strict";

modulum('GridWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Grid widget.
     * @class GridWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     */
    cls.GridWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.GridWidget.prototype */ {
        __name: "GridWidget",
        _scrollWidget: null,
        _pageSize: null,
        _size: null,

        destroy: function() {
          if (this._scrollWidget) {
            this._scrollWidget.destroy();
            this._scrollWidget = null;
          }
          $super.destroy.call(this);
        },

        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          const scrollWidget = this.getScrollWidget();
          if (scrollWidget) {
            scrollWidget.setEnabled(enabled);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('Grid', cls.GridWidget);
  });
;

"use strict";

modulum('GroupTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group title widget.
     * @class GroupTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.GroupTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.GroupTitleWidget.prototype */ {
        __name: "GroupTitleWidget",

        /**
         * @type {HTMLElement}
         */
        _textContainer: null,

        /**
         * is owner group collapsible
         * @type {boolean}
         */
        _isCollapsible: false,
        /**
         * @type {HTMLElement}
         */
        _collapser: null,
        /**
         * @type {HTMLElement}
         */
        _collapserIcon: null,

        /**
         * is owner group collapsed
         * @type {boolean}
         */
        _collapsed: false,

        /**
         * has text
         * @type {boolean}
         */
        _isEmpty: true,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutInformation.getSizePolicyConfig().setMode('dynamic');
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textContainer = this._element.getElementsByTagName('span')[0];
          this._collapser = this._element.getElementsByTagName('span')[1];
          this._collapserIcon = this._element.getElementsByTagName('i')[0];
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          this._textContainer = null;
          this._collapser = null;
          this._collapserIcon = null;
          $super.destroy.call(this);
        },
        /**
         * Defines group title text
         * @param {string} text - text describing the group
         * @publicdoc
         */
        setText: function(text) {
          this.domAttributesMutator(function() {
            if (/^[ \t]+$/.test(text)) {
              this._textContainer.innerHTML = "&nbsp;";
            } else {
              this._textContainer.textContent = text;
            }
            this._element.toggleClass("empty", !text);
          }.bind(this));
          this._isEmpty = !text;
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * Returns group title text
         * @returns {string} text describing the group
         * @publicdoc
         */
        getText: function() {
          return this._textContainer.textContent;
        },

        /**
         * Display collapsible control if needed
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._element.toggleClass("collapsible", this._isCollapsible);
        },

        /**
         * Indicates whether the owner group is collapsed or not
         * @return {boolean}
         */
        isCollapsed: function() {
          return this._collapsed;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this._isEmpty) {
            this._collapsed = !this._collapsed;
            this._updateToggle();
            this.emit(context.constants.widgetEvents.click);
          }
          return true;
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         */
        setCollapsed: function(collapsed) {
          if (this._collapsed !== Boolean(collapsed)) {
            this._collapsed = Boolean(collapsed);
            this._updateToggle();
          }
        },
        /**
         * update the toggle icon
         * @private
         */
        _updateToggle: function() {
          this._collapserIcon.toggleClass("zmdi-chevron-down", !this._collapsed).toggleClass("zmdi-chevron-right", this._collapsed);
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.removeClass("collapser-position-right");
          this.removeClass("collapser-position-left");
          this.addClass("collapser-position-" + pos);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('GroupTitle', cls.GroupTitleWidget);
  });
;

"use strict";

modulum('GroupWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group widget.
     * @class GroupWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     * @publicdoc
     */

    cls.GroupWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.GroupWidget.prototype */ {
        __name: "GroupWidget",
        /**
         * @type {classes.GroupTitleWidget}
         */
        _title: null,

        /**
         * @type {HandleRegistration}
         */
        _titleClickHandler: null,

        /**
         * flag to determine if group is collapsible
         * @type {boolean}
         */
        _isCollapsible: false,

        /**
         * @type {HandleRegistration}
         */
        _gridWidthHandle: null,

        /**
         * @type {HTMLElement}
         */
        _groupWidgetContent: null,

        /**
         * @type {HTMLElement}
         */
        _groupContent: null,

        /**
         * @type {{formName:string, id:string}}
         */
        _groupIdentifier: null,
        /**
         * set the stored settings identifier
         * @param {{formName:string, id:string}} id
         */
        setGroupIdentifier: function(id) {
          this._groupIdentifier = id;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._title = cls.WidgetFactory.createWidget("GroupTitle", this.getBuildParameters());
          this._titleClickHandler = this._title.when(context.constants.widgetEvents.click, this._onTitleClick.bind(this));
          this._groupWidgetContent = this._element.getElementsByClassName("gbc_GroupWidgetContent")[0];
          this._groupWidgetContent.prependChild(this._title.getElement());
          this._groupContent = this._groupWidgetContent.getElementsByClassName("containerElement")[0];
          // Set the default value of the collapsers to the theme definition
          this.setCollapserPosition(gbc.ThemeService.getValue("gbc-GroupWidget-collapser-position"));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.GroupLayoutEngine(this);
          this._gridWidthHandle = this.getLayoutInformation().onGridInfoChanged(this._onGridWidthChanged.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._titleClickHandler) {
            this._titleClickHandler();
            this._titleClickHandler = null;
          }

          if (this._title) {
            this._title.destroy();
            this._title = null;
          }
          if (this._gridWidthHandle) {
            this._gridWidthHandle();
            this._gridWidthHandle = null;
          }
          this._groupWidgetContent = null;
          this._groupContent = null;
          $super.destroy.call(this);
        },

        /**
         * Handle grid width changes
         */
        _onGridWidthChanged: function() {
          this._title.getLayoutInformation().setGridWidth(this.getLayoutInformation().getGridWidth());
        },

        /**
         * @inheritDoc
         */
        setGridChildrenInParent: function(isGridChildrenInParent) {
          if (this._isGridChildrenInParent !== isGridChildrenInParent) {
            if (!isGridChildrenInParent) {
              this._groupContent.removeClass("gridChildrenInParent");
            }
            $super.setGridChildrenInParent.call(this, isGridChildrenInParent);
            if (isGridChildrenInParent) {
              this._groupContent.addClass("gridChildrenInParent");
            }
          }
        },
        /**
         * Defines group title text
         * @param {string} text - text describing the group
         * @publicdoc
         */
        setText: function(text) {
          this._title.setText(text);
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * Returns group title text
         * @returns {string} text describing the group
         * @publicdoc
         */
        getText: function() {
          return this._title.getText();
        },
        /**
         * when group title is clicked
         * @private
         */
        _onTitleClick: function() {
          if (this._isCollapsible) {
            this._updateCollapsedState();
            this.emit(context.constants.widgetEvents.toggleClick);

            const session = context.SessionService.getCurrent();
            if (session) {
              const app = session.getCurrentApplication();
              if (app) {
                app.layout.when(context.constants.widgetEvents.afterLayout, function() {
                  let pw = this.getParentWidget();
                  while (pw) {
                    pw.emit(context.constants.widgetEvents.splitViewChange, true);
                    pw = pw.getParentWidget();
                  }
                }.bind(this), true);
              }
            }
          }
        },

        /**
         * Set the group collapsible
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._title.setCollapsible(this._isCollapsible);
          if (this._isCollapsible) {
            this.setCollapsed(Boolean(context.StoredSettingsService
              .getGroupCollapsedState(this._groupIdentifier.formName, this._groupIdentifier.id)));
          }
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         * @return {boolean} true if collapsed state has changed
         */
        setCollapsed: function(collapsed) {
          let result = false;
          if (this._isCollapsible) {
            if (this._title.isCollapsed() !== Boolean(collapsed)) {
              this._title.setCollapsed(collapsed);
              this._updateCollapsedState();
              result = true;
            }
          }
          return result;
        },

        /**
         * Define the position of the collapser
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this._title.setCollapserPosition(pos);
        },

        /**
         * update the layout engine collapsed information
         * @private
         */
        _updateCollapsedState: function() {
          this._layoutEngine._willRenderContent = !this._title.isCollapsed();
          context.StoredSettingsService.setGroupCollapsedState(this._groupIdentifier.formName,
            this._groupIdentifier.id, Boolean(this._title.isCollapsed()));
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Group', cls.GroupWidget);
  });
;

"use strict";

modulum('HBoxSplitterWidget', ['SplitterWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class HBoxSplitterWidget
     * @memberOf classes
     * @extends classes.SplitterWidget
     */
    cls.HBoxSplitterWidget = context.oo.Class(cls.SplitterWidget, function($super) {
      return /** @lends classes.HBoxSplitterWidget.prototype */ {
        __name: "HBoxSplitterWidget",
        __templateName: "SplitterWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_SplitterWidget");
        },
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutInformation.setMaximal(8, cls.Size.maximal);
        },
        _onDragOver: function(evt) {
          $super._onDragOver.call(this, evt);
          this._pagePosition = evt.pageX;
        },
        _updateResizerDrag: function(evt) {
          this._pagePosition = evt.pageX;
          this._resizerDragPosition = evt.pageX;
        },
        updateSplits: function(delta) {
          if (this.isReversed()) {
            delta = -delta;
          }
          $super.updateSplits.call(this, delta);
        },

        // Touch only
        _onTouchStart: function(evt) {
          this._splitStartPos = evt.touches[0].clientX;
          $super._onTouchStart.call(this, evt);
        },

        _onTouchMove: function(evt) {
          this._pagePosition = evt.touches[0].clientX;
          $super._onTouchMove.call(this, evt);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('HBoxSplitter', cls.HBoxSplitterWidget);
  });
;

"use strict";

modulum('HBoxWidget', ['BoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HBox widget
     * @publicdoc Widgets
     * @class HBoxWidget
     * @memberOf classes
     * @extends classes.BoxWidget
     */
    cls.HBoxWidget = context.oo.Class(cls.BoxWidget, function($super) {
      return /** @lends classes.HBoxWidget.prototype */ {
        __name: "HBoxWidget",

        /** @type {classes.GestureService} */
        _gesture: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._orientation = "horizontal";
          $super.constructor.call(this, opts);
          this._element.addClass("g_HBoxLayoutEngine");
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._gesture) {
            this._gesture.destroy();
            this._gesture = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        getDefaultOrientation: function() {
          return "horizontal";
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.HVBoxLayoutEngine(this);
          this._layoutEngine.setOrientation(this._orientation);
        },

        /**
         * Get the widget gesture service
         * @return {classes.GestureService}
         */
        getGestureService: function() {
          return this._gesture;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('HBox', cls.HBoxWidget);
  });
;

"use strict";

modulum('HVBoxSplitterWidget', ['SplitterWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class HVBoxSplitterWidget
     * @memberOf classes
     * @extends classes.SplitterWidget
     */
    cls.HVBoxSplitterWidget = context.oo.Class(cls.SplitterWidget, function($super) {
      return /** @lends classes.HVBoxSplitterWidget.prototype */ {
        __name: "HVBoxSplitterWidget",
        __templateName: "SplitterWidget",
        _orientation: "vertical",

        setOrientation(orientation) {
          this._orientation = orientation;
          this.toggleClass("gbc_VBoxSplitterWidget", "gbc_HBoxSplitterWidget", this._isVertical());
        },

        _isVertical() {
          return this._orientation === "vertical";
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_SplitterWidget");
        },
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutInformation.setMaximal(cls.Size.maximal, 8);
        },
        _onDragOver: function(evt) {
          $super._onDragOver.call(this, evt);
          this._pagePosition = this._isVertical() ? evt.pageY : evt.pageX;
        },
        _updateResizerDrag: function(evt) {
          this._pagePosition = this._isVertical() ? evt.pageY : evt.pageX;
          this._resizerDragPosition = this._isVertical() ? evt.pageY : evt.pageX;
        },

        updateSplits: function(delta) {
          // Only for HBOX
          if (!this._isVertical()) {
            if (this.isReversed()) {
              delta = -delta;
            }
          }
          $super.updateSplits.call(this, delta);
        },

        // Touch only
        _onTouchStart: function(evt) {
          this._splitStartPos = this._isVertical() ? evt.touches[0].clientY : evt.touches[0].clientX;
          $super._onTouchStart.call(this, evt);
        },

        _onTouchMove: function(evt) {
          this._pagePosition = this._isVertical() ? evt.touches[0].clientY : evt.touches[0].clientX;
          $super._onTouchMove.call(this, evt);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('HVBoxSplitter', cls.HVBoxSplitterWidget);
  });
;

"use strict";

/**
 * @callback ListDropDownItemRenderer
 * @param {string[]} model splitted string model
 * @param {Object} item the object value
 * @return {string} rendered html
 */

/**
 * @typedef {Object} ListDropDownWidgetItem
 * @property {string} text
 * @property {string} value
 */

modulum('ListDropDownWidget', ['DropDownWidget', 'WidgetFactory'],
  function(context, cls) {
    /**
     * List Drop Down Widget.
     * The values of this widget is meant to be controlled by another widget.
     * @class ListDropDownWidget
     * @memberOf classes
     * @extends classes.DropDownWidget
     */
    cls.ListDropDownWidget = context.oo.Class(cls.DropDownWidget, function($super) {
      return /** @lends classes.ListDropDownWidget.prototype */ {
        /** @lends classes.ListDropDownWidget */
        $static: {
          /**
           *
           * @private
           */
          _defaultItemRenderer: null,
          /**
           * Produces the default item renderer
           * @todo : See if it's possible to refactor and remove all this special renderer system. And just compose a widget
           * @return {ListDropDownItemRenderer}
           */
          getDefaultItemRenderer: function() {
            if (!cls.ListDropDownWidget._defaultItemRenderer) {
              const uiModel = context.TemplateService.renderDOM(
                cls.CheckBoxWidget.prototype.__name,
                cls.CheckBoxWidget.prototype.__ascendance
              );
              uiModel.className += " " + cls.CheckBoxWidget.prototype.__ascendanceClasses;
              uiModel.addClass("gbc_ListDropDownWidget_item");
              uiModel.setAttribute("combovalue", "#$value#");
              const labelElement = document.createElement('div');
              labelElement.addClass('label');
              labelElement.textContent = "#$text#";
              uiModel.getElementsByClassName('content')[0].appendChild(labelElement);
              const model = uiModel.outerHTML.split("#");
              cls.ListDropDownWidget._defaultItemRenderer = function(model, item) {
                let result = "";
                for (const element of model) {
                  // escape HTML conflicting chars such as quote and double-quotes before adding it in the DOM
                  result += element[0] === "$" ? (item[element.substr(1)].escapeHTML() || "") : element;
                }
                return result;
              }.bind(null, model);
            }
            return cls.ListDropDownWidget._defaultItemRenderer;
          }
        },

        __name: "ListDropDownWidget",
        __templateName: "DropDownWidget",
        /**
         * @inheritDoc
         */
        autoSize: true,
        /**
         * whether or not this list will allow multiple value selection
         * @type {boolean}
         */
        _allowMultipleValues: false,
        /**
         * whether or not this list will allow null value
         * @type {boolean}
         */
        _notNull: false,
        /**
         * current items - raw data
         * @type {Object[]}
         */
        _items: null,

        /**
         * currently highlighted element
         * @type {number}
         */
        _currentIndex: -1,

        /** Last selected item index */
        _lastSelectedValueIndex: -1,
        /**
         * currently set value
         * @type {string[]}
         */
        _selectedValues: null,

        /**
         * item renderer
         * @type {ListDropDownItemRenderer}
         */
        _itemRenderer: null,

        /** styles */
        _cssSelector: ".gbc_ListDropDownWidget_item",

        /**
         * @inheritdoc
         */
        constructor: function(opts) {
          this._selectedValues = [];
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._removeHoverBindings();
          this._items.length = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._items = [];
          this._itemRenderer = cls.ListDropDownWidget.getDefaultItemRenderer();

          this.onOpen(this._addHoverBindings.bind(this));
          this.onClose(this._removeHoverBindings.bind(this));

          this._updateVisualElementState();
        },

        /**
         * Bind dropdown items hover styling events
         * @private
         */
        _addHoverBindings: function() {
          if (!window.isMobile()) {
            this._containerElement.on('mouseover.ListDropDownWidget', this._onMouseover.bind(this));
          }
        },

        /**
         * Remove dropdown items hover styling events
         * @private
         */
        _removeHoverBindings: function() {
          if (!window.isMobile()) {
            this._containerElement.off('mouseover.ListDropDownWidget');
          }
        },

        /**
         * Set the available items
         * @param {ListDropDownWidgetItem[]} list items
         */
        setItems: function(list) {
          this._items = [];
          list.map((element) => {
            this.getItems().push({
              text: element.text,
              value: element.value,
              searchText: element.text.toLocaleLowerCase(),
              nullItem: element.nullItem,
              virtualItem: false
            });
          });

          this.updateUIList();
        },

        /**
         * Get the items
         * @return {ListDropDownWidgetItem[]} list items
         */
        getItems: function() {
          return this._items;
        },

        /**
         * refresh DOM list
         * @todo : Refactor and optimise me please ! I do way too many useless operations
         * Put the null checking part inside the setItems method !
         */
        updateUIList: function() {
          let hasNull = false,
            hasNotNull = false;

          const content = [];

          const isConstruct = this.getParentWidget().getDialogType() === 'Construct',
            isNullText = `＜${i18next.t('gwc.main.combobox.isnull', 'blank')}＞`,
            isNotNullText = `＜${i18next.t('gwc.main.combobox.isnotnull', 'not blank')}＞`;

          this._items = this._items.filter(function(i) {
            return !i.virtualItem;
          });

          for (const item of this.getItems()) {
            // @short-circuit  use compact version instead : hasNull ||= isConstruct && item.value === "=";
            if (!hasNull) {
              hasNull = isConstruct && item.value === "=";
            }
            // @short-circuit : use shorthand instead : hasNotNull ||= isConstruct && item.value.match(/!=|<>/);
            if (!hasNotNull) {
              hasNotNull = isConstruct && item.value.match(/!=|<>/);
            }

            if (!hasNull && item.nullItem) {
              item.value = isConstruct ? "=" : "";
              item.text = isConstruct && item.text === "" ? isNullText : item.text;
              item.searchText = item.text.toLocaleLowerCase().escapeHTML();
              hasNull = true;
            }

            content.push(this._itemRenderer(item));
          }

          if (!this._notNull) {
            let needMeasure = false;
            if (!hasNull) {
              this._items.push({
                text: isConstruct ? isNullText.escapeHTML() : "",
                value: isConstruct ? "=" : "",
                searchText: isConstruct ? isNullText.replace(/[<>]/g, "") : "",
                nullItem: true,
                virtualItem: true
              });

              content.push(this._itemRenderer(this._items[this._items.length - 1]));

              needMeasure = true;
            }

            if (!hasNotNull && isConstruct) {
              this._items.push({
                text: isNotNullText.escapeHTML(),
                value: "!=",
                searchText: isNotNullText.replace(/[<>]/g, ""),
                nullItem: false,
                virtualItem: true
              });

              content.push(this._itemRenderer(this._items[this._items.length - 1]));

              needMeasure = true;
            }

            if (needMeasure) {
              this._layoutEngine.invalidateMeasure();
              this._layoutEngine.needMeasure();
            }
          }

          this._containerElement.innerHTML = content.join("");

          if (this.isVisible()) {
            this.hide();
            this.show();
          }

          this._updateAriaAttributes();
          this._updateCheckboxVisibility();
        },

        /**
         * update item checkboxes visibility
         * @private
         */
        _updateCheckboxVisibility: function() {
          this.domAttributesMutator(function() {
            const checkboxes = this._containerElement.querySelectorAll(".gbc_ListDropDownWidget_item i.zmdi");
            for (const checkbox of checkboxes) {
              checkbox.setAttribute("style", this._allowMultipleValues ? "" : "display:none !important");
            }
          }.bind(this));
        },

        /**
         * update items accessibility attributes
         * @private
         */
        _updateAriaAttributes: function() {
          this.domAttributesMutator(function() {
            const items = this._containerElement.querySelectorAll(".gbc_ListDropDownWidget_item"),
              len = items.length;
            for (let i = 0; i < len; ++i) {
              items[i].setAttribute("aria-role", 'option');
              items[i].setAttribute("aria-posinset", (i + 1).toString());
              items[i].setAttribute("aria-setsize", len.toString());
            }
          }.bind(this));
        },

        /**
         * Check items checkbox accordingly to selectedValues
         * Set current item accordingly to _currentItem
         * This method is very safe, but performance heavy
         * @private
         */
        _updateVisualElementState: function() {
          const elements = this._containerElement.querySelectorAll('.gbc_ListDropDownWidget_item');
          let index = 0;
          for (const element of elements) {
            if (this.allowMultipleChoices) {
              const checkBox = element.querySelector("i");
              if (checkBox) {
                const valueIndex = this._selectedValues.findIndex(value => value === element.getAttribute("combovalue"));
                const rmClass = valueIndex === -1 ? "checked" : "unchecked";
                const adClass = valueIndex === -1 ? "unchecked" : "checked";
                checkBox.removeClass(rmClass).addClass(adClass);
              }
            }
            element.removeClass("current");
            if (index === this._currentIndex) {
              element.addClass("current");
            }
            index += 1;
          }
        },

        /**
         * Get item index by its value
         * @param {string} value value
         * @return {number} The matching index. -1 if not found
         */
        indexByValue: function(value) {
          return this._items.findIndex((item) => item.value === value);
        },

        /**
         * Get item by its value
         * @param {string} value value
         * @return {Object} the item
         */
        findByValue: function(value) {
          return this._items.find(function(item) {
            return item.value === value;
          });
        },
        /**
         * Get item by its text
         * @param {string} text value
         * @param {boolean} caseSensitive true by default
         * @return {Object} the item
         */
        findByText: function(text, caseSensitive) {
          if (!caseSensitive) {
            text = text.toLocaleLowerCase();
          }

          return this._items.find(item => item.text === text);
        },

        /**
         * find item starting by searchPattern beginning at current index. will loop to cover all items.
         * @param {string} searchPattern first letters of searched item
         * @param {boolean} startAfterCurrentItem exclude current index item as first matching element
         * @return {Object} found item
         */
        findStartingByText: function(searchPattern, startAfterCurrentItem) {
          const current = this._currentIndex + (startAfterCurrentItem ? 1 : 0);

          return this._items.find(function(item, i) {
            return i >= current && item.searchText.match(new RegExp(`^${searchPattern}`, ""));
          }) || this._items.find(function(item, i) {
            return i < current && item.searchText.match(new RegExp(`^${searchPattern}`, ""));
          });
        },

        /**
         * get value of the current index
         * @return {string|null} Return the value of the current item, if no current item (current index == -1) return null
         */
        getCurrentValue: function() {
          if (this._currentIndex < 0 || this._currentIndex >= this.getItems().length) {
            return null;
          }
          return this.getItems()[this._currentIndex].value;
        },

        /**
         * @returns The index of the current item
         */
        getCurrentIndex: function() {
          return this._currentIndex;
        },

        /**
         * Set the selected values of the widget.
         * And update the UI
         * @param {string[]} values The selected values
         */
        setSelectedValues: function(values) {
          if (!Array.isArray(values)) {
            return;
          }
          this._selectedValues = values;
          const index = this.indexByValue(this._selectedValues[this._selectedValues.length - 1]);
          this._lastSelectedValueIndex = index;
          // Get the last value and set it as current
          this._updateVisualElementState();
        },

        /**
         * Set current index and potentially scroll to it
         * !! WARNING !! : This method don't change any "selected Value"
         * @param {number} index The new index, this index will be clamped between 0 and items count
         */
        setCurrentIndex: function(index) {
          index = Math.clamp(index, -1, this.getItems().length - 1);

          if (this._currentIndex !== -1) {
            const previousItem = this._containerElement.children[this._currentIndex];
            if (previousItem) {
              previousItem.removeClass("current");
            }
          }

          this._currentIndex = index;

          const currentItem = this._containerElement.children[this._currentIndex];
          if (currentItem) {
            currentItem.addClass("current");
            if (this.isVisible()) {
              this.scrollItemIntoView(currentItem);
            }
          }
        },

        setCurrentIndexOnLastItem: function() {
          // Set the current index as the last value of the selectedValues
          const index = this.indexByValue(this._selectedValues[this._selectedValues.length - 1]);
          this.setCurrentIndex(index);
        },

        /**
         * Select the item. And update the UI
         * @param {string} value value
         * @private
         */
        _selectItem: function(value) {
          if (value === null) {
            return;
          }

          const itemIndex = this._items.findIndex(item => item.value === value);
          if (itemIndex === -1) {
            return;
          }

          this._lastSelectedValueIndex = itemIndex;
          this._updateVisualElementState();

          this.emit(context.constants.widgetEvents.select, value);
        },

        /**
         * sorts input array in the same order as items array
         * @param {string[]} values input values
         * @return {string[]} sorted array
         */
        sortValues: function(values) {
          const result = [],
            isConstruct = this.getParentWidget().getDialogType() === 'Construct';
          let hasNull = false;

          for (const item of this._items) {
            if (values.indexOf(item.value) >= 0) {
              result.push(item.value);
              //On construct "=" equal "NULL" item because it means 'is not null'
              if (item.nullItem || (item.value === "=" && isConstruct)) {
                hasNull = true;
              }
            }
          }

          const nullKey = isConstruct ? "=" : "";
          if (!hasNull && values.indexOf(nullKey) >= 0) {
            result.push(nullKey);
          }

          return result;
        },

        /**
         * @inheritDoc
         */
        setFontFamily: function(fontFamily) {
          const fontFamilly = fontFamily === null || fontFamily === undefined ? fontFamily :
            fontFamily.escapeFontFamily();

          this.setStyle({
            selector: this._cssSelector
          }, {
            "font-family": fontFamilly
          });
        },

        /**
         * @inheritDoc
         */
        setFontWeight: function(weight) {
          this.setStyle({
            selector: this._cssSelector
          }, {
            "font-weight": weight
          });
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          this.setStyle({
            selector: this._cssSelector
          }, {
            "font-style": style
          });
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this.setStyle({
            selector: this._cssSelector
          }, {
            "text-align": align
          });
        },

        /**
         * set whether or not this list will allow null value
         * @param {boolean} notNull not null
         */
        setNotNull: function(notNull) {
          if (this._notNull !== notNull) {
            this._notNull = notNull;
            this.updateUIList();
          }
        },

        /**
         * set whether or not this list allow multiple choices
         * @param {boolean} allow allow
         */
        allowMultipleChoices: function(allow) {
          this._allowMultipleValues = allow;
          this._updateCheckboxVisibility();
          this._updateVisualElementState();
        },

        /**
         * set current index on item
         * @param {Object} item item
         */
        navigateToItem: function(item) {
          this.setCurrentIndex(this.indexByValue(item.value));
        },

        /**
         * Scroll to element if needed
         * @param {HTMLElement} element element
         * @publicdoc
         */
        scrollItemIntoView: function(element) {
          if (this.getElement().scrollTop > element.offsetTop) {
            element.scrollIntoView();
          } else if (this.getElement().scrollTop + this.getElement().offsetHeight < element.offsetTop + element.offsetHeight) {
            element.scrollIntoView(false);
          }
        },

        /**
         * On click handler raised when selecting an item in the dropdown :
         * Parent widget get value of clicked item and dropdown is closed.
         * @param domEvent
         * @private
         */
        _onClick: function(domEvent) {
          const item = domEvent.target.closest("gbc_ListDropDownWidget_item"),
            value = item?.getAttribute("combovalue");
          if (value !== null) {
            this._selectItem(value);
            if (domEvent) {
              domEvent.stopPropagation();
            }
            if (!this._allowMultipleValues) {
              this.hide();
            }
          }
        },

        /**
         * Mouse over handler used to highlight current item.
         * @param event
         * @private
         */
        _onMouseover: function(event) {
          const element = event.target;
          if (element) {
            const widgetElement = element.hasClass("gbc_ListDropDownWidget_item") ? element : element.parent("gbc_ListDropDownWidget_item");
            if (widgetElement) {
              this.setCurrentIndex(widgetElement.index());
            }
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onClick(domEvent);
          return false;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          switch (keyString) {
            case "space":
              if (this.isVisible()) {
                if (this._allowMultipleValues) {
                  this._selectItem(this.getCurrentValue());
                } else {
                  this.hide();
                }
                keyProcessed = true;
              }
              break;
            case "enter":
            case "return":
              if (this.isVisible()) {
                if (!this._allowMultipleValues) {
                  this._selectItem(this.getCurrentValue());
                }
                this.hide();
                keyProcessed = true;
              }
              break;
            case "up":
              this._manageValueChangeKey(this._currentIndex - 1);
              keyProcessed = true;
              break;
            case "down":
              this._manageValueChangeKey(this._currentIndex + 1);
              keyProcessed = true;
              break;
            case "pageup":
              this._manageValueChangeKey(this._currentIndex - 10);
              keyProcessed = true;
              break;
            case "pagedown":
              this._manageValueChangeKey(this._currentIndex + 10);
              keyProcessed = true;
              break;
            case "home":
              if (this.isVisible()) {
                this._manageValueChangeKey(0);
                keyProcessed = true;
              }
              break;
            case "end":
              if (this.isVisible()) {
                this._manageValueChangeKey(this.getItems().length - 1);
                keyProcessed = true;
              }
              break;
            case "tab":
            case "shift+tab":
              if (this.isVisible()) {
                this.hide();
              }
              break;
          }

          if (keyProcessed) {
            return true;
          }
          return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
        },

        /**
         * Macro for managing the up, down, pageup, pagedown, start and end key
         * @param {number} index 
         * @private
         */
        _manageValueChangeKey(index) {
          if (index < 0 && this.getCurrentIndex() === -1) {
            index = this.getItems().length + (index + 1);
          }
          index = Math.clamp(index, 0, this.getItems().length - 1);
          this.setCurrentIndex(index);
        },
        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          // nothing intentionally here
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          // nothing intentionally here
        },

        /**
         * Show the widget dropdown
         */
        show: function() {
          $super.show.call(this);

          // Set the current item as the current value (or the last if multiple values are allowed)
          this.setCurrentIndex(this._lastSelectedValueIndex);

          //resize elements inside dropdown to fix GBC-4203 - COMBOBOX drop-down list very long entry truncated when hovering over it
          const items = this._containerElement.querySelectorAll('.gbc_ListDropDownWidget_item');
          let maxItemWidth = 0;
          for (const item of items) {
            if (item.scrollWidth > maxItemWidth) {
              maxItemWidth = item.scrollWidth;
            }
          }
          const parent = (this.parentElement ? this.parentElement : this.getParentWidget().getElement());
          if (maxItemWidth > parent.scrollWidth) {
            for (const item of items) {
              item.style.width = maxItemWidth + "px";
            }
          }
        },

        hide: function() {
          $super.hide.call(this);

          this.setCurrentIndex(this._lastSelectedValueIndex);
        },

        /**
         * Create a regex that help finding possible values
         * @param {string} valueToMatch The value to find in the items
         * @returns {RegExp} The regex that will filter if the value exist in the possible values
         * @private
         */
        _buildValueRegex(valueToMatch, textToMatch) {
          if (valueToMatch === undefined && textToMatch === undefined) {
            return new RegExp("", "gi");
          }
          valueToMatch = valueToMatch.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
          textToMatch = textToMatch.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
          if (textToMatch !== "") {
            valueToMatch = `(?:${valueToMatch})|(?:${textToMatch})`;
          }
          return new RegExp(`(^|\\|)(?:${valueToMatch})(\\||$)`, 'gi');
        },

        /**
         * Test if a value exist in the possible values.
         * The argument value is tested against item key or text.
         * @param {string} valueString The value to test agains
         * @param {string} discardUnavailbleValues Should this method return empty string if the valueString is not in the availble items. False by defualt
         * @returns {{remaining : string, values : string[], replacedValue: string, replacedText: string}} The value keys that where found in the value given in parameter.
         */
        filterValues(valueString, discardUnavailbleValues = false) {
          if (valueString === undefined || valueString === null || valueString === "") {
            // Check if the value exists in the items
            const item = this.getItems().find(item => item.value === valueString);

            return {
              remaining: "",
              values: [""],
              formattedValues: "",
              formattedText: item?.text !== undefined ? item.text : "",
            };
          }
          let strippedValue = valueString;
          let replacedText = valueString;
          let replacedValues = valueString;

          const processedValues = this.getItems().reduce(function(filteredKeys, item) {
            if (valueString.match(this._buildValueRegex(item.value, item.text))) {
              filteredKeys.push(item.value);
              strippedValue = strippedValue.replaceAll(this._buildValueRegex(item.value, item.text), "");
              replacedValues = replacedValues.replaceAll(this._buildValueRegex(item.value, item.text), `$1${item.value}$2`);
              replacedText = replacedText.replaceAll(this._buildValueRegex(item.value, item.text), `$1${item.text}$2`);
            }
            return filteredKeys;
          }.bind(this), []);

          // Remove the pipes that could have stayed
          strippedValue = strippedValue.replace("|", "");
          /* If we do not allow values that are not in the items,
           * and no values was found, that mean we should not return anything
           */
          if (discardUnavailbleValues && processedValues.length === 0) {
            replacedValues = "";
            replacedText = "";
          }

          return {
            remaining: strippedValue,
            values: processedValues,
            formattedValues: replacedValues,
            formattedText: replacedText
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ListDropDown', cls.ListDropDownWidget);
  });
;

"use strict";

modulum('ListViewRowWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * ListViewRow widget.
     * @class ListViewRowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.ListViewRowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ListViewRowWidget.prototype */ {
        __name: "ListViewRowWidget",

        /** @type boolean */
        _current: false,
        /** @type classes.ImageWidget */
        _imageWidget: null,
        /** @type boolean */
        _horizontalLayout: false,

        /** @type Element */
        _imageElement: null,

        /** @type classes.RowBoundDecoratorWidget */
        _rowBoundDecoratorWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._imageElement = this._element.getElementsByClassName("gbc_ListViewRowImage")[0];
          this._element.onDoubleTap("ListViewRowWidget", this._onDoubleClick.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.offDoubleTap("ListViewRowWidget");

          if (this._imageWidget) {
            this._imageWidget.destroy();
            this._imageWidget = null;
          }
          if (this._rowBoundDecoratorWidget) {
            this._rowBoundDecoratorWidget.destroy();
            this._rowBoundDecoratorWidget = null;
          }
          this._imageElement = null;

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * Request focus for this row
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          const listViewWidget = this.getTableWidgetBase();
          if (listViewWidget) {
            listViewWidget.requestFocusFromWidget(this._children[0], domEvent);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          // Send a request focus only if none of the child widgets has been clicked
          // Otherwise, the request has already been sent
          let childClicked = false;
          for (let i = 0; !childClicked && i < this._children.length; ++i) {
            childClicked = domEvent.target.isElementOrChildOf(this._children[i].getElement());
          }
          const listViewWidget = this.getTableWidgetBase();
          if (!childClicked) {
            this.requestFocus(domEvent);
          }

          // trigger row action (but never if click is on rowbound)
          const clickInRowbound = listViewWidget.haveRowBoundActions() && domEvent.target.isElementOrChildOf(this._rowBoundDecoratorWidget
            .getElement());
          if (!listViewWidget.isRowActionTriggerByDoubleClick() && !clickInRowbound) {
            listViewWidget.emit(context.constants.widgetEvents.rowAction);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          this._onDoubleClick(domEvent);
          return false;
        },

        /**
         * Handle double click on row event
         * @param {Object} event
         */
        _onDoubleClick: function(event) {
          const listViewWidget = this.getTableWidgetBase();
          if (listViewWidget && listViewWidget.isRowActionTriggerByDoubleClick()) {
            listViewWidget.emit(context.constants.widgetEvents.rowAction);
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length > 2) {
            throw new Error("A listview item can only contain two children");
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * Sets the first and second widgets layout type to horizontal or vertical
         * @param {boolean} horizontal true for horizontal layout, false otherwise
         */
        setHorizontalLayout: function(horizontal) {
          this._horizontalLayout = horizontal;
          this._element.toggleClass('horizontal', horizontal);
        },

        /**
         * @return {boolean} true if the layout is horizontal
         */
        isHorizontalLayout: function() {
          return this._horizontalLayout;
        },

        /**
         * Set image of the row
         * @param {string} path - image path
         */
        setImage: function(path) {
          if (path && path !== "") {
            if (!this._imageWidget) {
              this._imageWidget = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._imageWidget.setParentWidget(this);
              this._imageElement.appendChild(this._imageWidget.getElement());
            }
            this._imageWidget.setSrc(path);

            // fix for ie11, this browser is not able to auto resize an SVG
            if (window.browserInfo.isIE) {
              let width = null;
              if (path.startsWith("font:")) {
                width = this.getParentWidget().getRowHeight() + "px";
              }
              this.setStyle(" .gbc_ImageWidget", {
                "width": width
              });
            } // end ie11 fix

            this._imageWidget.getElement().removeClass("hidden");
            this._imageElement.removeClass("hidden");

          } else if (this._imageWidget) {
            this._imageElement.addClass("hidden");
          }
        },

        /**
         * Returns the number of line in the row
         * @returns {number} number of line in the row
         * @publicdoc
         */
        getLineCount: function() {
          if (this._horizontalLayout) {
            return Math.min(this.getChildren().length, 1);
          } else {
            return this.getChildren().length;
          }
        },

        /**
         * Sets if the row is the current one
         * @param {boolean} current - true if row is the current one, false otherwise
         * @publicdoc
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = current;
            if (current) {
              this._element.addClass("currentRow");
            } else {
              this._element.removeClass("currentRow");
            }
          }
        },

        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          return true;
        },

        /**
         * Creates and adds rowBound decorator element to DOM
         */
        addRowBoundDecorator: function() {
          if (this._rowBoundDecoratorWidget === null) {
            this._rowBoundDecoratorWidget = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
            this._rowBoundDecoratorWidget.setParentWidget(this);
            this._element.appendChild(this._rowBoundDecoratorWidget.getElement());
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ListViewRow', cls.ListViewRowWidget);
  });
;

"use strict";

modulum('ListViewWidget', ['TableWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Listview widget.
     * @class ListViewWidget
     * @memberOf classes
     * @extends classes.TableWidgetBase
     * @publicdoc
     */
    cls.ListViewWidget = context.oo.Class(cls.TableWidgetBase, function($super) {
      return /** @lends classes.ListViewWidget.prototype */ {
        __name: "ListViewWidget",

        /** @type boolean */
        _needToUpdateVerticalScroll: false,
        /** @type Object */
        _timerId: null,

        $static: {
          defaultRowHeight: 24,
          defaultOneLineHeightRatio: 1.7,
          defaultTwoLinesHeightRatio: 2.6
        },

        /** styles */
        _highlightCurrentRowCssSelector: ":not(.disabled).highlight .gbc_ListViewRowWidget.currentRow",

        /** @type boolean */
        _userScrollAction: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setRowHeight(cls.ListViewWidget.defaultRowHeight);
          this.getScrollableArea().on('scroll.ListViewWidget', this._onScroll.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ListViewLayoutEngine(this);

          this._layoutEngine.onLayoutApplied(this._layoutApplied.bind(this));
          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);

          const minPageSize = parseInt(context.ThemeService.getValue("gbc-ListViewWidget-min-page-size"), 10);
          this._layoutEngine.setMinPageSize(isNaN(minPageSize) ? 1 : minPageSize);
          const minWidth = parseInt(context.ThemeService.getValue("gbc-ListViewWidget-min-width"), 10);
          this._layoutEngine.setMinWidth(isNaN(minWidth) ? 60 : minWidth);
        },

        /**
         * Call when layout is finished
         */
        _layoutApplied: function() {
          if (this.isElementInDOM()) {
            // if table is visible and was already active
            this.updateVerticalScroll(this._needToUpdateVerticalScroll && !this._userScrollAction);
            this._needToUpdateVerticalScroll = false;
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.destroyChildren();
          this._clearTimeout(this._timerId);
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this.domFocus(fromMouse);
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Called when a scroll is done
         * @param {Object} event - scroll event
         */
        _onScroll: function(event) {
          if (this._isScrollEventManuallyTriggered) {
            this._isScrollEventManuallyTriggered = false;
            return;
          }

          if (this._userScrollAction) {
            this.afterDomMutator(function() {
              if (event.target) {
                // Emit scroll event for vertical scrolling
                this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());
                this._clearTimeout(this._timerId);
                this._timerId = this._registerTimeout(function() {
                  this._userScrollAction = false;
                }.bind(this), 100);

              }
            }.bind(this));
          } else {
            this._userScrollAction = true;
          }
        },

        /**
         * Returns row widgets
         * @returns {classes.ListViewRowWidget[]} array of row widgets
         * @publicdoc
         */
        getRows: function() {
          return this.getChildren();
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);

          if (this.haveRowBoundActions() && widget.isInstanceOf(cls.ContextMenuWidget)) {
            // rowbound widget: must decorator on all rows
            for (const row of this.getRows()) {
              row.addRowBoundDecorator();
            }
          } else if (widget.isInstanceOf(cls.ListViewRowWidget)) {
            widget.setHidden(this._children.length >= this._visibleRows);
            if (this.haveRowBoundActions()) {
              widget.addRowBoundDecorator();
            }
          }
        },

        /**
         * @inheritDoc
         */
        setVisibleRows: function(visibleRows) {
          if (this._visibleRows !== visibleRows) {
            this._needToUpdateVerticalScroll = true;
            this._visibleRows = visibleRows;
            const rows = this.getChildren();
            for (let i = 0; i < rows.length; ++i) {
              const row = rows[i];
              row.setHidden(i >= visibleRows);
            }
          }
        },

        /**
         * @inheritDoc
         */
        setRowHeight: function(height) {
          if (this._rowHeight !== height) {
            this._rowHeight = height;
            this.setStyle(" .gbc_ListViewRowWidget", {
              "height": height + "px"
            });

            this.setStyle(" .gbc_ImageWidget", {
              "height": height + "px"
            });

            this.updateVerticalScroll(true); // refresh vertical scroll if row height has changed
          }
        },

        /**
         * @inheritDoc
         */
        setVerticalScroll: function(offset, forceScroll = false) {

          if (this._size !== null) {
            let top = 0;
            let height = 0;

            if (this.isEnabled()) {
              top = offset * this.getRowHeight();
              height = (this._size - offset) * this.getRowHeight();
            } else {
              height = this._visibleRows * this.getRowHeight();
            }

            this.setStyle({
              preSelector: ".g_measured ",
              selector: ".gbc_ListViewRowsContainer"
            }, {
              "margin-top": top + "px",
              "height": height + "px"
            });

            // if offset is different or if scrolltop value of current scrollarea is different too different from calculated value
            // need to rest scrolltop of scrollablearea
            if (forceScroll || (this.lastSentOffset === null || this.lastSentOffset === offset) && offset !== this._offset) {
              this._offset = offset;
              // need to do this because to scroll we need to wait the style "height" set just before is really applied in the dom
              this.afterDomMutator(function() {
                this.doScroll(top, false);
              }.bind(this));
            }
            this.lastSentOffset = null;
          }
        },

        /**
         * Returns if vertical scroll bar is at end
         * @returns {boolean} true if vertical Scroll bar is at end
         */
        isVerticalScrollAtEnd: function() {
          const scrollArea = this.getScrollableArea();
          return (scrollArea.scrollTop + scrollArea.clientHeight) === scrollArea.scrollHeight;
        },

        /**
         * Do native vertical scroll
         * @param {number} value - new scroll value
         * @param {boolean} delta - if true, value is added to old scroll value
         */
        doScroll: function(value, delta) {
          const isTableVisible = this.isVisibleRecursively();

          if (isTableVisible) {
            let top = value;

            if (delta) {
              top = (this.getScrollableArea().scrollTop + value);
            }

            if (this.getScrollableArea().scrollTop !== top) {
              this._userScrollAction = false;
              this._isScrollEventManuallyTriggered = true;
              this.getScrollableArea().scrollTop = top;
            }
          } else {
            this._needToUpdateVerticalScroll = true;
          }
        },

        /**
         * @inheritDoc
         */
        setCurrentRow: function(row, ensureRowVisible = false, vmCurrentRow = null) {
          this._currentRow = row;
          const children = this.getChildren();
          const length = children.length;
          for (let i = 0; i < length; ++i) {
            const rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }
          this._needToUpdateVerticalScroll = true;
        },

        // ============== START - STYLE FUNCTIONS ===================
        /**
         * @inheritDoc
         */
        setHighlightColor: function(color) {

          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });

            this.setStyle({
              selector: this._highlightCurrentRowCssSelector + " *",
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightTextColor: function(color) {

          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector + " *",
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });
          }
        },

        /**
         * @inheritDoc
         */
        setHighlightCurrentRow: function(b) {
          this._highlightCurrentRow = b;
          this.getElement().toggleClass("highlight", b);
          this.getElement().toggleClass("nohighlight", !b);
        },

        /**
         * Update highlight row
         */
        updateHighlight: function() {
          this.setCurrentRow(this._currentRow);
        },

        // ============== END - STYLE FUNCTIONS ===================

        // ============== START - DOM ELEMENT GETTERS ===================
        /**
         * @inheritDoc
         */
        getScrollableArea: function() {
          if (!this._scrollAreaElement) {
            this._scrollAreaElement = this._element.getElementsByClassName("gbc_ListViewScrollArea")[0];
          }
          return this._scrollAreaElement;
        }
        // ============== END - DOM ELEMENT GETTERS =====================
      };
    });
    cls.WidgetFactory.registerBuilder("RTable[tableType=listView]", cls.ListViewWidget);
  });
;

"use strict";

modulum('ModalWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Modal widget.
     * @class ModalWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ModalWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.ModalWidget.prototype */ {
        __name: "ModalWidget",
        /**
         * header element
         * @type {HTMLElement}
         */
        _header: null,
        /**
         * header hidden state
         * @type {boolean}
         */
        _headerHidden: false,
        /**
         * footer element
         * @type {HTMLElement}
         */
        _footer: null,
        /**
         * title element
         * @type {HTMLElement}
         */
        _title: null,
        /**
         * dialog pane element
         * @type {HTMLElement}
         */
        _dialogPane: null,

        /**
         * header actions host element
         * @type {HTMLElement}
         */
        _actionsHost: null,
        /**
         * close button element
         * @type {HTMLElement}
         */
        _closeButton: null,

        /**
         * is displayed
         * @type {boolean}
         */
        _displayed: false,
        /**
         * is a system modal
         * @type {boolean}
         */
        _systemModal: false,
        /**
         * resize handler
         */
        _systemModalResizeHandler: null,

        /**
         * flag to set first fixed size
         * @type {boolean}
         */
        _hasInitialContainment: true,
        /**
         * is movable
         * @type {boolean}
         */
        _canMove: false,
        /**
         * has it moved
         * @type {boolean}
         */
        _hasBeenMoved: false,
        /**
         * internal computing information
         * @type {?{current:{x:number, y:number}, reference:{x:number, y:number}, minDelta:{x:number, y:number}, maxDelta:{x:number, y:number}, drag:{x:number, y:number}}}
         */
        _movingPositions: null,
        /**
         * is it moving
         * @type {boolean}
         */
        _isMoving: false,
        /**
         * move drag handle element
         * @type {HTMLElement}
         */
        _movableDragHandle: null,
        /**
         * has been positioned by VM
         * @type {boolean}
         */
        _positionedByVm: false,
        /** @type {Object} **/
        _initialVmPosition: null,

        /**
         * is it sizable
         * @type {boolean}
         */
        _canSize: false,
        /**
         * has it resized
         * @type {boolean}
         */
        _hasBeenSized: false,
        /**
         * internal computing information
         * @type {?{current:{x:number, y:number}, size:{x:number, y:number}, min:{x:number, y:number}, max:{x:number, y:number}, contentMin:{x:number, y:number}, decoration:{x:number, y:number}, drag:{x:number, y:number}}}
         */
        _sizingPositions: null,
        /**
         * is it resizing
         * @type {boolean}
         */
        _isSizing: false,
        /**
         * resize drag handle element
         * @type {HTMLElement}
         */
        _sizableDragHandle: null,
        /**
         * resize drag indicator element
         * @type {HTMLElement}
         */
        _resizerIcon: null,
        /**
         * is modal closable. Yes by default.
         * @type {boolean}
         */
        _isClosable: true,

        /**
         * Directly hide on click
         * @type {boolean}
         */
        _directlyHide: false,

        /**
         * Hide on overlay click
         * @type {boolean}
         */
        _hideOnClickOut: false,

        /**
         * Should the modal Widget reset its transformations at start
         * @type {boolean}
         */
        _forceDefaultSettings: false,

        constructor: function(opts) {
          // Build the storedSettingsKey for this modal
          this._storedSettingsKey = `${opts.storedSettingsKey}.modal`;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._header = this._element.getElementsByClassName('mt-dialog-header')[0];
          this._header.toggleClass("hidden", false);
          this._footer = this._element.getElementsByClassName('mt-dialog-footer')[0];
          this._title = this._header.getElementsByClassName('mt-dialog-title')[0];
          this._actionsHost = this._header.getElementsByClassName('mt-dialog-actions')[0];
          this._dialogPane = this._element.querySelector(".mt-dialog-pane");
          this._closeButton = this._actionsHost.getElementsByClassName('close')[0];
          this._resizerIcon = this._element.getElementsByClassName("mt-resizer-icon")[0];
          this._initMovable();
          this._initSizable();
          this.restoreStoredDimension();
          this.restorePosition();
          this.setMovable(true);
        },

        resetLayout: function() {
          this._hasInitialContainment = true;
          this._hasBeenMoved = false;
          this._hasBeenSized = false;
          this._dialogPane.style.top = "auto";
          this._dialogPane.style.right = "auto";
          this._dialogPane.style.bottom = "auto";
          this._dialogPane.style.left = "auto";
          this._dialogPane.style.width = "auto";
          this._dialogPane.style.height = "auto";
          this._dialogPane.removeClass("moved");
          this._dialogPane.removeClass("sized");
          this._resetMovable();
          this._resetSizable();
          this.getLayoutEngine().reset(true);
          this.getLayoutInformation().reset(true);
        },
        /**
         * set first fixed size
         * @private
         */
        _removeInitialContainment: function() {
          if (this._hasInitialContainment) {
            this._hasInitialContainment = false;
            const containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect();
            this._setAsMoved(
              this.isReversed() ? containerRect.right - dialogRect.right : (dialogRect.left - containerRect.left),
              dialogRect.top - containerRect.top);
            this._dialogPane.removeClass("initial");
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.hasClass("close") || domEvent.target.parentElement.hasClass("close")) {
            if (this._directlyHide) {
              this.hide();
            }
            this.emit(context.constants.widgetEvents.close);
          }

          // backdrop click
          if (domEvent.target === this._element) {
            if (this._hideOnClickOut) {
              this.hide();
            }
            this.emit(context.constants.widgetEvents.modalOut);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          // Double click on resizer restore default size
          if (domEvent.target.isElementOrChildOf(this._resizer)) {
            this.resetDimension();
          }
          // Double click on header restore default position
          if (domEvent.target.isElementOrChildOf(this._header)) {
            this.resetPosition();
          }
          return true;
        },

        /**
         * Make the modal window movable
         * @param {boolean} movable will it be movable
         */
        setMovable: function(movable) {
          this._canMove = movable;
          this._element.toggleClass("movable", movable);
        },

        /**
         * Start the movable process
         * @private
         */
        _initMovable: function() {
          this._resetMovable();
          this._movableDragHandle = this._element.getElementsByClassName("movable_firefox_placekeeper")[0];
          this._header.setAttribute("draggable", "true");
          this._header.on("dragstart.MovableModalWidget", this._onMovableDragStart.bind(this));
          this._header.on("dragend.MovableModalWidget", this._onMovableDragEnd.bind(this));
          this._header.on("drag.MovableModalWidget", this._onMovableDrag.bind(this));
        },

        _resetMovable: function() {
          this._movingPositions = {
            reference: {
              x: 0,
              y: 0
            },
            current: {
              x: 0,
              y: 0
            },
            minDelta: {
              x: 0,
              y: 0
            },
            maxDelta: {
              x: 0,
              y: 0
            },
            drag: {
              x: 0,
              y: 0
            }
          };
        },

        /**
         * handle on drag over for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragOver: function(evt) {
          this._movingPositions.current.x = evt.pageX;
          this._movingPositions.current.y = evt.pageY;
          evt.preventCancelableDefault();
        },

        /**
         * Move Modal at given position
         * @param {number} x - horizontal position
         * @param {number} y - vertical position
         */
        setPosition: function(x, y) {
          // this comes from external class (mostly 4ST position:field/center) : don't save in storedSettings
          this._positionedByVm = true;
          this._initialVmPosition = {
            x,
            y
          };
          this._setAsMoved(x, y);
          if (!this.isInViewport()) {
            this.resetDimension();
          }
        },

        /**
         * move at given position
         * @param {number} x x position
         * @param {number} y y position
         * @private
         */
        _setAsMoved: function(x, y) {
          this._dialogPane.addClass("moved");
          this._removeInitialContainment();
          this._movingPositions.reference.x = x;
          this._movingPositions.reference.y = y;
          this._dialogPane.style.left = this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x) + "px");
          this._dialogPane.style.right = !this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x) + "px");
          this._dialogPane.style.top = "" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions
              .reference
              .y) +
            "px";

          this._hasBeenMoved = true;
        },
        _resetAsMoved: function() {
          this._dialogPane.removeClass("moved");
          this._movingPositions.reference.x = 0;
          this._movingPositions.reference.y = 0;
          this._dialogPane.style.top = "auto";
          this._dialogPane.style.right = "auto";
          this._dialogPane.style.bottom = "auto";
          this._dialogPane.style.left = "auto";
          this._hasBeenMoved = true;
        },

        /**
         * Ensure the modal is fully visible in viewPort, will reset position if not
         */
        ensureInViewPort: function() {
          if (!this.isInViewport() && !this._isSizing) {
            this.resetDimension();
            this.resetPosition();
          }
        },

        /**
         * Save Layout measured Info for sizing / positioning modal
         * @param {classes.Size} info - the measured size to store
         */
        setMeasuredInfo: function(info) {
          this._measuredInfo = info;
        },
        /**
         * handle on drag start for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragStart: function(evt) {
          if (this._canMove) {
            this._element.addClass("moving");
            const containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect();
            if (!this._hasBeenMoved) {
              this._setAsMoved(this.isReversed() ? containerRect.right - dialogRect.right : (dialogRect.left - containerRect.left),
                dialogRect.top - containerRect.top);
            }
            this._movingPositions.minDelta.x =
              (this.isReversed() ? dialogRect.right - containerRect.right : (containerRect.left - dialogRect.left)) +
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this._movingPositions.minDelta.y = containerRect.top - dialogRect.top + context.ThemeService.getValue(
              "theme-margin-ratio") * 8;
            this._movingPositions.maxDelta.x =
              (this.isReversed() ?
                dialogRect.right - containerRect.right + containerRect.width - dialogRect.width :
                (containerRect.left - dialogRect.left + containerRect.width - dialogRect.width)) -
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this._movingPositions.maxDelta.y = containerRect.height + containerRect.top - dialogRect.height - dialogRect.top -
              context.ThemeService.getValue("theme-margin-ratio") * 8;
            this.getElement().on("dragover.MovableModalWidget", this._onMovableDragOver.bind(this));
            this._isMoving = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._movableDragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._movingPositions.current.x = evt.pageX;
            this._movingPositions.current.y = evt.pageY;
            this._movingPositions.drag.x = evt.pageX;
            this._movingPositions.drag.y = evt.pageY;
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        /**
         * handle on drag end for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDragEnd: function(evt) {
          this._element.removeClass("moving");
          this.getElement().off("dragover.MovableModalWidget");
          const deltaX = (this._movingPositions.current.x - this._movingPositions.drag.x) * (this.isReversed() ? -1 : 1);
          const deltaY = this._movingPositions.current.y - this._movingPositions.drag.y;
          if (deltaX * deltaX + deltaY * deltaY > 16 * 16) {
            this._movingPositions.reference.x =
              Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x +
                Math.min(Math.max(deltaX, this._movingPositions.minDelta.x), this._movingPositions.maxDelta.x));
            this._movingPositions.reference.y =
              Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.y +
                Math.min(Math.max(deltaY, this._movingPositions.minDelta.y), this._movingPositions.maxDelta.y));
            this._isMoving = false;
          }
          this.savePosition();
        },

        /**
         * handle on drag for move
         * @param {MouseEvent} evt the event
         * @private
         */
        _onMovableDrag: function(evt) {
          if (this._isMoving) {
            const deltaX = (this._movingPositions.current.x - this._movingPositions.drag.x) * (this.isReversed() ? -1 : 1);
            const deltaY = this._movingPositions.current.y - this._movingPositions.drag.y;
            if (deltaX * deltaX + deltaY * deltaY > 100) {
              this._updateMovablePosition(
                Math.min(Math.max(deltaX, this._movingPositions.minDelta.x), this._movingPositions.maxDelta.x),
                Math.min(Math.max(deltaY, this._movingPositions.minDelta.y), this._movingPositions.maxDelta.y)
              );
            }
          }
        },

        /**
         * update visual position when moving
         * @param {number} deltaX x position delta
         * @param {number} deltaY y position delta
         * @private
         */
        _updateMovablePosition: function(deltaX, deltaY) {
          this._dialogPane.style.left = this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x + deltaX) +
              "px");
          this._dialogPane.style.right = !this.isReversed() ? "" :
            ("" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions.reference.x + deltaX) +
              "px");
          this._dialogPane.style.top = "" + Math.max(context.ThemeService.getValue("theme-margin-ratio") * 8, this._movingPositions
            .reference
            .y +
            deltaY) + "px";
        },

        /**
         * Make the modal window resizable
         * @param {boolean} sizable will it be sizable
         */
        setSizable: function(sizable) {
          this._canSize = sizable;
          this._element.toggleClass("sizable", sizable);
        },
        /**
         * init sizable data
         * @private
         */
        _initSizable: function() {
          this._resetSizable();
          this._resizer = this._element.querySelector(".mt-dialog-resizer");
          this._sizableDragHandle = this._element.getElementsByClassName("sizable_firefox_placekeeper")[0];
          this._resizer.setAttribute("draggable", "true");
          this._resizer.on("dragstart.SizableModalWidget", this._onSizableDragStart.bind(this));
          this._resizer.on("dragend.SizableModalWidget", this._onSizableDragEnd.bind(this));
          this._resizer.on("drag.SizableModalWidget", this._onSizableDrag.bind(this));
        },

        _resetSizable: function() {
          this._sizingPositions = {
            size: {
              x: 0,
              y: 0
            },
            reference: {
              x: 0,
              y: 0
            },
            current: {
              x: 0,
              y: 0
            },
            min: {
              x: 0,
              y: 0
            },
            contentMin: {
              x: 0,
              y: 0
            },
            max: {
              x: 0,
              y: 0
            },
            drag: {
              x: 0,
              y: 0
            },
            decoration: {
              x: 0,
              y: 0
            }
          };
        },

        /**
         * handle on drag over for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragOver: function(evt) {
          this._sizingPositions.current.x = evt.pageX;
          this._sizingPositions.current.y = evt.pageY;
          evt.preventCancelableDefault();
        },
        /**
         * handle on drag start for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragStart: function(evt) {
          if (this._canSize) {
            this._element.addClass("sizing");
            const containerRect = this.getElement().getBoundingClientRect(),
              dialogRect = this._dialogPane.getBoundingClientRect(),
              contentRect = (this._element.querySelector(".gbc_WindowContent") || this._containerElement).getBoundingClientRect();
            if (!this._hasBeenMoved) {
              this._setAsMoved(dialogRect.left - containerRect.left, dialogRect.top - containerRect.top);
            }
            if (!this._hasBeenSized) {
              this._dialogPane.addClass("sized");
              this._removeInitialContainment();
              this._sizingPositions.min.x = dialogRect.width;
              this._sizingPositions.min.y = dialogRect.height;
              this._hasBeenSized = true;
            }
            this._sizingPositions.decoration.x = dialogRect.width - contentRect.width;
            this._sizingPositions.decoration.y = dialogRect.height - contentRect.height;

            // min value between initial rendered size and min size defined by layout engine
            this._sizingPositions.min.x = Math.min(this._sizingPositions.contentMin.x ?
              this._sizingPositions.contentMin.x + this._sizingPositions.decoration.x + window.scrollBarSize : dialogRect.width, this
              ._sizingPositions.min.x);
            this._sizingPositions.min.y = Math.min(this._sizingPositions.contentMin.y ?
              this._sizingPositions.contentMin.y + this._sizingPositions.decoration.y + window.scrollBarSize : dialogRect.height, this
              ._sizingPositions.min.y);
            this._sizingPositions.size.x = this._sizingPositions.reference.x = dialogRect.width;
            this._sizingPositions.size.y = this._sizingPositions.reference.y = dialogRect.height;

            this._sizingPositions.max.x = (this.isReversed() ?
                containerRect.width + dialogRect.right - containerRect.right :
                (containerRect.width - dialogRect.left + containerRect.left)) - context.ThemeService.getValue(
                "theme-margin-ratio") *
              8;
            this._sizingPositions.max.y = containerRect.height - dialogRect.top +
              containerRect.top - context.ThemeService.getValue("theme-margin-ratio") * 8;
            this.getElement().on("dragover.SizableModalWidget", this._onSizableDragOver.bind(this));
            this._isSizing = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._sizableDragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._sizingPositions.current.x = evt.pageX;
            this._sizingPositions.current.y = evt.pageY;
            this._sizingPositions.drag.x = evt.pageX;
            this._sizingPositions.drag.y = evt.pageY;
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        /**
         * handle on drag end for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDragEnd: function(evt) {
          this._element.removeClass("sizing");
          this.getElement().off("dragover.SizableModalWidget");
          const deltaX = this._sizingPositions.reference.x + (this._sizingPositions.current.x - this._sizingPositions.drag.x) * (this
            .isReversed() ? -1 : 1);
          const deltaY = this._sizingPositions.reference.y + this._sizingPositions.current.y - this._sizingPositions.drag.y;
          this._sizingPositions.reference.x = Math.min(Math.max(deltaX, this._sizingPositions.min.x), this._sizingPositions.max.x);
          this._sizingPositions.reference.y = Math.min(Math.max(deltaY, this._sizingPositions.min.y), this._sizingPositions.max.y);
          this._sizingPositions.size.x = this._sizingPositions.reference.x;
          this._sizingPositions.size.y = this._sizingPositions.reference.y;
          this._isSizing = false;

          this.emit(context.constants.widgetEvents.modalResize);
          this.saveDimension();
          this.savePosition(); // save position as we want to put it where it was
        },

        /**
         * handle on drag for resize
         * @param {MouseEvent} evt the event
         * @private
         */
        _onSizableDrag: function(evt) {
          if (this._isSizing) {
            const deltaX = this._sizingPositions.reference.x + (this._sizingPositions.current.x - this._sizingPositions.drag.x) * (
              this.isReversed() ? -1 : 1);
            const deltaY = this._sizingPositions.reference.y + this._sizingPositions.current.y - this._sizingPositions.drag.y;
            this._sizingPositions.size.x = Math.min(Math.max(deltaX, this._sizingPositions.min.x), this._sizingPositions.max.x);
            this._sizingPositions.size.y = Math.min(Math.max(deltaY, this._sizingPositions.min.y), this._sizingPositions.max.y);
            this._updateSizablePosition(this._sizingPositions.size.x, this._sizingPositions.size.y);
          }
        },
        /**
         * update visual size when resizing
         * @param {number} deltaX x position delta
         * @param {number} deltaY y position delta
         * @private
         */
        _updateSizablePosition: function(deltaX, deltaY) {
          this._dialogPane.style.width = "" + deltaX + "px";
          this._dialogPane.style.height = "" + deltaY + "px";
          this.emit(context.constants.widgetEvents.modalResize);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._element) {
            this._element.off("keydown.ModalWidget");
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          if (this._systemModalResizeHandler) {
            this._systemModalResizeHandler();
            this._systemModalResizeHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * Set that the modal is only for GBC
         */
        _gbcSystemModal: function() {
          this._systemModal = true;
          this._element.addClass("gbc_SystemModal");
          this._element.setAttribute("tabindex", "0");
          if (!this._systemModalResizeHandler) {
            this._systemModalResizeHandler = context.HostService.onScreenResize(this.resizeHandler.bind(this));
          }
          this._element.domFocus();
          // do not propagate key event  to avoid sending them to VM
          this._element.on("keydown.ModalWidget", function(evt) {
            if (evt.keyCode === 27) {
              this.hide();
              if (!this.isDestroyed()) {
                this.destroy();
              }
            }
            evt.stopPropagation();
            // TODO we should prevent default browser behavior for CTRL+A, CTRL+P, CTRL+S, BACKSPACE
            // like in gbc.js document.body.addEventListener('keydown', function(event) {
          }.bind(this));
          gbc.LogService.ui.log("SystemModal open", true, this.__name, this);
        },
        /**
         * fired when resizing
         */
        resizeHandler: function() {
          if (this._element) {
            this._element.toggleClass("left-realign", this._dialogPane.offsetWidth > this._element.offsetWidth);
            this._element.toggleClass("top-realign", this._dialogPane.offsetHeight > this._element.offsetHeight);
          }
        },

        /**
         * Save current modal Positions to StoredSettings
         * Won't store it if positioned by VM or system modal, or 4ST forceDefaultSettings is true
         */
        savePosition: function() {
          if (!this._positionedByVm && !this._systemModal && !this._forceDefaultSettings) {
            gbc.StoredSettingsService.setSettings(this._storedSettingsKey + ".position", this._movingPositions);
            gbc.LogService.ui.log("ModalWidget - Moved -> saved Position in stored settings");
          }
        },

        /**
         * Cancel all manual positioning of the modal to initial
         */
        resetPosition: function() {
          gbc.LogService.ui.log("ModalWidget - restore original Position");
          gbc.StoredSettingsService.setSettings(this._storedSettingsKey + ".position", null);
          this._hasBeenMoved = false;

          // Take care of the reset position for modal positioned by VM
          if (this._positionedByVm) {
            this._setAsMoved(this._initialVmPosition.x, this._initialVmPosition.y);
            return;
          }
          this._dialogPane.style.top = "auto";
          this._dialogPane.style.right = "auto";
          this._dialogPane.style.bottom = "auto";
          this._dialogPane.style.left = "auto";
          this._dialogPane.removeClass("moved");
          this._resetMovable();
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().reset(true);
            this.getLayoutInformation().reset(true);
          }
          this.emit(context.constants.widgetEvents.modalResize);
        },

        /**
         * Restore modal position from StoredSettings
         */
        restorePosition: function() {
          const storedMovingPositions = gbc.StoredSettingsService.getSettings(this._storedSettingsKey + ".position");
          if (storedMovingPositions) {
            gbc.LogService.ui.log("ModalWidget - restore Position from stored settings");
            const {
              x,
              y
            } = storedMovingPositions.reference;
            this._setAsMoved(x, y); // restore position
          }
        },

        /**
         * Save current modal Dimensions to StoredSettings
         * Won't store it if system modal, or 4ST forceDefaultSettings is true
         */
        saveDimension: function() {
          if (!this._systemModal && !this._forceDefaultSettings) {
            gbc.StoredSettingsService.setSettings(this._storedSettingsKey + ".dimension", this._sizingPositions);
            gbc.LogService.ui.log("ModalWidget - Resized -> saved Dimensions in stored settings");
          }
        },

        /**
         * Cancel all dimensioning of the modal to initial
         */
        resetDimension: function() {
          gbc.LogService.ui.log("ModalWidget - restore original Dimensions");
          gbc.StoredSettingsService.setSettings(this._storedSettingsKey + ".dimension", null);
          this._hasBeenSized = false;
          this._dialogPane.style.width = "auto";
          this._dialogPane.style.height = "auto";
          this._dialogPane.removeClass("sized");
          this._resetSizable();
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().reset(true);
            this.getLayoutInformation().reset(true);
          }
          this.emit(context.constants.widgetEvents.modalResize);
        },

        /**
         * Restore modal Dimensions from StoredSettings
         */
        restoreStoredDimension: function() {
          const storedSizingPositions = gbc.StoredSettingsService.getSettings(this._storedSettingsKey + ".dimension");
          if (storedSizingPositions) {
            gbc.LogService.ui.log("ModalWidget - restore Dimensions from stored settings");
            this._sizingPositions = storedSizingPositions;
            // Cannot restore dimension if the modal isn't in the viewport
            if (!this.isInViewport()) {
              this.resetDimension(); //reset initial dimension
              return;
            }
            this._dialogPane.style.width = this._sizingPositions.size.x + "px";
            this._dialogPane.style.height = this._sizingPositions.size.y + "px";
            this._hasBeenSized = true;
            this.emit(context.constants.widgetEvents.modalResize);
          }
        },

        /**
         * Check if modal is fully in the viewport
         * @return {boolean} - true if in viewport, false otherwise
         */
        isInViewport: function() {
          const {
            innerWidth,
            innerHeight
          } = window;

          const rect = this._dialogPane.getBoundingClientRect();

          const inViewPort = {
            x: rect.x + rect.width < innerWidth,
            y: rect.y + rect.height < innerHeight
          };

          return inViewPort.x && inViewPort.y;
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          this._backgroundColor = color;
          this.setStyle('.mt-dialog-pane', {
            "background-color": color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * set the modal header
         * @param {string|HTMLElement} header the header
         */
        setHeader: function(header) {
          if (Object.isString(header)) {
            this._header.toggleClass("hidden", (header.length === 0) || this._headerHidden);
            this._title.textContent = header;
          } else {
            this._title.empty();
            if (header) {
              this._title.appendChild(header);
            }
          }
        },

        /**
         * Returns header element
         * @returns {HTMLElement}
         */
        getHeader: function() {
          return this._header;
        },

        /**
         * set header raw hidden state
         * @param {boolean} headerHidden is header hidden
         */
        setHeaderHidden: function(headerHidden) {
          if (headerHidden !== this._headerHidden) {
            this._headerHidden = Boolean(headerHidden);
            this._header.toggleClass("hidden", (this._title.textContent.length === 0) || this._headerHidden);
          }
        },
        /**
         * Set the image of the modal widget
         * @param {string} image the image src
         */
        setImage: function(image) {
          if (image && image !== "") {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
              this._title.parentNode.insertBefore(this._image.getElement(), this._title);
            }
            this._image.setSrc(image);
          }
        },

        /**
         * set the modal footer
         * @param {string|HTMLElement} footer - the footer
         */
        setFooter: function(footer) {
          if (Object.isString(footer)) {
            this._footer.textContent = footer;
          } else {
            this._footer.empty();
            if (footer) {
              this._footer.appendChild(footer);
            }
          }
        },

        /**
         * Return footer element
         * @returns {HTMLElement}
         */
        getFooter: function() {
          return this._footer;
        },

        /**
         * set the modal content
         * @param {string|HTMLElement} content - the content
         */
        setContent: function(content) {
          if (Object.isString(content)) {
            this._containerElement.textContent = content;
          } else {
            if (this._containerElement.children.length !== 1 ||
              this._containerElement.children[0] !== content) {
              // Setting this._containerElement.innerHTML = "" can cause unwanted cleaning under IE11. In our case content.innerHTML gets cleaned (GBC-727). Prefer cleaning by looping on children
              this._containerElement.empty();
              if (content) {
                this._containerElement.appendChild(content);
              }
            }
          }
        },

        /**
         * Set the modal closable
         * @param {boolean} closable -  true if the dialog is closable, false otherwise
         * @param {boolean} directlyHide -
         * @param {boolean} hideOnClickOut - true if dialg should be hidden when user click outside of modal
         */
        setClosable: function(closable, directlyHide, hideOnClickOut) {
          if (closable) {
            this._closeButton.removeClass("hidden");
          } else {
            this._closeButton.addClass("hidden");
          }
          this._isClosable = !!closable;
          this._directlyHide = !!directlyHide;
          this._hideOnClickOut = !!hideOnClickOut;

        },

        /**
         * is the modal closable
         * @returns {boolean} true if the dialog is closable, false otherwise
         */
        isClosable: function() {
          return this._isClosable;
        },
        /**
         * show the modal
         */
        show: function() {
          if (this._element) {
            this._element.addClass("displayed");
          }
          this._displayed = true;

          if (this._systemModal) {
            gbc.systemModalOpened = true;
            this._element.domFocus();
            this.resizeHandler();
          }
        },
        /**
         * hide the modal
         */
        hide: function() {
          if (this._element && this.isVisible()) {
            this._element.removeClass("displayed");
            this._displayed = false;
            this.emit(context.constants.widgetEvents.close);
          }
          if (this._systemModal) {
            gbc.systemModalOpened = false;
            gbc.LogService.ui.log("SystemModal open", false, this.__name);
          }
        },
        /**
         * test if the modal is visible
         * @return {boolean} true if the modal is visible
         */
        isVisible: function() {
          return this._displayed;
        },
        /**
         * register a hook when modal is closed
         * @param {Hook} hook the hook to fire
         * @param {boolean=} once - if true, will only fire once
         * @return {HandleRegistration} a handle registration to free the hook
         */
        onClose: function(hook, once) {
          this.when(context.constants.widgetEvents.close, hook, once);
        },

        /**
         * Ignore stored Settings (for position and size)
         * @param {Boolean} forceDefaultSettings
         */
        setForceDefaultSettings: function(forceDefaultSettings) {
          this._forceDefaultSettings = forceDefaultSettings;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Modal', cls.ModalWidget);
  });
;

"use strict";

modulum('PagedScrollGridWidget', ['StretchableScrollGridWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Paged Scroll Grid widget to display Scroll grid with tiles
     * @class PagedScrollGridWidget
     * @memberOf classes
     * @extends classes.StretchableScrollGridWidgetBase
     * @publicdoc
     */
    cls.PagedScrollGridWidget = context.oo.Class(cls.StretchableScrollGridWidgetBase, function($super) {

      return /** @lends classes.PagedScrollGridWidget.prototype */ {
        __name: "PagedScrollGridWidget",
        _currentRow: 0,

        _paginationWidget: null,
        _onOffsetHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._paginationWidget = cls.WidgetFactory.createWidget("Pagination", this.getBuildParameters());
          this._paginationWidget.setParentWidget(this);
          this._element.appendChild(this._paginationWidget.getElement());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._onOffsetHandler) {
            this._onOffsetHandler();
            this._onOffsetHandler = null;
          }
          this._paginationWidget.destroy();
          this._paginationWidget = null;

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target.isElementOrChildOf(this._containerElement)) {
            cls.ScrollGridWidget._onClick.call(this, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          if (domEvent.target.isElementOrChildOf(this._containerElement)) {
            cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          widget.removeClass("gbc_WidgetBase_standalone");
          widget.addClass("gbc_WidgetBase_in_array");
        },

        /**
         * Get the Data area height
         * @returns {number} scroll data area width
         */
        getDataAreaWidth: function() {
          // TODO perf use layoutInformation
          return this.getContainerElement().getBoundingClientRect().width;
        },

        /**
         * Get the Data area height
         * @returns {number} scroll data area height
         */
        getDataAreaHeight: function() {
          // TODO perf use layoutInformation
          return this.getContainerElement().getBoundingClientRect().height;
        },

        /**
         * Get the width of a Row
         * @return {number} row width or 1;
         */
        getRowWidth: function() {
          const children = this.getChildren();
          if (children.length !== 0) {
            return children[0].getElement().getBoundingClientRect().width;
          }
          return 0;
        },

        /**
         * Get the height of a Row
         * @return {number} row height or 1;
         */
        getRowHeight: function() {
          const children = this.getChildren();
          if (children.length !== 0) {
            return children[0].getElement().getBoundingClientRect().height;
          }
          return 0;
        },

        /**
         * @param {number} size - size of the dataset
         * @param {number} pageSize - viewport size
         * @param {number} offset - viewport offset
         */
        setVerticalScroll: function(size, pageSize, offset) {
          this._paginationWidget.update(size, pageSize, offset);
        },

        /**
         * @return {classes.PaginationWidget} the pagination widget
         */
        getPaginationWidget: function() {
          return this._paginationWidget;
        },

        /**
         * Set how children will align
         * @param {string} alignment
         */
        setItemsAlignment: function(alignment) {
          if (this._containerElement) {
            this._containerElement.style.justifyContent = {
              start: "flex-start",
              left: "flex-start",
              center: "center",
              right: "flex-end",
              end: "flex-end"
            } [alignment] || "flex-start";
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollGrid[customWidget=pagedScrollGrid]', cls.PagedScrollGridWidget);
    cls.WidgetFactory.registerBuilder('StretchableScrollGrid[customWidget=pagedScrollGrid]', cls.PagedScrollGridWidget);
  });
;

"use strict";

modulum('PageTitleWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Page title in folder widget.
     * @class PageTitleWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.PageTitleWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.PageTitleWidget.prototype */ {
        __name: "PageTitleWidget",

        /** @type {classes.ImageWidget} */
        _image: null,
        /** @type {HTMLElement} */
        _titleElement: null,
        /** @type {HTMLElement} */
        _actionsContainerElement: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._titleElement = this._element.getElementsByClassName("mt-tab-title-text")[0];
          this._actionsContainerElement = this._element.getElementsByClassName("mt-tab-title-actions")[0];
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._actionsContainerElement = null;
          this._titleElement = null;
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * Set the page title text
         * @param {string} text the text to display
         * @publicdoc
         */
        setText: function(text) {
          if (text !== null) {
            const title = text.replace(/&(.)/g, "$1");
            this._setTextContent(title, "_titleElement");
            if (!this.getTitle()) { // fallback if no title defined
              this.setTitle(title);
            }
          }
        },

        /**
         * Set the dom title of the pageTitle widget
         * @param {string} title - text to display as title
         */
        setTitle: function(title) {
          this.domAttributesMutator(function() {
            this._titleElement.title = title;
          }.bind(this));
        },

        /**
         * Get the dom title of the pageTitle widget
         * @return {string} text displayed as title
         */
        getTitle: function() {
          return this._titleElement.title;
        },

        /**
         * Get the page title text
         * @returns {string} the text displayed
         * @publicdoc
         */
        getText: function() {
          return this._titleElement.textContent;
        },

        /**
         * Get the action container element
         * @return {HTMLElement} the action container
         */
        getActionsContainerElement: function() {
          return this._actionsContainerElement;
        },

        /**
         * Define an image to display next to the title
         * @param {string} image the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        setImage: function(image) {
          if (!this._image) {
            const opts = this.getBuildParameters();
            opts.ignoreLayout = true;
            this._image = cls.WidgetFactory.createWidget("ImageWidget", opts);
            this._element.prependChild(this._image.getElement());
          }
          this._image.setHidden(true);
          if (image && image !== "") {
            this._image.setSrc(image);
            this._image.setHidden(false);
            if (!this._image.getTitle()) {
              this.domAttributesMutator(function() {
                this._image.setTitle(this._titleElement.title);
              }.bind(this));
            }
          }
        },

        /**
         * Get the image displayed next to the title
         * @returns {?string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Set the tab to be the current one
         * @param {boolean} current displays the current tab indicator
         * @publicdoc
         */
        setCurrent: function(current) {
          this._element.toggleClass("mt-tab-current", current);
          this.setAriaAttribute("selected", current.toString());
        },

        /**
         * Check if the tab is the current one
         * @returns {boolean} true if the current tab indicator is displayed
         * @publicdoc
         */
        isCurrent: function() {
          return this._element.hasClass("mt-tab-current");
        },

        /**
         * Define the position of the collapser icon
         * @param {string} pos - could be 'left' or 'right' (default)
         */
        setCollapserPosition: function(pos) {
          this.addClass("collapser-position-" + pos);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('PageTitle', cls.PageTitleWidget);
  });
;

"use strict";

modulum('PageWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Page widget.
     * @class PageWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.PageWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.PageWidget.prototype */ {
        __name: "PageWidget",

        /**
         * The title widget
         * @type {classes.PageTitleWidget}
         */
        _title: null,
        /** @function */
        _clickHandler: null,
        /** @function */
        _onActivationHandler: null,
        /** @function */
        _pageActivateHandler: null,
        /** @function */
        _pageDisableHandler: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._title = cls.WidgetFactory.createWidget("PageTitle", this.getBuildParameters());
          this._clickHandler = this._title.when(context.constants.widgetEvents.click, function(event) {
            const folderWidget = this.getParentWidget();
            if (folderWidget) {
              folderWidget.onTitleClick(this);
              this.emit(context.constants.widgetEvents.click, event);
            }
          }.bind(this));
          this._onActivationHandler = this.when(context.constants.widgetEvents.ready, this._onActivation.bind(this));
          this.setAriaAttribute("labelledby", this._title.getRootClassName());
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.PageLayoutInformation(this);
          this._layoutEngine = new cls.PageLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          if (this._pageDisableHandler) {
            this._pageDisableHandler();
            this._pageDisableHandler = null;
          }
          if (this._onActivationHandler) {
            this._onActivationHandler();
            this._onActivationHandler = null;
          }
          if (this._clickHandler) {
            this._clickHandler();
            this._clickHandler = null;
          }
          this._title.destroy();
          this._title = null;

          $super.destroy.call(this);
        },

        activate: function() {
          this.emit(context.constants.widgetEvents.activate, this);
        },

        onActivate: function(hook) {
          return this.when(context.constants.widgetEvents.activate, hook);
        },

        disable: function() {
          this.emit(context.constants.widgetEvents.disable);
        },

        onDisable: function(hook) {
          return this.when(context.constants.widgetEvents.disable, hook);
        },

        _onActivation: function(event, widget, parentPageWidget) {
          if (parentPageWidget) {
            this._pageActivateHandler = parentPageWidget.onActivate(this.activate.bind(this));
            this._pageDisableHandler = parentPageWidget.onDisable(this.disable.bind(this));
          }
        },

        /**
         * Returns index of the pager in the parent folder
         * @returns {number} index of the page in the folder
         */
        getPageIndex: function() {
          const parent = this.getParentWidget();
          if (parent) {
            return parent.getChildren().indexOf(this);
          }
          return -1;
        },

        /**
         * @returns {classes.PageTitleWidget} the title widget
         */
        getTitleWidget: function() {
          return this._title;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw new Error("A page can only contain a single child");
          }
          $super.addChildWidget.call(this, widget, options);
        },

        /**
         * @param {string} text the text to display in the header
         */
        setText: function(text) {
          this._title.setText(text);
        },

        /**
         * @returns {string} the text to display in the header
         */
        getText: function() {
          return this._title.getText();
        },

        /**
         * @param {string} title the text to display in the title
         */
        setTitle: function(title) {
          this._title.setTitle(title);
        },

        /**
         * @return {string} the title of the page
         */
        getTitle: function() {
          return this._title.getTitle();
        },

        /**
         * @param {string} image the URL of the image or a font-image URL: font:[fontname]:[character]:[color] to display in the header
         */
        setImage: function(image) {
          this._title.setImage(image);
        },

        /**
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         */
        getImage: function() {
          return this._title.getImage();
        },
        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== hidden) {
            this.getParentWidget().emit(context.constants.widgetEvents.pageVisibility);
          }

          $super.setHidden.call(this, hidden);
          this._title.setHidden(hidden);
          // if un-hiding a non-current page
          if (this.getParentWidget().getCurrentPage() !== this && !this.isHidden()) {
            //Need to add this page back in dom to calculate its size in case it's bigger than the current page
            this.addInDom();
          }

          // if current is hidden, we need to display another one
          if (this.getParentWidget().getCurrentPage() === this && this.isHidden()) {
            // if focused node is inside a folder page, display that one otherwise display next not hidden page.
            this.getParentWidget().updateCurrentPage();
          }

        },

        /**
         * @inheritDoc
         */
        isVisible: function() {
          return this.getParentWidget().getCurrentPage() === this && !this.isHidden();
        },
        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          return true;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Page', cls.PageWidget);
  });
;

"use strict";

modulum('PaginationWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Pagination buttons for a specified range
     * @class PaginationWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.PaginationWidget = context.oo.Class(cls.WidgetBase, function($super) {

      return /** @lends classes.PaginationWidget.prototype */ {
        __name: "PaginationWidget",

        /** @type {number} */
        _pageSize: 0,
        /** @type {number} */
        _size: 0,
        /** @type {number} */
        _offset: 0,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._navigationPrevPage = this._element.children[0];
          this._navigationNextPage = this._element.children[1];
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this._navigationPrevPage) {
            this._navigatePrevPage();
            return false;
          } else if (domEvent.target === this._navigationNextPage) {
            this._navigateNextPage();
            return false;
          } else if (domEvent.target.hasClass("navbutton")) {
            this._navigatePage(parseInt(domEvent.target.getAttribute("index")), domEvent);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._clearNavigationButtons();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // No layout used
        },

        /**
         * Updates the pagination content
         */
        _update: function() {
          let i;
          if (this._pageSize === 0) {
            // not initialized yet
            this._navigationPrevPage.toggleClass('disabled', false);
            this._navigationNextPage.toggleClass('disabled', false);
            return;
          }
          this._clearNavigationButtons();
          const pageCount = Math.ceil(this._size / this._pageSize);
          const current = Math.floor(this._offset / this._pageSize);
          if (pageCount <= 10) {
            for (i = 0; i < pageCount; ++i) {
              this._createNavigationButton(i, current);
            }
          } else {
            const maxButtons = 3;
            this._createNavigationButton(0, current);
            if (current < maxButtons - 1) {
              for (i = 1; i < maxButtons; ++i) {
                this._createNavigationButton(i, current);
              }
              this._createNavigationEllipsis();
            } else if (current > pageCount - maxButtons) {
              this._createNavigationEllipsis();
              for (i = pageCount - maxButtons - 1; i < pageCount - 1; ++i) {
                this._createNavigationButton(i, current);
              }
            } else {
              this._createNavigationEllipsis();
              const n = Math.floor(maxButtons / 2);
              for (i = current - n; i <= current + n; ++i) {
                this._createNavigationButton(i, current);
              }
              this._createNavigationEllipsis();
            }
            this._createNavigationButton(pageCount - 1, current);
          }
          this._navigationPrevPage.toggleClass('disabled', current === 0);
          this._navigationNextPage.toggleClass('disabled', current === pageCount - 1);
        },

        /**
         * Add a navigation button with index inside
         * @param {number} index - page linked to this button
         * @param {number} current - current page
         * @private
         */
        _createNavigationButton: function(index, current) {
          const span = document.createElement('span');
          span.addClass("navbutton");
          span.setAttribute("index", index);
          span.textContent = "" + (index + 1);
          if (index === current) {
            span.addClass('current');
          }
          this._element.insertBefore(span, this._navigationNextPage);
        },

        /**
         * Add ellipsis (...) to the navigation bar
         * @private
         */
        _createNavigationEllipsis: function() {
          const span = document.createElement('span');
          span.textContent = '\u2026';
          this._element.insertBefore(span, this._navigationNextPage);
        },

        /**
         * Handler to switch to previous page
         * @param {Object} event - DOM event
         */
        _navigatePrevPage: function(event) {
          if (!this._navigationPrevPage.hasClass('disabled')) {
            const offset = Math.max(0, this._offset - this._pageSize);
            this.getParentWidget().emit(context.constants.widgetEvents.offset, offset);
          }
        },

        /**
         * Handler to switch to next page
         * @param {Object} event - DOM event
         */
        _navigateNextPage: function(event) {
          if (!this._navigationNextPage.hasClass('disabled')) {
            const maxOffset = Math.floor(this._size / this._pageSize) * this._pageSize;
            const offset = Math.min(maxOffset, this._offset + this._pageSize);
            this.getParentWidget().emit(context.constants.widgetEvents.offset, offset);
          }
        },

        /**
         * Handler to switch to a given page
         * @param {number} index - page number to switch to
         * @param {Object} event - DOM event
         */
        _navigatePage: function(index, event) {
          const offset = index * this._pageSize;
          this.getParentWidget().emit(context.constants.widgetEvents.offset, offset);
        },

        /**
         * Unregister all navigation callbacks
         * @private
         */
        _clearNavigationButtons: function() {
          const children = this._element.children;
          while (children.length > 2) {
            // Remove ellipsis
            this._element.removeChild(children[1]);
          }
        },

        /**
         * @param {number} size - size of the dataset
         * @param {number} pageSize - viewport size
         * @param {number} offset - viewport offset
         */
        update: function(size, pageSize, offset) {
          this._size = size;
          this._pageSize = pageSize;
          this._offset = offset;
          this._update();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Pagination', cls.PaginationWidget);
  });
;

"use strict";

modulum('RTableColumnWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Responsive Table column widget.
     * @class RTableColumnWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.RTableColumnWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.RTableColumnWidget.prototype */ {
        // JS DOC definition
        /**
         * @typedef {Object} DragLimit
         * @property {number} min - The minimum index possible to drop on 
         * @property {number} max - The maximum index possible to drop on 
         */

        /** @inheritdoc */
        __name: "RTableColumnWidget",

        /** @type {boolean} */
        _isTreeView: false,

        /** @type {boolean} */
        _isAlwaysHidden: false,

        /** @type {boolean} */
        _isUnhidable: false,

        /** @type {boolean} */
        _isLeftFrozen: false,
        /** @type {boolean} */
        _isLastLeftFrozen: false,
        /** @type {boolean} */
        _isRightFrozen: false,
        /** @type {boolean} */
        _isFirstRightFrozen: false,

        /** @type {number} */
        _leftFrozenPosition: 0,
        /** @type {number} */
        _rightFrozenPosition: 0,

        /**
         * The aggregate widget
         * @type {classes.LabelWidget}
         */
        _aggregateLabelWidget: null,

        /** @type {classes.ContextMenuWidget} */
        _contextMenu: null,

        /**
         * column width (user value)
         * @type {number|null}
         */
        _userWidth: null,

        /** @type {boolean} */
        _isSorted: false,

        /**
         * column order
         * @type {number|null}
         */
        _order: null,

        /**
         * is column draggable/movable
         * @type {boolean}
         */
        _isMovable: true,

        /**
         * is column resizable
         * @type {boolean}
         */
        _isSizable: true,

        /** @type {boolean} */
        _isCurrent: false,

        /**
         * is column detached from dom
         * @type {boolean}
         */
        _detachedFromDom: false,

        /** @type {Object} **/
        _saveStyle: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          opts.inTable = true;
          this._isTreeView = opts.isTreeView;
          this._tableWidgetBase = opts.tableWidget;

          this.getTableWidgetBase().addColumn(this);
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._children = [];

          if (this._aggregateLabelWidget) {
            this._aggregateLabelWidget.destroy();
            this._aggregateLabelWidget = null;
          }

          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this._contextMenu && this._contextMenu.isVisible()) {
            keyProcessed = this._contextMenu.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!domEvent.target.hasClass("resizer") && !this.getTableWidgetBase()
            .isInputMode()) { // disable column header sorting in Input mode
            this.getTableWidgetBase().emit(context.constants.widgetEvents.tableHeaderSort, this.getColumnIndex());
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          let target = domEvent.target;

          // double click on resizer 
          if (target.hasClass("resizer") && !target.hasClass("unresizable")) {
            this.onResizerDoubleClick(domEvent);
            return false;
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseRightClick: function(domEvent) {
          if (!domEvent.shiftKey) {
            domEvent.preventCancelableDefault();
            this._buildContextMenu(domEvent);
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          options = options || {};
          options.isRowData = true;

          options.position = typeof(options.position) === "undefined" ? null : options.position;
          options.rowIndex = options.position !== null ? options.position : this._children.length;

          options.colWidget = this;

          if (this.isHidden()) { // if col is hidden do not add item in the DOM
            options.noDOMInsert = true;
            this.setDetachedFromDom(true);
          }
          this.getTableWidgetBase().addChildWidget(widget, options);
        },

        /**
         * Build context menu and show it
         */
        _buildContextMenu: function(domEvent) {

          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          let opts = this.getBuildParameters();
          opts.inTable = false; // contextmenu is not really in the table, it is outside
          opts.ignoreLayout = true;
          opts.unHidable = this.isUnhidable(); // pass unHidable param

          this._contextMenu = cls.WidgetFactory.createWidget("ContextMenu", opts);
          this._contextMenu.allowMultipleChoices(true);
          this._contextMenu.setParentWidget(this);
          this._contextMenu.setColor(this.getColor());
          this._contextMenu.setBackgroundColor(this.getBackgroundColor());
          this._contextMenu.onClose(function() {
            this.afterDomMutator(function() {
              if (this._contextMenu) {
                this._contextMenu.destroyChildren();
                this._contextMenu.destroy();
                this._contextMenu = null;
              }
            }.bind(this));
          }.bind(this), true);

          let tableWidget = this.getTableWidgetBase();
          let columns = tableWidget.getColumns();

          if (tableWidget.isFrozenTable()) {
            let leftFrozenLabel = cls.WidgetFactory.createWidget("Label", opts);
            let rightFrozenLabel = cls.WidgetFactory.createWidget("Label", opts);
            let unfreezeLabel = cls.WidgetFactory.createWidget("Label", opts);
            let freezeIndex = 0;
            let columnCount = 0;

            leftFrozenLabel.setValue(i18next.t("gwc.contextMenu.freezeLeft"));
            rightFrozenLabel.setValue(i18next.t("gwc.contextMenu.freezeRight"));
            unfreezeLabel.setValue(i18next.t("gwc.contextMenu.unfreezeAll"));

            leftFrozenLabel.addClass("gbc_freezeLeft_action");
            rightFrozenLabel.addClass("gbc_freezeRight_action");
            unfreezeLabel.addClass("gbc_unfreezeAll_action");

            leftFrozenLabel.setEnabled(!this.isRightFrozen());
            rightFrozenLabel.setEnabled(!this.isLeftFrozen());

            this._contextMenu.addChildWidget(leftFrozenLabel, {
              clickCallback: function() {
                if (leftFrozenLabel.isEnabled()) {
                  freezeIndex = this.getOrderedColumnIndex() + 1;
                  tableWidget.setLeftFrozenColumns(freezeIndex);
                  tableWidget.updateFrozenColumns();
                  tableWidget.updateVisibleColumnsInDom();

                  tableWidget.emit(gbc.constants.widgetEvents.tableLeftFrozen, freezeIndex);
                }
              }.bind(this)
            });
            this._contextMenu.addChildWidget(rightFrozenLabel, {
              clickCallback: function() {
                if (rightFrozenLabel.isEnabled()) {
                  columnCount = columns.length;
                  freezeIndex = this.getOrderedColumnIndex();
                  tableWidget.setRightFrozenColumns(columnCount - freezeIndex);
                  tableWidget.updateFrozenColumns();
                  tableWidget.updateVisibleColumnsInDom();

                  tableWidget.emit(gbc.constants.widgetEvents.tableRightFrozen, columnCount - freezeIndex);
                }
              }.bind(this)
            });
            this._contextMenu.addChildWidget(unfreezeLabel, {
              clickCallback: function() {
                tableWidget.setLeftFrozenColumns(0);
                tableWidget.setRightFrozenColumns(0);
                tableWidget.updateFrozenColumns();
                tableWidget.updateVisibleColumnsInDom();
                tableWidget.emit(gbc.constants.widgetEvents.tableLeftFrozen, 0);
                tableWidget.emit(gbc.constants.widgetEvents.tableRightFrozen, 0);
              }.bind(this)
            });
          }

          // Reset sort order action
          if (this._isSorted) {
            if (tableWidget.isFrozenTable()) {
              this._contextMenu.addSeparator();
            }

            let resetLabel = cls.WidgetFactory.createWidget("Label", opts);
            resetLabel.setValue(i18next.t("gwc.contextMenu.restoreColumnSort"));
            resetLabel.addClass("gbc_restoreColumnSort_action");
            this._contextMenu.addChildWidget(resetLabel, {
              clickCallback: function() {
                tableWidget.emit(context.constants.widgetEvents.tableHeaderSort, -1);
              }.bind(this)
            });
          }

          // hide other columns action
          if (!this.isUnhidable() && !((tableWidget.isInputMode() || tableWidget.isInputArrayMode()) && !this.isCurrent())) {
            //if (this.isCheckable()) {
            let hideOtherColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            hideOtherColumnsLabel.setValue(i18next.t("gwc.contextMenu.hideAllButSelected"));
            hideOtherColumnsLabel.addClass("gbc_hideAllButSelected_action");
            this._contextMenu.addChildWidget(hideOtherColumnsLabel, {
              clickCallback: function() {
                this.hideOtherColumns();
              }.bind(this)
            });
            this._contextMenu.addSeparator();
          }

          this.getTableWidgetBase().fillContextMenu(this._contextMenu, opts);

          // beware setFocus should not raise a scroll event (it will immediately close contextmenu)
          this._element.domFocus(null, this.getElement());

          this._contextMenu.parentElement = this.getElement();
          this._contextMenu.show();
        },

        /**
         * Hide other columns
         */
        hideOtherColumns: function() {
          let tableWidget = this.getTableWidgetBase();
          let columns = tableWidget.getColumns();
          for (let column of columns) {
            if (!column.isAlwaysHidden() && !column.isUnhidable() && column !== this) {
              column.emit(gbc.constants.widgetEvents.tableShowHideCol, "hide");
            }
          }
          // we hide other columns but we must show current column
          this.emit(gbc.constants.widgetEvents.tableShowHideCol, "show");
        },

        /**
         * Returns Table items of this column
         * @returns {classes.RTableItemWidget[]}
         */
        getItems: function() {
          return this._children;
        },

        /**
         * Returns column item at the specified index (row)
         * @param {number} index - index of the item (row)
         * @returns {classes.RTableItemWidget} item widget
         * @publicdoc
         */
        getItem: function(index) {
          return this._children[index];
        },

        /**
         * Sets column title text
         * @param {string} text - the title text
         * @publicdoc
         */
        setTitleText: function(text) {
          this._setTextContent(text, function() {
            return this._element.getElementsByClassName("headerText")[0];
          }.bind(this));

          // add data-header on each item
          for (const item of this._children) {
            item.getElement().setAttribute("data-header", text);
          }
        },

        /**
         * Returns column title text
         * @returns {string} the title text
         * @publicdoc
         */
        getText: function() {
          return this._element.getElementsByClassName("headerText")[0].textContent;
        },

        /**
         * Returns the element used to resize the column
         * @returns {HTMLElement} the resizer element
         * @publicdoc
         */
        getResizerElement: function() {
          return this._element.getElementsByClassName("resizer")[0];
        },

        /**
         * Returns index of the column in the parent table (vm aui index)
         * @returns {number} index of the column in the table
         * @publicdoc
         */
        getColumnIndex: function() {
          let tableWidget = this.getTableWidgetBase();
          if (tableWidget) {
            return tableWidget.getColumns().indexOf(this);
          }
          return -1;
        },

        /**
         * Returns index of the column in the parent table only in visible columns
         * @returns {number} index of the visible column in the table
         * @publicdoc
         */
        getVisibleColumnIndex: function() {
          let tableWidget = this.getTableWidgetBase();

          let index = 0;
          let found = false;
          for (const colWidget of tableWidget.getOrderedColumns()) {
            if (colWidget === this) {
              found = true;
              break;
            }
            if (!colWidget.isDetachedFromDom()) { // detachedFromDom = hidden + out of view
              index++;
            }
          }

          return found ? index : -1;
        },

        /**
         * Returns index of the column in the parent table (visual index)
         * @returns {number} index of the column in the table
         * @publicdoc
         */
        getOrderedColumnIndex: function() {
          let tableWidget = this.getTableWidgetBase();
          if (tableWidget) {
            return tableWidget.getOrderedColumns().indexOf(this);
          }
          return -1;
        },

        /**
         * Returns true if column is detached from DOM (column not visible)
         * @returns {boolean}
         */
        isDetachedFromDom: function() {
          return this._detachedFromDom;
        },

        /**
         * Flag column as detached from DOM
         * @param detached
         */
        setDetachedFromDom: function(detached) {
          this._detachedFromDom = detached;
        },

        /**
         *  Remove all items (container element) from DOM
         */
        detachItemsFromDom: function() {
          if (!this.isDetachedFromDom()) {
            this.setDetachedFromDom(true);
            this.getElement().remove();
          }
          for (const itemWidget of this.getChildren()) {
            if (!itemWidget.isDetachedFromDom()) {
              itemWidget.setDetachedFromDom(true);
              itemWidget.getElement().remove();
            }
          }
        },

        /**
         * Attach all items (container element) to DOM
         * @param prepend
         */
        attachItemsToDom: function(prepend = false) {
          let colIndex = 0;
          // we try to keep a proper order of columns in the DOM even if columns order is corrected by css order attributes
          // this is why we will determine column dom position relative to current columns being in the DOM
          if (prepend === true) { // add in begining but after last left frozen column
            colIndex = this.getTableWidgetBase().getLeftFrozenColumns();
          } else {
            colIndex = this.getVisibleColumnIndex();
          }
          if (this.isDetachedFromDom()) {
            this.setDetachedFromDom(false);
            this.getElement().insertAt(colIndex, this.getParentWidget().getContainerElement());
          }

          // insert column items the same way
          for (const itemWidget of this.getChildren()) {
            if (itemWidget.isDetachedFromDom()) {
              let rowWidget = itemWidget.getParentWidget();
              if (rowWidget) {
                itemWidget.setDetachedFromDom(false);
                itemWidget.getElement().insertAt(colIndex, rowWidget.getContainerElement());

              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        setHidden: function(state) {
          // optimization : do not recalculate when no state change
          if (this.isHidden() === state) {
            return;
          }

          $super.setHidden.call(this, state);

          if (this._aggregateLabelWidget) {
            this._aggregateLabelWidget.setHidden(this.isHidden());
          }

          // update table
          let tableWidget = this.getTableWidgetBase();

          if (!this.getLayoutInformation().getMeasured()
            .hasSize()) { // TODO add an explicit function for (this.getLayoutInformation().getMeasured().hasSize())
            // Unknown size (it means column has never been measured) => force measurement
            tableWidget.resetMeasure();
          }

          // col has already been measured, just update columns in DOM
          // delay this operation in scheduler to group all updates when multiple columns are set hidden by VM
          const app = context.SessionService.getCurrent().getCurrentApplication();
          app.scheduler.callbackCommand(function() {
            if (tableWidget && !tableWidget.isDestroyed()) {
              tableWidget.update(false, tableWidget.isFlipped(), !tableWidget.isFlipped());
              tableWidget.updateVisibleColumnsInDom();
            }
          }.bind(this));

        },

        /**
         * Sets if the column must be always hidden
         * @param {boolean} isAlwaysHidden - is always hidden ?
         * @publicdoc
         */
        setAlwaysHidden: function(isAlwaysHidden) {
          this._isAlwaysHidden = isAlwaysHidden;
        },

        /**
         * Returns true if column must be always hidden
         * @returns {boolean} true if column is always hidden
         * @publicdoc
         */
        isAlwaysHidden: function() {
          return this._isAlwaysHidden;
        },

        /**
         * Sets if the column can be hidden by the user
         * @param {boolean} isUnhidable - is not hiddable ?
         */
        setUnhidable: function(isUnhidable) {
          this._isUnhidable = isUnhidable;
        },

        /**
         * Returns true if column is unhidable
         * @returns {boolean} true if column is unhidable
         */
        isUnhidable: function() {
          return this._isUnhidable;
        },

        /**
         * Returns true if column can be checked (show/hide)
         * @returns {boolean}
         */
        isCheckable: function() {
          return !this.isUnhidable() && !((this.getTableWidgetBase().isInputMode() || this.getTableWidgetBase().isInputArrayMode()) && this
            .isCurrent());
        },

        /**
         * Sets if the column can be moved by the user
         * @param {boolean} isMovable - is movable ?
         * @publicdoc
         */
        setMovable: function(isMovable) {
          this._isMovable = isMovable;
        },

        /**
         * Return true if the column can be moved
         * @returns {boolean} true if column is movable and not frozen 
         * @publicdoc
         */
        isMovable: function() {
          return this._isMovable;
        },

        /**
         * Sets if the column can be sized by the user
         * @param {boolean} isSizable - is sizable ?
         * @publicdoc
         */
        setSizable: function(isSizable) {
          if (this._isSizable !== isSizable) {
            this._isSizable = isSizable;
            this.getResizerElement().toggleClass("unresizable", !isSizable);
          }
        },

        /**
         * Returns true if column is sizable
         * @returns {boolean} true il column is sizable
         * @publicdoc
         */
        isSizable: function() {
          return this._isSizable;
        },

        /**
         * Returns true if column is a tree
         * @returns {boolean} true if is a tree
         * @publicdoc
         */
        isTreeView: function() {
          return this._isTreeView;
        },

        /**
         * Sets the sort decorator caret.
         * @param {string} sortType - "asc", "desc" or ""
         */
        setSortDecorator: function(sortType) {

          if (this._element === null) {
            return;
          }

          let sortClass = null;
          if (sortType === "asc") {
            sortClass = "sort-asc";
          } else if (sortType === "desc") {
            sortClass = "sort-desc";
          }

          this._element.removeClass("sort-asc");
          this._element.removeClass("sort-desc");

          if (sortClass !== null) {
            this._element.addClass(sortClass);
          }

          this._isSorted = (sortClass !== null);
        },

        /**
         * Set text alignment
         * @param {string} align - (left, center, right)
         * @param {boolean} [force] - force alignment even if not auto
         */
        setTextAlign: function(align, force = false) {

          let tableWidget = this.getTableWidgetBase();

          if (this._textAlign === align) {
            return;
          }

          // Header alignment: alignment is applied only if headerAlignment is auto
          if (force || tableWidget.getHeaderAlignment() === "auto") {
            if (align) {
              this.setStyle({
                "text-align": align
              });
            }
          }

          // Aggregate alignment
          if (this._aggregateLabelWidget) {
            this._aggregateLabelWidget.setTextAlign(align);

            let rightAlign = (align === "right");
            this._aggregateLabelWidget.setStyle(".gbc-label-text-container", {
              "float": rightAlign ? "right" : null
            }); // float right to overflow on left side
            this._aggregateLabelWidget.setStyle({
              "overflow": rightAlign ? "visible" : null
            }); // activate overflow on left side
          }

          this._textAlign = align;
        },

        /**
         * Set/add an aggregate footer
         * @param text - aggregate text & value, if null don't upgrade aggregate value, if "" do nothing
         */
        setAggregate: function(text) {
          if (text === null) {
            return;
          }
          let tableWidget = this.getTableWidgetBase();
          tableWidget.setHasFooter(true);

          if (!this._aggregateLabelWidget) {
            this._aggregateLabelWidget = cls.WidgetFactory.createWidget("Label", this.getBuildParameters());
            let options = {};
            options.footerAggregateItem = true;
            options.colWidget = this;
            tableWidget.getFooterAggregatesRowWidget().addChildWidget(this._aggregateLabelWidget, options);
          }

          //Ensure the correct date format
          if (this.getChildren().length > 0) {
            const item = this.getItem(0);
            const widget = item.getChildren().length > 0 ? item.getChildren()[0] : null;
            if (widget?.getFormat) { // use same date format as first widget of column
              text = cls.DateTimeHelper.toDbDateFormat(text, widget.getFormat());
            }
          }

          this._aggregateLabelWidget.setValue(text);

          this._aggregateLabelWidget.setHidden(this.isHidden());

          this.reorderAggregateLabel();
          if (this._textAlign) {
            this._aggregateLabelWidget.setTextAlign(this._textAlign);
          }
        },

        /**
         * Sets the width of column (define from user)
         * @param {?number} width - column width (pixels)
         * @param {boolean} ignoreRelayout - if false, asks the table to check and update its layout
         * @publicdoc
         */
        setUserWidth: function(width, ignoreRelayout = false) {
          if (this._userWidth === width) {
            return;
          }

          this._userWidth = width;

          // update table
          if (!ignoreRelayout) {
            let tableWidget = this.getTableWidgetBase();
            tableWidget.update(false, false, true);
          }
        },

        /**
         * Set width (from a user interaction)
         * @param {number} width - column width (pixels)
         * @param {boolean} ignoreRelayout - if false, asks the table to check and update its layout
         */
        setUserWidthFromInteraction: function(width, ignoreRelayout = false) {
          this.setUserWidth(width, ignoreRelayout);
          this.emit(gbc.constants.widgetEvents.tableResizeCol, width);
          if (!ignoreRelayout) {
            this.getTableWidgetBase().updateVisibleColumnsInDom();
          }
        },

        /**
         * Returns column width (define from user)
         * @returns {?number} column width (pixels)
         * @publicdoc
         */
        getUserWidth: function() {
          return this._userWidth;
        },

        /**
         * Reset width column
         * @publicdoc
         */
        resetWidth: function() {
          this.setUserWidth(null);
        },

        /**
         * Returns column width (user or if not define measured)
         * @returns {?number} column width (pixels)
         * @publicdoc
         */
        getWidth: function() {
          return this.getUserWidth() || this.getLayoutInformation().getMeasured().getWidth();
        },

        /**
         * Update aggregate css grid definition according to its column position
         */
        reorderAggregateLabel: function() {
          // remove spacer column from start
          if (!this._aggregateLabelWidget) {
            return;
          }

          //Hide the aggregate when the column is no longer visible
          this._aggregateLabelWidget.setHidden(this.isDetachedFromDom());
          if (this.isDetachedFromDom()) {
            return;
          }
          let start = this.getVisibleColumnIndex() + 2;
          if (this.isLeftFrozen()) {
            start = this.getVisibleColumnIndex() + 1;
          }
          this._aggregateLabelWidget.setStyle({
            "grid-column-start": start,
            "order": this.getOrder()
          });
        },

        /**
         * Sets index order of column
         * @param {number} index - order index
         * @param {boolean} noLayout - if true, no table update and relayouts will be fired
         */
        setOrder: function(index, noLayout = false) {
          // make the index starts with 1 instead of 0 which is for the spacer
          index = index + 1;
          if (this._order === index) {
            return;
          }

          // set order style on header column
          this.getElement().style.order = index;

          // set order style on aggregate
          if (this._aggregateLabelWidget) {
            this._aggregateLabelWidget.getElement().style.order = index;
          }

          // set order style on each column item
          for (const itemWidget of this.getChildren()) {
            itemWidget.setOrder(index);
          }

          this._order = index;

          // if noLayout is true, no table update will be executed meaning no measure of rows/cols will be done
          if (!noLayout) {
            // update table
            const tableWidget = this.getTableWidgetBase();
            tableWidget.update(true, false, true);
          }
        },

        /**
         * Returns index order of column
         * @returns {number} order index
         * @publicdoc
         */
        getOrder: function() {
          return this._order;
        },

        /**
         * Table Header are not affected by color
         * @override
         */
        setColor: function(color) {},

        /**
         * Defines if column is the current or not
         * @param {boolean} current - true if the column is the current one, false otherwise
         */
        setCurrent: function(current) {
          if (this._isCurrent === Boolean(current)) {
            return;
          }

          this._isCurrent = Boolean(current);
          this.getElement().toggleClass("currentColumn", this._isCurrent);

          for (const itemWidget of this.getChildren()) {
            itemWidget.setCurrentColumn(this._isCurrent);
          }
        },

        /**
         * Returns if column is the current one
         * @returns {boolean} is the current column ?
         * @publicdoc
         */
        isCurrent: function() {
          return this._isCurrent;
        },

        /**
         * Handle resizer double click event
         */
        onResizerDoubleClick: function() {
          this.autoSetWidth();
        },

        /**
         * Auto set width according to max length of column values
         * @param {boolean} ignoreRelayout - if false, asks the table to check and update its layout
         */
        autoSetWidth: function(ignoreRelayout = false) {
          if (this.isHidden()) {
            return;
          }

          let children = this.getChildren();
          let width = null;
          let widget = null;
          let tableColumnItemWidget = null;
          let i;

          // measure title width
          const colOutOfDom = this.isDetachedFromDom();
          // temporarily add column to DOM to be able to measure it
          if (colOutOfDom && !this.getTableWidgetBase().isFlipped()) {
            this.attachItemsToDom();
          }

          this.getElement().addClass("g_TableMeasuring");

          let maxWidth = this.getElement().getBoundingClientRect().width;

          this.getElement().removeClass("g_TableMeasuring");

          // measure widgets width
          if (children.length > 0) {
            let firstWidget = children[0].getChildren()[0];
            let measureDataElement = firstWidget.getLayoutEngine().getDataContentMeasureElement();
            let hasInputElement = firstWidget.getElement().getElementsByTagName("input").length > 0;
            // if widgets are inputs, use the first charMeasurer to measure to search the larger
            if (hasInputElement && measureDataElement) {

              firstWidget.getElement().addClass("g_measuring");
              firstWidget.getElement().addClass("g_TableMeasuring");
              let initialContent = measureDataElement.textContent;

              for (i = 0; i < children.length; ++i) {
                tableColumnItemWidget = children[i];
                widget = tableColumnItemWidget.getChildren()[0];

                if (widget.getFormattedValue) {
                  measureDataElement.textContent = widget.getFormattedValue(widget.getValue());
                } else {
                  measureDataElement.textContent = widget.getValue();
                }
                width = firstWidget.getElement().getBoundingClientRect().width;
                if (width > maxWidth) {
                  maxWidth = width;
                }
              }
              measureDataElement.textContent = initialContent;
              firstWidget.getElement().removeClass("g_TableMeasuring");
              firstWidget.getElement().removeClass("g_measuring");
            }
            // if widgets are not inputs, measure each widget and keep the larger size
            else {
              for (i = 0; i < children.length; ++i) {
                tableColumnItemWidget = children[i];
                tableColumnItemWidget.getElement().addClass("g_TableMeasuring");
                width = tableColumnItemWidget.getElement().getBoundingClientRect().width;
                tableColumnItemWidget.getElement().removeClass("g_TableMeasuring");

                if (width > maxWidth) {
                  maxWidth = width;
                }
              }
            }
          }
          this.setUserWidthFromInteraction(maxWidth, ignoreRelayout);

          // remove column from DOM if it was previously the case
          if (colOutOfDom && !this.getTableWidgetBase().isFlipped()) {
            this.detachItemsFromDom();
          }
        },

        /**
         * Enable Dnd of items
         * @param {boolean} enableDndItem
         */
        setDndItemEnabled: function(enableDndItem) {
          let items = this.getChildren();
          for (let item of items) {
            item.setDndEnabled(enableDndItem);
          }
        },

        /**
         * Handle drop event
         */
        onDropAfterLastItem: function() {
          this.emit(gbc.constants.widgetEvents.tableDrop, this.getTableWidgetBase().getVisibleRows());
        },

        /**
         * Handle dragOver event
         * @param {Object} evt - dragover event
         */
        onDragOverAfterLastItem: function(evt) {
          this.emit(gbc.constants.widgetEvents.tableDragOver, this.getTableWidgetBase().getVisibleRows(), evt);
        },

        // ============== START - Reordering Event/DnD FUNCTIONS ===================

        /**
         * Apply the correct CSS class depending on the other column index
         * If the other column index is smaller, then the column comes from the left
         * so we reorder to the right 
         * else it comes from the right, so we reorder to the lef
         * If the indexes are the same, remove classes
         * @param {number} otherColumnIndex The other column index
         */
        setReorderingSide: function(otherColumnIndex) {
          const orderedIndex = this.getOrderedColumnIndex();
          if (orderedIndex === otherColumnIndex) {
            this.cleanReorderingState();
          } else {
            this.getElement().addClass(otherColumnIndex < orderedIndex ? "reordering_right" :
              "reordering_left");
          }
        },

        /**
         * Remove the CSS classes displaying reordering state 
         */
        cleanReorderingState: function() {
          this.getElement()
            .removeClass("reordering_left").removeClass("reordering_right");
        },

        /**
         * Compute and return the min and max index on which it's possible to drop the column when dragged
         * @returns {DragLimit} The drag limit indexes.
         */
        getDragLimit() {
          const tableWidget = this.getTableWidgetBase();
          const orderedColumns = tableWidget.getOrderedColumns();
          /**
           * Right Frozen columns should be movable only between right frozen columns
           * Left Frozen columns should be movable only between left frozen columns
           * Not Frozen columns should be movable only between not frozen columns
           */
          const lastIndex = orderedColumns.length - 1;

          let minDragIndex = tableWidget.getLeftFrozenColumns();
          let maxDragIndex = lastIndex - tableWidget.getRightFrozenColumns();
          if (this.isLeftFrozen()) {
            minDragIndex = 0;
            maxDragIndex = tableWidget.getLeftFrozenColumns() - 1;
          } else if (this.isRightFrozen()) {
            minDragIndex = orderedColumns.length - tableWidget.getRightFrozenColumns();
            maxDragIndex = lastIndex;
          }

          return {
            min: minDragIndex,
            max: maxDragIndex
          };
        },

        // ============== END - Reordering Event/DnD FUNCTIONS ===================

        // ============== START - FROZEN COLUMNS FUNCTIONS ===================
        /**
         * Sets if the column is left frozen
         * @param {boolean} isLeftFrozen - is left frozen ?
         * @publicdoc
         */
        setLeftFrozen: function(isLeftFrozen) {
          this._isLeftFrozen = isLeftFrozen;
          this.toggleClass("leftFrozen", isLeftFrozen);
          this.toggleClass("lastLeftFrozen", this.isLastLeftFrozen());

          let tableWidget = this.getTableWidgetBase();

          // search the sum of all previous columns widths
          this._leftFrozenPosition = 0;
          const orderedColumns = tableWidget.getOrderedColumns();
          for (const colWidget of orderedColumns) {
            if (colWidget === this) {
              break;
            }
            if (!colWidget.isHidden()) {
              this._leftFrozenPosition += colWidget.getWidth();
            }
          }

          for (const itemWidget of this._children) {
            itemWidget.setLeftFrozen(isLeftFrozen);
          }

          if (isLeftFrozen) {
            this.setStyle({
              "left": this._leftFrozenPosition + "px"
            });
          }
          this.reorderAggregateLabel();
        },

        /**
         * Sets if the column is right frozen
         * @param {boolean} doFreezeRight - is right frozen ?
         * @publicdoc
         */
        setRightFrozen: function(doFreezeRight) {
          this._isRightFrozen = doFreezeRight;
          this.toggleClass("rightFrozen", doFreezeRight);
          this.toggleClass("firstRightFrozen", this.isFirstRightFrozen());

          let tableWidget = this.getTableWidgetBase();

          // search the sum of all previous columns widths
          this._rightFrozenPosition = tableWidget.haveRowBoundActions() ? 32 : 0;
          for (let i = tableWidget.getOrderedColumns().length - 1; i >= 0; i--) {
            const colWidget = tableWidget.getOrderedColumns()[i];
            if (colWidget === this) {
              break;
            }
            if (!colWidget.isHidden()) {
              this._rightFrozenPosition += colWidget.getWidth();
            }
          }

          for (const itemWidget of this._children) {
            itemWidget.setRightFrozen(doFreezeRight);
          }

          if (doFreezeRight) {
            this.setStyle({
              "right": this._rightFrozenPosition + "px"
            });
          }
          this.reorderAggregateLabel();
        },

        /**
         * Returns if the column is left frozen
         * @return {boolean} is left frozen ?
         * @publicdoc
         */
        isLeftFrozen: function() {
          return this._isLeftFrozen;
        },

        /**
         * Sets if the column is last left frozen
         * @param {boolean} isLastLeftFrozen - is last left frozen ?
         * @publicdoc
         */
        setLastLeftFrozen: function(isLastLeftFrozen) {
          this._isLastLeftFrozen = isLastLeftFrozen;
        },

        /**
         * Returns if the column is the last left frozen
         * @return {boolean} is last left frozen ?
         * @publicdoc
         */
        isLastLeftFrozen: function() {
          return this._isLastLeftFrozen;
        },

        /**
         * Returns the left frozen position (pixels)
         * @return {number} left frozen column position
         */
        getLeftFrozenPosition: function() {
          return this._leftFrozenPosition;
        },

        /**
         * Returns if the column is right frozen
         * @return {boolean} is right frozen ?
         * @publicdoc
         */
        isRightFrozen: function() {
          return this._isRightFrozen;
        },

        /**
         * Sets if the column is first right frozen
         * @param {boolean} isFirstRightFrozen - is first right frozen ?
         * @publicdoc
         */
        setFirstRightFrozen: function(isFirstRightFrozen) {
          this._isFirstRightFrozen = isFirstRightFrozen;
        },

        /**
         * Returns if the column is the first right frozen
         * @return {boolean} is first right frozen ?
         * @publicdoc
         */
        isFirstRightFrozen: function() {
          return this._isFirstRightFrozen;
        },

        /**
         * Returns the right frozen position (pixels)
         * @return {number} right frozen column position
         */
        getRightFrozenPosition: function() {
          return this._rightFrozenPosition;
        },

        /**
         * Indicates if table has frozen columns
         * @returns {boolean} returns true if table has frozen columns
         * @publicdoc
         */
        isFrozen: function() {
          return this.isRightFrozen() || this.isLeftFrozen();
        },

        // ============== END - FROZEN COLUMNS FUNCTIONS ===================

      };
    });
    cls.WidgetFactory.registerBuilder('RTableColumn', cls.RTableColumnWidget);
  });
;

"use strict";

modulum('RTableItemWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Responsive Table item widget.
     * @class RTableItemWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.RTableItemWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.RTableItemWidget.prototype */ {
        __name: "RTableItemWidget",

        /** @type {Element|null} */
        _treeAnchor: null,
        /** @type {classes.ImageWidget} */
        _imageWidget: null,
        /** @type {Function} */
        _imageClickHandler: null,
        /** @type {boolean} */
        _dndEnabled: false,
        /** @type {boolean} */
        _isBlurred: false,
        /** @type {string|null} */
        _currentImagePath: null,
        /** @type {boolean} */
        _clientSelected: false,
        /** @type {boolean} */
        _isTreeItem: false,
        /** @type {classes.RTableColumnWidget} */
        _columnWidget: null,
        /**
         * is item detached from dom
         * @type {boolean}
         */
        _detachedFromDom: false,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          this._isTreeItem = opts.isTreeItem;
          opts.inTable = true;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._element.onDoubleTap("RTableItemWidget", this.manageMouseDblClick.bind(this, null));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        isLayoutMeasureable: function(deep) {
          // first table item of each row is measurable
          return true;
        },

        /**
         * Init item
         */
        init: function() {
          this.setLeftFrozen(this._columnWidget.isLeftFrozen());
          this.setRightFrozen(this._columnWidget.isRightFrozen());
          const columnOrder = this._columnWidget.getOrder();
          this.setOrder(columnOrder !== null ? columnOrder : this._columnWidget
            .getOrderedColumnIndex()); // use ordered column index on first display when no order has been computed
          this.setCurrentColumn(this._columnWidget.isCurrent());
          this.setDndEnabled(this.getTableWidgetBase().isDndItemEnabled());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._treeAnchor = null;

          if (this._imageClickHandler) {
            this._imageClickHandler();
            this._imageClickHandler = null;
          }
          if (this._imageWidget) {
            this._imageWidget.destroy();
            this._imageWidget = null;
          }
          this._columnWidget = null;

          this._element.offDoubleTap("RTableItemWidget");

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== Boolean(hidden)) {
            this._hidden = Boolean(hidden);
            if (this._element) {
              if (this._hidden) {
                this.addClass("hidden");
              } else {
                this.removeClass("hidden");
              }
            }
          }
        },

        /**
         * Request focus for this row (keep current column)
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          let tableWidget = this.getTableWidgetBase();
          if (tableWidget) {
            tableWidget.requestFocusFromWidget(this.getWidget(), domEvent);
          }
        },

        /**
         * Returns item widget
         * @returns {classes.WidgetBase}
         */
        getWidget: function() {
          return this._children[0];
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this.getElement()) { // click on item, but not on sub element
            this.getTableWidgetBase().requestFocusFromWidget(this.getWidget(), domEvent);
            return true;
          }
          if (domEvent.target === this._treeAnchor) { // click on tree anchor
            let index = this.getRowIndex();
            let tableWidget = this.getTableWidgetBase();
            tableWidget.emit(context.constants.widgetEvents.toggleClick, index);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          if (domEvent && domEvent.target === this._treeAnchor) {
            // if double-click on tree anchor, do nothing
            return false;
          }
          const rowWidget = /** @type classes.RTableRowWidget */ this.getParentWidget();
          // Call double-click on the row, with the right column index
          const processed = rowWidget.onDoubleClick(domEvent, this.getColumnWidget().getColumnIndex());

          return !processed;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (this._children.length !== 0) {
            throw new Error("A item only contain a single child");
          }

          this._layoutInformation = widget.getLayoutInformation();
          $super.addChildWidget.call(this, widget, options);

          if (this._isTreeItem) {
            this._treeAnchor = document.createElement("span");
            this._treeAnchor.addClass("gbc_TreeAnchor");
            this._element.prependChild(this._treeAnchor);
            this.setLeaf(true);
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          if (this._backgroundColor !== color) {
            this._backgroundColor = color;
            this.setStyle({
              "background-color": color && !this._ignoreBackgroundColor ? color : null
            });
          }
        },

        /**
         * Enable drag and drop
         * @param {boolean} b - true to enable
         */
        setDndEnabled: function(b) {
          if (this._dndEnabled !== b) {
            this._dndEnabled = b;
            if (b) {
              this._element.setAttribute("draggable", "true");
            } else {
              this._element.removeAttribute("draggable");
            }
          }
        },

        /**
         * Check if item is tree item
         * @returns {boolean} true if the element is a tree item, false otherwise
         * @publicdoc
         */
        isTreeItem: function() {
          return this._isTreeItem;
        },

        /**
         * Sets if item is a leaf of tree
         * @param {boolean} leaf - true if the item is a leaf item, false otherwise
         */
        setLeaf: function(leaf) {
          if (this.isTreeItem()) {
            this.setAriaExpanded(null);
            if (leaf) {
              this._treeAnchor.removeClass("treeExpanded");
              this._treeAnchor.removeClass("treeCollapsed");
            }
            this._treeAnchor.toggleClass("treeLeaf", leaf);

          }
        },

        /**
         * Checks if item is tree leaf item
         * @returns {boolean} leaf true if the item is a leaf item, false otherwise
         * @publicdoc
         */
        isLeaf: function() {
          return this.isTreeItem() && this._treeAnchor.hasClass("treeLeaf");
        },

        /**
         * Expands or collapse tree item
         * @param {boolean} expanded - true if the item should be expanded, false otherwise
         * @publicdoc
         */
        setExpanded: function(expanded) {
          if (this.isTreeItem() && !this.isLeaf()) {
            this.setAriaExpanded(expanded);
            this._treeAnchor.toggleClass("treeExpanded", "treeCollapsed", expanded);

            if (gbc.qaMode) {
              // add qa expanded info
              let qaElement = this.getContainerElement().querySelector("[data-gqa-name]");
              if (qaElement) {
                qaElement.setAttribute('data-gqa-expanded', expanded.toString());
              }
            }
          }
        },

        /**
         * Sets aria attribute expanded
         * @param {boolean} expanded - true if the item should be expanded, false otherwise
         */
        setAriaExpanded: function(expanded) {
          this.setAriaAttribute("expanded", expanded);
          if (this.getWidget()) {
            this.getWidget().setAriaAttribute("expanded", expanded);
          }
        },

        /**
         * @inheritDoc
         */
        isReversed: function() {
          return this.getParentWidget().isReversed();
        },

        /**
         * Sets tree item depth
         * @param {number} depth - item depth
         */
        setDepth: function(depth) {
          let depthObj = {};
          depthObj["padding-" + this.getStart()] = depth + 'em';
          this.setStyle(depthObj);
        },

        /**
         * Sets if the item is left frozen
         * @param {boolean} b - is left frozen ?
         * @publicdoc
         */
        setLeftFrozen: function(b) {
          this.toggleClass("leftFrozen", b);
          this.toggleClass("lastLeftFrozen", this.getColumnWidget().isLastLeftFrozen());
          if (b) {
            this.setStyle({
              "left": this.getColumnWidget().getLeftFrozenPosition() + "px"
            });
          }
        },

        /**
         * Sets if the item is right frozen
         * @param {boolean} b - is right frozen ?
         * @publicdoc
         */
        setRightFrozen: function(b) {
          this.toggleClass("rightFrozen", b);
          this.toggleClass("firstRightFrozen", this.getColumnWidget().isFirstRightFrozen());
          if (b) {
            this.setStyle({
              "right": this.getColumnWidget().getRightFrozenPosition() + "px"
            });
          }
        },

        /**
         * Sets if the item is in the current column
         * @param {boolean} b - is in current column ?
         * @publicdoc
         */
        setCurrentColumn: function(b) {
          this.toggleClass("currentColumn", b);
        },

        /**
         * Blur data on item widget
         * @param enable
         */
        blur: function(enable) {
          if (enable === this._isBlurred) {
            return;
          }
          this._isBlurred = enable;
          this.toggleClass("blurred", this._isBlurred);
        },

        /**
         * Sets index order  (row + col)
         * @param {number} colIndex - order column index
         */
        setOrder: function(colIndex) {
          let rowWidget = this.getParentWidget();
          // take row index, start index with 1 (instead of 0) and generate a 4 digits number
          const rowIndex = (rowWidget.getRowIndex() + 1) * rowWidget.getOrderMultiplier();
          // add column index to row index
          const order = rowIndex + colIndex;
          this._order = order;
          this.getElement().style.order = order;
        },

        /**
         * Returns index order of column
         * @returns {number} order index
         * @publicdoc
         */
        getOrder: function() {
          return this._order;
        },

        /**
         * Returns true if column is detached from DOM (column not visible)
         * @returns {boolean}
         */
        isDetachedFromDom: function() {
          return this._detachedFromDom;
        },

        /**
         * Flag column as detached from DOM
         * @param detached
         */
        setDetachedFromDom: function(detached) {
          this._detachedFromDom = detached;
        },

        /**
         * Sets image item
         * @param {string} path - image path
         * @publicdoc
         */
        setImage: function(path) {
          if (this._currentImagePath !== path) {
            if (path && path !== "") {
              if (!this._imageWidget) {
                let opts = this.getBuildParameters();
                opts.inTable = true;
                this._imageWidget = cls.WidgetFactory.createWidget("ImageWidget", opts);
                this._imageWidget.getElement().addClass("gbc_RTableItemImage");
                this._imageWidget.setParentWidget(this);
                this._imageClickHandler = this._imageWidget.when(context.constants.widgetEvents.click, function(event) {
                  this.getTableWidgetBase().requestFocusFromWidget(this.getWidget(), event);
                }.bind(this));
                this._element.prependChild(this._imageWidget.getElement());
              }
              this._imageWidget.setSrc(path, true);
              this._imageWidget.setHidden(false);
            } else if (this._imageWidget) {
              this._imageWidget.setHidden(true);
            }
            this._currentImagePath = path;
          }
        },

        /**
         * Checks if item is client selected
         * @returns {boolean} true if the row item is client selected, false otherwise
         */
        isClientSelected: function() {
          return this._clientSelected;
        },

        /**
         * Sets if item is client selected
         * @param {boolean} selected - true if the item is client selected, false otherwise
         */
        setClientSelected: function(selected) {
          this._clientSelected = selected;
        },

        /**
         * Returns column widget which contains this item
         * @returns {classes.RTableColumnWidget} column widget
         */
        getColumnWidget: function() {
          return this._columnWidget;
        },

        /**
         * Sets the column widget wich contains this itme
         * @param {classes.RTableColumnWidget} colWidget - column widget
         */
        setColumnWidget: function(colWidget) {
          this._columnWidget = colWidget;
        },

        /**
         * Returns row index of the item
         * @returns {number} row index of the item
         * @publicdoc
         */
        getRowIndex: function() {
          let parent = this.getParentWidget();
          if (parent) {
            return parent.getRowIndex();
          }
          return -1;
        },

        /**
         * Handle dragStart event
         * @param {Object} evt - dragstart event
         */
        onDragStart: function(evt) {
          if (window.browserInfo.isFirefox) { // Firefox 1.0+
            try {
              evt.dataTransfer.setData('text/plain', ''); // for Firefox compatibility
            } catch (ex) {
              console.error("evt.dataTransfer.setData('text/plain', ''); not supported");
            }
          }

          this._columnWidget.emit(gbc.constants.widgetEvents.tableDragStart, this.getRowIndex(), evt);
        },

        /**
         * Handle dragEnd event
         */
        onDragEnd: function() {
          this._columnWidget.emit(gbc.constants.widgetEvents.tableDragEnd);
        },

        /**
         * Handle dragOver event
         * @param {Object} evt - dragover event
         */
        onDragOver: function(evt) {
          this._columnWidget.emit(gbc.constants.widgetEvents.tableDragOver, this.getRowIndex(), evt);
        },

        /**
         * Handle dragLeave event
         * @param {Object} evt - dragleave event
         */
        onDragLeave: function(evt) {
          this._columnWidget.emit(gbc.constants.widgetEvents.tableDragLeave, this.getRowIndex(), evt);
        },

        /**
         * Handle dragEnter event
         * @param {Object} evt - dragenter event
         */
        onDragEnter: function(evt) {
          this._columnWidget.emit(gbc.constants.widgetEvents.tableDragEnter, this.getRowIndex(), evt);
        },

        /**
         * Handle drop event
         */
        onDrop: function() {
          this._columnWidget.emit(gbc.constants.widgetEvents.tableDrop, this.getRowIndex());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('RTableItem', cls.RTableItemWidget);
  });
;

"use strict";

modulum('RTableRowWidget', ['WidgetGroupBase'],
  function(context, cls) {

    /**
     * Responsive Table row widget.
     * @class RTableRowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.RTableRowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.RTableRowWidget.prototype */ {
        __name: "RTableRowWidget",

        /** @type {boolean} */
        _isCurrent: false,

        /** @type {boolean} */
        _isSelected: false,

        /** @type {boolean} */
        _isHeader: false,

        /** @type {boolean} */
        _isFooter: false,

        /** @type {number} */
        _orderMultiplier: 10000,

        /** @type {classes.RowBoundDecoratorWidget} */
        _rowBoundDecoratorWidget: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this.getRowBoundDecorator()) {
            this.getRowBoundDecorator().destroy();
            this._rowBoundDecoratorWidget = null;
          }

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @todo : Review the attach flow to be called automatically
         * @inheritdoc
         */
        onAttachedToParentTable: function() {
          const order = (this.getRowIndex() + 1) * this.getOrderMultiplier();
          this.setStyle(".left_spacer", {
            "order": order
          });

          this.addRowBoundDecorator();
        },

        /**
         * Request focus for this row
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(domEvent) {
          this._children[0].requestFocus(domEvent);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          let tableWidget = this.getTableWidgetBase();

          if (!this._isHeader && !this._isFooter && tableWidget && !tableWidget.isRowActionTriggerByDoubleClick()) {
            tableWidget.emit(context.constants.widgetEvents.rowAction);
            return false;
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          this.onDoubleClick(domEvent);
          return false;
        },

        /**
         * Handle double click on row event
         * @param {Object} event - dblclick dom event
         * @param {?number} colIndex - column index
         * @returns {boolean} true if event has been processed
         */
        onDoubleClick: function(event, colIndex = null) {
          const tableWidget = this.getTableWidgetBase();
          if (!this._isHeader && !this._isFooter && tableWidget && tableWidget.isRowActionTriggerByDoubleClick()) {
            tableWidget.emit(context.constants.widgetEvents.rowAction, colIndex);
            return true;
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {

          let item = null;
          if (options.headerItem) {
            item = widget;
          } else if (options.footerAggregateItem) {
            item = widget;
          } else {
            let opts = this.getBuildParameters();
            let colWidget = options.colWidget;
            opts.isTreeItem = colWidget.isTreeView();

            // data row
            item = cls.WidgetFactory.createWidget("RTableItem", opts);
            item.addChildWidget(widget);
            item.getElement().setAttribute("data-header", colWidget.getText());

            // position for DOM insertion is colIndex
            item.setColumnWidget(colWidget);
            colWidget.getChildren().push(item);

            // if add a widget in the first row need to measure widget to compute column width
            if (options.rowIndex === 0) {
              this.getParentWidget().resetMeasure();
            }
            if (options.noDOMInsert === true) {
              item.setDetachedFromDom(true);
            }
          }

          $super.addChildWidget.call(this, item, options);

          // initialize item after it has been added
          if (item.init) {
            item.init();
          }

          if (this.getRowBoundDecorator()) {
            this.getRowBoundDecorator().setOrder(this._getRowBoundDecoratorOrder());
          }

        },

        /**
         * Returns item widgets
         * @returns {classes.RTableItemWidget[]} array of item widgets
         * @publicdoc
         */
        getItems: function() {
          return this.getChildren();
        },

        /**
         * Returns row index in the table
         * @returns {number} row index in the table
         * @publicdoc
         */
        getRowIndex: function() {
          let tableWidget = this.getTableWidgetBase();
          if (tableWidget) {
            return tableWidget.getRows().indexOf(this);
          }
          return -1;
        },

        /**
         * Sets if the row is the current one
         * @param {boolean} current - true if row is the current one, false otherwise
         * @publicdoc
         */
        setCurrent: function(current) {
          if (this._isCurrent !== current) {
            this._isCurrent = current;
            if (current) {
              this._element.addClass("currentRow");
            } else {
              this._element.removeClass("currentRow");
            }
          }
        },

        /**
         * Returns if row is the current one
         * @returns {boolean} is the current row ?
         * @publicdoc
         */
        isCurrent: function() {
          return this._isCurrent;
        },

        /**
         * Sets if the row is the header row
         * @param {boolean} header - true if row is the header, false otherwise
         * @publicdoc
         */
        setHeader: function(header) {
          this._isHeader = header;
        },

        /**
         * Sets if the row is the footer row
         * @param {boolean} footer - true if row is the footer, false otherwise
         * @publicdoc
         */
        setFooter: function(footer) {
          this._isFooter = footer;
        },

        /**
         * Sets if row is selected
         * @param {boolean} selected - true if the row should be selected, false otherwise
         */
        setSelected: function(selected) {
          if (this._isSelected !== selected) {
            this._isSelected = selected;
            this._element.toggleClass("selectedRow", Boolean(selected));
          }
        },

        /**
         * Checks if row is selected
         * @returns {boolean} true if the row is selected, false otherwise
         */
        isSelected: function() {
          return this._isSelected;
        },

        /**
         * Return rowBound decorator widget
         * @return {classes.RowBoundDecoratorWidget} - rowBound decorator widget
         */
        getRowBoundDecorator: function() {
          return this._rowBoundDecoratorWidget;
        },

        /**
         * @returns {number} The rowBoundDecorator column index
         */
        _getRowBoundDecoratorOrder: function() {
          return parseInt(this.getParentWidget().getColumns().length + 1, 10);
        },

        /**
         * Creates and adds rowBound decorator element to DOM
         */
        addRowBoundDecorator: function() {
          if (this.getRowBoundDecorator() !== null) {
            return;
          }
          // Create the rowbound decoractor
          this._rowBoundDecoratorWidget = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
          this.getRowBoundDecorator().setParentWidget(this);
          this.getRowBoundDecorator().setContextMenuWidget(this.getTableWidgetBase().getRowBoundMenu());

          this.getRowBoundDecorator().update();
          // hack to have the same css rule
          this.getRowBoundDecorator().addClass("gbc_RTableItemWidget");
          this.getRowBoundDecorator().addClass("gbc_WidgetBase_in_array");

          this._element.appendChild(this.getRowBoundDecorator().getElement());

          // rowbound is the very last column
          // rowbound div order = max visible columns + 10 to be sure it is the last one
          this.getRowBoundDecorator().setOrder(this._getRowBoundDecoratorOrder());

          if (this._isHeader || this._isFooter) {
            this.getRowBoundDecorator().setEnabled(false);
          }
        },

        /**
         * Create, update, destroy the rowbound depending on the situation
         */
        updateRowBound: function() {
          this.getRowBoundDecorator()?.update();
        },

        /**
         * Returns order multiplier used to handle all items
         * @returns {*}
         */
        getOrderMultiplier: function() {
          return this._orderMultiplier;
        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          if (this._hidden !== Boolean(hidden)) {
            this._hidden = Boolean(hidden);
            if (this._element) {
              if (this._hidden) {
                this.addClass("hidden");
              } else {
                this.removeClass("hidden");
              }
            }

            // hide/show all items of row
            for (const item of this.getItems()) {
              item.setHidden(hidden);
            }
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('RTableRow', cls.RTableRowWidget);
  });
;

"use strict";

modulum('RTableWidget', ['TableWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Responsive table widget.
     * @class RTableWidget
     * @memberOf classes
     * @extends classes.TableWidgetBase
     * @publicdoc
     */
    cls.RTableWidget = context.oo.Class(cls.TableWidgetBase, function($super) {
      return /** @lends classes.RTableWidget.prototype */ {
        __name: "RTableWidget",

        /** @type {classes.ContextMenuWidget} */
        _contextMenu: null,

        /** @type {classes.RTableRowWidget} */
        _headerRowWidget: null,
        /** @type {classes.RTableRowWidget} */
        _footerAggregatesRowWidget: null,

        /** @type {boolean} */
        _multiRowSelectionEnabled: false,

        // Pagination nav WIP
        /** @type {classes.PaginationWidget} */
        //_paginationWidget: null,

        /** @type {classes.RTableColumnWidget[]} */
        _columns: null,
        /** @type {classes.RTableColumnWidget[]} */
        _orderedColumns: null,

        /** @type {boolean} */
        _hasFooter: false,

        /** @type {boolean} */
        _firstLayout: true,

        /** @type {number} */
        _currentColumn: 0,

        /** DOM Elements */
        _headerGroupElement: null,
        _footerGroupElement: null,
        /** @type {Element} */
        _scrollerXElement: null,
        /** @type {Element} */
        _scrollerYElement: null,
        _aggregateGlobalTextElement: null,

        /** Item client selection */
        _defaultItemSelection: false,
        _firstItemSelected: null,
        _itemSelectionInProgress: false,
        _itemSelectionHasChanged: false,
        _itemSelectionElement: null,

        /** @type {?number} */
        lastSentOffset: null,

        /** @type {number} */
        _previousScrollLeftValue: -1,
        /** @type {number} */
        _previousScrollTopValue: 0,
        /** @type {number|null} */
        _previousTouchYValue: null,
        /** @type {number} */
        _totalLeftFrozenColumnWidth: 0,
        /** @type {number} */
        _totalVisibleLeftFrozenColumns: 0,
        /** @type {boolean} */
        _frozenTable: false,
        /** @type {number} */
        _leftFrozenColumns: 0,
        /** @type {number} */
        _rightFrozenColumns: 0,

        /** @type {String} */
        _evenRowBackgroundColor: "",
        /** @type {String} */
        _oddRowBackgroundColor: "",

        /** @type {String} */
        _viewType: "", // Type of table view

        // All views: variables/settings
        /** @type {boolean|null} */
        _alternateRows: null,
        /** @type {boolean|null} */
        _rowHover: null,

        // 4st styles
        /** @type {boolean|null} */
        _showGridX: null,
        /** @type {boolean|null} */
        _showGridY: null,
        /** @type {boolean|null} */
        _headerHidden: null,
        /** @type {String} */
        _headerAlignment: null,

        /** Mouse down target html element */
        _mouseDownTarget: null,

        /** @type {classes.RTableItemWidget} */
        _currentItem: null,

        /** @type {Boolean} **/
        _hasUnhidableColumns: false,

        /** @type {Boolean} **/
        _isScrolling: false,

        /** @type {?number} **/
        _vmCurrentRow: null,

        // Store mouse move prev positions
        _itemSelectionMouseMovePrevX: 0,
        _itemSelectionMouseMovePrevY: 0,

        /** @type {boolean} */
        _cancelMenuButtonForThisTouchPhase: false,

        /**
         * @type {classes.TableMenuButtonWidgetComponent}
         */
        _menuButtonComponent: null,

        /**
         * @type {classes.ColumnManipulationWidgetComponent}
         */
        _columnContainerComponent: null,

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._headerRowWidget) {
            this._headerRowWidget.destroy();
            this._headerRowWidget = null;
          }

          if (this._footerAggregatesRowWidget) {
            this._footerAggregatesRowWidget.destroy();
            this._footerAggregatesRowWidget = null;
          }

          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          if (this._cachedDataModel) {
            this._cachedDataModel.destroy();
            this._cachedDataModel = null;
          }

          if (this._menuButtonComponent) {
            this._menuButtonComponent.destroy();
            this._menuButtonComponent = null;
          }

          if (this._columnContainerComponent) {
            this._columnContainerComponent.destroy();
            this._columnContainerComponent = null;
          }

          // Pagination nav WIP
          //if (this._paginationWidget) {
          //  this._paginationWidget.destroy();
          //  this._paginationWidget = null;
          //}

          this.setDndItemEnabled(false);

          this.getScrollableArea().off('scroll.RTableWidget');

          // Mouse drag
          this.getHeaderGroupElement().off("dragstart.RTableWidget");
          this.getHeaderGroupElement().off("dragend.RTableWidget");
          this.getHeaderGroupElement().off("drag.RTableWidget");
          this.getHeaderGroupElement().off("dragover.RTableWidget");
          this.getHeaderGroupElement().off("drop.RTableWidget");
          this.getHeaderGroupElement().off("dragleave.RTableWidget");

          // Touch drag
          this.getHeaderGroupElement().off("touchstart.RTableWidget");
          this.getHeaderGroupElement().off("touchend.RTableWidget");
          this.getHeaderGroupElement().off("touchmove.RTableWidget");

          // client select items events
          this.getElement().off("mousemove.RTableWidget");
          this.getElement().off("mouseleave.RTableWidget");

          this.getElement().off("wheel.RTableWidget");
          this.getElement().off("touchstart.RTableWidget");
          this.getElement().off("touchmove.RTableWidget");

          this._headerGroupElement = null;
          this._footerGroupElement = null;
          this._aggregateGlobalTextElement = null;
          this._scrollerXElement = null;
          this._scrollerYElement = null;

          this._columns = [];
          this._orderedColumns = null;

          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._resetItemsSelection();

          // Pagination nav WIP
          //this._paginationWidget = cls.WidgetFactory.createWidget("Pagination", this.getBuildParameters());
          //this._paginationWidget.setParentWidget(this);
          //this._element.appendChild(this._paginationWidget.getElement());

          this._cachedDataModel = new cls.TableCachedDataModel(this);
          this._columns = [];
          this.setViewType("classic");
          this.setRowHeight(context.ThemeService.getTableMinimalRowHeight());
          this.setAlternateRows(true);
          this.setRowHover(!window.isMobile());

          if (this.isTreeView()) {
            this.getElement().addClass("gbc_TreeView");
          }

          // set scrollbar size for css rules
          this._element.style.setProperty('--scrollBarHorizontalHeight', window.scrollBarSize + "px");
          this._element.style.setProperty('--scrollBarVerticalWidth', window.scrollBarSize + "px");

          this.getElement().on("wheel.RTableWidget", this._onWheel.bind(this));
          this.getElement().on("touchstart.RTableWidget", this._onTouchStart.bind(this));
          this.getElement().on("touchmove.RTableWidget", this._onTouchMove.throttle(10).bind(this));
        },

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);

          this._columnContainerComponent = new cls.ColumnManipulationWidgetComponent(this);
          this._menuButtonComponent = new cls.TableMenuButtonWidgetComponent(this, true);

          this.getScrollableArea().on('scroll.RTableWidget', this._onScroll.bind(this));

          this._headerRowWidget = cls.WidgetFactory.createWidget("RTableRow", this.getBuildParameters());
          this.getHeaderRowWidget().setHeader(true);
          this.getHeaderGroupElement().appendChild(this._headerRowWidget.getElement());
          this.getHeaderRowWidget().setParentWidget(this);
          this.getHeaderRowWidget().onAttachedToParentTable();

          this.getHeaderGroupElement()
            .on("dragstart.RTableWidget", this._onHeaderDragStart.bind(this))
            .on("dragend.RTableWidget", this._onHeaderDragEnd.bind(this))
            .on("drag.RTableWidget", this._onHeaderDrag.throttle(5).bind(this))
            .on("dragover.RTableWidget", this._onHeaderDragOver.bind(this))
            .on("drop.RTableWidget", this._onHeaderDrop.bind(this))
            .on("dragleave.RTableWidget", this._onHeaderDragLeave.bind(this))
            .on("touchstart.RTableWidget", this._onHeaderTouchStart.bind(this))
            .on("touchend.RTableWidget", this._onHeaderTouchEnd.bind(this))
            .on("touchmove.RTableWidget", this._onHeaderTouchMove.throttle(5).bind(this));

          // client select items events
          this.getElement()
            .on("mouseleave.RTableWidget", this._onItemMouseLeave.bind(this));

          this._footerAggregatesRowWidget = cls.WidgetFactory.createWidget("RTableRow", this.getBuildParameters());
          this._footerAggregatesRowWidget.setFooter(true);
          this.getFooterGroupElement().appendChild(this._footerAggregatesRowWidget.getElement());
          this._footerAggregatesRowWidget.setParentWidget(this);
        },

        /**
         * @inheritDoc
         */
        _whenParentActivated: function(opt) {
          $super._whenParentActivated.call(this, opt);

          let widgetActivated = opt.data.length > 0 && opt.data[0];
          if (this.isChildOf(widgetActivated)) {

            let contextScrollTop = this._previousScrollTopValue;
            let contextScrollLeft = this._previousScrollLeftValue;
            this.getScrollableArea().scrollTop = contextScrollTop;
            this.getScrollableArea().scrollLeft = contextScrollLeft;

            // synchronize header & data horizontal scroll
            this.getHeaderGroupElement().scrollLeft = contextScrollLeft;
            this.getFooterGroupElement().scrollLeft = contextScrollLeft;

            if (this.getLayoutEngine().isLayoutDone() === false) {
              this.getLayoutEngine().forceMeasurement();
              this.getLayoutEngine().invalidateMeasure();
            }
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._layoutInformation) {
            this._layoutInformation = new cls.LayoutInformation(this);

            this._layoutInformation.getStretched().setDefaultX(true);
            this._layoutInformation.getStretched().setDefaultY(true);
          }
          this._layoutEngine = new cls.RTableLayoutEngine(this);
          this._layoutEngine.onLayoutApplied(this._layoutApplied.bind(this));

          let minPageSize = parseInt(context.ThemeService.getValue("gbc-TableWidget-min-page-size"), 10);
          this._layoutEngine.setMinPageSize(isNaN(minPageSize) ? 1 : minPageSize);
          let minWidth = parseInt(context.ThemeService.getValue("gbc-TableWidget-min-width"), 10);
          this._layoutEngine.setMinWidth(isNaN(minWidth) ? 60 : minWidth);
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          $super.resetLayout.call(this);
          this.setRowHeight(context.ThemeService.getTableMinimalRowHeight());
          this._firstLayout = true;
          //Refresh alternate rows color in case of theme change
          this.setAlternateRows(this._alternateRows, true, true);
          this._layoutEngine.resetLayout();
        },

        /**
         * Call when layout is finished
         */
        _layoutApplied: function() {
          if (this.isElementInDOM()) {
            const forceColsMeasure = this._firstLayout;
            if (this._firstLayout && this._layoutEngine.isLayoutDone()) {
              // first time layout is applied
              this._firstLayout = false;
              this.updateFrozenColumns();
              this.updateAllAggregate();
              this.updateVerticalScroll(true);
              // once measured (needed for columns layout), hide first row if size = 0
              const firstRow = this.getRows()[0];
              if (firstRow) {
                firstRow.setHidden(this._visibleRows === 0);
              }
            }
            // add/remove non-visible columns from DOM
            // force columns grid css measure event if no columns are remove/add from DOM on first  layout
            this.updateVisibleColumnsInDom(this.getScrollableArea().scrollLeft, forceColsMeasure);
          }
        },

        /**
         * True if the element is visible
         * @param {DOMElement} element
         * @returns {boolean}
         */
        isElementVisible: function(element) {
          const rect = element.getBoundingClientRect(),
            vWidth = window.innerWidth || document.documentElement.clientWidth,
            vHeight = window.innerHeight || document.documentElement.clientHeight;

          // Return false if it's not in the viewport
          if (rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight) {
            return false;
          }

          // true if any of its four corners are visible
          return element.contains(document.elementFromPoint(Math.ceil(rect.left), Math.ceil(rect.top))) ||
            element.contains(document.elementFromPoint(Math.floor(rect.right), Math.ceil(rect.top))) ||
            element.contains(document.elementFromPoint(Math.floor(rect.right), Math.floor(rect.bottom))) ||
            element.contains(document.elementFromPoint(Math.ceil(rect.left), Math.floor(rect.bottom)));
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {

          if (this.isElementInDOM()) {
            this.domFocus(fromMouse || this.isElementVisible(this.getElement()));
          } else {
            let uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          }

          $super.setFocus.call(this, fromMouse);

          // if focus comes from VM not mouse update the rowBound actions
          if (!fromMouse) {
            for (const row of this.getRows()) {
              row.updateRowBound();
            }
          }
        },

        /**
         * @inheritDoc
         */
        loseVMFocus: function(vmNewFocusedWidget = null) {
          $super.loseVMFocus.call(this, vmNewFocusedWidget);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this._contextMenu && this._contextMenu.isVisible()) {
            return this._contextMenu.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }

          // manage CTRL+C case
          if (keyString === "ctrl+c" || keyString === "meta+c") {
            if (this.hasItemsSelected()) { // copy selection
              this._copySelectionInClipboard();
              keyProcessed = true;
            } else if (this.isDisplayMode() && !this.isMultiRowSelectionEnabled() && this.isCurrentRowVisible()) { // copy current row
              if (this.hasFocusOnField()) {
                this._copyCurrentCellInClipboard();
                keyProcessed = true;
              } else {
                this._copyCurrentRowInClipboard();
                keyProcessed = true;
              }
            }
          } else if (this.isMultiRowSelectionEnabled()) {
            let key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
            if (key === "space") {
              this.emit(context.constants.widgetEvents.keySpace, domKeyEvent);
              keyProcessed = true;
            } else if (keyString === "ctrl+a" || keyString === "meta+a") {
              this.emit(context.constants.widgetEvents.selectAll);
              keyProcessed = true;
            } else if (domKeyEvent) {
              keyProcessed = this._manageNavigationKeys(domKeyEvent);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Manage navigation keys
         * @param {Object} domKeyEvent - key event from DOM
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         * @private
         */
        _manageNavigationKeys: function(domKeyEvent) {
          const key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
          let keyProcessed = true;
          switch (key) {
            case "down":
              this.emit(context.constants.widgetEvents.keyArrowDown, domKeyEvent);
              break;
            case "up":
              this.emit(context.constants.widgetEvents.keyArrowUp, domKeyEvent);
              break;
            case "pageup":
              this.emit(context.constants.widgetEvents.keyPageUp, domKeyEvent);
              break;
            case "pagedown":
              this.emit(context.constants.widgetEvents.keyPageDown, domKeyEvent);
              break;
            case "home":
              this.emit(context.constants.widgetEvents.keyHome, domKeyEvent);
              break;
            case "end":
              this.emit(context.constants.widgetEvents.keyEnd, domKeyEvent);
              break;
            default:
              keyProcessed = false;
          }

          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          const key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];

          if (!this.isMultiRowSelectionEnabled() && domKeyEvent) {
            keyProcessed = this._manageNavigationKeys(domKeyEvent);
          }

          if (!keyProcessed && this.isDisplayMode()) {
            if (key === "left") {
              this.emit(context.constants.widgetEvents.keyArrowLeft, domKeyEvent);
              keyProcessed = true;
            } else if (key === "right") {
              this.emit(context.constants.widgetEvents.keyArrowRight, domKeyEvent);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          this._onItemMouseDown.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseUp: function(domEvent) {
          this._onItemMouseUp.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (domEvent.target === this.getContainerElement()) {
            if (domEvent.target === this._mouseDownTarget || !this.isEnabled()) {
              this.emit(context.constants.widgetEvents.requestFocus);
              // Add new row, done by emit(tableClickOnContainer)
              // when clicking the container element and not an item
              let clickedColumnIndex = 0;
              if (this._columns.length > 1) {
                // If there is multiple columns. Get the clicked column
                let orderedCols = this.getOrderedColumns();
                let xClick = domEvent.clientX || domEvent.screenX;
                let counter = 0;
                for (const col of orderedCols) {
                  let rect = col.getElement().getBoundingClientRect();
                  if (xClick > rect.left && xClick < rect.right) {
                    // If the click is done in a column
                    clickedColumnIndex = counter;
                    continue;
                  }
                  counter += 1;
                }
              }
              // if click is not after the last item use first column to add new row
              this.emit(context.constants.widgetEvents.tableClickOnContainer, clickedColumnIndex);
              return false;
            }
          } else if (domEvent.target.elementOrParent(cls.TableMenuButtonWidgetComponent._elementCssClass)) {
            this._buildContextMenu(domEvent);
            return false;
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          let target = domEvent.target;

          // click on data
          let isDataContainerClick = target.isElementOrChildOf(this.getContainerElement());

          if (isDataContainerClick) {
            if (this.isRowActionTriggerByDoubleClick()) {
              // emit row action for this table
              this.emit(context.constants.widgetEvents.rowAction);
            }
            return false;
          }

          return true;
        },

        /**
         * Fill a context menu with the usual table context meny elements
         * @param contextMenu - context menu to fill
         * @param opts - application build parameters
         */
        fillContextMenu: function(contextMenu, opts) {
          // Show those entries only if column is hideable
          if (!this._hasUnhidableColumns && !opts.unHidable) {
            // Be sure that the last checkbox is always check (cannot hide all columns)
            let checkLast = function() {
              const children = contextMenu.getChildren();
              let checkCount = children.filter(function(c) {
                const colWidget = c._colWidget;
                if (colWidget) {
                  // Re-enables in case it was previously last but no longer, if it is checkable
                  c.setEnabled(colWidget.isCheckable());
                  if (c.isInstanceOf(cls.CheckBoxWidget) && c.getValue()) {
                    return c;
                  }
                }
              });
              if (checkCount.length === 1) {
                checkCount[0].setEnabled(false);
              }
            };

            // Hide/show columns
            let hideShowFunc = function() {

              this.emit(gbc.constants.widgetEvents.tableShowHideCol, "toggle");

              // refocus UI widget to keep key processing & dropdown manage keys active
              // because dropdown element is outside UserInterface in the HTML Dom
              let tableWidget = this.getTableWidgetBase();
              if (tableWidget._contextMenu && tableWidget._contextMenu.isVisible()) {
                let uiWidget = tableWidget.getUserInterfaceWidget();
                if (uiWidget) {
                  uiWidget.getElement().domFocus();
                }
              }
            };

            let checkNextValue = function() {
              this.setValue(this.getNextValue());
            };

            // for each col add hide/show checkbox
            for (const col of this.getOrderedColumns()) {
              if (!col.isAlwaysHidden()) {
                let check = cls.WidgetFactory.createWidget("CheckBox", opts);
                check._colWidget = col;
                check.setEnabled(col.isCheckable());
                check.setText(col.getText());
                check.setValue(!col.isHidden());
                check.when(context.constants.widgetEvents.valueChanged, checkNextValue.bind(check));
                check.when(context.constants.widgetEvents.click, checkLast.bind(col));
                contextMenu.addChildWidget(check, {
                  clickCallback: hideShowFunc.bind(col, check)
                });
              }
            }
            checkLast();
            contextMenu.addSeparator();

            // Show all columns action
            let showAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
            showAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.showAllColumns"));
            showAllColumnsLabel.addClass("gbc_showAllColumns_action");
            contextMenu.addChildWidget(showAllColumnsLabel, {
              clickCallback: function() {
                let columns = this.getColumns();
                for (const element of columns) {
                  let tc = element;
                  if (!tc.isAlwaysHidden() && !tc.isUnhidable()) {
                    tc.emit(gbc.constants.widgetEvents.tableShowHideCol, "show");
                  }
                }
              }.bind(this)
            });

            // Hide all columns action
            // Not available in inputmode to avoid cancelling modifications
            if (this.isDisplayMode()) {
              let hideAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
              hideAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.hideAllColumns"));
              hideAllColumnsLabel.addClass("gbc_hideAllColumns_action");
              contextMenu.addChildWidget(hideAllColumnsLabel, {
                clickCallback: function() {
                  let columns = this.getOrderedColumns();
                  for (const col of columns) {
                    if (!col.isHidden()) {
                      col.hideOtherColumns();
                      return;
                    }
                  }
                }.bind(this)
              });
            }
          }

          // AutoFit column width based on values
          let autoFitAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
          autoFitAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.autoFitAllColumns"));
          autoFitAllColumnsLabel.addClass("gbc_autoFitAllColumns_action");
          contextMenu.addChildWidget(autoFitAllColumnsLabel, {
            clickCallback: function() {
              this.autoFitAllColumns();
            }.bind(this)
          });

          // Fit column width so all columns visible
          // Example: if table width = 600px and there are two columns currently 100 and 200px
          // then this will set width of columns to 200 and 400 px respectively
          let fitToViewAllColumnsLabel = cls.WidgetFactory.createWidget("Label", opts);
          fitToViewAllColumnsLabel.setValue(i18next.t("gwc.contextMenu.fitToViewAllColumns"));
          fitToViewAllColumnsLabel.addClass("gbc_fitToViewAllColumns_action");
          contextMenu.addChildWidget(fitToViewAllColumnsLabel, {
            clickCallback: function() {
              this.fitToViewAllColumns();
            }.bind(this)
          });

          contextMenu.addSeparator();

          // Reset to default action
          let resetDefaultLabel = cls.WidgetFactory.createWidget("Label", opts);
          resetDefaultLabel.setValue(i18next.t("gwc.contextMenu.restoreDefaultSettings"));
          resetDefaultLabel.addClass("gbc_restoreColumnSort_action");
          contextMenu.addChildWidget(resetDefaultLabel, {
            clickCallback: function() {
              this.emit(context.constants.widgetEvents.tableResetToDefault);
            }.bind(this)
          });

          // Reset sort order action
          let resetLabel = cls.WidgetFactory.createWidget("Label", opts);
          resetLabel.setValue(i18next.t("gwc.contextMenu.restoreColumnSort"));
          resetLabel.addClass("gbc_restoreColumnSort_action");
          contextMenu.addChildWidget(resetLabel, {
            clickCallback: function() {
              this.emit(context.constants.widgetEvents.tableHeaderSort, -1);
            }.bind(this)
          });
        },

        /**
         * Build context menu and show it
         */
        _buildContextMenu: function(domEvent) {

          if (this._contextMenu) {
            this._contextMenu.destroyChildren();
            this._contextMenu.destroy();
            this._contextMenu = null;
          }

          let opts = this.getBuildParameters();
          opts.inTable = false; // contextmenu is not really in the table, it is outside
          opts.ignoreLayout = true;

          this._contextMenu = cls.WidgetFactory.createWidget("ContextMenu", opts);
          this._contextMenu.allowMultipleChoices(true);
          this._contextMenu.setParentWidget(this);
          this._contextMenu.setColor(this.getColor());
          this._contextMenu.setBackgroundColor(this.getBackgroundColor());
          this._contextMenu.onClose(function() {
            // Hide the menu button if it's visible

            this.afterDomMutator(function() {
              if (this._contextMenu) {
                this._contextMenu.destroyChildren();
                this._contextMenu.destroy();
                this._contextMenu = null;

                this._menuButtonComponent.unfreezeAndHide(cls.TableMenuButtonWidgetComponent._postHoverDelay);
              }
            }.bind(this));
          }.bind(this), true);

          this.fillContextMenu(this._contextMenu, opts);

          // beware setFocus should not raise a scroll event (it will immediately close contextmenu)
          this._element.domFocus(null, this.getElement());

          this._contextMenu.reverseX = true;
          this._contextMenu.parentElement = domEvent.target;
          this._menuButtonComponent.freeze();
          this._contextMenu.show();
        },

        /**
         * @inheritDoc
         */
        buildExtraContextMenuActions: function(contextMenu) {
          let copyFunction = null;

          if (this._selectionSquareIdx.left.x !== null) {
            copyFunction = function(contextMenu) {
              contextMenu.hide();
              this._copySelectionInClipboard();
            }.bind(this);

            contextMenu.addAction("copy", i18next.t("gwc.clipboard.copy"), null, "Control+C", {
              clickCallback: copyFunction.bind(this, contextMenu)
            }, true);
          }

          // A current line must be defined and all the selected items must be on the same row (if a selection is defined)
          if (this.canShowCopyCellAndRow()) {
            contextMenu.addAction("copyRow", i18next.t("gwc.contextMenu.copyRow"), null,
              null, {
                clickCallback: function() {
                  contextMenu.hide();
                  this._copyCurrentRowInClipboard();
                }.bind(this)
              }, true);
          }

          if (this.isMultiRowSelectionEnabled()) {
            contextMenu.addAction("selectAll", i18next.t("gwc.contextMenu.selectAll"), "font:FontAwesome.ttf:f0ea", "Ctrl+A", {
              clickCallback: function() {
                contextMenu.hide();
                this.emit(context.constants.widgetEvents.selectAll);
              }.bind(this)
            }, true);
          }
        },

        /**
         * Invalidate measure to force width & row height measure in next layout cycle
         */
        resetMeasure: function() {
          this.resetLayout();
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
          if (this.getLayoutEngine().invalidatePreferredSize) {
            this.getLayoutEngine().invalidatePreferredSize();
          }
        },

        /**
         * Update table depending on parameters
         * @param {boolean} resetOrderedColumns - reset ordered columns
         * @param {boolean} layoutRow - update row height layout
         * @param {boolean} layoutCol - update col width layout
         */
        update: function(resetOrderedColumns, layoutRow, layoutCol) {

          if (resetOrderedColumns) {
            this.resetOrderedColumns();
          }
          if (this.getLayoutEngine().computeRowsColsCss(layoutRow, layoutCol)) {
            this.getLayoutEngine().measureDecoration();
            this.updateAllAggregate();
            this.updateFrozenColumns();
          }
        },

        /**
         * Change the type of view (classic, flipped, listview)
         * @param {String} viewType - type of view (classic, flipped, listview)
         * @param {boolean} [forceLayout] - if true, force layout of table
         */
        setViewType: function(viewType, forceLayout = false) {
          if (this.getViewType() === viewType) {
            return;
          }

          this._viewType = viewType;
          this.getElement().setAttribute("viewType", viewType);

          // Reset the layout engine
          if (this._layoutEngine && forceLayout) {
            this.resetMeasure();
            this._initLayout();
            this.update(false, true, true);
            this.getLayoutEngine().computeRowsColsCss(true, true, true);
            this.emit(context.constants.widgetEvents.layout);
            this.updateVerticalScroll(true);
          }
        },

        /**
         * Return type of view (classic, flipped, listview)
         * @return {String} (classic, flipped, listview)
         */
        getViewType: function() {
          return this._viewType;
        },

        /**
         * Is flipped view ?
         * @return {boolean} is flipped view ?
         */
        isFlipped: function() {
          return this.getViewType() === "flipped";
        },

        /**
         * Enable/disable alternate row color
         * @param {boolean} b - enable/disable alternate row color
         * @param {boolean} forceUpdate - force update of alternate row colors
         * @param {boolean} refresh - reload colors from theme service
         */
        setAlternateRows: function(b, forceUpdate = false, refresh = false) {
          let update = forceUpdate;
          if ((this._alternateRows !== b) || refresh) {
            this._alternateRows = b;
            let evenRowBackgroundColor = context.ThemeService.getValue("gbc-TableWidget-even-row-background-color");
            let oddRowBackgroundColor = context.ThemeService.getValue("gbc-TableWidget-odd-row-background-color");
            this._evenRowBackgroundColor = this._alternateRows ? evenRowBackgroundColor :
              context.ThemeService.getValue("theme-field-background-color");
            this._oddRowBackgroundColor = this._alternateRows ? oddRowBackgroundColor :
              context.ThemeService.getValue("theme-field-background-color");
            update = true;
          }
          if (update) {
            // update odd and even backcolor
            // if diff offset is odd, switch odd/even colors
            let switchOddEven = (this._offset % 2 !== 0);
            this.getElement().style.setProperty('--evenRowBackgroundColor', switchOddEven ? this._oddRowBackgroundColor : this
              ._evenRowBackgroundColor);
            this.getElement().style.setProperty('--oddRowBackgroundColor', switchOddEven ? this._evenRowBackgroundColor : this
              ._oddRowBackgroundColor);
          }
        },

        /**
         * Called when a scroll is done
         * @param {Object} event - scroll event
         */
        _onScroll: function(event) {
          const scrollLeft = event.target.scrollLeft;
          const scrollTop = event.target.scrollTop;
          if (this._currentItem) {
            this._currentItem.removeClass("currentCell");
            this._currentItem = null;
          }

          const leftScrolled = this._previousScrollLeftValue !== scrollLeft;

          if (this._previousScrollTopValue !== scrollTop) {
            this._previousScrollTopValue = scrollTop;
            if (event.target) {
              // Emit scroll event for vertical scrolling
              this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());
            }
          }

          if (leftScrolled) {
            this._previousScrollLeftValue = scrollLeft;
            // synchronize header & data horizontal scroll
            this.getHeaderGroupElement().scrollLeft = scrollLeft;
            this.getFooterGroupElement().scrollLeft = scrollLeft;

            // remove hidden columns from DOM during horizontal scroll
            this.updateVisibleColumnsInDom(scrollLeft);
          }

          // reset items selection after each scroll change
          this._resetItemsSelection();
        },

        /**
         * Update the list of columns which are in the DOM according to current viewport and horizontal scroll position (optimisation)
         * @param {number} scrollLeft
         * @param {boolean} forceColsMeasure
         * @private
         */
        updateVisibleColumnsInDom: function(scrollLeft, forceColsMeasure = false) {
          if (!this._layoutInformation) {
            return;
          }
          const isVisible = this.isVisibleRecursively();
          if (!isVisible) {
            return;
          }

          // read scrollLeft if specified otherwise retrieve it
          scrollLeft = typeof scrollLeft !== 'undefined' ? scrollLeft : this.getScrollableArea().scrollLeft;

          const columns = this.getOrderedColumns();
          const tableWidth = this._layoutInformation.getAllocated().getWidth();
          let currentWidth = 0;
          const colsToRemove = [];
          const colsToAdd = [];

          for (const col of columns) {
            if (!this.isFlipped() && !col.isFrozen() && !col.isHidden()) { // scrollable columns
              const colLayoutInfo = col.getLayoutInformation();
              if (colLayoutInfo) {
                let colWidth = col.getWidth();

                // Use stretchmin width instead if it is greater than the measured width
                if (colLayoutInfo.isXStretched()) {
                  const rawStretchMin = colLayoutInfo.getRawInformation().getStretchMin();
                  if (rawStretchMin !== 0) {
                    const stretchMin = cls.CharSize.translate(rawStretchMin, colLayoutInfo.getCharSize().getWidthM(), colLayoutInfo
                      .getCharSize().getWidth0());
                    colWidth = stretchMin > colWidth ? stretchMin : colWidth;
                  }
                }

                // Detach columns which are not visible at left
                if ((currentWidth + colWidth) < (scrollLeft) || (currentWidth - scrollLeft) > (tableWidth - this
                    ._totalLeftFrozenColumnWidth)) {
                  colsToRemove.push(col);
                } else {
                  colsToAdd.push(col);
                }
                currentWidth += colWidth;
              }
            } else if (col.isHidden()) {
              colsToRemove.push(col);
            } else {
              colsToAdd.push(col);
            }
          }

          let measureCols = false;
          if (colsToRemove.length > 0 || colsToAdd.length > 0) {
            const prepend = scrollLeft < this._previousScrollLeftValue;
            /**
             * when prepending columns, reverse orders to prepend them from the last one to the first one
             * we try to conserve correct dom orders for columns and items even if its unnecessary 
             * because processed by their CSS order attribute, but it's nice to have
             */
            if (prepend) {
              colsToAdd.reverse();
            }
            colsToRemove.forEach(c => {
              c.detachItemsFromDom();
              c.reorderAggregateLabel();
            });
            colsToAdd.forEach(c => {
              c.attachItemsToDom(prepend);
              c.reorderAggregateLabel();
            });
            measureCols = true;
          }

          if (forceColsMeasure || measureCols) {
            // update CSS grid template
            this.getLayoutEngine().computeRowsColsCss(false, true, false);
          }

        },

        /**
         * @inheritDoc
         */
        setScrolling: function(up, down) {

          this._isScrolling = up || down;
          // unnecessary for now
          //this.getScrollerElement().toggleClass("scrollingUp", up);
          //this.getScrollerElement().toggleClass("scrollingDown", down);
        },

        /**
         * Returns item widget
         * @param {number} row - item row
         * @param {number} col - item col
         * @returns {classes.RTableItemWidget} item widget
         * @publicdoc
         */
        getItem: function(row, col) {
          return this.getRows()[row].getItems()[col];
        },

        /**
         * Returns row widgets
         * @returns {classes.RTableRowWidget[]} array of row widgets
         * @publicdoc
         */
        getRows: function() {
          return this.getChildren();
        },

        /**
         * Returns header row widget
         * @returns {classes.RTableRowWidget} header row widget
         * @publicdoc
         */
        getHeaderRowWidget: function() {
          return this._headerRowWidget;
        },

        /**
         * Returns footer row widget
         * @returns {classes.RTableRowWidget} footer row widget
         * @publicdoc
         */
        getFooterAggregatesRowWidget: function() {
          return this._footerAggregatesRowWidget;
        },

        /**
         * @inheritDoc
         */
        setPageSize: function(pageSize) {
          if (this._pageSize !== pageSize) {
            this.getElement().style.setProperty('--pageSize', pageSize + '');
            this._resetItemsSelection(); // reset items selection after pageSize change
          }
          $super.setPageSize.call(this, pageSize);
        },

        /**
         * @inheritDoc
         */
        setBufferSize: function(bufferSize) {
          if (this._bufferSize !== bufferSize) {
            this.getElement().style.setProperty('--bufferSize', bufferSize + '');
          }
          $super.setBufferSize.call(this, bufferSize);
        },

        /**
         * @inheritDoc
         */
        setSize: function(size) {
          if (this._size !== size) {
            // in input one extra line for user to click after last line
            size = (this.isInputMode() || this.isInputArrayMode()) ? size + 1 : size;
            this.getElement().style.setProperty('--size', size + '');

            // if size of table changed, update row number in cached data model
            this._cachedDataModel.updateNbRows(size);
          }
          $super.setSize.call(this, size);
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          options = options || {};

          if (options.isRowData) {
            let rowWidget = this.getRows()[options.rowIndex];

            // create row widget
            if (!rowWidget) {
              rowWidget = cls.WidgetFactory.createWidget("RTableRow", this.getBuildParameters());

              // don't hide first row it is used for layout computation
              let hideRow = options.rowIndex >= this._visibleRows && options.rowIndex !== 0;
              rowWidget.setHidden(hideRow);

              $super.addChildWidget.call(this, rowWidget);

              rowWidget.onAttachedToParentTable();
            }
            // add item to row widget
            rowWidget.addChildWidget(widget, options);
          } else if (widget.isInstanceOf(cls.RTableColumnWidget)) {
            options.headerItem = true;
            options.colWidget = widget;
            widget.setOrder(this.getHeaderRowWidget().getChildren().length, true); // set order on header columns as well
            this.getHeaderRowWidget().addChildWidget(widget, options);
          } else {
            $super.addChildWidget.call(this, widget, options);
          }

          this.resetOrderedColumns();
        },

        /**
         * @inheritDoc
         */
        removeChildWidget: function(widget) {
          $super.removeChildWidget.call(this, widget);
          this.resetOrderedColumns();
        },

        /**
         * @inheritDoc
         */
        setVisibleRows: function(visibleRows) {
          if (this._visibleRows !== visibleRows) {
            this._visibleRows = visibleRows;
            this.updateVisibleColumnsInDom();
            let rows = this.getRows();
            for (let i = 0; i < rows.length; ++i) {
              let row = rows[i];
              row.setHidden(i >= visibleRows);
            }
          }
        },

        /**
         * @inheritDoc
         */
        setRowHeight: function(height) {
          if (this._rowHeight !== height) {
            this.setStyle({
              '--rowHeight': `${height}px`
            });
          }
          $super.setRowHeight.call(this, height);
        },

        /**
         * @inheritDoc
         */
        getRowHeight: function() {

          if (this.getViewType() === "flipped") {

            /* Hack : Used for GBC-4255. To design Flipped table, the row decoration is not taken into account. 
             * Resulting in a wrongly computed pageSize
             * 
             * As defined in the Scss file
             */
            let rowMarginAndPadding = Math.ceil(
              parseFloat(context.ThemeService.getValue("gbc-TableWidget-margin-ratio"), 10) *
              parseFloat(context.ThemeService.getValue("gbc-TableWidget-table-margin"), 10) *
              2.5 *
              3
            );

            return $super.getRowHeight.call(this) + rowMarginAndPadding;
          }

          return $super.getRowHeight.call(this);
        },

        /**
         * @inheritDoc
         */
        setVerticalScroll: function(offset, forceScroll = false) {
          // Pagination nav WIP
          //if (this._paginationWidget) {
          //  this._paginationWidget.update(size, pageSize, offset);
          //}

          if (this.getLayoutEngine().isLayoutDone()) {

            let top = 0;
            if (this.isEnabled()) {
              top = offset * this.getRowHeight();
            }
            this.getElement().style.setProperty('--scrollTop', top + "px");

            // if offset is different or if scrolltop value of current scrollarea is different too different from calculated value
            // need to rest scrolltop of scrollablearea
            if (!!forceScroll || (this.lastSentOffset === null || this.lastSentOffset === offset) && offset !== this._offset) {
              this._offset = offset;
              this.doScroll(top, false);
            }
            this.lastSentOffset = null;
          }
        },

        /**
         * Returns if vertical scroll bar is at end
         * @returns {boolean} true if vertical Scroll bar is at end
         */
        isVerticalScrollAtEnd: function() {
          let scrollArea = this.getScrollableArea();
          return (scrollArea.scrollTop + scrollArea.clientHeight) === scrollArea.scrollHeight;
        },

        /**
         * Do native vertical scroll
         * @param {number} value - new scroll value
         * @param {boolean} delta - if true, value is added to old scroll value
         */
        doScroll: function(value, delta) {
          if (delta) {
            value = (this.getScrollableArea().scrollTop + value);
          }
          // update this in case of element is not in DOM, event scroll will not be emitted
          this._previousScrollTopValue = value;

          this.getScrollableArea().scrollTo({
            top: value,
            behavior: "instant"
          });
        },

        /**
         * Do a horizontal scrolling (column by column)
         * @param {string} direction - "left" or "right"
         */
        doHorizontalScroll: function(direction) {
          let scrollArea = this.getScrollableArea();
          let scrollPos = scrollArea.scrollLeft;
          let columns = this.getOrderedColumns();
          let width = 0;
          for (const element of columns) {
            let col = element;
            if (col.isFrozen() === false && col.isHidden() === false) {
              let colWidth = col.getWidth();

              let isScrollAtStartColumn = (Math.abs(scrollPos - width) <= 2);
              let isScrollAtEndColumn = (Math.abs(scrollPos - (width + colWidth)) <= 2);
              if ((isScrollAtStartColumn || scrollPos > width) && (isScrollAtEndColumn || scrollPos < width + colWidth)) {
                if (isScrollAtStartColumn && direction === "right") {
                  scrollPos = width + colWidth;
                  direction = "left";
                } else if (isScrollAtEndColumn && direction === "right") {
                  scrollPos = width + colWidth;
                } else {
                  scrollArea.scrollLeft = direction === "right" ? width + colWidth : width;
                  break;
                }
              }
              width += colWidth;
            }
          }
        },

        /**
         * @inheritDoc
         */
        setCurrentRow: function(row, ensureRowVisible = false, vmCurrentRow = null) {

          if (vmCurrentRow !== null) {
            this._vmCurrentRow = vmCurrentRow;
          }
          this._currentRow = row;

          const children = this.getRows();
          const length = children.length;
          for (let i = 0; i < length; ++i) {
            let rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }

        },

        /**
         * @inheritDoc
         */
        setCurrentColumn: function(col) {
          this._currentColumn = col;
          let columns = this.getColumns();
          for (let i = 0; i < columns.length; i++) {
            if (columns[i].setCurrent) {
              columns[i].setCurrent(i === col);
            }
          }
        },

        /**
         * Update current item
         */
        updateCurrentItem: function() {
          const currentRow = this.getRows()[this._currentRow];
          const currentItem = currentRow && currentRow.getItems()[this._currentColumn];
          if (currentItem && currentItem !== this._currentItem) {
            if (this._currentItem) {
              this._currentItem.removeClass("currentCell");
            }
            this._currentItem = currentItem;
            this._currentItem.addClass("currentCell");
          }
        },

        /**
         * Generates a manual horizontal scroll (if needed) to make sure focused column item if visible and thus attached to DOM
         */
        scrollToCurrentColumn: function() {
          // need to scroll the table horizontally
          if (this.isFlipped()) {
            return;
          }
          const columns = this.getOrderedColumns();
          const currentCol = columns[this._currentColumn];
          if (currentCol && currentCol.isDetachedFromDom()) {

            let minScrollLeft = 0;
            // calculate required scrollLeft to make the focused column visible
            for (const col of columns) {
              if (col.isFrozen() === false && col.isHidden() === false) {
                if (col.isCurrent()) {
                  break;
                }
                minScrollLeft += col.getWidth();
              }
            }

            // substract table width (viewport width) from the calculated scrollLeft to horizontally center the focused column toward the visible viewport zone
            this.getScrollableArea().scrollLeft = Math.max((minScrollLeft - (this._layoutInformation.getAllocated().getWidth() / 2)), 0);
          }
        },

        /** Returns current column
         * @returns {number} current column
         * @public
         */
        getCurrentColumn: function() {
          return this._currentColumn;
        },

        /**
         * Add a table column (virtual)
         * @param {classes.RTableColumnWidget} col - table column
         */
        addColumn: function(col) {
          this._columns.push(col);
        },

        /**
         * Returns an array with all table columns
         * @return {classes.RTableColumnWidget[]} table columns array
         */
        getColumns: function() {
          return this._columns;
        },

        /**
         * Reset cache of ordered columns.
         */
        resetOrderedColumns: function() {
          this._orderedColumns = null;
        },

        /**
         * Returns column widgets (visual order)
         * @returns {classes.RTableColumnWidget[]} array of column widgets
         * @publicdoc
         */
        getOrderedColumns: function() {
          let columns = this.getColumns();
          if (this._orderedColumns === null || columns.length !== this._orderedColumns.length) {
            let children = columns.slice();
            children.sort(function(a, b) {
              return a.getOrder() - b.getOrder();
            });
            this._orderedColumns = children;
          }
          return this._orderedColumns;
        },

        /**
         * Set sorted column and type
         * @param sortType - sort type "asc" or "desc" (empty string for no sort)
         * @param sortColumn - column sorted (-1 for no sort)
         */
        setSort: function(sortType, sortColumn) {
          let columns = this.getColumns();

          for (let i = 0; i < columns.length; i++) {
            if (i === sortColumn) {
              columns[i].setSortDecorator(sortType);
            } else {
              columns[i].setSortDecorator("");
            }
          }
        },

        /**
         * Enable/disable row hover
         * @param {boolean} rowHover - if true enable row hover, else disable it
         */
        setRowHover: function(rowHover) {
          if (this._rowHover !== rowHover) {
            this._rowHover = rowHover;
            this._element.toggleClass("rowHover", Boolean(rowHover));
          }
        },

        /**
         * @param {boolean} enable - true if the table should allow multi-row selection, false otherwise
         */
        setMultiRowSelectionEnabled: function(enable) {
          if (this._multiRowSelectionEnabled !== enable) {
            this._multiRowSelectionEnabled = enable;
            this._element.toggleClass("multiRowSelection", enable);
          }
        },

        /**
         * Returns if multi-row selection is enabled
         * @returns {boolean} true if the table allow multi-row selection, false otherwise
         * @publicdoc
         */
        isMultiRowSelectionEnabled: function() {
          return this._multiRowSelectionEnabled;
        },

        /**
         * Sets the specified row is selected
         * @param {number} row - index of the row
         * @param {boolean} selected - true if the row should be selected, false otherwise
         */
        setRowSelected: function(row, selected) {
          if (row < this.getRows().length) {
            this.getRows()[row].setSelected(selected && !this.isInputMode()); // disable multi row selection in Input mode
          }
        },

        /**
         * Returns if the specified row is selected
         * @param {number} row - index of the row
         * @returns {boolean} true if the row is selected, false otherwise
         */
        isRowSelected: function(row) {
          return (row < this.getRows().length) && this.getRows()[row].isSelected();
        },

        /**
         * Auto-fit all column widths
         */
        autoFitAllColumns: function() {
          const app = context.SessionService.getCurrent().getCurrentApplication();
          app.scheduler.callbackCommand(function() {
            if (!this.isDestroyed()) {
              let columns = this.getColumns();
              for (const tc of columns) {
                tc.autoSetWidth(true);
              }

              // relayout & update css properties once all columns have been re-measured
              this.update(false, false, true);
              this.updateVisibleColumnsInDom();
            }
          }.bind(this));
        },

        /**
         * Auto fit column widths so all columns visible.
         */
        fitToViewAllColumns: function() {
          // phase 1 work out total
          let visibleColumns = this.getOrderedColumns().filter((column) => !column.isHidden());
          let availableSpace = this.getDataAreaWidth();
          let sizableColumnsTotalWidth = 0;
          for (const column of visibleColumns) {
            if (column.isSizable()) {
              sizableColumnsTotalWidth = sizableColumnsTotalWidth + column.getWidth();
            } else {
              availableSpace = availableSpace - column.getWidth();
            }
          }

          // It means that there is no column to resize
          if (sizableColumnsTotalWidth <= 0) {
            return;
          }

          // phase 2 set column width in proportion to space available
          let sizableColumns = visibleColumns.filter((column) => column.isSizable());
          const transformationRatio = availableSpace / sizableColumnsTotalWidth;
          let availableSpaceLeft = availableSpace;
          let i = 0;
          let width = 0;
          for (const sizableColumn of sizableColumns) {
            // Give the remaining width to the last column
            if (i === sizableColumns.length - 1) {
              width = availableSpaceLeft;
            } else {
              // Round down to avoid getting out of space for the last column
              width = Math.floor(sizableColumn.getWidth() * transformationRatio);
            }
            sizableColumn.setUserWidthFromInteraction(width, true);
            availableSpaceLeft -= width;
            i += 1;
          }

          // relayout & update css properties once all columns have been re-measured
          this.update(false, false, true);
          this.updateVisibleColumnsInDom();
        },

        /**
         * Sets if the column can be hidden by the user
         * @param {boolean} b - is not hiddable ?
         */
        setUnhidable: function(b) {
          this._hasUnhidableColumns = b;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          if (this._enabled !== enabled) {
            $super.setEnabled.call(this, enabled);

            this._resetItemsSelection();
            this.updateVerticalScroll(enabled);
          }
        },

        /**
         * @inheritDoc
         */
        setInTableWidgetColor: function(widget, color) {

          widget.setStyle({
            preSelector: ".gbc_RTableWidget:not(.gbc_highlightCurrentRow) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "color": color ? color + " !important" : null,
          });

          widget.setStyle({
            preSelector: ".gbc_highlightCurrentRow .gbc_RTableRowWidget:not(.currentRow) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "color": color ? color + " !important" : null,
          });
        },

        /**
         * @inheritDoc
         */
        setInTableWidgetBackgroundColor: function(widget, color) {

          // TODO need to review all style color management, it is too complex
          // TODO can we use css variables ?
          widget.setStyle({
            preSelector: ".gbc_RTableWidget:not(.gbc_highlightCurrentRow.gbc_highlightCurrentCell) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "background-color": color && !widget._ignoreBackgroundColor ? color + " !important" : null,
          });

          widget.setStyle({
            preSelector: ".RTableWidget:not(.gbc_HighlightCurrentCell) .currentCell ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "background-color": color && !widget._ignoreBackgroundColor ? color + " !important" : null,
          });

          widget.setStyle({
            preSelector: ".gbc_highlightCurrentRow.noHighlightCurrentCell .gbc_RTableRowWidget:not(.currentRow) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "background-color": color && !widget._ignoreBackgroundColor ? color + " !important" : null,
          });

          widget.setStyle({
            preSelector: "gbc_RTableWidget.highlightCurrentCell:not(gbc_HighlightCurrentRow) .gbc_RTableItemWidget:not(.currentCell) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "background-color": color && !widget._ignoreBackgroundColor ? color + " !important" : null,
          });

          widget.setStyle({
            preSelector: ".highlightCurrentRow.highlightCurrentCell .gbc_RTableRowWidget:not(.currentRow) .gbc_RTableItemWidget:not(.currentCell) ",
            selector: ".gbc_WidgetBase_in_array",
            appliesOnRoot: true
          }, {
            "background-color": color && !widget._ignoreBackgroundColor ? color + " !important" : null,
          });

        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          this.setStyle('.gbc_TableHeaderGroup', {
            "background-color": color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * @inheritDoc
         */
        setHaveRowBoundActions: function(haveActions) {
          $super.setHaveRowBoundActions.call(this, haveActions);

          if (haveActions) {
            this._headerRowWidget.updateRowBound();
            for (const row of this.getRows()) {
              row.updateRowBound();
            }
          }
        },

        /**
         * @inheritDoc
         */
        setDialogType: function(dialogType) {
          // Disable vertical scrollbar in INPUT mode
          $super.setDialogType.call(this, dialogType);
          // disable vertical scrolling in INPUT mode
          this.getContainerElement().toggleClass("overflow-y-hidden", this.isInputMode());
          /** @hack : As a table create labels instead of edits in display array, 
           * we need to recompute the layout when changing the dialog type for flipped table,
           * because a small change in pixel size, can mess up the whole row
           * */
          if (this.isFlipped()) {
            this.resetMeasure();
          }
        },

        // ============== START - ANTICIPATE SCROLLING FUNCTIONS ===================
        /**
         * @inheritDoc
         */
        anticipateScrolling: function() {

          // update table widgets from data model
          this.applyDataFromModel(true);

          // Update --scrollTop css variable to set table items at the right position
          const top = this._offset * this.getRowHeight();
          this.getElement().style.setProperty('--scrollTop', top + "px");

          // update currentRow
          if (this._vmCurrentRow !== null) {
            this.setCurrentRow(this._vmCurrentRow - this._offset, false);
          }

          // update alternate rows
          this.setAlternateRows(this._alternateRows, true);
        },

        /**
         * Apply data from model to widget
         * @param {boolean} blur - if true blur rows which have no data in the model
         * @todo : Simplify this method ? I don't get why we run through the table column by column instead of using the availble rows
         */
        applyDataFromModel: function(blur) {

          if (!this.isEnabled()) {
            return;
          }
          context.styler.bufferize();
          const tableColumns = this.getColumns();

          let isFirstVisibleColumn = false;
          for (let columnIndex = 0; columnIndex < tableColumns.length; ++columnIndex) {
            const column = tableColumns[columnIndex];
            const columnItems = column.getItems();

            const maxLoop = Math.min(columnItems.length, this.getBufferSize());
            const isColumnVisible = (maxLoop > 0); // if there is now rows --> col is not visible
            isFirstVisibleColumn = (isColumnVisible && !isFirstVisibleColumn);

            for (let rowIndex = 0; rowIndex < maxLoop; rowIndex++) {
              const columnItem = columnItems[rowIndex];

              const rowModelIndex = this.getOffset() + rowIndex;
              if (rowModelIndex >= this._cachedDataModel.getData().length) {
                continue;
              }
              const rowModel = this._cachedDataModel.getData()[rowModelIndex];

              if (isFirstVisibleColumn && rowModel.selected !== null) {
                // do it for the first visible column only because it's about the entire row
                // update selected rows
                this.setRowSelected(rowIndex, rowModel.selected);
              }

              if (columnItem.isTreeItem() && rowModel.treeDepth !== null && rowModel.treeLeaf !== null && rowModel.treeExpanded !== null) {
                // apply tree item attributes
                columnItem.setDepth(rowModel.treeDepth);
                columnItem.setLeaf(rowModel.treeLeaf);
                columnItem.setExpanded(rowModel.treeExpanded);
              }

              const data = rowModel.items[columnIndex];
              if (data) {
                // if an item doesn't have data from model yet, then blur it
                columnItem.blur(blur && !rowModel.vm);

                if (columnIndex === 0) {
                  // if the first column is blured, blur the rowbound item
                  this.getRows()[rowIndex].getRowBoundDecorator()?.blur(blur && !rowModel.vm);
                }

                // update table items from data model when we are anticipating, otherwise let the behaviors do their job node by node
                for (const prop in data) {
                  this._updateItem(columnItem, prop, data[prop]);
                }
              }
            }
          }

          context.styler.flush();
        },

        /**
         * Update table item with datas
         * @param {classes.RTableItemWidget} tableItemWidget
         * @param {String} dataName - data name
         * @param {*} dataValue - data value
         */
        _updateItem: function(tableItemWidget, dataName, dataValue) {

          if (dataValue !== undefined) {
            const cellWidget = tableItemWidget.getWidget();

            switch (dataName) {
              case "value":
                if (cellWidget.setValue && (!cellWidget.isEditing || !cellWidget.isEditing())) {

                  if (cellWidget instanceof cls.ImageWidget) {
                    // for ImageWidget setSrc with directApply is faster than setValue
                    // TODO need to have a generic way to call a faster setValue function from WidgetBase
                    cellWidget.setSrc(dataValue, this._isScrolling);
                  } else {
                    cellWidget.setValue(dataValue, true);
                  }
                }
                break;
              case "image":
                tableItemWidget.setImage(dataValue);
                break;
              case "textColor":
                if (cellWidget.setColor) {
                  cellWidget.setColor(dataValue);
                }
                break;
              case "textDecoration":
                if (cellWidget.setTextDecoration) {
                  cellWidget.setTextDecoration(dataValue);
                }
                break;
              case "backgroundColor":
                tableItemWidget.setBackgroundColor(dataValue);
                break;
              case "fontWeight":
                if (cellWidget.setFontWeight) {
                  cellWidget.setFontWeight(dataValue);
                }
                break;
              default:
            }
          }
        },
        // ============== END - ANTICIPATE SCROLLING FUNCTIONS ===================

        // ============== START - HEADER Event/DnD FUNCTIONS ===================

        /**
         * Handle drag start on header
         * @param {DragEvent} evt - dragstart event
         * @private
         */
        _onHeaderDragStart: function(evt) {
          this._columnContainerComponent.onDragStart(evt);
        },

        /**
         * Handle drag end on header
         * @param {DragEvent} evt - dragend event
         * @private
         */
        _onHeaderDragEnd: function(evt) {
          this._columnContainerComponent.onDragEnd(evt);
        },

        /**
         * Handle drag start on header
         * @param {DragEvent} evt - drag event
         * @private
         */
        _onHeaderDrag: function(evt) {
          // Not handled, everything is handled into the _onHeaderDragOver() method
          return;
        },

        /**
         * Handle drag over on header
         * @param {DragEvent} evt - dragover event
         * @private
         */
        _onHeaderDragOver: function(evt) {
          this._columnContainerComponent.onDragOver(evt);
        },

        /**
         * Handle drag leave on header
         * @param {DragEvent} evt - dragleave event
         * @private
         */
        _onHeaderDragLeave: function(evt) {
          this._columnContainerComponent.onDragLeave(evt);
        },

        /**
         * Handle drop event on header
         * @param {DragEvent} evt - drop event
         * @private
         */
        _onHeaderDrop: function(evt) {
          this._columnContainerComponent.onDrop(evt);
        },

        // ====================================
        // TOUCH EVENTS
        // ====================================

        /**
         * Handle Touch Start event
         * @param {TouchEvent} evt
         */
        _onHeaderTouchStart: function(evt) {
          this._columnContainerComponent.onTouchStart(evt);
        },

        /**
         * Handle touch end event
         * @param {Object} evt 
         */
        _onHeaderTouchEnd: function(evt) {
          this._columnContainerComponent.onTouchEnd(evt);
        },

        /**
         * Handle Touch move event
         * @param {TouchEvent} evt - The touch event
         */
        _onHeaderTouchMove: function(evt) {
          this._columnContainerComponent.onTouchMove(evt);
        },

        // ============== END - HEADER Event/DnD FUNCTIONS ===================

        // ============== START - MENU BUTTON SHOW / HIDE EVENTS ===================
        /**
         * Handle wheel event
         * @param {WheelEvent} evt
         */
        _onWheel: function(evt) {
          if (evt.deltaY < 0) {
            this._menuButtonComponent.show(cls.TableMenuButtonWidgetComponent._defaultDelay);
          }
        },

        /**
         * Handle Touch Start event
         * @param {TouchEvent} evt
         */
        _onTouchStart: function(evt) {
          this._previousTouchYValue = evt.touches[0].clientY;
          this._cancelMenuButtonForThisTouchPhase = false;
        },

        /**
         * Handle Touch Move event
         * @param {TouchEvent} evt
         */
        _onTouchMove: function(evt) {
          if (evt.touches.length === 0 || this._cancelMenuButtonForThisTouchPhase) {
            return;
          }

          if (evt.touches[0].clientY > this._previousTouchYValue) {
            this._menuButtonComponent.show(cls.TableMenuButtonWidgetComponent._defaultDelay);
          } else {
            /*
             * For mobile, if the user do not scroll directly upward,
             * cancel the menu button show.
             */
            this._cancelMenuButtonForThisTouchPhase = true;
          }
        },

        // ============== END - MENU BUTTON SHOW / HIDE EVENTS ===================

        // ============== START - ITEMS CLIENT SELECTION FUNCTIONS ===================
        /**
         * Set if item selection is the default behavior (disable dnd in this case)
         * @param {boolean} b
         */
        setDefaultItemSelection: function(b) {
          this._defaultItemSelection = b;
          if (b === true) {
            this.setDndItemEnabled(false);
          }
        },

        /**
         * Check if this mouse event can allow item selection
         * @param {Object} evt - mouse event
         * @returns {boolean}
         */
        _isEventAllowItemSelection: function(evt) {
          return (this.isDisplayMode() && (evt.ctrlKey || evt.metaKey || this._defaultItemSelection)) || (this.isInputArrayMode() && (
            evt.ctrlKey ||
            evt.metaKey || (this._defaultItemSelection &&
              !this._enabled)));
        },

        /**
         * Returns true if there are some items selected
         * @returns {boolean} true if there are some items selected
         */
        hasItemsSelected: function() {
          if (this._itemSelectionElement === null) {
            return false;
          }
          return !(this._itemSelectionElement.hasClass("hidden"));
        },

        /**
         * Reset items selection
         */
        _resetItemsSelection: function() {
          this._selectionSquareIdx = {
            left: {
              x: null,
              y: null
            },
            right: {
              x: null,
              y: null
            }
          };

          if (this._firstItemSelected !== null) {
            this._itemSelectionInProgress = false;
            this._firstItemSelected = null;
            if (this._itemSelectionElement) {
              this._itemSelectionElement.addClass("hidden");
            }
            this._setItemSelection(false);
          }
        },

        /**
         * Handle mouseDown event for table items
         * @param {Object} evt - mousedown event
         */
        _onItemMouseDown: function(evt) {
          //if not left button
          if (evt.which !== 1) {
            return;
          }

          this._mouseDownTarget = evt.target;

          this._itemSelectionMouseMovePrevX = evt.screenX;
          this._itemSelectionMouseMovePrevY = evt.screenY;

          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");

          this._resetItemsSelection();

          // Start item selection
          if (itemWidget && this._isEventAllowItemSelection(evt)) {

            // To avoid text selection in input array
            evt.stopPropagation();
            evt.preventCancelableDefault();

            // Create selection rect element
            if (this._itemSelectionElement === null) {
              this._itemSelectionElement = document.createElement("span");
              this._itemSelectionElement.addClass("gbc_RTableItemSelectionArea");
              this._itemSelectionElement.addClass("hidden");
              this._element.appendChild(this._itemSelectionElement);
            }
            this._itemSelectionInProgress = true;
            this._firstItemSelected = itemWidget;

            // bind mousemove event
            this.getElement().on("mousemove.RTableWidget", this._onItemMouseMove.bind(this));

            // disable dnd
            this._temporaryEnabledDndOnItem(false, this._firstItemSelected);
          }
        },

        /**
         * Stop item selection in progress
         * @param {Object} evt - mouse event
         */
        _stopInProgressItemSelection: function(evt) {
          this._itemSelectionInProgress = false;
          if (this._isEventAllowItemSelection(evt)) {
            // re-enable dnd
            this._temporaryEnabledDndOnItem(this._dndItemEnabled, this._firstItemSelected);
          }
        },

        /**
         * Handle mouseUp event for table items
         * @param {Object} evt - mouseup event
         */
        _onItemMouseUp: function(evt) {

          // unbind mousemove event
          this.getElement().off("mousemove.RTableWidget");

          this._itemSelectionMouseMovePrevX = 0;
          this._itemSelectionMouseMovePrevY = 0;

          this._stopInProgressItemSelection(evt);
        },

        /**
         * Handle mouseLeave event for table items
         * @param {Object} evt - mouseleave event
         */
        _onItemMouseLeave: function(evt) {
          this._stopInProgressItemSelection(evt);
        },

        /**
         * Handle mouseMove event for table items
         * @param {Object} evt - mousemove event
         */
        _onItemMouseMove: function(evt) {
          let movementX = (this._itemSelectionMouseMovePrevX ? evt.screenX - this._itemSelectionMouseMovePrevX : 0);
          let movementY = (this._itemSelectionMouseMovePrevY ? evt.screenY - this._itemSelectionMouseMovePrevY : 0);

          if (Math.abs(movementX) > 1 || Math.abs(movementY) > 1) { // execute code only if movement > 1px
            if (this._itemSelectionInProgress && this._isEventAllowItemSelection(evt)) {
              let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
              if (itemWidget) {
                if (this._firstItemSelected !== null) {
                  this._setItemSelection(true, this._firstItemSelected, itemWidget);
                }
              }
            }
          }

          this._itemSelectionMouseMovePrevX = evt.screenX;
          this._itemSelectionMouseMovePrevY = evt.screenY;
        },

        /**
         * Copy current items selection in the clipboard
         */
        _copySelectionInClipboard: function() {
          let rows = [];
          let rowIndex;

          let orderedColumns = this.getOrderedColumns();
          for (const col of orderedColumns) {
            rowIndex = 0;
            for (const item of col.getChildren()) {
              if (item.isClientSelected()) {

                let text = item.getChildren()[0].getClipboardValue(true) + "\t";
                if (rows.length <= rowIndex) {
                  rows.push(text);
                } else {
                  rows[rowIndex] += text;
                }
                rowIndex++;
              }
            }
          }
          for (let i = 0; i < rows.length; ++i) {
            rows[i] = rows[i].substring(0, rows[i].length - 1);
          }
          gbc.ClipboardService.copyFromWidget(this, rows.join("\r\n"));
        },

        /**
         * Copy current row items in the clipboard
         */
        _copyCurrentRowInClipboard: function() {
          let row = "";

          let orderedColumns = this.getOrderedColumns();
          for (let i = 0; i < orderedColumns.length; i++) {
            let col = orderedColumns[i];
            if (!col.isHidden()) {
              if (this._currentRow >= 0 && this._currentRow < col.getChildren().length) {
                let item = col.getChildren()[this._currentRow];
                row += item.getChildren()[0].getClipboardValue(true);
                if (i < orderedColumns.length - 1) {
                  row += '\t';
                }
              }
            }
          }

          gbc.ClipboardService.copyFromWidget(this, row);
        },

        /**
         * Copy current cell item in the clipboard
         */
        _copyCurrentCellInClipboard: function() {
          let cell = "";
          let col = this.getColumns()[this._currentColumn];

          if (this._currentRow >= 0 && this._currentRow < col.getChildren().length) {
            let item = col.getChildren()[this._currentRow];
            cell = item.getChildren()[0].getClipboardValue(true);
          }

          gbc.ClipboardService.copyFromWidget(this, cell);
        },

        /**
         * Select items
         * @param {boolean} doSelect - true/false select or unselect items
         * @param {classes.TableColumnItemWidget} [startSelectedItem]
         * @param {classes.TableColumnItemWidget} [endSelectedItem]
         */
        _setItemSelection: function(doSelect, startSelectedItem, endSelectedItem) {

          let realStartRow = -1;
          let realEndRow = -1;
          let realStartCol = -1;
          let realEndCol = -1;

          this._itemSelectionHasChanged = false;

          if (doSelect && startSelectedItem && endSelectedItem) {

            let startCol = startSelectedItem.getColumnWidget().getOrderedColumnIndex();
            let startRow = startSelectedItem.getRowIndex();
            let endCol = !endSelectedItem ? startCol : endSelectedItem.getColumnWidget().getOrderedColumnIndex();
            let endRow = !endSelectedItem ? startRow : endSelectedItem.getRowIndex();

            this._selectionSquareIdx.left.x = realStartRow = (startRow < endRow) ? startRow : endRow;
            this._selectionSquareIdx.right.x = realEndRow = (startRow < endRow) ? endRow : startRow;
            this._selectionSquareIdx.left.y = realStartCol = (startCol < endCol) ? startCol : endCol;
            this._selectionSquareIdx.right.y = realEndCol = (startCol < endCol) ? endCol : startCol;

            let mostLeftItem = (realStartCol === startCol) ? startSelectedItem : endSelectedItem;
            let mostRightItem = (realStartCol === startCol) ? endSelectedItem : startSelectedItem;
            let left = mostLeftItem.getElement().getBoundingClientRect().left;
            let right = mostRightItem.getElement().getBoundingClientRect().right;

            let mostTopItem = (realStartRow === startRow) ? startSelectedItem : endSelectedItem;
            let mostBottomItem = (realStartRow === startRow) ? endSelectedItem : startSelectedItem;
            let top = mostTopItem.getElement().getBoundingClientRect().top;
            let bottom = mostBottomItem.getElement().getBoundingClientRect().bottom;
            let tableTop = this.getElement().getBoundingClientRect().top;
            let tableLeft = this.getElement().getBoundingClientRect().left;

            this.setStyle(".gbc_RTableItemSelectionArea", {
              "left": (left - tableLeft) + "px",
              "top": (top - tableTop) + "px",
              "width": (right - left) + "px",
              "height": (bottom - top) + "px"
            });

            this._itemSelectionElement.removeClass("hidden");
            this._itemSelectionHasChanged = true;
          }

          for (let i = 0; i < this.getOrderedColumns().length; i++) {
            let col = this.getOrderedColumns()[i];
            for (let j = 0; j < col.getChildren().length; j++) {
              let item = col.getChildren()[j];

              let select = (doSelect && i >= realStartCol && i <= realEndCol && j >= realStartRow && j <= realEndRow);
              item.setClientSelected(select);
            }
          }
        },

        /**
         * Enable or disable Dnd on a item
         * @param {boolean} b - true/false enable/disable Dnd on item
         * @param {classes.TableColumnItemWidget} item
         */
        _temporaryEnabledDndOnItem: function(b, item) {
          if (item) {
            item.setDndEnabled(b);

            if (b) {
              this.getContainerElement().setAttribute("draggable", "true");
            } else {
              this.getContainerElement().removeAttribute("draggable");
            }
          }
        },
        // ============== END - ITEMS CLIENT SELECTION FUNCTIONS ===================

        // ============== START - ITEMS DnD FUNCTIONS ===================

        /**
         * Is Dnd of items enabled ?
         * @returns {boolean} is item dnd enabled ?
         */
        isDndItemEnabled: function() {
          return this._dndItemEnabled;
        },

        /**
         * Enable Dnd of items
         * @param {boolean} b
         */
        setDndItemEnabled: function(b) {
          if (b && this._defaultItemSelection) {
            return; // no dnd if default is item selection
          }

          if (this._dndItemEnabled !== b) {
            this._dndItemEnabled = b;

            let columns = this.getColumns();
            for (const element of columns) {
              element.setDndItemEnabled(b);
            }

            let containerElement = this.getContainerElement();
            if (b) {
              containerElement.setAttribute("draggable", "true");
              containerElement.on("dragstart.TableWidget", this._onItemDragStart.bind(this));
              containerElement.on("dragend.TableWidget", this._onItemDragEnd.bind(this));
              containerElement.on("dragover.TableWidget", this._onItemDragOver.bind(this));
              containerElement.on("drop.TableWidget", this._onItemDrop.bind(this));
              containerElement.on("dragleave.TableWidget", this._onItemDragLeave.bind(this));
              containerElement.on("dragenter.TableWidget", this._onItemDragEnter.bind(this));
            } else {
              containerElement.removeAttribute("draggable");
              containerElement.off("dragstart.TableWidget");
              containerElement.off("dragend.TableWidget");
              containerElement.off("dragover.TableWidget");
              containerElement.off("drop.TableWidget");
              containerElement.off("dragleave.TableWidget");
              containerElement.off("dragenter.TableWidget");
            }
          }
        },

        /**
         * Handle dragStart event for table items
         * @param {Object} evt - dragstart event
         */
        _onItemDragStart: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDragStart) {
            itemWidget.onDragStart(evt);
          }
        },
        /**
         * Handle dragEnd event for table items
         * @param {Object} evt - dragend event
         */
        _onItemDragEnd: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDragEnd) {
            itemWidget.onDragEnd(evt);
          }
        },
        /**
         * Handle dragOver event for table items
         * @param {Object} evt - dragover event
         */
        _onItemDragOver: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDragOver) {
            itemWidget.onDragOver(evt);
          } else if (evt.target.hasClass("gbc_TableDataGroup")) {
            let firstColumnWidget = this.getColumns()[0];
            firstColumnWidget.onDragOverAfterLastItem(evt);
          }
        },
        /**
         * Handle drop event for table items
         * @param {Object} evt - drop event
         */
        _onItemDrop: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDrop) {
            itemWidget.onDrop(evt);
          } else if (evt.target.hasClass("gbc_TableDataGroup")) {
            let firstColumnWidget = this.getColumns()[0];
            firstColumnWidget.onDropAfterLastItem();
          }
        },
        /**
         * Handle dragLeave event for table items
         * @param {Object} evt - dragleave event
         */
        _onItemDragLeave: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDragLeave) {
            itemWidget.onDragLeave(evt);
          }
        },
        /**
         * Handle dragEnter event for table items
         * @param {Object} evt - dragenter event
         */
        _onItemDragEnter: function(evt) {
          let itemWidget = gbc.WidgetService.getWidgetFromElement(evt.target, "gbc_RTableItemWidget");
          if (itemWidget && itemWidget.onDragEnter) {
            itemWidget.onDragEnter(evt);
          }
        },

        // ============== END - ITEMS DnD FUNCTIONS =====================

        // ============== START - FROZEN COLUMNS FUNCTIONS ===================
        /**
         * Update frozen columns.
         */
        updateFrozenColumns: function() {
          let columns = this.getOrderedColumns();
          this._totalLeftFrozenColumnWidth = 0;
          this._totalVisibleLeftFrozenColumns = 0;
          let totalLeftFrozenColumns = parseInt(this._leftFrozenColumns);

          context.styler.bufferize();
          for (let i = 0; i < columns.length; i++) {
            let currentColumn = columns[i];

            if (i < this._leftFrozenColumns) {
              // left frozen column
              currentColumn.setLastLeftFrozen((i + 1) === this._leftFrozenColumns);
              currentColumn.setLeftFrozen(true);
              currentColumn.setFirstRightFrozen(false);
              currentColumn.setRightFrozen(false);
              // left frozen columns get a negative order to force them to be located even before the grid spacer
              currentColumn.setOrder(-(totalLeftFrozenColumns + 1), true);
              totalLeftFrozenColumns--;
              if (!currentColumn.isHidden()) {
                this._totalLeftFrozenColumnWidth += currentColumn.getWidth();
                this._totalVisibleLeftFrozenColumns++;
              }
            } else if (columns.length - i <= this._rightFrozenColumns) {
              // right frozen column
              currentColumn.setLastLeftFrozen(false);
              currentColumn.setLeftFrozen(false);
              currentColumn.setFirstRightFrozen((columns.length - i) === this._rightFrozenColumns);
              currentColumn.setRightFrozen(true);
            } else {
              // regular column
              currentColumn.setLastLeftFrozen(false);
              currentColumn.setLeftFrozen(false);
              currentColumn.setFirstRightFrozen(false);
              currentColumn.setRightFrozen(false);
              if (currentColumn.getOrder() < 0) { // previously left frozen : replace negative order to normal order
                currentColumn.setOrder(currentColumn.getOrderedColumnIndex(), true);
              }
            }
          }

          context.styler.flush();
        },

        /**
         * Sets the number of left frozen columns.
         * @param {number} n - number of left frozen columns
         * @publicdoc
         */
        setLeftFrozenColumns: function(n) {
          if (this._leftFrozenColumns !== n) {
            this._leftFrozenColumns = n;
          }
        },

        /**
         * Sets the number of right frozen columns.
         * @param {number} n - number of right frozen columns
         * @publicdoc
         */
        setRightFrozenColumns: function(n) {
          if (this._rightFrozenColumns !== n) {
            this._rightFrozenColumns = n;
          }
        },

        /**
         * Returns number of left frozen columns
         * @returns {number} number of left frozen columns
         * @publicdoc
         */
        getLeftFrozenColumns: function() {
          return this._leftFrozenColumns;
        },

        /**
         * Returns number of right frozen columns
         * @returns {number} number of right frozen columns
         * @publicdoc
         */
        getRightFrozenColumns: function() {
          return this._rightFrozenColumns;
        },

        /**
         * Returns number of left frozen columns currently visible
         * @returns {number|*}
         */
        getTotalVisibleLeftFrozenColumns: function() {
          return this._totalVisibleLeftFrozenColumns;
        },

        /**
         * Returns true if table can have frozen columns
         * @returns {boolean} true if table can have frozen columns
         * @publicdoc
         */
        isFrozenTable: function() {
          return this._frozenTable;
        },

        /**
         * Sets if table can contain frozen cols.
         * @param {boolean} frozen - true if table can have frozen columns
         */
        setFrozenTable: function(frozen) {
          if (frozen === this._frozenTable) {
            return;
          }
          this._frozenTable = frozen;
          // If the table should not be frozen, unfreeze all the columns
          if (!this._frozenTable) {
            this.setLeftFrozenColumns(0);
            this.setRightFrozenColumns(0);
            this.updateFrozenColumns();
            this.updateVisibleColumnsInDom();
          }
        },
        // ============== END - FROZEN COLUMNS FUNCTIONS =====================

        // ============== START - FOOTER/AGGREGATE FUNCTIONS ===================
        /**
         * Defines if the footer element is needed (used to display aggregate)
         * @param {boolean} b - true to display footer, false to hide it
         */
        setHasFooter: function(b) {
          if (this._hasFooter !== b) {
            this._hasFooter = b;
            this.getFooterGroupElement().toggleClass("hidden", !b);
          }
        },

        /**
         * Returns if table has a footer (used for aggregate)
         * @returns {boolean} true if footer is visible
         */
        hasFooter: function() {
          return this._hasFooter;
        },

        /**
         * Global text for aggregates
         * @param {string} text - global aggregate text
         */
        setAggregateGlobalText: function(text) {
          if (text !== "") {
            if (!this._aggregateGlobalTextElement) {
              this._aggregateGlobalTextElement = document.createElement("div");
              this._aggregateGlobalTextElement.addClass("gbc_TableAggregateGlobalText");
            }
            this._aggregateGlobalTextElement.textContent = text;

            this._footerAggregatesRowWidget.getElement().prependChild(this.getAggregateGlobalTextElement());
          }
        },

        /**
         * Update all aggregates
         */
        updateAllAggregate: function() {
          if (this.hasFooter()) {
            for (const columnWidget of this.getColumns()) {
              columnWidget.setAggregate(null);
            }
          }
        },

        // ============== END - FOOTER/AGGREGATE FUNCTIONS ===================

        // ============== START - STYLE FUNCTIONS ===================
        /**
         * Show/hide table X grid
         * @param {boolean} showGridX - if true always show grid
         */
        setShowGridX: function(showGridX) {
          if (this._showGridX !== showGridX) {
            this._showGridX = showGridX;
            this._element.toggleClass("showGridX", Boolean(showGridX));
          }
        },

        /**
         * Show/hide table Y grid
         * @param {boolean} showGridY - if true always show grid
         */
        setShowGridY: function(showGridY) {
          if (this._showGridY !== showGridY) {
            this._showGridY = showGridY;
            this._element.toggleClass("showGridY", Boolean(showGridY));
          }
        },

        /**
         * Hide/Show column headers
         * @param {boolean} hidden - true if header must be hidden
         */
        setHeaderHidden: function(hidden) {
          if (this._headerHidden !== hidden) {
            this._headerHidden = hidden;
            this._element.toggleClass("headerHidden", Boolean(hidden));

          }
        },

        /**
         * Set header columns alignment
         * @param {string} alignment - (left, center, right, auto)
         */
        setHeaderAlignment: function(alignment) {
          if (this._headerAlignment !== alignment) {
            this._headerAlignment = alignment;

            if (alignment === "auto") {
              // if alignment is auto don't force specific alignement
              return;
            }

            let columns = this.getColumns();
            for (const columnElement of columns) {
              columnElement.setTextAlign(alignment, true);
            }
          }
        },

        /**
         * Get header columns alignment
         * @return {string} alignment - (left, center, right, auto)
         */
        getHeaderAlignment: function() {
          return this._headerAlignment;
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          if (color === this._defaultTTFColor) {
            return;
          }
          this.setStyle(".gbc_RTableItemImage svg", {
            'fill': color
          });
        },

        /**
         * Indicates if the last visible column should fill the empty space.
         * @param {boolean} fillEmptySpace - true if last column fills empty space
         */
        setResizeFillsEmptySpace: function(fillEmptySpace) {
          this._resizeFillsEmptySpace = fillEmptySpace;
        },

        /**
         * Indicates if the last visible column should fill the empty space.
         * @return {boolean} true if last column fills empty space
         * @publicdoc
         */
        isResizeFillsEmptySpace: function() {
          return this._resizeFillsEmptySpace;
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {},

        // ============== END - STYLE FUNCTIONS ===================

        // ============== START - DOM ELEMENT GETTERS ===================
        /**
         * @inheritDoc
         */
        getScrollableArea: function() {
          return this.getContainerElement();
        },

        /**
         * Returns header group DOM Element
         * @returns {HTMLElement} header group DOM Element
         * @publicdoc
         */
        getHeaderGroupElement: function() {
          if (!this._headerGroupElement) {
            this._headerGroupElement = this.getElement().getElementsByClassName("gbc_TableHeaderGroup")[0];
          }
          return this._headerGroupElement;
        },

        /**
         * Returns footer group DOM Element
         * @returns {HTMLElement} footer group DOM Element
         * @publicdoc
         */
        getFooterGroupElement: function() {
          if (!this._footerGroupElement) {
            this._footerGroupElement = this.getElement().getElementsByClassName("gbc_TableFooterGroup")[0];
          }
          return this._footerGroupElement;
        },

        /**
         * Returns vertical scroller DOM Element
         * @returns {HTMLElement} scroller DOM Element
         * @publicdoc
         */
        getScrollerYElement: function() {
          if (!this._scrollerYElement) {
            this._scrollerYElement = this.getScrollableArea().getElementsByClassName("scroller_y")[0];
          }
          return this._scrollerYElement;
        },

        /**
         * Returns horizontal scroller DOM Element
         * @returns {HTMLElement} scroller DOM Element
         * @publicdoc
         */
        getScrollerXElement: function() {
          if (!this._scrollerXElement) {
            this._scrollerXElement = this.getScrollableArea().getElementsByClassName("scroller_x")[0];
          }
          return this._scrollerXElement;
        },

        /**
         * Returns aggregate global text DOM Element
         * @returns {HTMLElement} aggregate global text DOM Element
         */
        getAggregateGlobalTextElement: function() {
          return this._aggregateGlobalTextElement;
        },

        // ============== END - DOM ELEMENT GETTERS =====================
      };
    });
    cls.WidgetFactory.registerBuilder("RTable", cls.RTableWidget);
  });
;

"use strict";

modulum('RSidebarApplistWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Applist widget.
     * @class RSidebarApplistWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.RSidebarApplistWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.RSidebarApplistWidget.prototype */ {
        __name: 'RSidebarApplistWidget',

        _expanded: false,

      };
    });
    cls.WidgetFactory.registerBuilder('RSidebarApplist', cls.RSidebarApplistWidget);
  });
;

"use strict";

modulum('RSidebarTopMenuWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TopMenu widget.
     * @class RSidebarTopMenuWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.RSidebarTopMenuWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.RSidebarTopMenuWidget.prototype */ {
        __name: 'RSidebarTopMenuWidget',

        _topMenuList: null,

        _levelList: null,
        _removedList: null,

        _backButton: null,
        _closeButton: null,
        _panelsElem: null,
        _titleElem: null,

        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._topMenuList = {};
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._backButton = this._element.querySelector(".back-button");
          this._closeButton = this._element.querySelector(".close-button");
          this._panelsElem = this._element.querySelector(".panels");
          this._titleElem = this._element.querySelector(".title");
        },
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._levelList = [this.getContainerElement()];
          this._removedList = [];
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Click on back button
          if (domEvent.target === this._backButton || domEvent.target === this._backButton.querySelector("i")) {
            this.displayPrev();
          }
          // Click on close button
          if (domEvent.target === this._closeButton) {
            this.displayFirst();

            context.HostLeftSidebarService.showTopMenu(false);
          }

          return true;
        },

        /**
         * Display previous item
         */
        displayPrev: function() {
          const removedElem = this._levelList.pop();
          this._panelsElem.removeChild(removedElem);

          if (removedElem && this._levelList.length > 0) {
            this._levelList.last().scrollIntoView();
            this.setTitle(this._levelList.last().getAttribute("data-title"));
            // hide/show backbutton
            this._backButton.toggleClass("unavailable", this._levelList.length <= 1);
          }
        },

        /**
         * Display next given item
         * @param {cls.WidgetBase} widget
         */
        displayNext: function(widget) {
          const nextElement = document.createElement("div");
          nextElement.setAttribute("data-parent", widget._auiTag);
          nextElement.setAttribute("data-title", widget.getText());
          nextElement.classList.add("slide");

          widget.getChildren().forEach(child => {
            nextElement.appendChild(child.getElement());
          });

          this.setTitle(widget.getText());
          this._panelsElem.appendChild(nextElement);
          this._levelList.push(nextElement);
          // show back button
          this._backButton.removeClass("unavailable");
          nextElement.scrollIntoView();
        },

        /**
         * Go to first level of menu
         */
        displayFirst: function() {
          if (this._levelList.length > 1) {
            this.displayPrev();
            this.displayFirst();
          }
        },

        /**
         * Check if first menu is displayed
         * @return {boolean} - true if first level is displayed
         */
        isFirstDisplayed: function() {
          return this._levelList.length === 1;
        },

        bindTopmenuWidget: function(topmenuwidget) {
          if (!this._topMenuList[topmenuwidget.getApplicationIdentifier()]) {
            this._topMenuList[topmenuwidget.getApplicationIdentifier()] = [];
          }
          this._topMenuList[topmenuwidget.getApplicationIdentifier()].push(topmenuwidget);
        },

        renderAppTopmenu: function(appHash) {
          // remove children from all top menu first
          this.getChildren().slice().forEach(child => {
            if (child._topMenuWidget) {
              child._topMenuWidget.adoptChildWidget(child);
            }
          });

          if (this._topMenuList[appHash]) {
            this._topMenuList[appHash].forEach(topmenu => {
              topmenu.getChildren().slice().forEach(child => this.adoptChildWidget(child));
            });
          }
        },
        /**
         * Choose where to render the topmenu
         * @param topmenuwidget
         * @param inSideBar
         */
        renderTopmenu: function(topmenuwidget, inSideBar) {
          const currentSession = gbc.SessionService.getCurrent();
          const currentApp = currentSession ? currentSession.getCurrentApplication().applicationHash : null;
          // get current app topmenus
          const appId = topmenuwidget.getApplicationIdentifier();

          // Not the app topmenu to render!
          if (currentApp !== appId) {
            return false;
          }

          //put back to correct tm
          this.getChildren().slice().forEach(child => {
            if (child._topMenuWidget) {
              child._topMenuWidget.adoptChildWidget(child);
            }
          });

          // display them
          if (inSideBar) { // put top menu children in sidebar
            this._topMenuList[appId].forEach((topmenu) => {
              topmenu.getChildren().slice().forEach((child) => {
                child._element.setAttribute("appId", appId);
                child.setHidden(topmenu.isHidden());
                this.adoptChildWidget(child);
              });
            });
          } else { // put sidebar children in topmenu
            this.getChildren().slice().forEach((child) => {
              topmenuwidget.adoptChildWidget(child);
            });
          }
          return this.getChildren().slice().length > 0;
        },

        setTitle: function(text) {
          this._titleElem.innerText = text;
        },
        /**
         * Priority of this menu
         * @param {number} order the priority of this menu
         * @publicdoc
         */
        setOrder: function(order) {
          this.setStyle({
            order: order
          });
        },

        /**
         * Get priority of this menu
         * @returns {number} priority of this menu
         * @publicdoc
         */
        getOrder: function() {
          return this.getStyle('order');
        },

        /**
         * Get previous topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns previous topmenugroup
         * @publicdoc
         */
        getPreviousMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) - 1];
        },

        /**
         * Get next topmenugroup located at same level that refMenu
         * @param {classes.TopMenuGroupWidget} refMenu - topmenugroup used as search criteria
         * @returns {classes.TopMenuGroupWidget} returns next topmenugroup
         * @publicdoc
         */
        getNextMenu: function(refMenu) {
          return this.getChildren()[this.getIndexOfChild(refMenu) + 1];
        },

        empty: function() {
          //"empty me"
        },

        destroy: function() {
          $super.destroy.call(this);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('RSidebarTopMenu', cls.RSidebarTopMenuWidget);
  });
;

"use strict";

modulum('RSidebarWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Sidebar for responsive
     * It contains :
     *    - The applist:
     *      -- always visible on wide screen (theme-variable control)
     *      -- hiden on small/medium (theme-variable control)
     *      -- could be expanded with big list with a button (as an educational way)
     *      -- contains the settings/about buttons to free space in chromebar
     *    - The topMenu:
     *      -- if present and set to sidebar (default with mobile, theme-variable controled)
     * @class RSidebarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.RSidebarWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.RSidebarWidget.prototype */ {
        __name: "RSidebarWidget",
        //_resizerElement: null,

        _topMenuContainer: null,
        _topMenuWidget: null,

        _appListContainer: null,
        _appListWidget: null,
        _applicationListVisible: null,
        _expanded: false,

        _menuIconElement: null,
        _appsIconElement: null,

        /**
         * @type ?number
         */
        _currentSize: null,

        _initElement: function() {
          $super._initElement.call(this);

          this._applicationListVisible = "auto"; // default value
          this._expanded = false; // default not expanded
          this.setAppListWidth(0); // hide default

          this._titleElement = this._element.getElementsByClassName("titleContainer")[0];
          this._topMenuContainer = this._element.getElementsByClassName("topmenuContainer")[0];
          this._appListContainer = this._element.getElementsByClassName("applistContainer")[0];
          this._settingsContainer = this._element.getElementsByClassName("settingsContainer")[0];

          this._sidebarToggle = this._element.getElementsByClassName("mt-sidebar-toggle")[0];

          this._element.on("transitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("oTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));
          this._element.on("webkitTransitionend.ApplicationHostSidebarWidget", this._onTransitionEnd.bind(this));

          this._menuIconElement = this._titleElement.querySelector(".zmdi-menu");
          this._appsIconElement = this._titleElement.querySelector(".zmdi-apps");

          this._expandElement = this._element.getElementsByClassName("arrow-expand")[0];
          window.addEventListener("resize", () => {
            this.updateResizeTimer(true);
          });

          if (window.isMobile()) {
            const root = window.document.querySelector(":root");
            root.style.setProperty('--applistWidth', 0); // default hidden
          }
          this._resizeHandler = context.HostService.onScreenResize((event) => {
            let hostSizeChanged = event.data[2];
            if (hostSizeChanged.width) {
              gbc.HostLeftSidebarService.hideSidebar();
              gbc.HostLeftSidebarService.showTopMenu(false);
              if (window.isMobile()) {
                window.document.querySelector(":root").style.setProperty('--applistWidth', 0);
              }
            }
          });

        },

        constructor: function(opts) {
          $super.constructor.call(this, opts);
          //constructor: create appList and topmenu

          this._topMenuWidget = cls.WidgetFactory.createWidget("RSidebarTopMenu", this.getBuildParameters());
          this._topMenuContainer.appendChild(this._topMenuWidget.getElement());
          this._appListWidget = cls.WidgetFactory.createWidget("RSidebarApplist", this.getBuildParameters());
          this._appListContainer.appendChild(this._appListWidget.getElement());
        },

        getTopmenu: function() {
          return this._topMenuWidget;
        },

        //show apps or topMenu
        showIcon: function(type) {
          if (type === "menu") {
            this._menuIconElement.style.display = "flex";
            this._appsIconElement.style.display = "none";
          } else {
            this._menuIconElement.style.display = "none";
            this._appsIconElement.style.display = "flex";
          }
        },

        setIcon: function(image) {
          if (!this._image) {
            this._image = cls.WidgetFactory.createWidget("ImageWidget", this.getBuildParameters());
            this._windowIcon.prependChild(this._image.getElement());
          }
          this._image.setHidden(true);
          if (image && image !== "") {
            this._image.setSrc(image);
            this._image.setHidden(false);
          }
        },

        getApplist: function() {
          return this._appListWidget;
        },

        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          // TODO
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const target = domEvent.target;
          if (target.isElementOrChildOf(this._sidebarToggle)) {
            const displayed = gbc.HostLeftSidebarService.toggleSidebar();
            this.showTopMenu(displayed);
            if (!displayed && window.isMobile()) {
              this.setAppListWidth(0);
              return false; //stop bubbling
            }
          }
          if (target.isElementOrChildOf(this._expandElement) || target.isElementOrChildOf(this._appsIconElement)) {
            this.toggleExpand();
          } else {
            this.expand(false);
          }
          return true;
        },

        // Show Hide methods
        showTitle: function(show) {
          show = (show || this._applicationListVisible === "yes") && this._applicationListVisible !== "no";
          if (this._titleElement) {
            this._titleElement.toggleClass("visible", show);
          }
        },
        showAppList: function(show) {
          this._appListVisible = show;
          show = (show || this._applicationListVisible === "yes") && this._applicationListVisible !== "no";
          this._appListContainer.toggleClass("visible", show);
          gbc.HostService.getApplicationHostWidget().toggleClass("has-applist-sidebar", show);
        },

        /**
         * Set Applist mode (for 4ST api)
         * @param {String} visible could be 'yes', 'no' or 'auto'
         * @param {Number?} appCount
         */
        setApplicationListVisible: function(visible, appCount) {
          this._applicationListVisible = visible;
          if (visible === 'no') {
            this._hideApplist();
          } else if (visible === 'yes') {
            this._showApplist();
          } else { // auto / default
            if (appCount && appCount > 1 && this._appListWidget.getChildren()[0].getChildren().length > 1) {
              this._showApplist();
            } else {
              this._hideApplist();
            }
          }
        },
        /**
         * Shortcut to display applList
         * @private
         */
        _showApplist() {
          this.showAppList(true);
          const themeSideBarSize = !this.isExpanded() ? gbc.ThemeService.getValue("theme-sidebar-default-width") : gbc.ThemeService.getValue(
            "theme-sidebar-max-width");
          this.setAppListWidth(parseInt(themeSideBarSize, 10));
          this.showSettings(true);
          this.showTitle(true);
          this.removeClass(".mt-sidebar-unavailable");
        },
        /**
         *
         * Shortcut to hide applList
         * @private
         */
        _hideApplist() {
          this.showAppList(false);
          this.setAppListWidth(0);
          this.showSettings(false);
          this.showTitle(false);
          this.addClass(".mt-sidebar-unavailable");
        },

        /**
         * Check if appList is displayed
         * @return {*}
         */
        isAppListDisplayed: function() {
          return this._appListContainer.hasClass("visible");
        },

        /**
         * Show the sidebar TopMenu
         * @param {Boolean} show - true to show, false otherwise
         */
        showTopMenu: function(show) {
          this._topMenuContainer.toggleClass("visible", show);
          this._topMenuWidget.displayFirst();
        },

        renderAppTopMenu: function(appHash) {
          if (this._topMenuWidget && this._topMenuWidget.getChildren().length > 0) {
            this._topMenuWidget.renderAppTopmenu(appHash);
          } else {
            // No topmenu for this App
            gbc.HostLeftSidebarService.setHasTopMenu(false);
          }
        },

        /**
         * Show/hide the settings/expand panel at bottom
         * @param {Boolean} show - true to display, false otherwise
         */
        showSettings: function(show) {
          show = (show || this._applicationListVisible === "yes") && this._applicationListVisible !== "no";
          if (this._settingsContainer) {
            this._settingsContainer.toggleClass("visible", show);
          }
        },

        updateResizeTimer: function(onlyRelayout) {
          if (window.isMobile() && !window.isOrientationImplemented) {
            window.orientation = window.innerWidth > window.innerHeight ? 90 : 0;
          }
          // for mobiles, only relayout on screen orientation
          if (!window.isMobile() || this._screenOrientation !== window.orientation) {
            this._screenOrientation = window.orientation;
            if (this._resizeHandle) {
              this._clearTimeout(this._resizeHandle);
              this._resizeHandle = null;
            }
            this._resizeHandle = this._registerTimeout(() => {
              if (onlyRelayout) {
                this.emit(context.constants.widgetEvents.displayChanged);
                return;
              }

              this.updateResize(null, false);
            }, 100);
          }
        },

        updateResize: function(deltaX, absolute) {
          const previousSize = this._currentSize;
          this._resizeHandle = null;

          const max = cls.Size.translate(context.ThemeService.getValue("theme-sidebar-max-width"));
          if (absolute) {
            this._currentSize = deltaX;
          } else {
            this._currentSize = (Object.isNumber(this._origin) ? this._origin : this._currentSize) + (deltaX || 0);
            if (this._currentSize < 16) {
              this._currentSize = 16;
            }
          }
          if (this._currentSize > max) {
            this._currentSize = max;
          }
          if (!this.isAlwaysVisible()) {
            this.getParentWidget().setCentralContainerPosition(0);
          } else {
            this.getParentWidget().setCentralContainerPosition(this._currentSize);
          }
          // if sidebar size or visibility changed, we emit displayChanged
          if (this._currentSize !== previousSize) {
            // if sidebar size changed only, we update size
            this.setStyle({
              width: this._currentSize + "px"
            });
            // Save sidebar width into storedSettings
            gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
          }
          this.emit(context.constants.widgetEvents.displayChanged);
        },
        /**
         *
         * @returns {classes.ApplicationHostWidget}
         */
        getParentWidget: function() {
          return $super.getParentWidget.call(this);
        },

        /**
         * Display sidebar
         * @param {Boolean} displayed - request display state
         * @return {Boolean} true if displayed, false otherwise
         */
        setDisplayed: function(displayed) {
          if (!this._topMenuWidget) {
            displayed = false;
          } else if (this._topMenuWidget && this._topMenuWidget.getChildren().length <= 0) {
            displayed = false;
          } else if (!displayed && this._topMenuWidget && this._topMenuWidget.getChildren().length > 0) {
            // when closed, go back to first level if not already
            if (!this._topMenuWidget.isFirstDisplayed()) {
              this._topMenuWidget.displayFirst();
            }
            displayed = false;
          }

          this.getElement().toggleClass("mt-sidebar-displayed", Boolean(displayed));

          return displayed;
        },
        isDisplayed: function() {
          return this.getElement().hasClass("mt-sidebar-displayed");
        },

        isUnavailable: function() {
          return this._unavailable;
        },
        setUnavailable: function(unavailable) {
          if (this._applicationListVisible === "yes") {
            this.getElement().removeClass("mt-sidebar-unavailable");
            return;
          }
          this._unavailable = Boolean(unavailable);
          this.getElement().toggleClass("mt-sidebar-unavailable", Boolean(unavailable));
        },

        _onTransitionEnd: function(evt) {
          if (evt.target.hasClass("mt-sidebar")) {
            const positionUpdated = this.getParentWidget().setCentralContainerPosition(!this.isAlwaysVisible() ? 0 : this
              ._currentSize);
            if (positionUpdated) {
              this.emit(context.constants.widgetEvents.displayChanged);
            }
          }
        },
        getCurrentSize: function() {
          return this._currentSize;
        },
        getTitle: function() {
          return this._titleTextElement.textContent;
        },

        /* Don't allow set title here
        setTitle: function(title) {
          this._titleTextElement.textContent = title;
        },*/

        /**https://t.co/N65YtC2QAa
         * expand the applist
         * @param expanded
         */
        expand: function(expanded) {
          if (this._expanded !== expanded) {
            this._expanded = expanded; //TODO: add this state to storedSettings

            const themeSideBarSize = parseInt(gbc.ThemeService.getValue("theme-sidebar-default-width"), 10);
            const themeExpandedSize = parseInt(gbc.ThemeService.getValue("theme-sidebar-max-width"), 10);
            const force = window.isMobile();
            this.setAppListWidth(expanded ? themeExpandedSize : themeSideBarSize, force);
            this.toggleClass("expanded", expanded);
          }
        },
        toggleExpand: function() {
          this.expand(!this._expanded);
        },

        /**
         * Check if sidebar is expanded
         * @return {boolean} true if expanded, false otherwise
         */
        isExpanded: function() {
          return this._expanded;
        },

        setAppListWidth: function(width, force) {
          if (this._currentSize === width) {
            return;
          }
          //Mobile
          if (window.isMobile()) {
            width = force ? width : 0;
          }

          // forced width since we want to make it always visible as long there is an app running
          if (this._applicationListVisible === "yes" && gbc.HostLeftSidebarService.getApplicationCount() > 0) {
            width = !this._expanded ? gbc.ThemeService.getValue("theme-sidebar-default-width") : gbc.ThemeService.getValue(
              "theme-sidebar-max-width");
          } else if (this._applicationListVisible === "no" || gbc.HostLeftSidebarService.getApplicationCount() <= 0) {
            width = 0;
          }
          this._currentSize = parseInt(width, 10);

          gbc.HostService.getApplicationHostWidget().toggleClass("has-visible-applist", this._currentSize > 0);

          window.document.querySelector(":root").style.setProperty('--applistWidth', parseInt(width, 10) + "px");
          if (this._titleElement) {
            this._titleElement.toggleClass("visible", width !== 0);
          }
          if (this._settingsContainer) {
            this._settingsContainer.toggleClass("visible", width !== 0);
          }

          gbc.HostService.syncCurrentWindow();
        },

        onDisplayChanged: function(hook) {
          return this.when(context.constants.widgetEvents.displayChanged, hook);
        },

        _onDragOver: function(evt) {
          this._pageX = evt.clientX || evt.screenX || evt.pageX;
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          document.body.on("dragover.ApplicationHostSidebarWidget", this._onDragOver.bind(this));
          this._isDragging = true;
          if (window.browserInfo.isFirefox) {
            evt.dataTransfer.setData('text', ''); // for Firefox compatibility
          }
          if (evt.dataTransfer.setDragImage) {
            evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
          }
          evt.dataTransfer.effectAllowed = "move";
          this._pageX = this._resizerDragX = evt.clientX || evt.screenX || evt.pageX;
          this._origin = this._currentSize;
        },
        _onDragEnd: function(evt) {
          document.body.off("dragover.ApplicationHostSidebarWidget");
          this._isDragging = false;
          this._origin = this._currentSize;
          // Save sidebar width into storedSettings
          gbc.StoredSettingsService.setSideBarwidth(this._currentSize);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            const deltaX = this._pageX - this._resizerDragX;
            this.updateResize(deltaX);

          }
        },
        isAlwaysVisible: function() {
          return window.matchMedia(
            "screen and (min-width: " + context.ThemeService.getValue("theme-sidebar-always-visible-min-width") + ")"
          ).matches;
        },

        setTitleText: function(text) {
          // is empty
        },

        _onSwipe: function(evt, distance) {
          this.emit(context.constants.widgetEvents.toggleClick);
        },

        setSidebarContent: function(widget) {
          if (this._alternateContentWidget && this._alternateContentWidget.getElement() &&
            this._alternateContentWidget.getElement().parent("mt-sidebar") === this.getElement()) {
            this._alternateContentWidget.getElement().remove();
          }
          if (widget) {
            if (this._contentElement) {
              this._contentElement.style.display = "none";
            }
            this._titleElement.style.display = "none";
            if (this._sidebarContentElement) {
              this._sidebarContentElement.appendChild(widget.getElement());
            }
          } else if (this._contentElement) {
            this._contentElement.style.display = "";
            this._titleElement.style.display = "";
          }
        },

        setSidebarTopMenu: function(widget) {

        },

        getSidebarTopMenu: function() {
          return this._topMenuWidget;
        },

      };
    });
    cls.WidgetFactory.registerBuilder('RSidebar', cls.RSidebarWidget);
  });
;

"use strict";

modulum('TableCachedDataModel', ['EventListener'],
  function(context, cls) {

    /**
     * Cached Data Model for table.
     * @class TableCachedDataModel
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc
     */
    cls.TableCachedDataModel = context.oo.Class({
      base: cls.EventListener
    }, function($super) {
      return /** @lends classes.TableCachedDataModel.prototype */ {
        __name: "TableCachedDataModel",

        /**
         * Data model
         * @type Object[]
         */
        _data: null,

        /**
         * AUI Value data
         * @type Object[]
         */
        _auiValueData: null,

        /**
         * AUI Row data
         * @type Object[]
         */
        _auiRowData: null,

        /** Ref on table widget which uses model
         * @type classes.RTableWidget
         */
        _tableWidget: null,

        /**
         * @constructs
         * @param {classes.RTableWidget} tableWidget - ref on table widget
         */
        constructor: function(tableWidget) {
          $super.constructor.call(this);

          this._tableWidget = tableWidget;
          this._data = [];
          this._auiValueData = [];
          this._auiRowData = [];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._data = null;
          this._auiValueData = null;
          this._auiRowData = null;
          this._tableWidget = null;

          $super.destroy.call(this);
        },

        /**
         * Initialize data model
         * @param {number} nbRows - number of rows in the data model
         */
        init: function(nbRows) {
          this._data = [];
          this.addDefaultRows(nbRows);
        },

        /**
         * Update number of rows in the model
         * @param nbRows
         */
        updateNbRows: function(nbRows) {
          const length = this._data.length;
          if (nbRows > length) {
            this.addDefaultRows(nbRows - length);
          }
          // TODO else if (nbRows < length) {}
        },

        /**
         * Add default and empty rows in the data model
         * @param {number} nbRows - number of rows to add
         */
        addDefaultRows: function(nbRows) {
          for (let i = 0; i < nbRows; i++) {
            const rowData = {
              vm: false,
              selected: null,
              treeDepth: null,
              treeLeaf: null,
              treeExpanded: null,
              items: []
            };
            this._data.push(rowData);
          }
        },

        /**
         * Check and add columns if necessary in the data model
         * @param {number} rowIndex - index of row
         * @param {number} colIndex - index of column
         */
        checkAndAddDefaultColumns: function(rowIndex, colIndex) {
          if (this._data && this._data.length > 0) {
            if (colIndex >= this._data[rowIndex].items.length) {
              for (let i = 0; i < this._data.length; i++) {
                while (this._data[i].items.length <= colIndex) {
                  const obj = {
                    value: undefined,
                    textColor: undefined,
                    image: undefined,
                    fontWeight: undefined,
                    textDecoration: undefined,
                    backgroundColor: undefined
                  };
                  this._data[i].items.push(obj); // add an object with default parameters by default
                }
              }
            }
          }
        },

        /**
         * Returns value from AUI value data
         * @param {number} valueNodeIndex - value node index
         * @param {number} tableColumNodeIndex - column index
         */
        getAUIValueData: function(valueNodeIndex, tableColumNodeIndex) {
          // init global object
          if (!this._auiValueData) {
            this._auiValueData = [];
          }
          // init row
          if (!this._auiValueData[valueNodeIndex]) {
            this._auiValueData[valueNodeIndex] = {};
          }
          // init value
          if (!this._auiValueData[valueNodeIndex][tableColumNodeIndex]) {
            this._auiValueData[valueNodeIndex][tableColumNodeIndex] = {};
          }

          return this._auiValueData[valueNodeIndex][tableColumNodeIndex];
        },

        /**
         * Returns value from AUI row data
         * @param {number} valueNodeIndex - value node index
         */
        getAUIRowData: function(valueNodeIndex) {
          // init global object
          if (!this._auiRowData) {
            this._auiRowData = [];
          }
          // init row
          if (!this._auiRowData[valueNodeIndex]) {
            this._auiRowData[valueNodeIndex] = {};
          }

          return this._auiRowData[valueNodeIndex];
        },

        /**
         * Update data model from a value node
         * @param {classes.ValueNode} valueNode - value node
         * @param {String} dataName - data name
         * @param {*} dataValue - data value
         */
        updateDataFromValueNode: function(valueNode, dataName, dataValue) {
          const tableColumnNode = valueNode.getAncestor("TableColumn");
          const tableNode = tableColumnNode.getParentNode();
          const valueNodeIndex = valueNode.getIndex("Value");
          const tableColumNodeIndex = tableColumnNode.getIndex("TableColumn");
          const tableOffset = tableNode.attribute('offset');
          const rowIndex = valueNodeIndex + tableOffset;

          this.updateData(rowIndex, tableColumNodeIndex, tableOffset, dataName, dataValue);
        },

        /**
         * Update data model
         * @param {number} rowIndex - row of the data to be updated
         * @param {number} colIndex - col of the data to be updated
         * @param {number} offset - table offset
         * @param {String} dataName - data name
         * @param {*} dataValue - data value
         */
        updateData: function(rowIndex, colIndex, offset, dataName, dataValue) {
          const currentAUIValueData = this.getAUIValueData((rowIndex - offset), colIndex);

          if (dataName) {
            /// update AUI value data model
            currentAUIValueData[dataName] = dataValue;
          }

          if (this._data === null) {
            return;
          }

          // case when scroll is at most bottom, and it is processing the last value node (bufferSize = pageSize + 1)
          if (rowIndex >= this._data.length) {
            return;
          }
          // check an add columns in model if necessary
          this.checkAndAddDefaultColumns(rowIndex, colIndex);

          // update value in model
          this._data[rowIndex].items[colIndex][dataName] = dataValue;

          // TODO if value really changed maybe need to inform widget to update it
          // TODO when GBC-3930 will be done

          // debug
          //console.log("updateDataModel(" + data + "," + rowIndex + "," + colIndex + ")");
          //console.log(this._data);
        },

        /**
         * Update row data
         * @param {number} rowIndex - row index
         * @param {number} offset - table offset
         * @param {String} dataName - data name
         * @param {*} dataValue - data value
         */
        updateRowData: function(rowIndex, offset, dataName, dataValue) {
          const currentAUIRowData = this.getAUIRowData((rowIndex - offset));

          if (dataName) {
            // update AUI row data model
            currentAUIRowData[dataName] = dataValue;
          }

          if (rowIndex >= this._data.length) {
            return;
          }

          // update in _data
          this._data[rowIndex][dataName] = dataValue;
        },

        /**
         * Flag rows as VM checked, meaning VM validated them. When a row is VM validated, we have no more reason to blur it later on
         * @param offset
         * @param bufferSize
         */
        vmFlagRows: function(offset, bufferSize) {
          const max = Math.min(this._data.length, (offset + bufferSize));
          for (let i = offset; i < max; i++) {
            this._data[i].vm = true;
          }
        },

        /**
         * Sync current offset of the data model
         * @param offset
         * @param bufferSize
         */
        syncModel: function(offset, bufferSize) {
          const max = Math.min(this._data.length, (offset + bufferSize));
          for (let rowIndex = offset; rowIndex < max; rowIndex++) {
            const row = this._data[rowIndex];
            for (let colIndex = 0; colIndex < row.items.length; colIndex++) {

              // sync valueNodeData in _data model
              const currentValueNodeData = this.getAUIValueData((rowIndex - offset), colIndex);
              const oldData = this._data[rowIndex].items[colIndex];

              // TODO PERF if this._data[rowIndex].vm is false, is it necessary to merge ?
              this._data[rowIndex].items[colIndex] = {
                ...oldData,
                ...currentValueNodeData
              };
            }

            // sync aui rowData in _data model
            const currentAUIRowData = this.getAUIRowData(rowIndex - offset);

            const oldData = this._data[rowIndex];
            this._data[rowIndex] = {
              ...oldData,
              ...currentAUIRowData
            };
          }
        },

        /**
         * Returns data model
         * @returns {Object[]} data model
         */
        getData: function() {
          return this._data;
        }
      };
    });
  });
;

"use strict";

modulum('RowBoundDecoratorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RowBound decorator.
     * @class RowBoundDecoratorWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc
     */
    cls.RowBoundDecoratorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.RowBoundDecoratorWidget.prototype */ {
        __name: "RowBoundDecoratorWidget",

        /** @type {classes.ContextMenuWidget} */
        _contextMenuWidget: null,

        /** @type {Element} */
        _contextMenuIconElement: null,
        /** @type {number|null} */
        _order: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);

          this._contextMenuIconElement = this._element.getElementsByTagName('span')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._contextMenuIconElement = null;
          this._contextMenuWidget = null;
          $super.destroy.call(this);
        },

        /**
         * Returns rowbound container widget
         * @returns {classes.TableWidgetBase|classes.StretchableScrollGridWidget} rowBound container widget
         */
        getRowBoundContainerWidget: function() {
          let rowBoundContainerWidget = this.getTableWidgetBase();
          if (!rowBoundContainerWidget && this.getParentWidget().isInstanceOf(cls.StretchableScrollGridLineWidget)) {
            rowBoundContainerWidget = this.getParentWidget().getParentWidget();
          }
          return rowBoundContainerWidget;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          if (!this.isEnabled()) {
            return true;
          }

          let rowBoundContainerWidget = this.getRowBoundContainerWidget();
          if (rowBoundContainerWidget) {
            // request focus
            if (this.getParentWidget().requestFocus) {
              this.getParentWidget().requestFocus(domEvent);
            }

            if (domEvent.target.isElementOrChildOf(this._contextMenuIconElement)) {
              // request open context  menu
              let rowBoundWidget = rowBoundContainerWidget.getRowBoundMenu();
              if (rowBoundWidget) {
                rowBoundWidget.parentElement = this._contextMenuIconElement;
                rowBoundWidget.reverseX = true;
                rowBoundContainerWidget.emit(context.constants.widgetEvents.rowBoundMenu);
                return false;
              }
            }
          }
          return true;
        },

        /**
         * Set the reference to rowBound context menu
         * @param {classes.ContextMenuWidget} contextMenu
         */
        setContextMenuWidget: function(contextMenu) {
          this._contextMenuWidget = contextMenu;
          if (this._contextMenuWidget) {
            this._contextMenuWidget.when("onActionChange", this.update.bind(this));
          }
        },

        /**
         * Sets index order of row bound cell
         * @param {number} colIndex - order index
         */
        setOrder: function(colIndex) {
          const rowWidget = this.getParentWidget();
          // take row index, start index with 1 (instead of 0) and generate a 4 digits number
          const rowIndex = (rowWidget.getRowIndex() + 1) * rowWidget.getOrderMultiplier();
          // add column index to row index
          const order = rowIndex + colIndex;
          this._order = order;
          this.getElement().style.order = order.toString();
        },

        /**
         * Update (visibility & quick actions)
         */
        update: function() {
          const actions = this._contextMenuWidget?.getActionWidgets();
          this._contextMenuIconElement?.toggleClass("hidden", actions.size === 0);
        },

        /**
         * Blur data on item widget
         * @param enable
         */
        blur: function(enable) {
          if (enable === this._isBlurred) {
            return;
          }
          this._isBlurred = enable;
          this.toggleClass("blurred", this._isBlurred);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('RowBoundDecorator', cls.RowBoundDecoratorWidget);
  });
;

"use strict";

modulum('ScrollGridWidget', ['WidgetGridLayoutBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Scroll Grid widget.
     * @class ScrollGridWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     * @publicdoc
     */
    cls.ScrollGridWidget = context.oo.Class(cls.GridWidget, function($super) {
      return /** @lends classes.ScrollGridWidget.prototype */ {
        $static: /** @lends classes.ScrollGridWidget */ {
          /** Generic click events handler */
          _onClick: function(event) {
            this.emit(context.constants.widgetEvents.click, event);
            if (!this._rowActionTriggerByDoubleClick && event.target !== this._containerElement) {
              this.emit(context.constants.widgetEvents.rowAction, event);
            }
          },
          _onDblClick: function(event) {
            if (this._rowActionTriggerByDoubleClick && event.target !== this._containerElement) {
              this.emit(context.constants.widgetEvents.rowAction, event);
            }
          },
        },
        __name: "ScrollGridWidget",

        /** @type {classes.ScrollWidget} */
        _scrollWidget: null,
        /** @type boolean */
        _rowActionTriggerByDoubleClick: true,
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,

        /** Handlers */
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /** @type {boolean} */
        _focusOnField: false,

        /** styles */
        _highlightColor: null,
        _highlightTextColor: null,
        _highlightCurrentRow: null,
        _highlightCurrentRowCssSelector: ":not(.disabled).gbc_ScrollGridWidget.highlight .currentRow",
        _highlightCurrentCellCssSelector: ":not(.disabled).gbc_ScrollGridWidget.highlightCell .currentRow.gbc_Focus",
        _highlightCurrentCell: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._scrollWidget = cls.WidgetFactory.createWidget("Scroll", this.getBuildParameters());
          this.addChildWidget(this._scrollWidget, {
            noDOMInsert: true
          });
          this._element.appendChild(this._scrollWidget.getElement());

          this._uiActivateHandler = this._uiWidget.onActivate(this.refreshScroll.bind(this, true));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this.refreshScroll.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ScrollGridLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          // ScrollWidget is owned directly by this widget no matter if gridChildrenInParent is set
          this._rerouteChildren = false;
          this._element.removeChild(this._scrollWidget.getElement());
          this._scrollWidget.destroy();
          this._scrollWidget = null;
          this._uiWidget = null;
          this._folderPageWidget = null;
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          cls.ScrollGridWidget._onClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        _listChildrenToMoveWhenGridChildrenInParent: function() {
          return this._children.filter(function(item) {
            return item !== this._scrollWidget;
          }.bind(this));
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /** Returns the scroll widget
         * @returns {classes.ScrollWidget} Scroll widget
         */
        getScrollWidget: function() {
          return this._scrollWidget;
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          return this._layoutInformation.getMeasured().getHeight(true) / Math.max(1, this._scrollWidget.getPageSize());
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          return this._scrollWidget.getElement();
        },

        /**
         * Defines the scroll grid pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._scrollWidget.setPageSize(pageSize);
        },

        /**
         * Defines the scroll grid size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._scrollWidget.setSize(size);
        },

        /**
         * Defines the scroll grid offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._scrollWidget.setOffset(offset);
        },

        /**
         * Sets the total height of the widget (pixels)
         * @param {number} size - total height
         */
        setTotalHeight: function(size) {
          this._scrollWidget.setTotalHeight(size);
        },

        /**
         * Refresh scroll widget
         */
        refreshScroll: function(force) {
          this._scrollWidget.setLineHeight(this.getRowHeight());
          this._scrollWidget.refreshScroll(force);
        },

        /**
         * Defines the highlighted text color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {

          if (this._highlightTextColor !== color) {
            this._highlightTextColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });

            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "color": color,
              "fill": color
            });
          }
        },

        /**
         * Defines the highlight color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {

          if (this._highlightColor !== color) {
            this._highlightColor = color;

            color = (color === null ? null : color + " !important");
            this.setStyle({
              selector: this._highlightCurrentRowCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });

            this.setStyle({
              selector: this._highlightCurrentCellCssSelector,
              appliesOnRoot: true
            }, {
              "background-color": color
            });
          }
        },

        /**
         * @param highlight false to disable current row highlighting
         */
        setHighlightCurrentRow: function(highlight) {
          if (!this._focusOnField) {
            this._highlightCurrentRow = highlight;
            this._element.toggleClass("nohighlight", !highlight);
            this._element.toggleClass("highlight", highlight);
          }
        },

        /**
         * Return if the current row must be highlighted
         * @returns {?boolean} true if current row must be highlighted
         * @publicdoc
         */
        isHighlightCurrentRow: function() {
          return this._highlightCurrentRow;
        },

        /**
         * Indicates if the current cell must be highlighted
         * @param {boolean} b - true if current cell must be highlighted
         */
        setHighlightCurrentCell: function(b) {
          this._highlightCurrentCell = b;
          this._element.toggleClass("highlightCell", b);
        },

        /**
         * Return if the current cell must be highlighted
         * @returns {?boolean} true if current cell must be highlighted
         * @publicdoc
         */
        isHighlightCurrentCell: function() {
          return this._highlightCurrentCell;
        },

        /**
         * Defines if focus in on a field or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          if (this._focusOnField !== focusOnField) {
            this._focusOnField = focusOnField;
            this._element.toggleClass("focusOnField", focusOnField);
            this._element.toggleClass("nohighlight", true);
            this._element.toggleClass("highlight", false);
          }
        },

        /**
         * Returns if focus is on a field (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * @returns {number} the current row
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * @param {number} currentRow the new current row
         */
        setCurrentRow: function(currentRow) {
          this._currentRow = currentRow;
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {}
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollGrid', cls.ScrollGridWidget);
  });
;

"use strict";

modulum('SpacerItemWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpacerItem widget.
     * @class SpacerItemWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SpacerItemWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SpacerItemWidget.prototype */ {
        __name: "SpacerItemWidget",

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);

          this._layoutInformation.setXStretched(false);
          this._layoutInformation.setYStretched(false);
          this._layoutInformation.setSizeHint(0, 0);
          this._layoutInformation.setMinimal(0, 0);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('SpacerItem', cls.SpacerItemWidget);
  });
;

"use strict";

modulum('SplitterWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class SplitterWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.SplitterWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.SplitterWidget.prototype */ {
        __name: "SplitterWidget",

        _canHaveSplitter: false,
        _pagePosition: 0,
        _resizerDragPosition: 0,
        _isDragging: false,
        _splitInfo: null,
        _dragHandle: null,
        _forcedDefault: false,
        /**
         * the split holder
         * @type HTMLElement
         */
        _splitHolder: null,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this._layoutInformation.setMaximal(8, 8);
          this._layoutInformation.setMinimal(8, 8);
          this._layoutInformation.setMeasured(8, 8);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._dragHandle = this._element.getElementsByClassName("firefox_placekeeper")[0];
          this._element.setAttribute("draggable", "true");
          this._element.on("dragstart.SplitterWidget", this._onDragStart.bind(this));
          this._element.on("dragend.SplitterWidget", this._onDragEnd.bind(this));
          this._element.on("drag.SplitterWidget", this._onDrag.bind(this));

          //handle touch events
          this._element.on("touchstart.SplitterWidget", this._onTouchStart.bind(this));
          this._element.on('touchend.SplitterWidget', this._onTouchEnd.bind(this));
          this._element.on('touchmove.SplitterWidget', this._onTouchMove.bind(this));

          this._splitHolder = document.createElement("div");
          this._splitHolder.className = "gbc_SplitterWidget_splitholder";
        },
        destroy: function() {
          this._element.off("dragstart.SplitterWidget");
          this._element.off("dragend.SplitterWidget");
          this._element.off("drag.SplitterWidget");
          $super.destroy.call(this);

        },
        _onDragOver: function(evt) {
          evt.preventCancelableDefault();
        },
        _onDragStart: function(evt) {
          if (this._canHaveSplitter) {
            this._element.parentNode.style.zIndex = 99999;
            this._splitHolder.style.zIndex = 99998;
            this._splitHolder.style.display = "block";
            this.getParentWidget().getElement().on("dragover.SplitterWidget", this._onDragOver.bind(this));
            this._splitHolder.on("dragover.SplitterWidget", this._onDragOver.bind(this));
            this._isDragging = true;
            if (window.browserInfo.isFirefox) {
              evt.dataTransfer.setData('text', ''); // for Firefox compatibility
            }
            if (evt.dataTransfer.setDragImage) {
              evt.dataTransfer.setDragImage(this._dragHandle, 0, 0);
            }
            evt.dataTransfer.effectAllowed = "move";
            this._updateResizerDrag(evt);
            this.emit(context.constants.widgetEvents.splitterStart);
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },
        _updateResizerDrag: function(evt) {

        },
        _onDragEnd: function(evt) {
          this._element.style.zIndex = "";
          this._splitHolder.style.zIndex = "";
          this._splitHolder.style.display = "";
          this._splitHolder.off("dragover.SplitterWidget");
          this.getParentWidget().getElement().off("dragover.SplitterWidget");
          this._isDragging = false;
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.style.opacity = "";
          }
          this.emit(context.constants.widgetEvents.splitterEnd);
        },
        _onDrag: function(evt) {
          if (this._isDragging) {
            const delta = this._pagePosition - this._resizerDragPosition;
            this.updateSplits(delta);
          }
        },

        _onTouchStart: function(evt) {
          if (this._canHaveSplitter) {
            this._element.parentNode.style.zIndex = 99999;
            this._splitHolder.style.zIndex = 99998;
            this._splitHolder.style.display = "block";
            this._isDragging = true;
            this._updateResizerDrag(evt);
            this.emit(context.constants.widgetEvents.splitterStart);
          } else {
            evt.preventCancelableDefault();
          }
          return false;
        },

        _onTouchEnd: function() {
          this._element.style.zIndex = "";
          this._splitHolder.style.zIndex = "";
          this._splitHolder.style.display = "";
          this._isDragging = false;
          if (window.browserInfo.isIE || window.browserInfo.isEdge) {
            this._element.style.opacity = "";
          }
          this.emit(context.constants.widgetEvents.splitterEnd);
        },

        _onTouchMove: function(evt) {
          if (this._isDragging) {
            const delta = this._pagePosition - this._splitStartPos;
            this.updateSplits(delta);
          }
        },

        _setDOMAttachedOrDetached: function() {
          if (this._element.parentNode) {
            this._element.parentNode.parentNode.appendChild(this._splitHolder);
          } else {
            this._splitHolder.remove();
          }
        },
        activateSplitter: function(canSplit) {
          this._canHaveSplitter = Boolean(canSplit);
          this._element.toggleClass("canSplit", Boolean(canSplit));
        },
        isReversed: function() {
          return this._parentWidget.isReversed();
        },
        updateSplits: function(delta) {
          if (!Number.isNaN(delta)) {
            this.emit(context.constants.widgetEvents.splitter, delta);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Splitter', cls.SplitterWidget);
  });
;

"use strict";

modulum('StackGroupWidget', ['StackLayoutWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Group widget.
     * @class StackGroupWidget
     * @memberOf classes
     * @extends classes.StackLayoutWidgetBase
     */
    cls.StackGroupWidget = context.oo.Class(cls.StackLayoutWidgetBase, function($super) {
      return /** @lends classes.StackGroupWidget.prototype */ {
        __name: "StackGroupWidget",
        /**
         * @type {classes.GroupTitleWidget}
         */
        _title: null,

        /**
         * @type {HandleRegistration}
         */
        _titleClickHandler: null,

        /**
         * flag to determine if group is collapsible
         * @type {boolean}
         */
        _isCollapsible: false,

        /**
         * @type {{formName:string, id:string}}
         */
        _groupIdentifier: null,
        /**
         * set the stored settings identifier
         * @param {{formName:string, id:string}} id
         */
        setGroupIdentifier: function(id) {
          this._groupIdentifier = id;
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._title = cls.WidgetFactory.createWidget("GroupTitle", this.getBuildParameters());
          this._titleClickHandler = this._title.when(context.constants.widgetEvents.click, this._onTitleClick.bind(this));
          this._groupWidgetContent = this._element.getElementsByClassName("gbc_GroupWidgetContent")[0];
          this._groupWidgetContent.prependChild(this._title.getElement());
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.StackGroupLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._titleClickHandler) {
            this._titleClickHandler();
            this._titleClickHandler = null;
          }

          if (this._title) {
            this._title.destroy();
            this._title = null;
          }

          this._groupWidgetContent = null;
          $super.destroy.call(this);
        },
        /**
         * @param {string} text text describing the group content
         */
        setText: function(text) {
          this._title.setText(text);
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        },

        /**
         * @returns {string} text describing the group content
         */
        getText: function() {
          return this._title.getText();
        },
        /**
         * when group title is clicked
         * @private
         */
        _onTitleClick: function() {
          if (this._isCollapsible) {
            this._updateCollapsedState();
            this.emit(context.constants.widgetEvents.toggleClick);
          }
        },
        /**
         * Set the group collapsible
         * @param {boolean} collapsible
         */
        setCollapsible: function(collapsible) {
          this._isCollapsible = Boolean(collapsible);
          this._title.setCollapsible(this._isCollapsible);
          if (this._isCollapsible) {
            this.setCollapsed(Boolean(context.StoredSettingsService
              .getGroupCollapsedState(this._groupIdentifier.formName, this._groupIdentifier.id)));
          }
        },

        /**
         * set the collapsed state
         * @param {boolean} collapsed the collapsed state
         */
        setCollapsed: function(collapsed) {
          let result = false;
          if (this._isCollapsible) {
            if (this._title.isCollapsed() !== Boolean(collapsed)) {
              this._title.setCollapsed(collapsed);
              this._updateCollapsedState();
              result = true;
            }
          }
          return result;
        },

        /**
         * update the layout engine collapsed information
         * @private
         */
        _updateCollapsedState: function() {
          this._layoutEngine._willRenderContent = !this._title.isCollapsed();
          this._containerElement.toggleClass("hidden", this._title.isCollapsed());
          context.StoredSettingsService.setGroupCollapsedState(this._groupIdentifier.formName,
            this._groupIdentifier.id, Boolean(this._title.isCollapsed()));
          this.getLayoutEngine().forceMeasurement();
          this.getLayoutEngine().invalidateMeasure();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Stack Group', cls.StackGroupWidget);
  });
;

"use strict";

modulum('StackLabelWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * StackLabel widget.
     * @class StackLabelWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.StackLabelWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.StackLabelWidget.prototype */ {
        __name: "StackLabelWidget",

        _text: null,
        _textElement: null,

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._textElement = this.getElement();
          this.setHidden(true);
        },
        destroy: function() {
          $super.destroy.call(this);
        },
        setText: function(text) {
          this._setTextContent(text, "_textElement");
          this._text = text;
          this.setHidden(!text);
        },
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden || !this._text);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StackLabel', cls.StackLabelWidget);
  });
;

"use strict";

modulum('StackLayoutWidgetBase', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class StackLayoutWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.StackLayoutWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StackLayoutWidgetBase.prototype */ {
        __name: "StackLayoutWidgetBase",

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._element.addClass("g_StackLayoutEngine");
        },

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.StackLayoutEngine(this);
        },

        _addChildWidgetToDom: function(widget, position) {
          const widgetHost = document.createElement('div');
          widgetHost.addClass('g_StackElement');
          widget.getLayoutInformation().setHostElement(widgetHost);
          const stackLabel = cls.WidgetFactory.createWidget("StackLabel", this.getBuildParameters());
          widgetHost.appendChild(stackLabel._element);
          widget.getLayoutInformation()._stackLabel = stackLabel;
          widgetHost.appendChild(widget._element);
          this.getLayoutEngine().registerChild(widget, position);
          widgetHost.insertAt(position, this._containerElement);
        },

        _removeChildWidgetFromDom: function(widget) {
          this.getLayoutEngine().unregisterChild(widget);
          const info = widget.getLayoutInformation();
          let host = info && info.getHostElement();
          const label = info && info._stackLabel;
          if (label) {
            label.destroy();
            info._stackLabel = null;
          }
          if (host && host.parentNode === this._containerElement) {
            widget._element.remove();
            host.remove();
            host = null;
          }
        },

        setStackLabelText: function(widget, text) {
          const info = widget.getLayoutInformation(),
            label = info && info._stackLabel;
          if (label) {
            label.setText(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('StackWidget', ['StackLayoutWidgetBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class StackWidget
     * @memberOf classes
     * @extends classes.StackLayoutWidgetBase
     */
    cls.StackWidget = context.oo.Class(cls.StackLayoutWidgetBase, function($super) {
      return /** @lends classes.StackWidget.prototype */ {
        __name: "StackWidget"
      };
    });
    cls.WidgetFactory.registerBuilder('Stack', cls.StackWidget);
  });
;

"use strict";

modulum('StretchableScrollGridLineWidget', ['GridWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Stretchable scroll grid line widget.
     * @class StretchableScrollGridLineWidget
     * @memberOf classes
     * @extends classes.GridWidget
     * @publicdoc
     */
    cls.StretchableScrollGridLineWidget = context.oo.Class(cls.GridWidget, function($super) {

      return /** @lends classes.StretchableScrollGridLineWidget.prototype */ {
        __name: "StretchableScrollGridLineWidget",

        /** @type boolean */
        _current: false,

        /** @type classes.RowBoundDecoratorWidget */
        _rowBoundDecoratorWidget: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = (opts || {});
          opts.inScrollGrid = true;
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._rowBoundDecoratorWidget) {
            this._rowBoundDecoratorWidget.destroy();
            this._rowBoundDecoratorWidget = null;
          }
          for (let child of this._children) {
            child.destroy();
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.requestFocus(domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          this.emit(context.constants.widgetEvents.doubleClick, domEvent);
          return true;
        },

        /**
         * Request focus for this row
         * @param {*} domEvent - dom event object
         */
        requestFocus: function(event) {
          if (event) {
            event.currentRow = this._rowIndex;
          }
          if (this.getParentWidget()?.requestFocus) {
            this.getParentWidget().requestFocus(event);
          }
        },

        /**
         * Sets if the row is the current one
         * @param {boolean} current - true if row is the current one, false otherwise
         * @publicdoc
         */
        setCurrent: function(current) {
          if (this._current !== current) {
            this._current = current;
            if (current) {
              this._element.addClass("currentRow");
              this._children.forEach(function(w) {
                w.addClass("currentRow");
              });
            } else {
              this._element.removeClass("currentRow");
              this._children.forEach(function(w) {
                w.removeClass("currentRow");
              });
            }
          }

          const parent = this.getParentWidget();
          if (parent) {
            this._element.toggleClass("highlight", parent.isHighlightCurrentRow());
            this._element.toggleClass("nohighlight", !parent.isHighlightCurrentRow());
          }
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          $super.addChildWidget.call(this, widget, options);
          widget.removeClass("gbc_WidgetBase_standalone");
          widget.addClass("gbc_WidgetBase_in_array");
        },

        /**
         * Creates and adds rowBound decorator element to DOM
         */
        addRowBoundDecorator: function() {
          this._rowBoundDecoratorWidget = cls.WidgetFactory.createWidget("RowBoundDecorator", this.getBuildParameters());
          this._rowBoundDecoratorWidget.setParentWidget(this);

          this._rowBoundDecoratorWidget.setContextMenuWidget(this.getParentWidget().getRowBoundMenu());
          this._rowBoundDecoratorWidget.update();

          this._element.appendChild(this._rowBoundDecoratorWidget.getElement());
        },

        /**
         * Return rowBound decorator widget
         * @return {classes.RowBoundDecoratorWidget} - rowBound decorator widget
         */
        getRowBoundDecoratorWidget: function() {
          return this._rowBoundDecoratorWidget;
        },

        /**
         * Return current row index of widget inside scrollgrid
         * @returns {?number|number|*}
         */
        getRowIndex: function() {
          return this._rowIndex;
        },

        /**
         * Set current row index of widget within scrollgrid
         * @param index
         */
        setRowIndex: function(index) {
          this._rowIndex = index;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('StretchableScrollGridLine', cls.StretchableScrollGridLineWidget);
  });
;

"use strict";

modulum('StretchableScrollGridWidget', ['StretchableScrollGridWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Stretchable scroll grid widget.
     * @class StretchableScrollGridWidget
     * @memberOf classes
     * @extends classes.StretchableScrollGridWidgetBase
     * @publicdoc
     */
    cls.StretchableScrollGridWidget = context.oo.Class(cls.StretchableScrollGridWidgetBase, function($super) {

      return /** @lends classes.StretchableScrollGridWidget.prototype */ {
        __name: "StretchableScrollGridWidget",
        /** @type {?number} */
        _pageSize: null,
        /** @type {?number} */
        _bufferSize: null,
        /** @type {?number} */
        _size: null,
        /** @type {?number} */
        _offset: null,
        /** @type {?number} */
        lastSentOffset: null,
        /** @type {number} */
        _rowHeight: 0,
        /** @type {number} */
        _currentRow: 0,

        /** Handlers */
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /** @type {classes.ContextMenuWidget} */
        _rowBoundWidget: null,

        /** @type {boolean} */
        _hasReduceFilter: false,

        /** @type {Number} **/
        _firstPageSize: null,

        /** @type {boolean} */
        _haveRowBoundActions: false,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on('scroll.StretchableScrollGridWidget', function(event) {
            this.emit(context.constants.widgetEvents.scroll, event, this.getRowHeight());
          }.bind(this));
          this._uiActivateHandler = this._uiWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this.updateVerticalScroll.bind(this, true));
          }

          this._rowBoundWidget = this.getApplicationWidget().getRowBoundMenu();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          this._element.off('scroll.StretchableScrollGridWidget');

          this._rowBoundWidget = null;
          this._uiWidget = null;
          this._folderPageWidget = null;
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);

          // if focus comes from VM not mouse
          if (!fromMouse) {
            this.activateRowBound();
          }
        },

        /**
         *  Activate rowbound on widget.
         */
        activateRowBound: function() {
          // always add rowBound class even if _haveRowBoundActions is false for VM compat
          this.addClass("rowBound");

          // update rowBound
          if (this._haveRowBoundActions) {
            for (const row of this.getChildren()) {
              row.getRowBoundDecoratorWidget().update();
            }
          }
        },

        /**
         * @inheritDoc
         */
        loseVMFocus: function(vmNewFocusedWidget = null) {
          $super.loseVMFocus.call(this, vmNewFocusedWidget);

          // if new focused widget is not in the scrollgrid
          if (!this._haveRowBoundActions && !vmNewFocusedWidget.isInScrollGrid(this)) {
            this.removeClass("rowBound");
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          cls.ScrollGridWidget._onClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          cls.ScrollGridWidget._onDblClick.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        addChildWidget: function(widget, options) {
          if (widget.isInstanceOf(cls.StretchableScrollGridLineWidget)) {
            $super.addChildWidget.call(this, widget, options);
            if (this.haveRowBoundActions()) {
              widget.addRowBoundDecorator();
            }
          }
        },

        /**
         * @returns {number} scroll grid data area height
         */
        getDataAreaHeight: function() {
          return this.getLayoutInformation().getAvailable().getHeight();
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          return this.getElement();
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          if (this._rowHeight === 0 && this.getChildren().length !== 0) {
            this._rowHeight = this.getChildren()[0]._element.getBoundingClientRect().height;
            if (this._rowHeight > 0) {
              let rowMargin = parseInt(context.ThemeService.getValue("gbc-ScrollGridWidget-inner-gutter"), 10);
              this._rowHeight += rowMargin;
            }
          }
          return this._rowHeight;
        },

        /**
         * Defines the scroll grid pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        /**
         * Defines the scroll grid size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Returns the scroll grid offset
         * @return {number} offset value
         */
        getOffset: function(offset) {
          return this._offset;
        },

        /**
         * Defines the scroll grid offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._offset = offset;
        },

        /**
         * Update vertical scroll
         * @param {boolean} forceScroll - true to force scrolling
         */
        updateVerticalScroll: function(forceScroll) {
          this.setVerticalScroll(this._size, this._pageSize, this._offset, forceScroll);
        },

        /**
         * Sets vertical scroll parameters
         * @param {number} size
         * @param {number} pageSize
         * @param {number} offset
         * @param {boolean} forceScroll
         */
        setVerticalScroll: function(size, pageSize, offset, forceScroll = false) {
          this.setSize(size);
          this._pageSize = pageSize;

          const top = offset * this.getRowHeight();
          const height = (size - offset) * this.getRowHeight();

          // @todo : Use CSS variables
          this.setStyle("> .containerElement", {
            "margin-top": top + "px",
            "height": height + "px"
          });

          if (forceScroll || (this.lastSentOffset === null ||
              this.lastSentOffset === offset) && offset !== this._offset) {
            this._offset = offset;
            // need to do this because to scroll we need to wait the style "height" set just before is really applied in the dom
            this.afterDomMutator(function() {
              this.getScrollableArea().scrollTop = top;
            }.bind(this));
          }

          this.lastSentOffset = null;
        },

        /**
         * Returns rowBound widget
         * @returns {classes.ContextMenuWidget} rowBound
         */
        getRowBoundMenu: function() {
          return this._rowBoundWidget;
        },

        /**
         * Indicates if the scrollgrid can have a reduce filter
         * @param {boolean} b - true if table can have a reduce filter
         */
        setReduceFilter: function(b) {
          this._hasReduceFilter = b;
        },

        /**
         * Return if the scrollgrid can have a reduce filter
         * @returns {boolean} true if table can have a reduce filter
         */
        hasReduceFilter: function() {
          return this._hasReduceFilter;
        },

        /**
         * Set how children will align
         * @param {string} alignment
         */
        setItemsAlignment: function(alignment) {
          if (this._containerElement) {
            this._containerElement.style.alignItems = {
              start: "flex-start",
              left: "flex-start",
              center: "center",
              stretch: "stretch",
              right: "flex-end",
              end: "flex-end"
            } [alignment] || "stretch";
          }
        },

        /**
         * Sets scrollgrid is scrolling
         * @param {boolean} up - scrolling up
         * @param {boolean} down - scrolling down
         */
        setScrolling: function(up, down) {},

        /**
         * Set if we are sure that scrollgrid has some rowBound actions
         * @param {boolean} b true if scrollgrid has some rowBound actions
         */
        setHaveRowBoundActions: function(b) {
          this._haveRowBoundActions = b;
          this.toggleClass("rowBound", b);
        },

        /**
         * Returns if we are sure that scrollgrid has some rowBound actions
         * @returns {boolean} true if scrollgrid has some rowBound actions
         */
        haveRowBoundActions: function() {
          return this._haveRowBoundActions;
        },

        /**
         * Returns if "anticipate scrolling" is enabled
         * @returns {boolean} true if enabled
         */
        isAnticipateScrollingEnabled: function() {
          return false;
        },

        /**
         * Anticipate scrolling by directly load data from cached model without waiting for VM response
         */
        anticipateScrolling: function() {
          // NOT IMPLEMENTED
        },
      };
    });
    cls.WidgetFactory.registerBuilder('StretchableScrollGrid', cls.StretchableScrollGridWidget);
  });
;

"use strict";

modulum('StretchableScrollGridWidgetBase', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Strechable Scroll Grid base widget
     * @class StretchableScrollGridWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.StretchableScrollGridWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.StretchableScrollGridWidgetBase.prototype */ {
        __name: "StretchableScrollGridWidgetBase",

        /** @type {boolean} */
        _rowActionTriggerByDoubleClick: true,
        /** @type {boolean} */
        _focusOnField: false,

        /** @type {classes.HighlightWidgetComponent} */
        _highlightComponent: null,

        /** @type {classes.RowAspectWidgetComponent} */
        _rowAspectComponent: null,

        constructor: function(opts) {
          this._highlightComponent = new cls.HighlightWidgetComponent(this, true, false);
          this._rowAspectComponent = new cls.RowAspectWidgetComponent(this);
          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._rowAspectComponent.destroy();
          this._rowAspectComponent = null;
          this._highlightComponent.destroy();
          this._highlightComponent = null;

          $super.destroy.call(this);
        },

        _initElement: function() {
          $super._initElement.call(this);
          this._rowAspectComponent.setRowAspect("default");
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          $super._initLayout.call(this);

          this._layoutEngine = new cls.StretchableScrollLayoutEngine(this);
          this._layoutInformation.getStretched().setDefaultX(true);
          this._layoutInformation.getStretched().setDefaultY(true);
        },

        /**
         * @inheritdoc
         */
        addChildWidget: function(childWidget, options) {
          if (childWidget.isInstanceOf(cls.StretchableScrollGridLineWidget)) {
            $super.addChildWidget.call(this, childWidget, options);
          }
        },

        /**
         * Launch a FocusCommand on the scheduler
         * @param {*} event 
         */
        requestFocus: function(event) {
          this.emit(context.constants.widgetEvents.requestFocus, event);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (domKeyEvent) {
            let key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
            keyProcessed = true;
            switch (key) {
              case "down":
                this.emit(context.constants.widgetEvents.keyArrowDown, domKeyEvent);
                break;
              case "up":
                this.emit(context.constants.widgetEvents.keyArrowUp, domKeyEvent);
                break;
              case "pageup":
                this.emit(context.constants.widgetEvents.keyPageUp, domKeyEvent);
                break;
              case "pagedown":
                this.emit(context.constants.widgetEvents.keyPageDown, domKeyEvent);
                break;
              case "home":
                this.emit(context.constants.widgetEvents.keyHome, domKeyEvent);
                break;
              case "end":
                this.emit(context.constants.widgetEvents.keyEnd, domKeyEvent);
                break;
              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /**
         * Defines if focus in on a field or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          if (this._focusOnField !== focusOnField) {
            this._focusOnField = focusOnField;
            this.toggleClass("gbc_focusOnField", focusOnField);
            this.updateHighlight();
          }
        },

        /**
         * Defines the scroll grid bufferSize
         * @param {number} bufferSize - buffer size
         */
        setBufferSize: function(bufferSize) {
          this._bufferSize = bufferSize;
        },

        /**
         * Returns scroll grid bufferSize
         * @returns {number}
         */
        getBufferSize: function() {
          return this._bufferSize;
        },

        /**
         * Returns if focus is on a field (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * Change current row
         * @param {number} row - new current row
         */
        setCurrentRow: function(row) {
          this._currentRow = row;
          const children = this.getChildren();
          const length = children.length;
          for (let i = 0; i < length; ++i) {
            const rowWidget = children[i];
            rowWidget.setCurrent(i === row);
          }
        },

        /**
         * @returns {number} the current row
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * Defines the highlight color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {
          this._highlightComponent.setHighlightBackgroundColor(color);
        },

        /**
         * Defines the highlighted text color of rows, used for selected rows
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {
          this._highlightComponent.setHighlightTextColor(color);
        },

        /**
         * Indicates if the current row must be highlighted
         * @param {boolean} doHighlight - true if current row must be highlighted
         */
        setHighlightCurrentRow: function(doHighlight) {
          this._highlightComponent.setShouldHighlightCurrentRow(doHighlight);
        },

        /**
         * Return if the current row must be highlighted
         * @returns {?boolean} true if current row must be highlighted
         * @publicdoc
         */
        isHighlightCurrentRow: function() {
          return this._highlightComponent.getShouldHighlightCurrentRow();
        },

        /**
         * Indicates if the current cell must be highlighted
         * @param {boolean} doHighlight - true if current cell must be highlighted
         */
        setHighlightCurrentCell: function(doHighlight) {
          this._highlightComponent.setShouldHighlightCurrentCell(doHighlight);
        },

        /**
         * Return if the current cell must be highlighted
         * @returns {?boolean} true if current cell must be highlighted
         * @publicdoc
         */
        isHighlightCurrentCell: function() {
          return this._highlightComponent.getShouldHighlightCurrentCell();
        },

        /**
         * Update highlight row and cell
         */
        updateHighlight: function() {},

        // Reset row height
        resetRowHeight: function() {
          this._rowHeight = 0;
        },

        // ============== START - COMPONENTS GETTERS =====================

        /**
         * @returns {classes.HighlightWidgetComponent} The highlight component of the widget
         */
        getHighlightComponent: function() {
          return this._highlightComponent;
        },

        /**
         * @returns {classes.RowAspectWidgetComponent} The row aspect component of the widget
         */
        getRowAspectComponent: function() {
          return this._rowAspectComponent;
        }

        // ============== START - COMPONENTS GETTERS =====================
      };
    });
  });
;

"use strict";

modulum('TabbedApplicationCloseWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class TabbedApplicationCloseWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.TabbedApplicationCloseWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.TabbedApplicationCloseWidget.prototype */ {
        __name: "TabbedApplicationCloseWidget",
        _activated: false,
        _processing: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this._processing) {
            this.emit(context.constants.widgetEvents.click);
          }
          return false;
        },

        setActive: function(active) {
          this._active = active;
          this._element.toggleClass("gbc-disabled", !active);
        },

        setHidden: function(hidden) {
          this._element.toggleClass("gbc-hidden", Boolean(hidden));
        },

        onClick: function(hook) {
          return this.when(context.constants.widgetEvents.click, hook);
        },

        _setProcessingStyle: function(processing) {
          this._processing = Boolean(processing);
          if (this._element) {
            if (this._processing) {
              this._element.setAttribute("processing", "processing");
            } else {
              this._element.removeAttribute("processing");
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TabbedApplicationClose', cls.TabbedApplicationCloseWidget);
  });
;

"use strict";

modulum('TabbedContainerWidget', ['FolderWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Tabbed container widget.
     * @class TabbedContainerWidget
     * @memberOf classes
     * @extends classes.FolderWidget
     */
    cls.TabbedContainerWidget = context.oo.Class(cls.FolderWidget, function($super) {
      return /** @lends classes.TabbedContainerWidget.prototype */ {
        __name: "TabbedContainerWidget",
        __templateName: "FolderWidget",

        /**
         * @type {HandleRegistration}
         */
        _browserResizeHandler: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);

          this._browserResizeHandler = context.HostService.onScreenResize(this.updateScrollersVisibility.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._browserResizeHandler) {
            this._browserResizeHandler();
            this._browserResizeHandler = null;
          }
          this.destroyChildren();
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this.setTabPosition("top");
          this._layoutInformation = new cls.FolderLayoutInformation(this);
          this._layoutEngine = new cls.TabbedContainerLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        onTitleClick: function(page) {
          this.setCurrentPage(page);
        },

        /**
         * @inheritDoc
         */
        _getAllocatedSize: function(isHorizontal) {
          if (this.getParentWidget()) {
            const info = this.getParentWidget().getWindowContentContainer().getBoundingClientRect();
            return info[isHorizontal ? "width" : "height"];
          }
          return 0;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TabbedContainer', cls.TabbedContainerWidget);
  });
;

"use strict";

modulum('TableWidgetBase', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TableWidgetBase widget (abstract class for TableWidget & ListViewWidget).
     * @class TableWidgetBase
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.TableWidgetBase = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TableWidgetBase.prototype */ {
        __name: "TableWidgetBase",

        /** @type {boolean} */
        __virtual: true,

        /** @type {number} */
        _currentRow: 0,
        /** @type {number} */
        _size: 0,
        /** @type {number} */
        _offset: 0,
        /** @type {number} */
        _pageSize: 0,
        /** @type {number} */
        _bufferSize: 0,
        /** @type {?number} */
        _firstPageSize: null,
        /** @type {boolean} */
        _fixedPageSize: false,
        /** @type {number} */
        _visibleRows: 0,

        /** @type {boolean} */
        _inputMode: false,
        /** @type {number} */
        _rowHeight: 0,

        /** @type {?boolean} */
        _rowActionTriggerByDoubleClick: true,
        /** @type {classes.UserInterfaceWidget} */
        _uiWidget: null,
        /** @type {classes.FolderWidgetBase} */
        _folderPageWidget: null,

        /** Handlers */
        /** @function */
        _uiActivateHandler: null,
        /** @function */
        _pageActivateHandler: null,

        /** @type {HTMLElement} */
        _scrollAreaElement: null,

        /** @type {boolean} */
        _hasReduceFilter: false,

        /** @type {boolean} */
        _isTreeView: false,

        /** @type {boolean} */
        _focusOnField: false,

        /** @type {boolean} */
        _haveRowBoundActions: false,

        /**
         * Selection square in pixel
         * @type {object}
         **/
        _selectionSquareIdx: null,

        /** @type {classes.TableCachedDataModel} */
        _cachedDataModel: null,

        /**
         * @type {classes.HighlightWidgetComponent}
         */
        _highlightComponent: null,

        /**
         * @type {classes.RowAspectWidgetComponent}
         */
        _rowAspectComponent: null,

        /**
         * @constructs
         * @param {*} opts - Options passed to the constructor
         */
        constructor: function(opts) {
          opts = opts || {};
          this._uiWidget = opts.uiWidget;
          this._folderPageWidget = opts.folderPageWidget;
          this._isTreeView = Boolean(opts.isTreeView);

          $super.constructor.call(this, opts);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._uiActivateHandler) {
            this._uiActivateHandler();
            this._uiActivateHandler = null;
          }
          if (this._pageActivateHandler) {
            this._pageActivateHandler();
            this._pageActivateHandler = null;
          }
          this._uiWidget = null;
          this._folderPageWidget = null;
          this._scrollAreaElement = null;

          this._rowAspectComponent.destroy();
          this._rowAspectComponent = null;
          this._highlightComponent.destroy();
          this._highlightComponent = null;

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.setFocusable(true);

          // TODO instead of having UserInterfaceWidget which emits an activate signal
          // TODO it should be directly the WindowWidget which should emit the signal
          // TODO also seems buggy we receive activate signal even when window is not added to DOM
          this._uiActivateHandler = this._uiWidget.onActivate(this._whenParentActivated.bind(this));
          if (this._folderPageWidget) {
            this._pageActivateHandler = this._folderPageWidget.onActivate(this._whenParentActivated.bind(this));
          }

          this._rowAspectComponent = new cls.RowAspectWidgetComponent(this);
          this._highlightComponent = new cls.HighlightWidgetComponent(this);
        },

        /**
         * When a parent widget is activated (added to DOM actually)
         * Used when parent window or parent folder page are removed from DOM and added again
         * we need to reapply context which are lost when table is removed from DOM
         * (scroll position)
         * @param {Object} opt - option of the emitted signal
         * @private
         */
        _whenParentActivated: function(opt) {},

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          $super.resetLayout.call(this);
          this._rowHeight = 0;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.getRowBoundMenu()?.isVisible()) {
            keyProcessed = this.getRowBoundMenu().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          return keyProcessed;
        },

        /**
         * Set the DOM focus to the widget
         * @param {boolean} [noScroll] - if true try to disable auto scroll
         * @publicdoc
         */
        domFocus: function(noScroll) {
          if (this._element) {
            if (!noScroll) {
              this._element.domFocus();
            } else {
              // try to not scroll when focus
              this._element.domFocus(null, this.getFormWidget().getContainerElement());
            }
          }
        },

        /**
         * Change current row
         * @param {number} row - new current row
         * @param {boolean} [ensureRowVisible] - if true scroll to be sure row is visible (useful when first row is partially visible)
         * @param {?number} [vmCurrentRow] - vm real current row
         */
        setCurrentRow: function(row, ensureRowVisible = false, vmCurrentRow = null) {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns current row
         * @returns {number} current row
         * @publicdoc
         */
        getCurrentRow: function() {
          return this._currentRow;
        },

        /**
         * Change current column
         * @param {number} col - new current column
         */
        setCurrentColumn: function(col) {
          // TO BE IMPLEMENTED, IF NEEDED
        },

        /**
         * Returns if "anticipate scrolling" is enabled
         * @returns {boolean} true if enabled
         */
        isAnticipateScrollingEnabled: function() {
          return this._cachedDataModel !== null; // && this.isDisplayMode();
        },

        /**
         * Get cached data model
         * @returns {classes.TableCachedDataModel} dataModel
         */
        getCachedDataModel: function() {
          return this._cachedDataModel;
        },

        /**
         * Defines the table pageSize
         * @param {number} pageSize - page size
         */
        setPageSize: function(pageSize) {
          this._setFirstPageSize(pageSize);
          this._pageSize = pageSize;
        },

        /**
         * Keep the first pageSize
         * @param {number} pageSize - page size
         */
        _setFirstPageSize: function(pageSize) {
          if (this._firstPageSize === null && pageSize > 0) {
            this._firstPageSize = pageSize;
          }
        },

        /**
         * Returns page size
         * @returns {?number} the page size
         * @publicdoc
         */
        getPageSize: function() {
          return this._pageSize;
        },

        /**
         * Defines the table bufferSize
         * @param {number} bufferSize - buffer size
         */
        setBufferSize: function(bufferSize) {
          this._bufferSize = bufferSize;
        },

        /**
         * Returns the buffer size
         * @returns {number}
         */
        getBufferSize: function() {
          return this._bufferSize;
        },

        /**
         * Defines if pageSize is fixed
         * @param {boolean} fixed - true if page size is fixed
         */
        setFixedPageSize: function(fixed) {
          if (this._fixedPageSize !== fixed) {
            this._fixedPageSize = fixed;
            this._layoutInformation.getStretched().setDefaultY(!fixed);
          }
        },

        /**
         * Returns if pageSize is fixed
         * @returns {boolean} true if pageSize is fixed
         * @publicdoc
         */
        isFixedPageSize: function() {
          return this._fixedPageSize;
        },

        /**
         * Returns table size
         * @returns {number} the table size
         * @publicdoc
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Defines the table size (total number of row)
         * @param {number} size - size value
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Defines the table offset
         * @param {number} offset - offset value
         */
        setOffset: function(offset) {
          this._offset = offset;
        },

        /**
         * Returns table offset
         * @returns {number} the table offset
         * @publicdoc
         */
        getOffset: function() {
          return this._offset;
        },

        /**
         * Sets the number of visible rows
         * @param {number} visibleRows - number of visible rows
         */
        setVisibleRows: function(visibleRows) {
          this._visibleRows = visibleRows;
        },

        /**
         * Returns number of visible rows
         * @returns {number} the number of visible rows
         */
        getVisibleRows: function() {
          return this._visibleRows;
        },

        /**
         * @inheritDoc
         */
        setDialogType: function(dialogType) {
          $super.setDialogType.call(this, dialogType);
          this._element.toggleClass("inputMode", this.isInputMode() || this.isInputArrayMode());
        },

        /**
         * Returns if table is in input mode.
         * @returns {boolean} true if input mode
         * @publicdoc
         */
        isInputMode: function() {
          return this._dialogType === "Input" || this._dialogType === "Construct";
        },

        /**
         * Returns if table is in input array mode.
         * @returns {boolean} true if input array mode
         * @publicdoc
         */
        isInputArrayMode: function() {
          return this._dialogType === "InputArray";
        },

        /**
         * Returns if table is in display mode.
         * @returns {boolean} true if display mode
         * @publicdoc
         */
        isDisplayMode: function() {
          return !this.isInputArrayMode() && !this.isInputMode();
        },

        /**
         * Sets the height of rows
         * @param {number} height - row height (pixels)
         * @publicdoc
         */
        setRowHeight: function(height) {
          this._rowHeight = height;
        },

        /**
         * Returns the row height in pixels
         * @returns {number} row height
         * @publicdoc
         */
        getRowHeight: function() {
          return this._rowHeight;
        },

        /**
         * Call when a widget in the table request the focus
         * @param {classes.WidgetBase} widget - widget that request focus
         * @param {Object} event - event that request focus
         */
        requestFocusFromWidget: function(widget, event) {
          if (this.isEnabled()) {
            widget.emit(context.constants.widgetEvents.requestFocus, event);
          }
        },

        /**
         * @returns {number} table data area height
         */
        getDataAreaHeight: function() {
          return this.getLayoutInformation().getAllocated().getHeight() - this.getLayoutInformation().getDecorating().getHeight();
        },

        /**
         * @returns {number} table data area width
         */
        getDataAreaWidth: function() {
          return this.getLayoutInformation().getAllocated().getWidth() - this.getLayoutInformation().getDecorating().getWidth();
        },

        /**
         * Indicates how the row action must be triggered.
         * @param {boolean} b - true if action is triggered by double click (else it is single click)
         */
        setRowActionTriggerByDoubleClick: function(b) {
          this._rowActionTriggerByDoubleClick = b;
        },

        /**
         * Indicates how the row action must be triggered.
         * @returns {boolean} true if action is triggered by double click (else it is single click)
         */
        isRowActionTriggerByDoubleClick: function() {
          return this._rowActionTriggerByDoubleClick;
        },

        /**
         * Defines the highlight color of rows for the table
         * @param {string} color - CSS color
         */
        setHighlightColor: function(color) {
          this._highlightComponent.setHighlightBackgroundColor(color);
        },

        /**
         * Defines the highlighted text color of rows for the table
         * @param {string} color - CSS color
         */
        setHighlightTextColor: function(color) {
          this._highlightComponent.setHighlightTextColor(color);
        },

        /**
         * Indicates if the current row must be highlighted
         * @param {boolean} b - true if current row must be highlighted
         */
        setHighlightCurrentRow: function(doHighlight) {
          this._highlightComponent.setShouldHighlightCurrentRow(doHighlight);
        },

        /**
         * Return if the current row must be highlighted
         * @returns {?boolean} true if current row must be highlighted
         * @publicdoc
         */
        isHighlightCurrentRow: function() {
          return this._highlightComponent.getShouldHighlightCurrentRow();
        },

        /**
         * Indicates if the current cell must be highlighted in a table
         * @param {boolean} b - true if current cell must be highlighted
         */
        setHighlightCurrentCell: function(doHighlight) {
          this._highlightComponent.setShouldHighlightCurrentCell(doHighlight);
        },

        /**
         * Return if the current cell must be highlighted
         * @returns {?boolean} true if current cell must be highlighted
         * @publicdoc
         */
        isHighlightCurrentCell: function() {
          return this._highlightComponent.getShouldHighlightCurrentCell();
        },

        /**
         * Set the widget color (specific code for widget in a table)
         * @param {classes.WidgetBase} widget - widget on which color will be applied
         * @param {string} color - a CSS color definition
         */
        setInTableWidgetColor: function(widget, color) {
          // TO BE IMPLEMENTED
        },

        /**
         * Set the widget background color (specific code for widget in a table)
         * @param {classes.WidgetBase} widget - widget on which bg color will be applied
         * @param {string} color - a CSS color definition
         */
        setInTableWidgetBackgroundColor: function(widget, color) {
          // TO BE IMPLEMENTED
        },

        /**
         * Update vertical scroll
         * @param {boolean} [forceScroll] - true to force scrolling
         */
        updateVerticalScroll: function(forceScroll) {
          this.setVerticalScroll(this._offset, forceScroll);
        },

        /**
         * Sets vertical scroll parameters
         * @param {?number} offset
         * @param {boolean} [forceScroll]
         */
        setVerticalScroll: function(offset, forceScroll = false) {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns scrollable area DOM Element
         * @returns {HTMLElement} scrollable area DOM Element
         */
        getScrollableArea: function() {
          // TO BE IMPLEMENTED
        },

        /**
         * Returns rowBound widget
         * @returns {classes.ContextMenuWidget} rowBound
         */
        getRowBoundMenu: function() {
          return this.getApplicationWidget().getRowBoundMenu();
        },

        /**
         * Set if we are sure that table has some rowBound actions
         * @param {boolean} b true if table has some rowBound actions
         */
        setHaveRowBoundActions: function(b) {
          this._haveRowBoundActions = b;
        },

        /**
         * Returns if we are sure that table has some rowBound actions
         * @returns {boolean} true if table has some rowBound actions
         */
        haveRowBoundActions: function() {
          return this._haveRowBoundActions;
        },

        /**
         * Indicates if the table can have a reduce filter
         * @param {boolean} b - true if table can have a reduce filter
         */
        setReduceFilter: function(b) {
          this._hasReduceFilter = b;
        },

        /**
         * Return if the table can have a reduce filter
         * @returns {boolean} true if table can have a reduce filter
         */
        hasReduceFilter: function() {
          return this._hasReduceFilter;
        },

        /**
         * Returns if table is a tree
         * @returns {boolean} true if table is a tree
         * @publicdoc
         */
        isTreeView: function() {
          return this._isTreeView;
        },

        /**
         * Sets table is scrolling
         * @param {boolean} up - scrolling up
         * @param {boolean} down - scrolling down
         */
        setScrolling: function(up, down) {},

        /**
         * Defines if focus in on a field (table item) or (default) on a row
         * @param {boolean} focusOnField - true if focus on field activated
         */
        setFocusOnField: function(focusOnField) {
          this._focusOnField = focusOnField;
        },

        /**
         * Returns if focus is on a field (table item) (by default focus is on a row)
         * @returns {boolean} true if focus on field activated
         */
        hasFocusOnField: function() {
          return this._focusOnField;
        },

        /**
         * Returns if current row is visible
         * @returns {boolean} true if current row is visible
         * @publicdoc
         */
        isCurrentRowVisible: function() {
          return this._currentRow >= 0 && this._currentRow <= this._pageSize;
        },

        /**
         * True if we can show the copy cell/copy row items in the context menu
         * @returns {boolean}
         */
        canShowCopyCellAndRow: function() {
          return this._currentRow >= 0 && this._selectionSquareIdx.left.x === null;
        },

        /**
         * Anticipate scrolling by directly load data from cached model without waiting for VM response
         */
        anticipateScrolling: function() {},

        // ============== START - COMPONENTS GETTERS =====================

        getRowAspectComponent: function() {
          return this._rowAspectComponent;
        },
        // ============== END - COMPONENTS GETTERS =====================

      };
    });
  });
;

"use strict";

modulum('TraditionalScreenWidget', ['WidgetGridLayoutBase'],
  function(context, cls) {

    /**
     * Base class for widget group.
     * @class TraditionalScreenWidget
     * @memberOf classes
     * @extends classes.WidgetGridLayoutBase
     */
    cls.TraditionalScreenWidget = context.oo.Class(cls.WidgetGridLayoutBase, function($super) {
      return /** @lends classes.TraditionalScreenWidget.prototype */ {
        __name: "TraditionalScreenWidget",

        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.TraditionalLayoutEngine(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalScreen', cls.TraditionalScreenWidget);
  });
;

"use strict";

modulum('TraditionalWindowContainerWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class TraditionalWindowContainerWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.TraditionalWindowContainerWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TraditionalWindowContainerWidget.prototype */ {
        __name: "TraditionalWindowContainerWidget",

        constructor: function(opts) {
          $super.constructor.call(this, opts);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalWindowContainer', cls.TraditionalWindowContainerWidget);
  });
;

"use strict";

modulum('TraditionalWindowWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class TraditionalWindowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.TraditionalWindowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.TraditionalWindowWidget.prototype */ {
        __name: "TraditionalWindowWidget",

        constructor: function(opts) {
          $super.constructor.call(this, opts);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('TraditionalWindow', cls.TraditionalWindowWidget);
  });
;

"use strict";

modulum('UserInterfaceWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * UserInterface widget.
     * @class UserInterfaceWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc Widgets
     */
    cls.UserInterfaceWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.UserInterfaceWidget.prototype */ {
        __name: "UserInterfaceWidget",

        $static: {
          startMenuPosition: 'gStartMenuPosition'
        },

        _text: "",
        _image: null,
        _topMenuContainer: null,
        /** @type {Array} **/
        _topMenus: null,
        _toolBarContainer: null,
        _toolBarWidgets: null,
        _toolBarPosition: "top",
        _startMenuWidget: null,
        _startMenuContainer: null,
        _traditionalWindowContainer: null,
        /**
         * VM Focused widget
         * @type {classes.WidgetBase}
         */
        _vmFocusedWidget: null,
        /**
         * VM Previously Focused widget
         * @type {classes.WidgetBase}
         */
        _vmPreviouslyFocusedWidget: null,

        _dbDate: "MDY4/", // default format
        _unBindLayoutHandler: null,
        _activeWindow: null,
        _errorMessageWidget: null,

        /** @type {Node} */
        _chromeBarContainer: null,
        /** @type {classes.ChromeBarWidget} */
        _chromeBar: null,

        _isBufferingKeys: null,

        _browserResizeHandler: null,

        _charLengthSemantics: null,
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._chromeBarContainer = this._element.getElementsByClassName("gbc_chromeBarContainer")[0];
          this._topMenuContainer = this._element.getElementsByClassName("gbc_topMenuContainer")[0];
          this._toolBarContainer = this._element.getElementsByClassName("gbc_toolBarContainer")[0];
          this._bottomToolBarContainer = this._element.getElementsByClassName("gbc_bottomToolBarContainer")[0];

          this._startMenuContainer = this._element.getElementsByClassName("gbc_startMenuContainer")[0];
          this._errorMessageWidget = cls.WidgetFactory.createWidget("Message", this.getBuildParameters());
          this._errorMessageWidget.setHidden(true);

          this._topMenus = [];

          this._toolBarWidgets = [];
          this._chromeBar = cls.WidgetFactory.createWidget("ChromeBar", this.getBuildParameters());
          const appHost = context.HostService.getApplicationHostWidget();
          this._chromeBar.when(context.constants.widgetEvents.toggleClick,
            () => gbc.HostLeftSidebarService.showSidebar());
          this.addChromeBar();

          this._browserResizeHandler = context.HostService.onScreenResize(function() {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutInformation().invalidateMeasure();
          }.bind(this));
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._browserResizeHandler) {
            this._browserResizeHandler();
            this._browserResizeHandler = null;
          }
          this._topMenuContainer = null;
          this._toolBarContainer = null;
          this._bottomToolBarContainer = null;
          this._startMenuContainer = null;
          if (this._unBindLayoutHandler) {
            this._unBindLayoutHandler();
            this._unBindLayoutHandler = null;
          }
          this._chromeBarContainer = null;
          if (this._chromeBar) {
            this._chromeBar.destroy();
            this._chromeBar = null;
          }
          this._topMenus.length = 0;
          this._toolBarWidgets = null;
          this._errorMessageWidget.destroy();
          this._errorMessageWidget = null;
          this._vmFocusedWidget = null;
          $super.destroy.call(this);
          this._startMenuWidget = null;
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.UserInterfaceLayoutEngine(this);
          this._unBindLayoutHandler = this._layoutEngine.onLayoutApplied(this._onLayoutApplied.bind(this));
        },

        _onLayoutApplied: function() {
          if (this.getContainerElement().children.length > 1) {
            for (const current of this.getChildren()) {
              if (this._canBeRemoved(current)) {
                current.getElement().remove();
              }
            }
          }

          if (this._unBindLayoutHandler) {
            this._unBindLayoutHandler();
            this._unBindLayoutHandler = null;
          }
        },

        /**
         * Defines if the string length is in character or byte
         * @param {boolean} charLengthSemantics true if we count the number of char
         * @publicdoc
         */
        setCharLengthSemantics: function(charLengthSemantics) {
          this._charLengthSemantics = charLengthSemantics;
        },

        /**
         * @return {boolean} true if we count the number of char
         */
        isCharLengthSemantics: function() {
          return this._charLengthSemantics;
        },

        _canBeRemoved: function(widget) {
          const currentWindowWidget = context.HostService.getCurrentWindowWidget();
          return widget instanceof cls.WindowWidget && (currentWindowWidget && widget !== currentWindowWidget) && !widget._forceVisible;
        },

        getMessageWidget: function() {
          return this._errorMessageWidget;
        },

        /**
         * Get the chromebar widget if any
         * @return {*|null}
         */
        getChromeBarWidget: function() {
          return this._chromeBar;
        },

        /**
         *
         * @param {classes.TopMenuWidget} topMenu
         * @param order
         */
        addTopMenu: function(topMenu, order) {
          topMenu.setOrder(order);
          if (topMenu.getParentWidget() === null) {
            this.addChildWidget(topMenu, {
              noDOMInsert: true
            });
          }
          topMenu.setGlobal(order === 1); // Order 1 is global tm
          this._topMenus.push(topMenu);
          topMenu.getElement().insertAt(order, this._topMenuContainer);
        },
        /**
         * Define where top menu is rendered: 'classic' or 'sidebar' according to device
         * @param {String} desktop - desktop rendering (default to "classic")
         * @param {String} mobile - mobile rendering (default to "sidebar")
         */
        setTopmenuRendering: function(desktop = "classic", mobile = "sidebar") {
          const inSideBar = (window.isMobile() && mobile === "sidebar") || (!window.isMobile() && desktop === "sidebar");
          if (inSideBar) {
            this._topMenus.forEach((tm) => {
              tm.setRenderInSideBar();
            });
          }
        },

        /**
         * Add the chromebar to the dom
         */
        addChromeBar: function() {
          if (this._chromeBar) {
            this.addChildWidget(this._chromeBar, {
              noDOMInsert: true
            });
            this._chromeBarContainer.appendChild(this._chromeBar.getElement());
          }
        },

        addStartMenu: function(widget) {
          this._startMenuWidget = widget;
          this._startMenuContainer.appendChild(widget.getElement());
        },

        getStartMenuWidget: function() {
          return this._startMenuWidget;
        },

        /**
         * Add a global toolbar
         * @param toolBar
         * @param order
         */
        addToolBar: function(toolBar, order) {
          toolBar.setOrder(order);
          if (toolBar.getParentWidget() === null) {
            this.addChildWidget(toolBar, {
              noDOMInsert: true
            });
          }
          this._toolBarWidgets.push(toolBar);
          this._toolBarContainer.prependChild(toolBar.getElement());

        },

        removeToolBar: function(toolBar) {
          this._toolBarWidgets = this._toolBarWidgets.filter(item => item !== toolBar);
        },

        /**
         * Set the Global Toolbar position
         * @param {String} position - "top", "bottom", "none", or nothing to refresh toolbar positions
         */
        setToolBarPosition: function(position) {
          if (position) {
            this._toolBarPosition = position;
          }

          this._toolBarWidgets.forEach(toolBar => {
            let position = this._toolBarPosition;
            if (toolBar.getPosition() && toolBar.getPosition() !== "default") {
              position = toolBar.getPosition();
            }

            switch (position) {
              case "top":
                toolBar.setHidden(false);
                this._toolBarContainer.prependChild(toolBar.getElement());
                break;
              case "bottom":
                toolBar.setHidden(false);
                this._bottomToolBarContainer.prependChild(toolBar.getElement());
                break;
              case "none":
                toolBar.setHidden(true);
                break;
            }
          });
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this.getElement().domFocus();
        },

        /**
         * Set focused widget
         * @param {classes.WidgetBase} widget - widget which gains focus
         */
        setFocusedWidget: function(widget) {
          this._vmPreviouslyFocusedWidget = this._vmFocusedWidget;
          if (this._vmFocusedWidget !== widget) {
            if (this._vmFocusedWidget && !this._vmFocusedWidget.isDestroyed()) {
              this._vmFocusedWidget.loseVMFocus(widget);
            }
          }

          //For buttonEdit after click on a completer the focus is on the InputWidget
          // and the _focusedWidget is a ButtonEditWidget
          //The auiTag on the input and the buttonEdit is the same
          if (this._vmFocusedWidget && this._vmFocusedWidget._auiTag !== widget._auiTag) {
            if (this._vmFocusedWidget.getElement()) {
              this._vmFocusedWidget.getElement().removeClass("gbc_Focus");
              this._vmFocusedWidget.loseFocus();
            }
          }

          if (!this._vmFocusedWidget || this._vmFocusedWidget._auiTag !== widget._auiTag) {
            this._vmFocusedWidget = widget;
            if (this._vmFocusedWidget.getElement()) {
              this._vmFocusedWidget.getElement().addClass("gbc_Focus");
            }
          }
        },

        /**
         * @returns {classes.WidgetBase} current focused widget (by VM)
         */
        getFocusedWidget: function() {
          return this._vmFocusedWidget;
        },

        /**
         * @returns {boolean} true if current focused widget changed (by VM)
         */
        hasFocusedWidgetChanged: function() {
          return this._vmFocusedWidget !== this._vmPreviouslyFocusedWidget;
        },

        /**
         * @param {string} text The window title
         */
        setText: function(text) {
          this._text = text;
        },
        /**
         * @returns {string} The window title
         */
        getText: function() {
          return this._text;
        },

        setImage: function(image) {
          this._image = image;
          this.emit(context.constants.widgetEvents.iconChanged, image);
        },

        getImage: function() {
          return this._image;
        },

        getDbDateFormat: function() {
          return this._dbDate;
        },

        setDbDateFormat: function(format) {
          this._dbDate = format;
        },

        getTraditionalWindowContainer: function() {
          if (!this._traditionalWindowContainer) {
            this._traditionalWindowContainer = cls.WidgetFactory.createWidget("TraditionalWindowContainer", this
              .getBuildParameters());
          }
          return this._traditionalWindowContainer;
        },

        removeTraditionalWindowContainer: function() {
          if (this._traditionalWindowContainer) {
            this.removeChildWidget(this._traditionalWindowContainer);
            this._traditionalWindowContainer = null;
          }
        },
        isLayoutTerminator: function() {
          return true;
        },
        activate: function(win) {
          this.emit(context.constants.widgetEvents.activate, win);
        },

        onActivate: function(hook) {
          return this.when(context.constants.widgetEvents.activate, hook);
        },
        onDisable: function(hook) {
          return this.when(context.constants.widgetEvents.disable, hook);
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          this.setStyle('> .gbc_barsContainer', {
            "background-color": color && !this._ignoreBackgroundColor ? color : null
          });
        },

        /**
         * Show/hide filter item in chromebar
         * @param {boolean} visible - true if item must be visible
         * @param {String} [filterValue] - initial filter value
         */
        showChromeBarFilterMenuItem: function(visible, filterValue) {
          if (this._chromeBar) {
            this._chromeBar.showFilterMenuItem(visible, filterValue);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('UserInterface', cls.UserInterfaceWidget);
  });
;

"use strict";

modulum('VBoxSplitterWidget', ['SplitterWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Splitter widget.
     * @class VBoxSplitterWidget
     * @memberOf classes
     * @extends classes.SplitterWidget
     */
    cls.VBoxSplitterWidget = context.oo.Class(cls.SplitterWidget, function($super) {
      return /** @lends classes.VBoxSplitterWidget.prototype */ {
        __name: "VBoxSplitterWidget",
        __templateName: "SplitterWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_SplitterWidget");
        },
        _initLayout: function() {
          $super._initLayout.call(this);
          this._layoutInformation.setMaximal(cls.Size.maximal, 8);
        },
        _onDragOver: function(evt) {
          $super._onDragOver.call(this, evt);
          this._pagePosition = evt.pageY;
        },
        _updateResizerDrag: function(evt) {
          this._pagePosition = evt.pageY;
          this._resizerDragPosition = evt.pageY;
        },

        // Touch only
        _onTouchStart: function(evt) {
          this._splitStartPos = evt.touches[0].clientY;
          $super._onTouchStart.call(this, evt);
        },

        _onTouchMove: function(evt) {
          this._pagePosition = evt.touches[0].clientY;
          $super._onTouchMove.call(this, evt);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('VBoxSplitter', cls.VBoxSplitterWidget);
  });
;

"use strict";

modulum('VBoxWidget', ['BoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * VBox widget
     * @publicdoc Widgets
     * @class VBoxWidget
     * @memberOf classes
     * @extends classes.BoxWidget
     */
    cls.VBoxWidget = context.oo.Class(cls.BoxWidget, function($super) {
      return /** @lends classes.VBoxWidget.prototype */ {
        __name: "VBoxWidget",
        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._orientation = "vertical";
          $super.constructor.call(this, opts);
          this._element.addClass("g_VBoxLayoutEngine");
        },
        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.HVBoxLayoutEngine(this);
          this._layoutEngine.setOrientation(this._orientation);
        },

      };
    });
    cls.WidgetFactory.registerBuilder('VBox', cls.VBoxWidget);
    cls.WidgetFactory.registerBuilder('HBox[customWidget=vbox]', cls.VBoxWidget);
  });
;

"use strict";

modulum('WindowWidget', ['WidgetGroupBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for widgets.
     * @class WindowWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     * @publicdoc
     */
    cls.WindowWidget = context.oo.Class(cls.WidgetGroupBase, function($super) {
      return /** @lends classes.WindowWidget.prototype */ {
        __name: "WindowWidget",
        /**
         * @type {classes.ModalWidget}
         */
        _modalWidget: null,
        /**
         * title
         * @type {?string}
         */
        _text: null,
        /**
         * window icon
         * @type {?string}
         */
        _image: null,
        _topMenus: null,
        /** @type {classes.TopMenuWidget} */
        _activeTopMenuWidget: null,
        /** @type {classes.MenuWidget} */
        _menuWidget: null,
        /** @type {classes.TabbedContainerWidget} */
        _tabbedContainerWidget: null,

        /**
         * List of toolbar widgets
         * @type {Array}
         */
        _toolBarWidgets: null,
        _closeHostMenuOnClickHandler: null,
        _menuContainerTop: null,
        _menuContainerBottom: null,
        _menuContainerLeft: null,
        _menuContainerRight: null,
        _menuContainerMiddle: null,
        _toolBarContainer: null,
        _topMenuContainer: null,
        _windowContent: null,
        _toolBarPosition: "top",
        _toolBarInWindow: false, // define if the toolbar is directly in the window or if it is in the global toolbar
        _startMenuType: null,
        _actionsEnabled: false,
        _disabled: false,
        _position: null,
        _positionClass: "gbc_WindowWidget_position_default",
        _processing: false,
        _messageWidget: null,

        /** @type {Boolean} **/
        _isClosable: true,

        /**
         * @type {boolean}
         */
        isModal: false,

        /**
         * @type {classes.ChromeBarWidget}
         */
        _chromeBar: null,

        /** @type {boolean}  */
        _forceDefaultSettings: false,

        /**
         * @constructs
         * @param {Object} opts - Options passed to the constructor
         * @publicdoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._menuContainerTop = this._element.getElementsByClassName("gbc_WindowMenuContainerTop")[0];

          this._menuContainerBottom = this._element.getElementsByClassName("gbc_WindowMenuContainerBottom")[0];
          this._menuContainerLeft = this._element.getElementsByClassName("gbc_WindowMenuContainerLeft")[0];
          this._menuContainerRight = this._element.getElementsByClassName("gbc_WindowMenuContainerRight")[0];
          this._menuContainerMiddle = this._element.getElementsByClassName("gbc_WindowMenuContainerMiddle")[0];

          this._toolBarContainer = this._element.getElementsByClassName("gbc_WindowToolBarContainer")[0];
          this._bottomToolBarContainer = this._element.getElementsByClassName("gbc_WindowBottomToolBarContainer")[0];

          this._topMenuContainer = this._element.getElementsByClassName("gbc_WindowTopMenuContainer")[0];
          this._windowContent = this._element.getElementsByClassName("gbc_WindowContent")[0];

          this._messageWidget = cls.WidgetFactory.createWidget("Message", this.getBuildParameters());
          this._messageWidget.setHidden(true);

          this._topMenus = [];

          this._toolBarWidgets = [];
          this._chromeBar = opts.chromeBar;
          this.setClosable(false); //default
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._position = null;
          if (context.HostService.getCurrentWindowWidget() === this) {
            context.HostService.unsetCurrentWindowNode();
          }
          if (this.getParentWidget() && this.getParentWidget()._activeWindow === this) {
            this.getParentWidget()._activeWindow = null;
          }
          if (this._modalWidget) {
            this._modalWidget.hide();
            this._modalWidget.destroy();
            this._modalWidget = null;
          }

          this._menuContainerTop = null;
          this._menuContainerBottom = null;
          this._menuContainerLeft = null;
          this._menuContainerRight = null;
          this._menuContainerMiddle = null;
          this._toolBarContainer = null;
          this._topMenuContainer = null;
          this._windowContent = null;
          this._messageWidget.destroy();
          this._messageWidget = null;
          this._topMenus.length = 0;
          this._activeTopMenuWidget = null;
          this._menuWidget = null;
          this._toolBarWidgets = null;

          if (this._tabbedContainerWidget) {
            this.removeChildWidget(this._tabbedContainerWidget);
            this._tabbedContainerWidget = null;
          }

          $super.destroy.call(this);

          gbc.InitService.emit(gbc.constants.widgetEvents.onBeforeUnload); // Store stored settings before leaving
        },

        /**
         * emit window close event
         */
        _emitClose: function() {
          if (!this._processing) {
            this.emit(context.constants.widgetEvents.close);
          }
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          if (this._chromeBar) {
            this._chromeBar.setDefaultTTFColor(color);
          }
        },

        /**
         * set the window title
         * @param {string} text window title
         * @publicdoc
         */
        setText: function(text) {
          this._text = text;
          if (this._modalWidget) {
            this._modalWidget.setHeader(text);
          }
        },

        /**
         * get the window title
         * @publicdoc
         * @returns {string} window title
         */
        getText: function() {
          return this._text;
        },

        /**
         * set the window icon
         * @publicdoc
         * @param {string} image the image to set
         */
        setImage: function(image) {
          this._image = image;
          if (this._modalWidget) {
            this._modalWidget.setImage(image);
          }
          this.emit(context.constants.widgetEvents.iconChanged, image);
        },

        /**
         * get the window icon
         * @publicdoc
         * @return {?string} the icon
         */
        getImage: function() {
          return this._image;
        },

        /**
         * get the window's message widget
         * @publicdoc
         * @return {classes.MessageWidget} the window's message widget
         */
        getMessageWidget: function() {
          return this._messageWidget;
        },

        /**
         * enable window contents
         */
        unfreeze: function() {
          this._disabled = false;
          this.enableActions();
          if (this._modalWidget) {
            this._modalWidget._element.removeClass("hidden");
          }
          this.emit(gbc.constants.widgetEvents.unfrozen);
        },
        /**
         * disable window contents
         */
        freeze: function(isNewWindowModal) {
          this._disabled = !isNewWindowModal;
          this.disableActions();
          if (this._modalWidget) {
            this._modalWidget._element.addClass("hidden");
          }
          this.emit(gbc.constants.widgetEvents.frozen);
        },

        /**
         *
         * @param hidden {boolean} true if the widget is hidden, false otherwise
         */
        setHidden: function(hidden) {
          if (this._modalWidget) {
            this._modalWidget.hide();
          }
          if (this._activeTopMenuWidget) {
            this._activeTopMenuWidget.setHidden(hidden);
          }
          if (this._toolBarWidgets?.length > 0) {
            this._toolBarWidgets.forEach(toolBar => {
              toolBar.setHidden(hidden || this._toolBarPosition === "none");
            });
          }
          this.getLayoutEngine().changeHidden(hidden);
        },

        /**
         * Defines the menu to be displayed as a modal one
         * @param {Object?} opt - options to pass to the new modal
         * @private
         */
        setAsModal: function(opt) {
          if (!this._modalWidget) {
            const buildParameters = this.getBuildParameters();
            buildParameters.storedSettingsKey = opt.storedSettingsKey;
            this._modalWidget = cls.WidgetFactory.createWidget("Modal", buildParameters);
            this._modalWidget.setReverse(this.isReversed());
            this._modalWidget.addClass('gbc_ModalWindowDialog');
            this._modalWidget.addClass('g_needLayout');
            this.getParentWidget().getContainerElement().appendChild(this._modalWidget.getElement());
            this._modalWidget.when(gbc.constants.widgetEvents.close, this._emitClose.bind(this));
            this._modalWidget.setClosable(false);
          }
          this._modalWidget.setHeader(this.getText());
          this._modalWidget.setImage(this.getImage());
          this._modalWidget.setContent(this.getElement());
          this._modalWidget.setBackgroundColor(this._backgroundColor);
          this.isModal = true;

          this._modalWidget.show();
          return this._modalWidget;
        },

        /**
         *
         * @return {classes.ModalWidget}
         */
        getModal: function() {
          return this._modalWidget;
        },
        /**
         * Right window menu container
         * @return {Element}
         */
        getWindowMenuContainerRight: function() {
          return this._menuContainerRight;
        },
        /**
         * Main window container which holds menus + forms
         * @return {Element}
         */
        getWindowMiddleContainer: function() {
          return this._menuContainerMiddle;
        },
        /**
         * Main window container which holds forms
         * @return {Element}
         */
        getWindowContentContainer: function() {
          return this._windowContent;
        },
        /**
         *
         * @private
         * @param rtl
         */
        setReverse: function(rtl) {
          $super.setReverse.call(this, rtl);
          if (this._modalWidget) {
            this._modalWidget.setReverse(rtl);
          }
        },

        /**
         * Set position of the window based on position 4ST attribute.
         * At the moment, only a modal window will be affected by this attribute, a normal window is always displayed full screen.
         * For the modal window, by default it's centered. If 4ST is set to 'field', pos parameter is referent widget.
         * @private
         * @param pos {string|classes.WidgetBase}
         */
        setPosition: function(pos) {
          const isPosString = typeof(pos) === "string";
          const isPosField = pos && pos.isInstanceOf && pos.isInstanceOf(cls.WidgetBase);
          this._element.removeClass(this._positionClass);
          this._positionClass = "gbc_WindowWidget_position_" + (isPosString ? pos : "center");
          this._element.addClass(this._positionClass);
          // setting position to field without having windowType to modal makes no sense,
          // it's considered as modal by GDC but not by HTMLv1.
          if (isPosField && this._modalWidget) {
            const rect = pos.getElement().getBoundingClientRect(),
              appRect = pos.getApplicationWidget().getElement().getBoundingClientRect(),
              chromeBar = pos.getApplicationWidget().getUserInterfaceWidget().getChromeBarWidget(),
              chromeBarRect = chromeBar && chromeBar.getElement()
              .getBoundingClientRect(); // Taking care of chromebar height in placement if any

            this._modalWidget.setPosition(
              this.isReversed() ? appRect.right - rect.right : rect.left - appRect.left,
              rect.top + rect.height - appRect.top - (chromeBarRect ? chromeBarRect.height : 0)
            );
          }
        },

        /**
         * @inheritDoc
         */
        setNoBorder: function(noBorder) {
          $super.setNoBorder.call(this, noBorder);
          if (this._modalWidget) {
            this._modalWidget.setHeaderHidden(noBorder);
          }
        },

        /**
         * @returns {boolean} true if the widget is hidden, false otherwise
         */
        isHidden: function() {
          return !this._element;
        },
        /**
         * @private
         * @param hook
         */
        onClose: function(hook) {
          this.when(gbc.constants.widgetEvents.close, hook);
        },
        /**
         * @private
         * @param closable
         */
        setClosable: function(closable) {
          this._isClosable = closable;
          if (this.isModal && this._modalWidget) {
            this._modalWidget.setClosable(Boolean(closable));
            context.HostService.setClosableWindowActionActive(this, false);
          } else {
            context.HostService.setClosableWindowActionActive(this, closable);
            if (this._chromeBar && this._chromeBar._closeMenuItem) {
              this._chromeBar._closeMenuItem.setHidden(!closable);
            }
          }
        },

        /**
         * Is window closable?
         * @return {Boolean}
         */
        isClosable: function() {
          return this._isClosable;
        },

        /**
         * Enable actions of the window
         */
        enableActions: function() {
          context.HostService.setClosableWindowActionHidden(this, false);
          this._actionsEnabled = true;
        },

        /**
         * Disable actions of the window
         */
        disableActions: function() {
          context.HostService.setClosableWindowActionHidden(this, true);
          this._actionsEnabled = false;
        },

        /**
         *
         * @private
         * @param path
         */
        setBackgroundImage: function(path) {
          if (path) {
            this.setStyle({
              "background-image": "url('" + path + "')"
            });
          } else {
            this.setStyle({
              "background-image": null
            });
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          if (this._modalWidget) {
            this._modalWidget.setBackgroundColor(color);
          }
        },

        /**
         * @param {classes.TabbedContainerWidget} tabbedContainer
         */
        addTabbedContainer: function(tabbedContainer) {
          this._tabbedContainerWidget = tabbedContainer;
          this.addChildWidget(tabbedContainer);
        },

        /**
         * @private
         * @param {classes.TopMenuWidget} topMenu
         * @param order
         * @param topMenuContainer
         */
        addTopMenu: function(topMenu, order, topMenuContainer) {
          this.addChildWidget(topMenu, {
            noDOMInsert: true
          });
          if (this._activeTopMenuWidget) {
            this._activeTopMenuWidget.setHidden(true);
          }
          this._topMenus.push(topMenu);
          this._activeTopMenuWidget = topMenu;
          if (topMenuContainer !== this) {
            topMenuContainer.addTopMenu(this._activeTopMenuWidget, order);
          } else {
            this._topMenuContainer.appendChild(this._activeTopMenuWidget.getElement());
          }
          this._activeTopMenuWidget.setHidden(false);
        },

        /**
         *
         * @private
         * @param topMenu
         */
        removeTopMenu: function(topMenu) {
          this._topMenus.remove(topMenu);
          if (this._activeTopMenuWidget === topMenu) {
            this._activeTopMenuWidget.setHidden(true);
            this._activeTopMenuWidget = this._topMenus.length ? this._topMenus[this._topMenus.length - 1] : null;
            if (this._activeTopMenuWidget) {
              this._activeTopMenuWidget.setHidden(false);
            }

          }
        },

        /**
         *
         * @private
         * @param container
         * @return {null}
         */
        getMenuContainer: function(container) {
          switch (container) {
            case "top":
              return this._menuContainerTop;
            case "bottom":
              return this._menuContainerBottom;
            case "left":
              return this._menuContainerLeft;
            case "right":
              return this._menuContainerRight;
            default:
              return null;
          }
        },

        /**
         * Add a toolbar to the window
         * @private
         * @param toolBar
         * @param order
         */
        addToolBar: function(toolBar, order) {
          toolBar.setOrder(order);
          this.addChildWidget(toolBar, {
            noDOMInsert: true
          });
          this._toolBarWidgets.push(toolBar);
          this._toolBarContainer.prependChild(toolBar.getElement());
        },

        /**
         *
         * @return {null}
         */
        getMenuContainers: function() {
          return {
            top: this._menuContainerTop,
            bottom: this._menuContainerBottom,
            left: this._menuContainerLeft,
            right: this._menuContainerRight
          };
        },

        /**
         * @param toolBar
         */
        removeToolBar: function(toolBar) {
          this._toolBarWidgets = this._toolBarWidgets.filter(item => item !== toolBar);
        },

        /**
         * Add a menu to the window
         * @private
         * @param widget
         */
        addMenu: function(widget) {
          this._menuWidget = widget;
          this.addChildWidget(widget, {
            noDOMInsert: true
          });
        },

        /**
         * Get window menu widget
         */
        getMenuWidget: function() {
          return this._menuWidget;
        },

        /**
         * Set the Window Toolbar position
         * @param {String} position - "top", "bottom", "none", or nothing to refresh toolbar positions
         */
        setToolBarPosition: function(position) {
          if (position) {
            this._toolBarPosition = position;
            // Mirror the setting to the user interface
            this.getUserInterfaceWidget().setToolBarPosition(position);
          }

          this._toolBarWidgets.forEach(toolBar => {
            let position = this._toolBarPosition;
            if (toolBar.getPosition() && toolBar.getPosition() !== "default") {
              position = toolBar.getPosition();
            }
            toolBar.setHidden(false);

            switch (position) {
              case "top":
                this._toolBarContainer.prependChild(toolBar.getElement());
                break;
              case "bottom":
                this._bottomToolBarContainer.prependChild(toolBar.getElement());
                break;
              case "none":
                toolBar.setHidden(true);
                break;
            }
          });
        },

        /**
         * Get the Window Toolbar position
         * @return {String} could be "top", "bottom", "none" or "chrome"
         */
        getToolBarPosition: function() {
          return this._toolBarPosition;
        },

        /**
         * Define where top menu is rendered: 'classic' or 'sidebar' according to device
         * @param {String} desktop - desktop rendering (default to "classic")
         * @param {String} mobile - mobile rendering (default to "sidebar")
         */
        setTopmenuRendering: function(desktop = "classic", mobile = "sidebar") {
          const inSideBar = (window.isMobile() && mobile === "sidebar") || (!window.isMobile() && desktop === "sidebar");
          if (inSideBar) {
            this._topMenus.forEach((tm) => {
              tm.setRenderInSideBar();
            });
          }
        },

        /**
         * @private
         * @param type
         */
        setStartMenuType: function(type) {
          this._startMenuType = type;
        },

        /**
         * @private
         */
        getStartMenuType: function() {
          return this._startMenuType;
        },

        /**
         *
         * @param processing
         * @private
         */
        _setProcessingStyle: function(processing) {
          this._processing = processing;
          context.HostService.setClosableWindowActionProcessing(this, processing);
        },

        /**
         * Ignore stored Settings (for position and size)
         * @param {Boolean} forceDefaultSettings
         */
        setForceDefaultSettings: function(forceDefaultSettings) {
          this._forceDefaultSettings = forceDefaultSettings;
          if (this._modalWidget) {
            this._modalWidget.setForceDefaultSettings(forceDefaultSettings);
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Window', cls.WindowWidget);
  });
;

"use strict";

modulum('DummyButtonEditWidget', ['ButtonEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ButtonEdit widget.
     * @class DummyButtonEditWidget
     * @memberOf classes
     * @extends classes.ButtonEditWidget
     */
    cls.DummyButtonEditWidget = context.oo.Class(cls.ButtonEditWidget, function($super) {
      return /** @lends classes.DummyButtonEditWidget.prototype */ {
        __name: "DummyButtonEditWidget",
        __templateName: "ButtonEditWidget",

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          // do nothing, no maxlength in Dummy widget
        },

        /**
         * @param {boolean} isPassword true if the widget should be in 'password' mode, false otherwise
         */
        setIsPassword: function(isPassword) {

        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this._edit.setTextAlign(this.getStart());
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyButtonEdit', cls.DummyButtonEditWidget);
  });
;

"use strict";

modulum('DummyDateEditWidget', ['DateEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DummyDateEdit widget.
     * @class DummyDateEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidget
     */
    cls.DummyDateEditWidget = context.oo.Class(cls.DateEditWidget, function($super) {
      return /** @lends classes.DummyDateEditWidget.prototype */ {
        __name: "DummyDateEditWidget",
        __templateName: "DateEditWidget",
        _unboundField: null,

        _initElement: function(datetime) {
          $super._initElement.call(this, datetime);
          this._unboundField = document.createElement("div");
        },

        destroy: function() {
          $super.destroy.call(this);
          this._unboundField = null;
        },

        _onIconClick: function(event) {
          this._dropDown.getElement().appendChild(this._picker.el);
          $super._onIconClick.call(this, event);
        },

        _getPickerConf: function() {
          const pickerConf = $super._getPickerConf.call(this);
          pickerConf.field = this._unboundField;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // manually set date to unbound input field on dropdown opening
          if (this._dropDown.isVisible()) {
            const formattedDate = this.getDate();
            if (formattedDate !== this.getValue()) {
              this._inputElement.value = formattedDate;
            }
          }
        },

        // -- Calendar type specific functions --

        _onDateSelect: function(date) {
          this.setValue(context.dayjs(date).format(this._displayFormat));
          $super._onDateSelect.call(this, date);
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DummyDateEdit', cls.DummyDateEditWidget);
  });
;

"use strict";

modulum('DummyDateTimeEditWidget', ['DateTimeEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DummyDateTimeEdit widget.
     * @class DummyDateTimeEditWidget
     * @memberOf classes
     * @extends classes.DateTimeEditWidget
     */
    cls.DummyDateTimeEditWidget = context.oo.Class(cls.DateTimeEditWidget, function($super) {
      return /** @lends classes.DummyDateTimeEditWidget.prototype */ {
        __name: "DummyDateTimeEditWidget",
        __templateName: "DateTimeEditWidget",
        _unboundField: null,

        _initElement: function(datetime) {
          $super._initElement.call(this, datetime);
          this._displayFormat = "YYYY-MM-DD HH:mm:ss";
          this._unboundField = document.createElement("div");
        },

        destroy: function() {
          $super.destroy.call(this);
          this._unboundField = null;
        },

        _onIconClick: function(event) {
          this._dropDown.getElement().appendChild(this._picker.el);
          $super._onIconClick.call(this, event);
        },

        _getPickerConf: function() {
          const pickerConf = $super._getPickerConf.call(this);
          pickerConf.field = this._unboundField;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // manually set date to unbound input field on dropdown opening
          if (this._dropDown.isVisible()) {
            const formattedDate = this.getDate();
            if (formattedDate !== this.getValue()) {
              this._inputElement.value = formattedDate;
            }
          }
        },

        // -- Calendar type specific functions --

        _onDateSelect: function(date) {
          this.setValue(context.dayjs(date).format(this._displayFormat));
          $super._onDateSelect.call(this, date);
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyDateTimeEdit', cls.DummyDateTimeEditWidget);
  });
;

"use strict";

modulum('DummyEditWidget', ['EditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Edit widget.
     * @class DummyEditWidget
     * @memberOf classes
     * @extends classes.EditWidget
     */
    cls.DummyEditWidget = context.oo.Class(cls.EditWidget, function($super) {
      return /** @lends classes.DummyEditWidget.prototype */ {
        __name: "DummyEditWidget",
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        _initElement: function() {
          $super._initElement.call(this);
          this._element.addClass("gbc_EditWidget");
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {

        },

        /**
         * @inheritDoc
         */
        isReadOnly: function() {
          return Boolean(this._element.getAttribute("readonly"));
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          // do nothing, no maxlength in Dummy widget
        },

        /**
         * @param {boolean} isPassword true if the widget should be in 'password' mode, false otherwise
         */
        setIsPassword: function(isPassword) {
          $super.setIsPassword.call(this, this._enabled ? false : isPassword);
        },

        /**
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         */
        isPassword: function() {
          return this._element.getAttribute("type") === "password";
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType the type attribute value to set
         */
        setType: function(valType) {},

        /**
         * @inheritDoc
         */
        setInputMode: function(valType) {},

        /**
         * @returns {string} this Edit current type
         */
        getType: function() {
          return this._element.getAttribute("type");
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format - display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * Get the display format if any
         * @return {?string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyEdit', cls.DummyEditWidget);
  });
;

"use strict";

modulum('DummyRadioGroupWidget', ['RadioGroupWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RadioGroup widget.
     * @class DummyRadioGroupWidget
     * @memberOf classes
     * @extends classes.RadioGroupWidget
     */
    cls.DummyRadioGroupWidget = context.oo.Class(cls.RadioGroupWidget, function($super) {
      return /** @lends classes.DummyRadioGroupWidget.prototype */ {
        __name: "DummyRadioGroupWidget",
        __templateName: "RadioGroupWidget",

        /**
         * @inheritDoc
         */
        getValue: function() {
          let value = "";
          const children = this._element.childrenExcept(this.__charMeasurer);
          for (const item of children) {
            if (item.getElementsByClassName("zmdi")[0].hasClass('checked')) {
              if (value.length !== 0) {
                value += '|';
              }
              value += item.getAttribute('data-value');
            }
          }
          return value;
        },

        /**
         * @inheritDoc
         */
        _setValue: function(value) {
          const values = ("" + value).split('|'),
            children = this._element.childrenExcept(this.__charMeasurer);
          for (const item of children) {
            const checkedElement = item.getElementsByClassName('zmdi')[0];
            // Reset radio checked
            if (values.indexOf(item.getAttribute("data-value")) !== -1) {
              checkedElement.addClass('checked');
              checkedElement.removeClass("unchecked");
            } else {
              checkedElement.addClass('unchecked');
              checkedElement.removeClass("checked");
            }
          }
          this.setEditing(this.getValue() !== this._oldValue);
        },

        /**
         * @param {number} index the value to display
         * @param {boolean} doSetValue
         * @private
         */
        _prepareValue: function(index, doSetValue) {
          let newValue = this.getValue();
          if (this.isEnabled()) {
            this._updateVisualAim();
            const children = this._element.childrenExcept(this.__charMeasurer);
            if (doSetValue) {
              const item = children[index].getElementsByClassName('zmdi')[0];
              item.toggleClass('checked', !item.hasClass('checked'));
              newValue = this.getValue();
              this.setEditing(newValue !== this._oldValue);
            }
          }
          return newValue;
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyRadioGroup', cls.DummyRadioGroupWidget);
  });
;

"use strict";

modulum('DummySpinEditWidget', ['SpinEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget.
     * @class DummySpinEditWidget
     * @memberOf classes
     * @extends classes.SpinEditWidget
     */
    cls.DummySpinEditWidget = context.oo.Class(cls.SpinEditWidget, function($super) {
      return /** @lends classes.DummySpinEditWidget.prototype */ {
        __name: "DummySpinEditWidget",
        __templateName: "SpinEditWidget",

        /**
         * @inheritDoc
         */
        _processKey: function(event, keyString) {

        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          const value = parseInt(this._inputElement.value, 10);
          const isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : this._inputElement.value;
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        },

      };
    });
    cls.WidgetFactory.registerBuilder('DummySpinEdit', cls.DummySpinEditWidget);
  });
;

"use strict";

modulum('DummyTextEditWidget', ['TextEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class DummyTextEditWidget
     * @memberOf classes
     * @extends classes.TextEditWidget
     */
    cls.DummyTextEditWidget = context.oo.Class(cls.TextEditWidget, function($super) {
      return /** @lends classes.DummyTextEditWidget.prototype */ {
        __name: "DummyTextEditWidget",
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        setHtmlControl: function(jcontrol) {
          jcontrol.innerHTML = this.getValue();
          this._inputElement.replaceWith(jcontrol);
          this._hasHTMLContent = true;
          this._inputElement = jcontrol;
        },

        /**
         * @inheritDoc
         */
        _setValue: function(value, fromVM) {
          this._inputElement.value = value;
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          // do nothing, no maxlength in Dummy widget
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle({
            "text-align": this.getStart()
          });
        }
      };
    });
    cls.WidgetFactory.registerBuilder('DummyTextEdit', cls.DummyTextEditWidget);
  });
;

"use strict";

modulum('DummyTimeEditWidget', ['TimeEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget.
     * @class DummyTimeEditWidget
     * @memberOf classes
     * @extends classes.TimeEditWidget
     */
    cls.DummyTimeEditWidget = context.oo.Class(cls.TimeEditWidget, function($super) {
      return /** @lends classes.DummyTimeEditWidget.prototype */ {
        __name: "DummyTimeEditWidget",
        __templateName: "TimeEditWidget",

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {
            switch (keyString) {
              case ":":
              case "shift+:":
              case "backspace":
              case "del":
              case "delete":
                break;
              default:
                keyProcessed = $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
            }
          }
          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        _processKey: function(event, keyString) {
          return false;
        },

        /**
         * All input widgets in constructs are left aligned (because of search criteria)
         */
        setTextAlign: function(align) {
          this.setStyle("input", {
            "text-align": this.getStart()
          });
        },
        _onClick: function(event) {
          this._onRequestFocus(event); // request focus
        },

        /**
         * Sets cursor positions
         * @param {number} cursor - start cursor position
         * @param {number} cursor2 - end cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }
          this._currentCursors.start = cursor;
          this._currentCursors.end = cursor2;

          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          const cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DummyTimeEdit', cls.DummyTimeEditWidget);
  });
;

"use strict";

modulum('BarcodeScannerWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class BarcodeScannerWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.BarcodeScannerWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.BarcodeScannerWidget.prototype */ {
        __name: "BarcodeScannerWidget",
        __templateName: "ModalWidget",

        _videoDom: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._element.addClass("gbc_ModalWidget");
          const dialogContents = document.createElement("div");
          const headerTitleDom = document.createElement('span');
          headerTitleDom.innerHTML = "Barcode Scanner";

          this._videoDom = document.createElement('video');

          this._videoDom.autoplay = true;
          dialogContents.appendChild(this._videoDom);

          this.setHeader(headerTitleDom);
          this.setClosable(true);
          this.setContent(dialogContents);

          this.when(context.constants.widgetEvents.modalOut, function() {
            this.hide(false);
          }.bind(this));
          this.when(context.constants.widgetEvents.close, function() {
            this.hide(false);
          }.bind(this));
        },

        /**
         * Starts the video feed in the widget
         * @returns {Promise<void>}
         * @private
         */
        _startStream: async function() {
          this._videoDom.srcObject = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              width: {
                max: window.innerWidth * 0.9
              },
              height: {
                max: window.innerHeight * 0.9
              },
              focusMode: "continuous",
              facingMode: {
                ideal: "environment"
              },
            }
          });
          this._videoDom.onloadedmetadata = (e) => {
            this._videoDom.play();
          };

        },

        /**
         * Self-repeating function that extracts a shot from the video feed to detect a barcode
         * once per second until a barcode is detected or the feed is cut
         * @param onDetect result callback which expects data as a parameter
         * @returns {Promise<void>}
         */
        detectBarcode: async function(onDetect) {
          if (!("BarcodeDetector" in window)) {
            onDetect(null);
            return;
          }
          if (this._videoDom && this._videoDom.videoWidth && this._videoDom.videoHeight) {
            const barcodeDetector = new window.BarcodeDetector();
            try {
              barcodeDetector.detect(this._videoDom).then((barcodes) => {
                if (barcodes.length > 0) {
                  onDetect(barcodes[0]);
                } else {
                  this._registerTimeout(this.detectBarcode.bind(this, onDetect), 1000);
                }
              });
            } catch (e) {
              onDetect(null);
            }
          } else {
            this._registerTimeout(this.detectBarcode.bind(this, onDetect), 1000);
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._videoDom) {
            if (this._videoDom.srcObject) {
              this._videoDom.srcObject.getTracks()[0].stop();
              this._videoDom.srcObject = null;
            }
            this._videoDom = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        show: async function() {
          await this._startStream();
          $super.show.call(this);
          this.resizeHandler();
        },

        /**
         * hides the dialog
         * @inheritDoc
         */
        hide: function() {
          if (this._videoDom) {
            this._videoDom.srcObject.getTracks()[0].stop();
            this._videoDom.srcObject = null;
            this._videoDom = null;
          }
          this._resetAsMoved();
          $super.hide.call(this);
        },
      };
    });
    cls.WidgetFactory.registerBuilder('BarcodeScanner', cls.BarcodeScannerWidget);
  });
;

'use strict';

modulum('DateEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget Base class.
     * @class DateEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.DateEditWidgetBase.prototype */ {
        __name: 'DateEditWidgetBase',

        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Format used to display dates of the calendar
         * @type {?string}
         */
        _displayFormat: null,

        /**
         * Get list of sorted days depending on first day of the week which is defined
         * @type {Array}
         */
        _sortedDays: null,

        /**
         * Callback function used to disable days of calendar (framework api)
         * @type {function}
         */
        _disableDayFn: null,

        /**
         * Chinese format for date
         * @type {boolean}
         */
        _useMingGuoYears: false,

        /**
         * Current date dayjs object of the widget
         * @type {Object}
         */
        _dateObj: null,

        /**
         * Last valid date
         * @type {?string}
         */
        _validValue: null,

        /**
         * Indicates if current date of the calendar has been validated by user
         * @type {boolean}
         */
        _mustValid: false,
        /**
         * To detect if we selected a date using keyboard or mouse
         * @type {boolean}
         */
        _keyPressed: false,
        /**
         * Save last clicked date value. Needed to detect double click
         * @type {?string}
         */
        _lastClickValue: null,
        /**
         * Picker icon used to display/hide calendar
         * @type {HTMLElement}
         */
        _pikerIcon: null,

        /** @type {string|null} */
        _defaultTTFColor: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
            this._layoutInformation.setReservedDecorationSpace(2);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          if (this._displayFormat === null) {
            this._displayFormat = 'MM/DD/YYYY'; //default format
          }

          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._pikerIcon = this._element.getElementsByTagName('i')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._pikerIcon = null;
          if (this._inputElement) {
            this._inputElement.remove();
            this._inputElement = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this.getStyle('input', 'text-align');
        },

        /**
         * Reset input field with last valid date
         */
        setLastValidValue: function() {
          if (this._inputElement) {
            this._inputElement.value = this._validValue;
          }
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
            if (window.browserInfo.isIE || window.browserInfo.isEdge) {
              this._inputElement.removeAttribute('contentEditable');
            }
          } else {
            this._inputElement.removeAttribute('readonly');
            if (window.browserInfo.isIE || window.browserInfo.isEdge) {
              // need to add this to be sure that user can enter text in the field
              // even if setCursorPosition is called before
              this._inputElement.setAttribute('contentEditable', 'true');
            }
          }
        },

        /**
         * Get the current dateedit value
         * @returns {string} the displayed value
         */
        getValue: function() {
          return this._inputElement.value;
        },

        /**
         * @inheritDoc
         */
        setValue: function(dateString, fromVM) {
          $super.setValue.call(this, dateString, fromVM);
          this.setDate(dateString);
        },

        /**
         * Return the current Date object
         * @returns {Object} returns current dayjs date object
         * @publicdoc
         */
        getDate: function() {
          return this._dateObj && this._dateObj.isValid() ? this._dateObj.format(this._displayFormat) : "Invalid date";
        },

        /**
         * Generate dayjs date object from a string and set it for both the calendar component and the input field
         * @param {string} date - date value in string format
         * @publicdoc
         */
        setDate: function(date) {
          // created date object based on received value using known format (for datepicker)
          if (this._useMingGuoYears) { // Convert Ming Guo year to 4 digit years for datepicker
            const str = cls.DateTimeHelper.mingGuoToGregorianYears(date);
            this._dateObj = context.dayjs(str, this._displayFormat, true);
          } else {
            this._dateObj = context.dayjs(date, this._displayFormat, true);
          }

          // set non formatted value to input (already formatted by VM)
          if (this.getValue() !== date) {
            this._inputElement.value = date;
          }
        },

        /**
         * Set a specified format of date. Default is MM/DD/YYYY
         * @param {string} format - date format used to display and send date to the VM.
         * @publicdoc
         */
        setFormat: function(format) {
          const years = format && format.match(/Y/g);
          if (years && years.length === 3) { // Ming Guo format
            this._useMingGuoYears = true;
            format = format.replace('YYY', 'YYYY');
          }
          if (this._displayFormat !== format) {
            this._displayFormat = format;
          }
        },

        /**
         * Return date format
         * @returns {string} the date format
         * @publicdoc
         */
        getFormat: function() {
          return this._displayFormat;
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          const cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number=} cursor2 - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }
          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          $super.setMaxLength.call(this, maxLength);
          if (maxLength > 0) {
            this._setElementAttribute('maxlength', maxLength + 1, "_inputElement");
          }
        },

        /**
         * Set Default color (defined by DefaultTTF)
         * @param {string} color - rgb formatted or css name
         */
        setDefaultColor: function(color) {
          this._defaultTTFColor = color;

          this.setStyle(".zmdi", {
            'color': color
          });
        },

        /**
         * Defines a different image for the icon of the DateEdit
         * @param {string} icon - src of the image
         */
        setButtonIcon: function(icon) {
          if (icon) {
            const img = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
            const imgElem = img.getElement();

            if (this._defaultTTFColor) {
              img.setDefaultColor(this._defaultTTFColor);
            }
            img.setSrc(context.SessionService.getCurrent().getApplicationByHash(this._appHash).wrapResourcePath(icon), true);
            img.setTitle("Open picker");
            this._pikerIcon.classList.remove('zmdi', 'zmdi-calendar-blank', 'zmdi-calendar-clock');
            this.domAttributesMutator(function() {
              this._pikerIcon.innerHTML = imgElem.innerHTML;
              img.destroy();
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          this.controlValueLength(event);
          if (!this.getInputTextState().isRestored()) {
            this.triggerValueChangedEvent(this.getValue(), false);
          }
        },

        /**
         * @inheritDoc
         */
        _checkValue: function(text, newTextPart) {
          if (this._dialogType !== 'Input' && this._dialogType !== 'InputArray') {
            return newTextPart;
          }

          newTextPart = this.checkValueDisplayWidth(text, newTextPart);

          return newTextPart;
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          const text = this.getValue().toString();
          const size = text ? text.length : 0;

          if (size > 0) {
            const cursors = this.getCursors();
            const endReached = cursors.start === cursors.end && cursors.start + 1 > size;

            if (endReached) {
              if (this._maxLength > 0) {
                return text.length >= this._maxLength;
              }
            }
          }

          return false;
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        }

      };
    });
  });
;

'use strict';

modulum('DateTimeEditWidgetBase', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget Base.
     * @class DateTimeEditWidgetBase
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateTimeEditWidgetBase = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateTimeEditWidgetBase.prototype */ {
        __name: 'DateTimeEditWidgetBase',
        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',
        /**
         * Active/disable seconds for the widget. By default, yes.
         * @type {boolean}
         */
        _showSeconds: false,
        /**
         * @inheritDoc
         */
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);

          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          this._displayFormat = format;
          this._showSeconds = Boolean(format && ~format.toLowerCase().indexOf('s'));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        }

      };
    });
  });
;

'use strict';

modulum('SpinEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget Base class.
     * @class SpinEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.SpinEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.SpinEditWidgetBase.prototype */ {
        __name: 'SpinEditWidgetBase',

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Up arrow element
         * @type {Element}
         */
        _upArrow: null,

        /**
         * Down arrow element
         * @type {Element}
         */
        _downArrow: null,

        /**
         * Step of value increment/decrement.
         * @type {number}
         */
        _step: 1,

        /**
         * Minimum value of the spinedit
         * @type {?number}
         */
        _min: null,

        /**
         * Maximum value of the spinedit
         * @type {?number}
         */
        _max: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._upArrow = this._element.getElementsByClassName('up')[0];
          this._downArrow = this._element.getElementsByClassName('down')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);

          // Manage requestFocus during selection of text
          cls.WidgetBase._onSelect.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus

          const target = domEvent.target;
          if (target.isElementOrChildOf(this._upArrow)) {
            this._onUpIcon(domEvent);
          } else if (target.isElementOrChildOf(this._downArrow)) {
            this._onDownIcon(domEvent);
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM);
          //GDC behaviour
          if (!this.validateValue(value)) {
            if (Object.isNumber(this._min) && Object.isNumber(this._max)) {
              if (this._max < 0) {
                this._oldValue = this._max;
              } else {
                this._oldValue = this._min;
              }
            } else if (Object.isNumber(this._min)) {
              this._oldValue = this._min;
            } else if (Object.isNumber(this._max)) {
              this._oldValue = this._max;
            }
          }
          // TODO: why not set value with oldvalue ?
          this._inputElement.value = value;
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          const value = parseInt(this._inputElement.value, 10);
          const isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : '';
        },

        /**
         * Handler called when arrow up icon has been touched/click
         * @param {UIEvent} evt - DOM event
         */
        _onUpIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            const newVal = this._increase();
            this.triggerValueChangedEvent(newVal);
          }
        },

        /**
         * Handler called when arrow down icon has been touched/click
         * @param {UIEvent} evt - DOM event
         */
        _onDownIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            const newVal = this._decrease();
            this.triggerValueChangedEvent(newVal);
          }
        },

        /**
         * Update value
         * @param {number} factor - value to add
         */
        _updateValue: function(factor) {
          if (factor > 0) {
            this._increase(factor);
          } else if (factor < 0) {
            this._decrease(Math.abs(factor));
          }
        },

        /**
         * Method used to validate or not the value of the widget or pass as parameter
         * @param {string|number} [value] - sets the value to display
         * @return {boolean} - true if valid, false otherwise
         */
        validateValue: function(value) {
          let cur = value ? value : this.getValue();
          if (Object.isNumber(this._min) && cur < this._min) {
            return false;
          }
          return !(Object.isNumber(this._max) && cur > this._max);
        },

        /**
         * Increase value
         * @param {number} [factor=1] - value to add (default is 1)
         */
        _increase: function(factor) {
          const curVal = parseInt(this._getWidgetValidValue(), 10);
          let newVal = (this._step * (factor && Object.isNumber(factor) ? factor : 1));
          newVal = curVal ? newVal + curVal : newVal;
          if (Object.isNumber(this._max) && newVal > this._max) {
            newVal = this._max;
          }
          this.setEditing(this._oldValue !== newVal);
          if (this.hasFocus()) {
            this.setValue(newVal);
            this.setCursors(0, -1); // highlight value and avoid an unwanted autonext
          }
          return newVal;
        },

        /**
         * Decrease value
         * @param {number} [factor=1] - value to remove (default is 1)
         */
        _decrease: function(factor) {
          const curVal = parseInt(this._getWidgetValidValue(), 10);
          let newVal = (this._step * (factor && Object.isNumber(factor) ? factor : 1));
          newVal = curVal ? curVal - newVal : -newVal;
          if (Object.isNumber(this._min) && newVal < this._min) {
            newVal = this._min;
          }
          this.setEditing(this._oldValue !== newVal);
          if (this.hasFocus()) {
            this.setValue(newVal);
            this.setCursors(0, -1); // highlight value and avoid an unwanted autonext
          }
          return newVal;
        },

        /**
         * Define the minimum possible value
         * @param {number} min - the minimum value
         * @publicdoc
         */
        setMin: function(min) {
          if (Object.isNumber(min)) {
            this._min = min;
          }
          this.setAriaAttribute("valuemin", min);
        },

        /**
         * Get minimum possible value
         * @returns {?number} the minimum value
         * @publicdoc
         */
        getMin: function() {
          return this._min;
        },

        /**
         * Define the maximum possible value
         * @param {number} max - the maximum value
         * @publicdoc
         */
        setMax: function(max) {
          if (Object.isNumber(max)) {
            this._max = max;
          }
          this.setAriaAttribute("valuemax", max);
        },

        /**
         * Get maximum possible value
         * @returns {?number} the maximum value
         * @publicdoc
         */
        getMax: function() {
          return this._max;
        },

        /**
         * Define the spinedit step when increasing or decreasing value
         * @param {number} step - the step value
         * @publicdoc
         */
        setStep: function(step) {
          let s = step && parseInt(step, 10);
          if (!s || Number.isNaN(s)) {
            s = 1;
          }
          this._step = s;
        },

        /**
         * Get spinedit step when increasing or decreasing value
         * @returns {number} the step value
         * @publicdoc
         */
        getStep: function() {
          return this._step;
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          if (this._isReadOnly !== readonly) {
            $super.setReadOnly.call(this, readonly);
            this._setInputReadOnly(readonly || this._notEditable || !this._enabled);
          }
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number=} cursor2 - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }
          if (cursor2 && cursor2 < 0) {
            cursor2 = ('' + this.getValue()).length;
          }
          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          const cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          const oldEnabled = this._enabled;
          const bEnabled = Boolean(enabled);

          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setFontWeight: function(weight) {
          this.setStyle('input', {
            'font-weight': weight
          });
        },

        /**
         * @inheritDoc
         */
        getFontWeight: function() {
          return this.getStyle('input', 'font-weight');
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          this.setStyle('input', {
            'font-style': style
          });
        },

        /**
         * @inheritDoc
         */
        getFontStyle: function() {
          return this.getStyle('input', 'font-style');
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this.setStyle(".gbc_SpinEditWidget_arrows", {
            'color': color
          });
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this.getStyle('input', 'text-align');
        },

        /**
         * @inheritDoc
         */
        getTextDecoration: function() {
          return this.getStyle('input', 'text-decoration');
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          this.setStyle('input', {
            'text-decoration': decoration
          });
        },

        /**
         * overrided since aria-required is not valid on spinbutton role
         * @inheritDoc
         */
        setRequired: function(required) {
          $super.setRequired.call(this, required);
          this.setAriaAttribute("required", null);
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          const text = this.getValue().toString();
          const size = text ? text.length : 0;

          if (size > 0) {
            const cursors = this.getCursors();
            const endReached = cursors.start === cursors.end && cursors.start + 1 > size;
            const isLastCharNumeric = cls.KeyboardHelper.isNumeric(text[text.length - 1]);

            if (endReached && isLastCharNumeric) {
              if (this._maxLength > 0) {
                return text.length >= this._maxLength;
              }
            }
          }

          return false;
        },

        /**
         * @inheritDoc
         */
        manageBeforeInput: function(dataString = "", event = null) {

          const isConstruct = this.getDialogType() === "Construct";

          if (!isConstruct && dataString && !(event?.isComposing)) { // composition event cannot be canceled
            const isDecimalChar = cls.KeyboardHelper.isDecimal(dataString);
            const isStringInteger = Math.isStringInteger(dataString);

            if (!isStringInteger && !isDecimalChar) {
              return false;
            }
          }

          return $super.manageBeforeInput.call(this, dataString, event);
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          this.controlValueLength(event);
          if (!this.getInputTextState().isRestored()) {
            this.triggerValueChangedEvent(this.getValue(), false);
          }
        },

        /**
         * @inheritDoc
         */
        _checkValue: function(text, newTextPart) {
          if (this._dialogType !== 'Input' && this._dialogType !== 'InputArray') {
            return newTextPart;
          }

          newTextPart = this.checkValueDisplayWidth(text, newTextPart);

          return newTextPart;
        },

        /**
         * Return a valid value (the current widget value or the last valid)
         * @return {?string|number}
         * @private
         */
        _getWidgetValidValue: function() {
          if (!this.validateValue()) {
            this.setValue(this._oldValue);
          }

          return this.getValue();
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        }

      };
    });
  });
;

'use strict';

modulum('TimeEditWidgetBase', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget Base class.
     * @class TimeEditWidgetBase
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditWidgetBase = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.TimeEditWidgetBase.prototype */ {
        __name: 'TimeEditWidgetBase',

        /**
         * Active/disable seconds for the widget. By default, yes.
         * @type {boolean}
         */
        _useSeconds: true,

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Format of TIMEEDIT (hh:mm or hh:mm:ss)
         * @type {string}
         */
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setTextAlign.call(this, align);
          this.setStyle('input', {
            'text-align': align
          });
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          this.setStyle(".gbc_TimeEditWidget_arrows", {
            'color': color
          });
        },

        /**
         * @inheritDoc
         */
        getTextDecoration: function() {
          return this.getStyle('input', 'text-decoration');
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          this.setStyle('input', {
            'text-decoration': decoration
          });
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          if (this.getValue() !== value) {
            this._setTimeAccuracy(value);
            this._inputElement.value = value;
          }
        },

        /**
         * Detect if seconds are defined in value or in format and set class variable
         * @param value
         * @protected
         */
        _setTimeAccuracy: function(value) {
          const groups = value.split(':');
          if (groups.length === 1) { // no ':'' detected, we look for varType
            this._useSeconds = !this.getDisplayFormat() || !this.getDisplayFormat().endsWith("MINUTE");
          } else {
            this._useSeconds = groups.length === 3;
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.value;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          this._inputElement.domFocus();
        },

        /**
         * Returns if max length of the widget has been reached
         * @returns {boolean} return true if max length is reached in input element
         */
        _isMaxLength: function() {
          return this._maxLength !== -1 && this._inputElement.value.length >= this._maxLength &&
            this._inputElement.selectionStart === this._inputElement.selectionEnd;
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          $super.setMaxLength.call(this, maxLength);
          if (maxLength > 0) {
            this._setElementAttribute('maxlength', maxLength, "_inputElement");
          }
        },

        /**
         * Get the timeedit format (hh:mm or hh:mm:ss)
         * @return {?string} timeedit format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set timeedit format (hh:mm or hh:mm:ss)
         * @param {string} format - format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
          this._setTimeAccuracy(this.getValue());
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        }
      };
    });
  });
;

'use strict';

modulum('ButtonEditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ButtonEdit widget.
     * @class ButtonEditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.ButtonEditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ButtonEditWidget.prototype */ {
        __name: 'ButtonEditWidget',
        /**
         * Edit part of the widget
         * @type {classes.EditWidget}
         */
        _edit: null,

        /**
         * Button part of the widget
         * @type {classes.ButtonWidget}
         */
        _button: null,

        /**
         * Redefine where the data is located
         * @type {string}
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Handler for click
         * @function
         */
        _clickHandler: null,

        /**
         * Handler for focus
         * @function
         */
        _focusHandler: null,

        /**
         * Handler for blur
         * @function
         */
        _blurHandler: null,

        /**
         * Handler for change
         * @function
         */
        _changeHandler: null,

        /**
         * Handler for image ready
         * @function
         */
        _imageReadyHandler: null,

        /**
         * Flag to manage if button has been clicked
         * @type {boolean}
         */
        _buttonClicked: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setReservedDecorationSpace(2);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._edit = cls.WidgetFactory.createWidget('EditWidget', this.getBuildParameters());
          this._button = cls.WidgetFactory.createWidget('ButtonWidget', this.getBuildParameters());
          // layout engine can be null if _ignoreLayout is true, which happens for widget being in table and not in first row. (cf constructor of WidgetBase)
          // in that case, we do not want to measure image once loaded
          if (!this._ignoreLayout) {
            this._imageReadyHandler = this._button.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
          }
          this._element.appendChild(this._edit.getElement());
          this._element.appendChild(this._button.getElement());
          this._edit.setParentWidget(this);
          this._button.setParentWidget(this);
          this._clickHandler = this._button.when(context.constants.widgetEvents.click, this._onButtonClick.bind(this));
          this._focusHandler = this._edit.when(context.constants.widgetEvents.requestFocus, this._onEditRequestFocus.bind(this));
          this._blurHandler = this._edit.when(context.constants.widgetEvents.blur, this._onEditBlur.bind(this));
          this._changeHandler = this._edit.when(context.constants.widgetEvents.valueChanged, this._onEditChange.bind(this));
        },

        /**
         * Handler called when the button image is loaded
         */
        _imageLoaded: function(event, src) {
          this._layoutEngine.invalidateMeasure();
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._clickHandler();
          this._clickHandler = null;
          this._focusHandler();
          this._focusHandler = null;
          this._blurHandler();
          this._blurHandler = null;
          this._changeHandler();
          this._changeHandler = null;
          this._edit.destroy();
          this._edit = null;
          this._button.destroy();
          this._button = null;

          if (this._completerWidget) {
            this._completerWidget.destroy();
            this._completerWidget = null;
          }
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageClipboardPaste: function(text) {
          this._edit.manageClipboardPaste(text);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          return this._edit.managePriorityKeyDown(keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          return this._edit.manageKeyDown(keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          this._edit.manageInput(dataString, event);
        },

        /**
         * Handler when click on button
         * @param {Object} event - DOM event
         * @param sender
         * @param domEvent
         */
        _onButtonClick: function(event, sender, domEvent) {
          if (this.isEnabled()) {
            this.emit(context.constants.widgetEvents.requestFocus, domEvent);
            this.emit(context.constants.widgetEvents.click, domEvent, !this.hasDOMFocus());
          }
        },

        /**
         * Handler when focus is requested
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditRequestFocus: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.requestFocus, domEvent);
        },

        /**
         * Handler when edit is blured
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditBlur: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.blur, domEvent);
        },

        /**
         * Handler when edit content changes
         * @param {object} event - dom event
         * @param {HTMLElement} sender - source element
         * @param {string} newValue - new value of the widget
         * @param {boolean} sendValue - if true new value must be sent to VM
         */
        _onEditChange: function(event, sender, newValue, sendValue) {
          this.emit(context.constants.widgetEvents.valueChanged, newValue, sendValue);
        },

        /**
         * @inheritDoc
         */
        getInputElement: function() {
          return this._edit.getInputElement();
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._edit.setTitle(title);
        },

        /**
         * Set button title from localized text of corresponding action
         * @param actionTitle
         */
        setActionTitle: function(actionTitle) {
          if (actionTitle && actionTitle.length <= 0) {
            this._button.setTitle(this.getTitle());
          } else {
            this._button.setTitle(actionTitle);
          }
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._edit.getTitle();
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          this._edit.setReadOnly(readonly);
        },

        /**
         * @inheritDoc
         */
        isReadOnly: function() {
          return this._edit.isReadOnly();
        },

        /**
         * @inheritDoc
         */
        setDataTypeWithNoScroll: function(checkDisplayValue) {
          this._edit.setDataTypeWithNoScroll(checkDisplayValue);
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          this._edit.setMaxLength(maxLength);
        },

        /**
         * @inheritDoc
         */
        getMaxLength: function() {
          return this._edit.getMaxLength();
        },

        /**
         * @inheritDoc
         */
        setScroll: function(scroll) {
          this._edit.setScroll(scroll);
        },

        /**
         * @inheritDoc
         */
        setVMWidth: function(width) {
          this._edit.setVMWidth(width);
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          return this._edit.canAutoNext();
        },

        /**
         * Set Default TTF color
         * @param {string} color - rgb formatted or css name
         */
        setDefaultTTFColor: function(color) {
          if (this._button) {
            this._button.setDefaultColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          this._edit.setTextAlign(align);
        },

        /**
         * @inheritDoc
         */
        getTextAlign: function() {
          return this._edit.getTextAlign();
        },

        /**
         * When cursor2 === cursor, it is a simple cursor set
         * @param {number} cursor - starting cursor position
         * @param {number} cursor2 - ending cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {

          if (this._edit) {
            this._edit.setCursors(cursor, cursor2);
          }
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          return this._edit.getCursors();
        },

        /**
         * Get the display format of the edit part
         * @return {string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._edit.getDisplayFormat();
        },

        /**
         * Set the display format of the edit part
         * @param {string} format the display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._edit.setDisplayFormat(format);
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          this._edit.setValue(value, fromVM, cursorPosition);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._edit.getValue();
        },

        /**
         * Set the image of the button part
         * @param {string} image - URL of the image to display
         * @publicdoc
         */
        setImage: function(image) {
          this._button.setImage(image);
        },

        /**
         * Get the image of the button part
         * @returns {string} the URL of the image displayed in the button part
         * @publicdoc
         */
        getImage: function() {
          return this._button.getImage();
        },

        /**
         * Defines the widget as autoscalable
         * @param {boolean} enabled the wanted state
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._button.setAutoScale(enabled);
        },

        /**
         * Set autoscale value as nnnpx
         * @param {string} value - css string value with valid units
         */
        setScaleIconValue: function(value) {
          this._button.setScaleIconValue(value);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._edit.setEnabled(enabled);
        },

        /**
         * @inheritDoc
         */
        isEnabled: function() {
          return this._edit.isEnabled();
        },
        /**
         * Enable the button
         * @param {boolean} enabled - true if the button should be enabled, false otherwise
         * @publicdoc
         */
        setButtonEnabled: function(enabled) {
          this._button.setEnabled(enabled);
        },

        /**
         * returns whether the button is enabled or not
         * @returns {boolean} true if the button is enabled, false otherwise
         * @publicdoc
         */
        isButtonEnabled: function() {
          return this._button.isEnabled();
        },

        /**
         * sets 'password' mode
         * @param {boolean} isPassword - true if the widget should be in 'password' mode, false otherwise
         * @publicdoc
         */
        setIsPassword: function(isPassword) {
          this._edit.setIsPassword(isPassword);
        },

        /**
         * returns whether the widget should be in 'password' mode or not.
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         * @publicdoc
         */
        isPassword: function() {
          return this._edit.isPassword();
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType - the type attribute value to set
         * @publicdoc
         */
        setType: function(valType) {
          this._edit.setType(valType);
        },

        /**
         * @inheritDoc
         */
        setInputMode: function(valType) {
          this._edit.setInputMode(valType);
        },

        /**
         * Get the keyboardHint method
         * @returns {string} this Edit current type
         * @publicdoc
         */
        getType: function() {
          return this._edit.getType();
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          if (this._completerWidget) {
            this._completerWidget.loseFocus();
          }
        },

        /**
         * @inheritDoc
         */
        setDialogType: function(dialogType) {
          $super.setDialogType.call(this, dialogType);

          this._edit.setDialogType(dialogType);
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);

          const inputElement = this._edit.getInputElement();

          if (inputElement) {
            inputElement.domFocus();
          }
        },

        /**
         * @inheritDoc
         */
        flash: function() {
          if (this._edit) {
            this._edit.flash();
          }
        },

        /**
         * Get the Completer widget from the edit
         * @return {classes.CompleterWidget}
         */
        getCompleterWidget: function() {
          return this._edit.getCompleterWidget();
        },

        /**
         * Will add a completer to the edit
         */
        addCompleterWidget: function() {
          this._edit.addCompleterWidget();
        },

        /**
         * return true if edit has a completer
         * @returns {boolean}
         */
        hasCompleter: function() {
          return this._edit.hasCompleter();
        },

        /**
         * Cancel valueChanged delayer (when completer)
         * @returns {boolean} true if timer has been cancelled
         */
        cancelCompleterValueChangedDelayer: function() {
          return this._edit.cancelCompleterValueChangedDelayer();
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          this._edit.setColor(color);
        },

        /**
         * @inheritDoc
         */
        getColor: function() {
          return this._edit.getColor();
        },

        /**
         * @inheritDoc
         */
        getColorFromStyle: function() {
          return this._edit.getColorFromStyle();
        },

        /**
         * @inheritDoc
         */
        setTextTransform: function(transform) {
          this._edit.setTextTransform(transform);
        },

        /**
         * @inheritDoc
         */
        removeTextTransform: function() {
          this._edit.removeTextTransform();
        },

        /**
         * @inheritDoc
         */
        getTextTransform: function() {
          return this._edit.getTextTransform();
        },

        /**
         * @inheritDoc
         */
        setEditing: function(editing) {
          if (this._edit) {
            this._edit.setEditing(editing);
          }
        },

        /**
         * @inheritDoc
         */
        getEditingTime: function() {
          return this._edit.getEditingTime();
        },

        /**
         * @inheritDoc
         */
        isEditing: function() {
          return this._edit.isEditing();
        },

        /**
         * @inheritDoc
         */
        setPlaceHolder: function(placeholder) {
          this._edit.setPlaceHolder(placeholder);
        },

        /**
         * @inheritDoc
         */
        setNotEditable: function(notEditable) {
          this._edit.setNotEditable(notEditable);
        },

        hasDOMFocus: function() {
          return this._edit.hasDOMFocus() || this._button.hasDOMFocus();
        },

        /**
         * @inheritDoc
         */
        isNotEditable: function() {
          return this._edit.isNotEditable();
        },

        /**
         * @inheritDoc
         */
        _preventEditAllowNavigation: function(evt, keyString) {
          this._edit._preventEditAllowNavigation(evt, keyString);
        },

        /**
         * @inheritDoc
         */
        setPicture: function(picture) {
          this._edit.setPicture(picture);
        },

        /**
         * @inheritDoc
         */
        getInputTextState: function() {
          return this._edit.getInputTextState();
        },

      };
    });
    cls.WidgetFactory.registerBuilder('ButtonEdit', cls.ButtonEditWidget);
  });
;

"use strict";

modulum('ButtonWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Button widget.
     * @class ButtonWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.ButtonWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.ButtonWidget.prototype */ {
        __name: "ButtonWidget",

        /**
         * @type {classes.ImageWidget}
         */
        _image: null,

        /**
         * @type {HTMLElement}
         */
        _textElement: null,

        /**
         * @type {HTMLElement}
         */
        _mtButton: null,

        /**
         * Type of the button (normal, link or commandLink)
         * @type {null|string}
         */
        _buttonType: null,

        /** @type {boolean} */
        _autoScale: false,

        _scaleIconValue: null,

        /** @type {Object} */
        _alignment: null,

        /** @type {string|null} */
        _defaultColor: null,

        /** @function */
        _imageReadyHandler: null,
        /** @function */
        _afterLayoutHandler: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);

          this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          this._layoutEngine = new cls.ButtonLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._mtButton = this._element.getElementsByClassName('mt-button')[0];
          this._textElement = this._mtButton.querySelector('.textimage span');
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (this._afterLayoutHandler) {
            this._afterLayoutHandler();
            this._afterLayoutHandler = null;
          }
          if (this._image) {
            this._image.destroy();
            this._image = null;
          }
          this._textElement = null;
          this._mtButton = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // Disable click when not clicking on text nor image
          if (this._buttonType === 'link' && (domEvent.target.tagName.toLowerCase() !== 'span' && domEvent.target.tagName
              .toLowerCase() !==
              'img')) {
            return true;
          }

          if (this.isEnabled() || this.isInterruptable()) {
            this.emit(context.constants.widgetEvents.click, domEvent);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.isEnabled()) {
            if (keyString === "space" || keyString === "enter" || keyString === "return") {
              this.emit(context.constants.widgetEvents.click, domKeyEvent);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Sets the text of the button
         * @param {string} text text to display in the button
         * @publicdoc
         */
        setText: function(text) {
          this.domAttributesMutator(function() {
            this.getElement().toggleClass('hasText', text.length !== 0);
            this._textElement.textContent = text;
          }.bind(this));

          if (this._layoutEngine) {
            if (this._layoutInformation && this._layoutInformation.getCurrentSizePolicy().isDynamic()) {
              this._layoutEngine.invalidateMeasure();
            }
          }

          // client QA code
          if (gbc.qaMode && ['qa_dialog_ready', 'qa_menu_ready'].indexOf(text) >= 0) {
            gbc.QAService.bindQAReadyButton(this);
          }
        },

        /**
         * Gets the text of the button
         * @returns {string} the text displayed in the button
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Sets the image of the button
         * @param {string} image the URL of the image to display
         * @publicdoc
         */
        setImage: function(image) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (image.length !== 0) {
            if (!this._image) {
              const opts = this.getBuildParameters();
              opts.inTable = false; // TODO image in button edit seem to not work correctly if inTable and buttonedit is intable
              this._image = cls.WidgetFactory.createWidget('ImageWidget', opts);
              const imageContainer = document.createElement('div');
              imageContainer.addClass('gbc_imageContainer');
              imageContainer.appendChild(this._image.getElement());
              this._mtButton.querySelector(".textimage").prependChild(imageContainer);
              this.setAutoScale(this._autoScale);
              if (this._defaultColor) {
                this._image.setDefaultColor(this._defaultColor);
              }
            }
            this._image.setSrc(image);
            this._imageReadyHandler = this._image.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            this.getElement().addClass('hasImage');

            if (!this._alignment) {
              this.afterDomMutator((function() {
                // if no alignment set and no text
                if (this.getText().length <= 0) {
                  this.setStyle(".mt-button", {
                    "justify-content": "center"
                  });
                } else {
                  this.setStyle(".mt-button", {
                    "justify-content": "flex-start"
                  });
                }
              }).bind(this));

              this.setStyle(".mt-button .textimage", {
                "align-self": "center",
                "align-items": "center"
              });
            }
          } else if (this._image) {
            this._image.getElement().parentElement.remove();
            this._image.destroy();
            this._image = null;
          }
        },

        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden);
        },

        /**
         * Callback once image has finish loading
         * @private
         */
        _imageLoaded: function(event, src) {
          this._layoutEngine.invalidateMeasure();
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * Gets the image of the button
         * @returns {?string} the URL of the displayed image
         * @publicdoc
         */
        getImage: function() {
          if (this._image) {
            return this._image.getSrc();
          }
          return null;
        },

        /**
         * Define the button as autoscaled or not
         * @param {boolean} enabled the button autoscale mode
         * @publicdoc
         */
        setAutoScale: function(enabled) {
          this._autoScale = enabled;
          if (this._image) {
            this._image.setAutoScale(this._autoScale);
            this._image.getElement().parentElement.toggleClass('gbc_autoScale', this._autoScale);
          }
        },

        /**
         * Set autoscale value as nnnpx
         * @param {string} value - css string value with valid units
         */
        setScaleIconValue: function(value) {
          this.scaleIconValue = value;
          if (this._image) {
            this._image.setScaleIconValue(value);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          if (this.getParentWidget() && (this.getParentWidget().isDropDown || this.getParentWidget().isHidden())) {
            const uiWidget = this.getUserInterfaceWidget();
            if (uiWidget) {
              uiWidget.getElement().domFocus();
            }
          } else {
            this._mtButton.domFocus();
          }
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this.domAttributesMutator(function() {
            this._mtButton.toggleClass('disabled', !enabled);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          this.setStyle('.mt-button', {
            'color': color ? color + ' !important' : null
          });
        },

        /**
         * @inheritDoc
         */
        getColor: function() {
          return this.getStyle('.mt-button', 'color');
        },

        /**
         * Set Default color (defined by DefaultTTF)
         * @param {string} color - rgb formatted or css name
         */
        setDefaultColor: function(color) {
          this._defaultColor = color;
          if (this._image) {
            this._image.setDefaultColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          this.setStyle('.mt-button', {
            'background-color': color ? color + ' !important' : null
          });
        },

        /**
         * @inheritDoc
         */
        getBackgroundColor: function() {
          return this.getStyle('.mt-button', 'background-color');
        },

        /**
         * Align the content of the button
         * @param {string} align the button content alignment
         * @publicdoc
         */
        setContentAlign: function(align) {
          this._element.toggleClass('content-left', align === 'left')
            .toggleClass('content-right', align === 'right');
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._image) {
            this._image.setTitle(title);
          }
        },

        /**
         * Hide the button text
         * @param {boolean} textHidden the button text visibility
         * @publicdoc
         */
        setTextHidden: function(textHidden) {
          this._element.toggleClass('text-hidden', textHidden);
        },

        /**
         * Define the button type (normal, link or commandLink)
         * @param {string} buttonType the button type
         * @publicdoc
         */
        setButtonType: function(buttonType) {
          if (this._buttonType) {
            this._mtButton.removeClass('buttonType_' + this._buttonType);
            this.removeClass('buttonType_' + this._buttonType);
          }
          this._buttonType = buttonType;
          this._mtButton.addClass('buttonType_' + buttonType);
          this.addClass('buttonType_' + buttonType);
        },

        /**
         * Defines the alignment of the button text
         * @param {string} vertical - vertical position
         * @param {string} horizontal - horizontal position left, right or centered
         */
        setAlignment: function(vertical, horizontal) {
          this._alignment = {
            "vertical": vertical,
            "horizontal": horizontal
          };

          const _flex = {
            "top": "flex-start",
            "verticalCenter": "center",
            "bottom": "flex-end",
            "left": "flex-start",
            "horizontalCenter": "center",
            "right": "flex-end"
          };

          if (["left", "center", "right"].indexOf(horizontal) >= 0) {
            this.setStyle(".mt-button", {
              "justify-content": _flex[horizontal]
            });
          }

          if (["top", "verticalCenter", "bottom"].indexOf(vertical) >= 0) {
            this.setStyle(".mt-button .textimage", {
              "align-self": _flex[vertical]
            });
          }
        },
        /**
         * @inheritDoc
         */
        setInterruptable: function(interruptable) {
          $super.setInterruptable.call(this, interruptable);
          if (this._mtButton) {
            if (interruptable) {
              this._mtButton.setAttribute("interruptable", "interruptable");
            } else {
              this._mtButton.removeAttribute("interruptable");
            }
          }
        },
        /**
         * @inheritDoc
         */
        setInterruptableActive: function(isActive) {
          $super.setInterruptableActive.call(this, isActive);
          if (this._mtButton) {
            if (isActive) {
              this._mtButton.setAttribute("interruptable-active", "interruptable-active");
            } else {
              this._mtButton.removeAttribute("interruptable-active");
            }
          }
        },

        /**
         * Set the aria-current attribute instead of aria-selected to help screen-reader to know wich widget is the current one
         */
        setAriaSelection: function() {
          this.domAttributesMutator(function() {
            const currentSelected = document.querySelector('[aria-current="true"]');
            if (currentSelected) {
              currentSelected.removeAttribute('aria-current');
            }
          });
          this.setAriaAttribute('current', "true");
        },

      };
    });
    cls.WidgetFactory.registerBuilder('Button', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('ButtonWidget', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('Action', cls.ButtonWidget);
    cls.WidgetFactory.registerBuilder('MenuAction', cls.ButtonWidget);
  });
;

'use strict';

modulum('CheckBoxWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Checkbox widget.
     * @class CheckBoxWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.CheckBoxWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.CheckBoxWidget.prototype */ {
        __name: 'CheckBoxWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * @type HTMLElement
         */
        _checkboxElement: null,
        /**
         * @type HTMLElement
         */
        _labelElement: null,
        /**
         * @type {*}
         */
        _checkedValue: true,
        /**
         * @type {*}
         */
        _uncheckedValue: false,
        /**
         * @type {*}
         */
        _value: false,
        /**
         * the value of the intermediate state
         * @type {?string}
         */
        _indeterminateValue: null,
        /**
         * @type {boolean}
         */
        _notNull: true,
        /**
         * @type {boolean}
         */
        _allowNullValue: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafDynamicHeightLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._checkboxElement = this._element.getElementsByClassName('zmdi')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._checkboxElement = null;
          this._labelElement = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (!this.isEnabled() && !this.isInTable() && !this.isInMatrix()) {
            return true; // if check disabled and not in matrix not in table --> nothing to do
          }

          this._onRequestFocus(domEvent); // request focus

          if (this.isEnabled()) {
            this._sendNextValue();
          }
          this.emit(context.constants.widgetEvents.click, domEvent);

          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled()) {
            if (keyString === "space" && !repeat) {
              keyProcessed = this._sendNextValue();
            }
          }
          //Catch arrow keys to prevent propagation when in a folder widget
          if (keyString === "right" || keyString === "left") {
            keyProcessed = true;
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Calculate next value and send it to behavior. Update visually the widget value if focused and ready
         * @returns {boolean}
         * @private
         */
        _sendNextValue: function() {
          this.setEditing(true);
          const newValue = this.getNextValue();
          if (this.hasFocus()) { // concerns mouse click
            this.setValue(newValue);
          }
          this.triggerValueChangedEvent(newValue);
          return true;
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowNullValue = mode === "Construct";
        },

        /**
         * Defines a third state
         * @param {*} indeterminateValue value corresponding to the 'intermediate' state
         * @publicdoc
         */
        setIndeterminateValue: function(indeterminateValue) {
          const old = this._indeterminateValue;
          this._indeterminateValue = indeterminateValue;
          if (this.getValue() === old) {
            this.setValue(indeterminateValue);
          }
        },

        /**
         * Get the third state value
         * @returns {*} value corresponding to the 'third' state
         * @publicdoc
         */
        getIndeterminateValue: function() {
          return this._indeterminateValue;
        },

        /**
         * @returns {*} the next value in the cycle
         * @private
         */
        getNextValue: function() {
          const current = this._value;
          if (current === this._indeterminateValue ||
            ((this._notNull && !this._allowNullValue) && current === this._uncheckedValue)) {
            return this._checkedValue;
          } else if (current === this._checkedValue) {
            return this._uncheckedValue;
          } else {
            if (this._allowNullValue || !this.notNull) {
              return this._indeterminateValue;
            }
          }
        },

        /**
         * Get the text of this checkbox
         * @returns {string} the text displayed next to the button
         * @publicdoc
         */
        getText: function() {
          if (this._labelElement) {
            return this._labelElement.textContent;
          }
          return '';
        },

        /**
         * Set the text of the checkbox
         * @param {string} text - the text displayed next to the button
         * @publicdoc
         */
        setText: function(text) {
          text = text ? text : ''; // fix for ie & edge

          if (this._labelElement === null && text !== '') {
            this._labelElement = document.createElement('div');
            this._labelElement.addClass('label');
            this._element.getElementsByClassName('content')[0].appendChild(this._labelElement);
          }
          if (this._labelElement) {
            this.domAttributesMutator(function() {
              this._labelElement.toggleClass('notext', !text);
              this._labelElement.textContent = text;
            }.bind(this));
            if (this.getLayoutEngine()) {
              this.getLayoutEngine().forceMeasurement();
              this.getLayoutEngine().invalidateMeasure();
            }
          }
        },

        /**
         * Set the checked value
         * @param {*} checkedValue - value corresponding to the 'checked' state
         * @publicdoc
         */
        setCheckedValue: function(checkedValue) {
          const old = this._checkedValue;
          this._checkedValue = checkedValue;
          if (this.getValue() === old) {
            this.setValue(checkedValue);
          }
        },

        /**
         * Get the checked value
         * @returns {*} value corresponding to the 'checked' state
         * @publicdoc
         */
        getCheckedValue: function() {
          return this._checkedValue;
        },

        /**
         * Set unchecked value
         * @param {*} uncheckedValue - value corresponding to the 'checked' state
         * @publicdoc
         */
        setUncheckedValue: function(uncheckedValue) {
          const old = this._uncheckedValue;
          this._uncheckedValue = uncheckedValue;
          if (this.getValue() === old) {
            this.setValue(uncheckedValue);
          }
        },

        /**
         * Get unchecked value
         * @returns {*} value corresponding to the 'checked' state
         * @publicdoc
         */
        getUncheckedValue: function() {
          return this._uncheckedValue;
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._checkboxElement.hasClass('indeterminate')) {
            return this._indeterminateValue;
          } else if (this._checkboxElement.hasClass('checked')) {
            return this._checkedValue;
          } else {
            return this._uncheckedValue;
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);
          this._value = value;
          this._checkboxElement.toggleClass('indeterminate', value === this._indeterminateValue);
          this._checkboxElement.toggleClass('checked', value === this._checkedValue);
          this._checkboxElement.toggleClass('unchecked', value !== this._checkedValue && value !== this._indeterminateValue);
          if (value === this._indeterminateValue) {
            this.setAriaAttribute("checked", "mixed");
          } else {
            this.setAriaAttribute("checked", (value === this._checkedValue).toString());
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._checkboxElement.toggleClass('disabled', !enabled);
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            if (this._checkboxElement.hasClass('checked')) {
              return this.getText();
            }

            return '';
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: !this.isInTable(),
            cut: false
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('CheckBox', cls.CheckBoxWidget);
    cls.WidgetFactory.registerBuilder('CheckBoxWidget', cls.CheckBoxWidget);
  });
;

'use strict';

modulum('ComboBoxWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Combobox widget.
     * @class ComboBoxWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */

    cls.ComboBoxWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ComboBoxWidget.prototype */ {
        $static: {
          _navigationKeyRegex: /up|down|pageup|pagedown|home|end/i,
        },
        __name: 'ComboBoxWidget',

        /** @type {string} */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',
        /** @type {classes.EditWidget}*/
        _editWidget: null,
        /** @type {classes.ListDropDownWidget} */
        _dropDown: null,
        /** @type {string} */
        _typedLetters: "",
        /** @function */
        _typedLettersCacheHandler: null,
        /** @function */
        _focusHandler: null,
        /** @function */
        _editFocusHandler: null,
        /** @function */
        _dropDownSelectHandler: null,
        /** @function */
        _visibilityChangeHandler: null,

        /**
         * Is the combobox query editable?
         * @type {boolean}
         * @protected
         */
        _isQueryEditable: false,

        /** @type {HTMLElement} */
        _toggleIcon: null,

        /** @type {string} */
        _placeholderText: '',

        /** @type {string} */
        _value: '',

        /** @type {string} */
        _lastVMValue: '',

        /** @type {boolean} */
        _allowMultipleValues: false,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.ComboBoxLayoutEngine(this);
            this._layoutInformation.setReservedDecorationSpace(2);
            this._layoutInformation.setSingleLineContentOnly(true);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * Bind all events listeners on combobox and create the combobox dropdown
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this.setFocusable(true);
          this.setAriaAttribute("expanded", "false");
          this.setAriaAttribute("live", "polite");

          this._toggleIcon = this.getElement().querySelector("i.toggle");

          this.setStyle('i.toggle', {
            'min-width': window.scrollBarSize + 'px',
          });

          // INIT EditWidget
          this._editWidget = cls.WidgetFactory.createWidget('EditWidget', this.getBuildParameters());
          this.getEditWidget().setFocusable(false);
          this.getEditWidget().setParentWidget(this);
          this._element.prependChild(this.getEditWidget().getElement());

          this.getEditWidget().getInputElement().on('blur.ComboBoxWidget', this._onBlur.bind(this));
          this._editFocusHandler = this.getEditWidget().when(context.constants.widgetEvents.requestFocus,
            this._onEditRequestFocus.bind(this));

          // INIT DropDownListWidget
          this._dropDown = cls.WidgetFactory.createWidget('ListDropDown', this.getBuildParameters());
          this.getDropDown().setParentWidget(this);
          this.getDropDown().fallbackMaxHeight = 300;
          this.getDropDown().hide();
          this._dropDownSelectHandler = this.getDropDown().when(context.constants.widgetEvents.select, this._onSelectValue.bind(this));
          this.getDropDown().onClose(this._onToggleDropDown.bind(this));
          this.getDropDown().onOpen(this._onToggleDropDown.bind(this));

          this._visibilityChangeHandler = this.getDropDown()
            .when(context.constants.widgetEvents.visibilityChange, this._updateEditState.bind(this));

          this.setAriaAttribute("owns", this.getDropDown().getRootClassName());
          this.setAriaAttribute("labelledby", this.getEditWidget().getRootClassName());
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._focusHandler) {
            this._focusHandler();
            this._focusHandler = null;
          }
          if (this._editFocusHandler) {
            this._editFocusHandler();
            this._editFocusHandler = null;
          }
          if (this._dropDownSelectHandler) {
            this._dropDownSelectHandler();
            this._dropDownSelectHandler = null;
          }
          if (this._visibilityChangeHandler) {
            this._visibilityChangeHandler();
            this._visibilityChangeHandler = null;
          }

          this.getEditWidget().getInputElement().off('blur.ComboBoxWidget');

          if (this.getDropDown()) {
            this.getDropDown().destroy();
            this._dropDown = null;
          }

          this._typedLettersCacheHandler = null;

          this.getEditWidget().destroy();
          this._editWidget = null;

          $super.destroy.call(this);
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowMultipleValues = mode === "Construct";
          this.getDropDown().allowMultipleChoices(this._allowMultipleValues);
          this._updateEditState();
          this._updateTextTransform();
        },

        /**
         * Returns whether the user should be able to input data freely or not
         * @return {boolean} true if user can input data
         */
        canInputText: function() {
          return this._isQueryEditable && this._allowMultipleValues;
        },

        /**
         * @inheritDoc
         */
        hasDOMFocus: function() {
          return (this.getEditWidget()?.hasDOMFocus()) ||
            $super.hasDOMFocus.call(this);
        },

        /**
         * Focus handler. 
         * Allow the Combobox to keep the focus even when clicking on sub widgets
         * @private
         */
        _onFocus: function() {
          this.setFocus(false);
        },

        /**
         * Handler when focus is requested
         * @param event
         * @param sender
         * @param domEvent
         */
        _onEditRequestFocus: function(event, sender, domEvent) {
          this.emit(context.constants.widgetEvents.requestFocus, domEvent);
        },

        /**
         * get the associate dropdown
         * @returns {classes.ListDropDownWidget}
         */
        getDropDown: function() {
          return this._dropDown;
        },

        /**
         * @inheritDoc
         */
        openDropDown() {
          if (!this.isEnabled()) {
            return;
          }
          this.setValue(this.getDropDown().filterValues(this.getValue()).formattedValues, false);
          this.getDropDown().setSelectedValues(this.getDropDown().filterValues(this.getValue()).values);
          this.getDropDown().show();
        },

        /**
         * Open the DropDown if closed
         * Close the DropDown if opened 
         */
        toggleDropDown() {
          if (!this.isEnabled) {
            return;
          }

          if (this.getDropDown().isVisible()) {
            this.getDropDown().hide();
          } else {
            this.getDropDown().show();
          }

        },

        /**
         * when value is selected in the dropdown
         * @param event
         * @param src
         * @param value
         * @private
         */
        _onSelectValue: function(event, src, value) {
          this.toggleValue(value);
          this.emit(context.constants.widgetEvents.requestFocus);
        },

        /**
         * Handle triggered once the dropdown open or close
         * @private
         */
        _onToggleDropDown: function() {
          this._updateEditState();
          this._toggleIcon.toggleClass("dd-open", this.getDropDown().isVisible());
        },

        /**
         * Blur handler
         * @private
         */
        _onBlur: function() {
          if (!this.getDropDown().isVisible()) {
            this.emit(context.constants.widgetEvents.blur);
          } else if (!this.hasFocus()) {
            this.getDropDown().hide();
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          this.emit(context.constants.widgetEvents.click, domEvent);
          if (!(this._isQueryEditable && domEvent.target.tagName === 'INPUT')) {
            this.emit(context.constants.widgetEvents.openDropDown);
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.getDropDown().isVisible()) {
            keyProcessed = this.getDropDown().managePriorityKeyDown(keyString, domKeyEvent, repeat);
            if (keyProcessed) {
              return true;
            }
          }

          switch (keyString) {
            case "space":
              if (!this._isQueryEditable) {
                this.emit(context.constants.widgetEvents.openDropDown);
                keyProcessed = true;
              }
              break;
            case "up":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() - 1);
              if (!keyProcessed) {
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() - 1);
              }
              break;
            case "down":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() + 1);
              if (!keyProcessed) {
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() + 1);
              }
              break;
            case "pageup":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() - 10);
              if (!keyProcessed) {
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() - 10);
              }
              break;
            case "pagedown":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() + 10);
              if (!keyProcessed) {
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getDropDown().getCurrentIndex() + 10);
              }
              break;
            case "home":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, 0);
              if (!this.canInputText() && !keyProcessed) { // Else let the editWidget manage the event
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, 0);
              }
              break;
            case "end":
              // @short-circuit : keyProcessed ||= this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getItems().length - 1);
              if (!this.canInputText() && !keyProcessed) { // Else let the editWidget manage the event
                keyProcessed = this._manageValueChangeKey(keyString, domKeyEvent, repeat, this.getItems().length - 1);
              }
              break;
            case "del":
            case "delete":
              if (this.getDropDown().isVisible() || !(this.canInputText && this.getEditWidget().hasDOMFocus())) {
                if (!this._notNull || this._allowMultipleValues) {
                  this.setValue("", true);
                }
                keyProcessed = true;
              }
              break;
          }

          if (keyProcessed) {
            return true;
          }
          return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled()) {
            switch (keyString) {
              case "alt+up":
              case "alt+down":
                this.emit(context.constants.widgetEvents.openDropDown);
                keyProcessed = true;
                break;
              case "right":
              case "left":
                // @short-circuit : keyProcessed ||= this.getEditWidget().manageKeyDown(keyString, domKeyEvent, repeat);
                if (!keyProcessed) {
                  keyProcessed = this.getEditWidget().manageKeyDown(keyString, domKeyEvent, repeat);
                }
                break;
            }
            if (!keyProcessed) {
              // auto item preselection by name
              keyProcessed = this._processKey(domKeyEvent, keyString);
            }
          }

          if (keyProcessed) {
            return true;
          }
          return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
        },

        /**
         * Process one key event
         * @param {Object} event
         * @param {string} keyString
         * @returns {boolean} true if key has been processed, false otherwise
         * @private
         */
        _processKey: function(event, keyString) {
          const key = event.gbcKey;

          if (key.length > 1) { // we only want single char
            return false;
          }
          if (this._typedLettersCacheHandler) {
            this._clearTimeout(this._typedLettersCacheHandler);
            this._typedLettersCacheHandler = 0;
          }
          if (!this.getDropDown().isVisible()) {
            if (this.canInputText()) {
              return false;
            }
          }

          const lastChar = key.toLocaleLowerCase();
          this._typedLettersCacheHandler = this._registerTimeout(this._clearTypedLettersCache.bind(this), 400);
          this._typedLetters += lastChar;
          // looking for an item matching with combination of typed chars within 400ms time interval
          let found = this.getDropDown().findStartingByText(this._typedLetters, this._typedLetters.length === 1);
          if (!found) {
            // if no item matched combination of chars we just display next item beginning with last typed char so user can scroll different values
            this._typedLetters = lastChar;
            found = this.getDropDown().findStartingByText(this._typedLetters, true);
          }
          if (found) {
            this.getDropDown().navigateToItem(found);
            if (!this.getDropDown().isVisible()) {
              this.setEditing(this._oldValue !== found.value);
              this.setValue(found.value);
            }
            return true;
          }
          return false;
        },

        _manageValueChangeKey(keyString, domKeyEvent, repeat, index = -1) {
          if (this.getDropDown().isVisible() || this.isInArray()) {
            // Return false as it should be treated by the dropdown or the RTable
            return false;
          }
          // Allow to start at the bottom of the dropdown list if the current index is -1
          if (index < 0 && this.getDropDown().getCurrentIndex() === -1) {
            index = this.getItems().length + (index + 1);
          }
          index = Math.clamp(index, 0, this.getItems().length - 1);

          this.setValue(this.getItems()[index].value, false);
          this.getDropDown().setCurrentIndex(index);
          return true;
        },

        /**
         * Clear the cache of typed letters
         * @private
         */
        _clearTypedLettersCache: function() {
          this._typedLettersCacheHandler = 0;
          this._typedLetters = "";
        },

        /**
         * Get the available items
         * @return {Object[]}
         */
        getItems: function() {
          return this.getDropDown().getItems();
        },

        /**
         * Set combobox items
         * @param {ListDropDownWidgetItem|ListDropDownWidgetItem[]} items - a single or a list of choices
         * @publicdoc
         */
        setItems: function(items) {
          if (!Array.isArray(items)) {
            items = items ? [items] : [];
          }
          /* Get the value before, so when in construct mode
           * the value is the index if it fits an item
           * and not the text of the item
           */
          const currentValue = this.getValue();
          this.getDropDown().setItems(items);
          this.setValue(currentValue);
          if (this._layoutEngine) {
            this._layoutEngine.invalidateMeasure();
          }
        },

        /**
         * @returns {classes.EditWidget} The EditWidget instance
         */
        getEditWidget: function() {
          return this._editWidget;
        },

        /**
         * update edit availability
         * @private
         */
        _updateEditState: function() {
          this.getEditWidget().setReadOnly(this.getDropDown().isVisible() || !this.canInputText());
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          // if autonext is enabled, we execute it on dropdown item click
          return this.hasFocus() && this.getDropDown().isVisible();
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (
            this.canInputText() &&
            this.getDropDown().filterValues(this.getEditWidget().getValue()).formattedValues !== this._value
          ) {
            return this.getEditWidget().getValue();
          }
          return this._value;
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function() {
          return this.getFormattedValue();
        },

        /**
         * Return the current values, formatted for display
         * @param {string} value value
         * @return {string} the formatted values as one string separated by 
         */
        getFormattedValue: function() {
          return this.getDropDown().filterValues(this._value, this.getDialogType() === "Input").formattedText;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);

          if (fromVM) {
            if (this.getEditWidget()) {
              this.getEditWidget().setEditing(false);
            }
            this._lastVMValue = value;
          }

          this._setValue(value, fromVM);
        },

        /**
         * Internal setValue used to be inherited correctly by OtherWidget
         * @param {string} value - the value
         * @param {boolean} [fromVM] - is value come from VM ?
         * @private
         */
        _setValue: function(value, fromVM) {
          const previousValue = this._value;

          const processedValue = this.getDropDown().filterValues(value);

          if (fromVM) {
            this._value = value;
          } else if (this.canInputText() && processedValue.remaining.length > 0) {
            this._value = processedValue.formattedValues;
          } else if (this._allowMultipleValues) {
            this._value = this.getDropDown().sortValues(processedValue.values).join("|");
          } else {
            this._value = processedValue.values[0];
          }

          this.getEditWidget().setValue(this.getFormattedValue());
          this.getDropDown().setSelectedValues(processedValue.values);
          if (!this.getDropDown().isVisible()) {
            this.getDropDown().setCurrentIndexOnLastItem();
          }
          if (!fromVM && previousValue !== this._value) {
            this.triggerValueChangedEvent(this._value);
          }
        },

        /**
         * Toggle the value given in parameter, according to the combobox settings
         * @param {string} value The value key to toggle.
         */
        toggleValue(value) {
          const previousValue = this._value;

          const item = this.getDropDown().findByValue(value);
          if (!item) {
            return;
          }
          this.setEditing(true);

          if (!this._allowMultipleValues || value.match(/^!?=$/) || this._value.match(/^!?=$/)) {
            this._value = value;
          } else {
            const filteredValues = this.getDropDown().filterValues(this._value);
            const valueIndex = filteredValues.values.findIndex(v => v === value);
            if (valueIndex > -1) {
              filteredValues.values.splice(valueIndex, 1);
            } else {
              filteredValues.values.push(value);
            }
            this._value = this.getDropDown().sortValues(filteredValues.values).join("|");
          }

          const processedValue = this.getDropDown().filterValues(this._value);
          this.getEditWidget().setValue(this.getFormattedValue());
          this.getDropDown().setSelectedValues(processedValue.values);

          // Emit if needed
          if (previousValue !== this._value) {
            this.triggerValueChangedEvent(this._value);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse, stayOnSameWidget) {
          $super.setFocus.call(this, fromMouse);

          if (this.getEditWidget()) {
            this.getEditWidget().getInputElement().domFocus();
          } else {
            this._element.domFocus();
          }
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._element.toggleClass('disabled', !enabled);
          this.getEditWidget().setEnabled(enabled);
          this._updateEditState();
          this.getDropDown().setEnabled(enabled);
        },

        /**
         * sets the combobox as query editable
         * @param {boolean} isQueryEditable
         */
        setQueryEditable: function(isQueryEditable) {
          this._isQueryEditable = isQueryEditable;
          this._updateEditState();
          this._updateTextTransform();
        },

        /**
         * @inheritDoc
         */
        setColor: function(color) {
          $super.setColor.call(this, color);
          this.getEditWidget().setColor(color);
          if (this.getDropDown()) {
            this.getDropDown().setColor(color);
          }
        },

        setDefaultColor: function(color) {
          this.setStyle(".zmdi", {
            'color': color
          });
        },

        /**
         * @inheritDoc
         */
        setBackgroundColor: function(color) {
          $super.setBackgroundColor.call(this, color);
          if (this.getDropDown()) {
            this.getDropDown().setBackgroundColor(color);
          }
        },

        /**
         * @inheritDoc
         */
        getColorFromStyle: function() {
          return this.getEditWidget().getColorFromStyle();
        },

        /**
         * @inheritDoc
         */
        setFontWeight: function(weight) {
          $super.setFontWeight.call(this, weight);
          this.getEditWidget().setFontWeight(weight);
          if (this.getDropDown()) {
            this.getDropDown().setFontWeight(weight);
          }
        },

        /**
         * @inheritDoc
         */
        setFontFamily: function(fontFamily) {
          $super.setFontFamily.call(this, fontFamily);
          if (this.getDropDown()) {
            this.getDropDown().setFontFamily(fontFamily);
          }
        },

        /**
         * @inheritDoc
         */
        setFontStyle: function(style) {
          $super.setFontStyle.call(this, style);
          this.getEditWidget().setFontStyle(style);
          if (this.getDropDown()) {
            this.getDropDown().setFontStyle(style);
          }
        },

        /**
         * @inheritDoc
         */
        setFontSize: function(size) {
          $super.setFontSize.call(this, size);
          // apply to dropdown as well
          if (this.getDropDown()) {
            this.getDropDown().setFontSize(size);
          }
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setFontAlign.call(this, align);
          this.getEditWidget().setTextAlign(align);
          if (this.getDropDown()) {
            this.getDropDown().setTextAlign(align);
          }
        },

        /**
         * @inheritDoc
         */
        setTextTransform: function(transform) {
          if (this._textTransform !== transform) {
            this._textTransform = transform;
            this._updateTextTransform();
          }
        },

        /**
         * @inheritDoc
         */
        removeTextTransform: function() {
          this._textTransform = 'none';
          this.getEditWidget().removeTextTransform();
        },

        /**
         * @inheritDoc
         */
        _updateTextTransform: function() {
          const wantedTextTransform = this.canInputText() ? this._textTransform : "none";
          if (wantedTextTransform !== this.getEditWidget().getTextTransform()) {
            this.getEditWidget().removeTextTransform();
            this.getEditWidget().setTextTransform(wantedTextTransform);
          }
        },

        /**
         * @inheritDoc
         */
        setTextDecoration: function(decoration) {
          $super.setTextDecoration.call(this, decoration);
          this.getEditWidget().setTextDecoration(decoration);
        },

        /**
         * Handle a null item if notNull is not specified
         * @param {boolean} notNull - combobox accept notNull value?
         * @publicdoc
         */
        setNotNull: function(notNull) {
          $super.setNotNull.call(this, notNull);
          this.getDropDown().setNotNull(notNull);
        },

        /**
         * @inheritDoc
         */
        setPlaceHolder: function(placeholder) {
          this.setAriaAttribute("placeholder", placeholder);
          this.getEditWidget().setPlaceHolder(placeholder);
        },

        /**
         * @inheritDoc
         */
        setDialogType: function(dialogType) {
          $super.setDialogType.call(this, dialogType);
          this.getDropDown().setDialogType(dialogType);
          this.getDropDown().updateUIList();
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        },

        getCursors: function() {
          if (!this._isQueryEditable) {
            return {
              start: 0,
              end: 0
            };
          }
          return this.getEditWidget().getCursors();
        },

        /**
         * When cursor2 === cursor, it is a simple cursor set
         * @param {number} cursor - starting cursor position
         * @param {number} cursor2 - ending cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!this._isQueryEditable) {
            cursor = cursor2 = 0;
          }
          if (this.getEditWidget()) {
            this.getEditWidget().setCursors(cursor, cursor2);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ComboBox', cls.ComboBoxWidget);
    cls.WidgetFactory.registerBuilder('ComboBoxWidget', cls.ComboBoxWidget);
  });
;

'use strict';

modulum('CommandLinkWidget', ['ButtonWidget', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Button widget CommandLinkWidget.
     * @class CommandLinkWidget
     * @memberOf classes
     * @extends classes.ButtonWidget
     */
    cls.CommandLinkWidget = context.oo.Class(cls.ButtonWidget, function($super) {
      return /** @lends classes.CommandLinkWidget.prototype */ {
        __name: 'CommandLinkWidget',

        /**
         * @type {HTMLElement}
         */
        _titleElement: null,
        /**
         * @type {HTMLElement}
         */
        _commandContainer: null,
        /**
         * @type {HTMLElement}
         */
        _imageContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textElement = this._mtButton.querySelector('span.text');
          this._titleElement = this._mtButton.querySelector('span.title');
          this._commandContainer = this._mtButton.querySelector('div.command');
          this._imageContainer = this._mtButton.querySelector('.gbc_ImageContainer');
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._titleElement = null;
          this._commandContainer = null;
          this._imageContainer = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setImage: function(image) {
          if (this._imageReadyHandler) {
            this._imageReadyHandler();
            this._imageReadyHandler = null;
          }
          if (image.length !== 0) {
            if (!this._image) {
              this._image = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
              this._imageContainer.appendChild(this._image.getElement());

              this.setAutoScale(this._autoScale);
              if (this._defaultColor) {
                this._image.setDefaultColor(this._defaultColor);
              }
            }
            this._image.setSrc(image);
            this._imageReadyHandler = this._image.when(context.constants.widgetEvents.ready, this._imageLoaded.bind(this));
            this.getElement().addClass('hasImage');
          } else if (this._image) {
            this._image.getElement().parentElement.remove();
            this._image.destroy();
            this._image = null;
          }
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._buttonType === 'commandLink') {
            this._titleElement.textContent = title;
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Button[buttonType=commandLink]', cls.CommandLinkWidget);
    cls.WidgetFactory.registerBuilder('CommandLink', cls.CommandLinkWidget);
  });
;

'use strict';

modulum('DateEditWidget', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget using pikaday.
     * @class DateEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditWidget = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateEditWidget.prototype */ {
        __name: 'DateEditWidget',

        $static: {
          /**
           * List of calendar days name
           * @type {Array.<string>}
           */
          pikaDaysList: ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday']
        },

        /**
         * Display or not the week Number
         * @type {?boolean}
         */
        _showWeekNumber: null,

        /**
         * name of the first day of the week
         * @type {string}
         */
        _firstDayOfWeek: null,

        /**
         * Get list of disabled days from calendar
         * @type {Array}
         */
        _disabledDays: null,

        /**
         * Dropdown widget which contains calendar
         * @type {classes.DropDownWidget}
         */
        _dropDown: null,

        /**
         * Button OK of the dropdown
         * @type {classes.ButtonWidget}
         */
        _buttonOk: null,

        /**
         * Button CANCEL of the dropdown
         * @type {classes.ButtonWidget}
         */
        _buttonCancel: null,

        /**
         * List of localized days visible in datepicker
         * @type {Array}
         */
        _localizedDaysList: null,

        /**
         * Reference of calendar instance (based on pikaday-time js library)
         * @type {Object}
         */
        _picker: null,

        /**
         * Type of dropdown. By default, it's in a modal like style
         * @type {boolean}
         */
        _isModal: true,

        /**
         * Listen on theme change to execute a callback
         * @type {function}
         */
        _themeHandleRegistration: null,

        /**
         * Coefficient used as multiplier with default font-size ratio to set dropdown max height
         * @type {number}
         */
        _coeffMaxHeight: 387,
        /**
         * Last user validated value (for calendar of type modal only)
         * @type {string}
         */
        _validValue: null,
        /**
         * Check if current value needs a validation using OK button (for calendar of type modal only)
         * @type {boolean}
         */
        _mustValid: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // create dropdown
          this._createCalendarContainer(true);
        },

        /**
         * Returns dateedit or datetimeedit dropdown
         * @returns {classes.DropDownWidget}
         */
        getDropDown: function() {
          return this._dropDown;
        },

        /**
         * Create calendar container depending on the calendarType 4ST style attribute.
         * By default, we use modal style
         * @param {boolean} isModal - true if we use modal style
         */
        _createCalendarContainer: function(isModal) {

          // destroy previous calendar container
          this._destroyCalendarContainer();

          this._dropDown = cls.WidgetFactory.createWidget('DropDown', this.getBuildParameters());
          this._dropDown.setParentWidget(this);
          this._dropDown.maxHeight = gbc.ThemeService.getValue("theme-font-size-ratio") * this._coeffMaxHeight;
          if (!this._themeHandleRegistration) {
            this._themeHandleRegistration = context.ThemeService.whenThemeChanged(function() {
              this._dropDown.maxHeight = gbc.ThemeService.getValue("theme-font-size-ratio") * this._coeffMaxHeight;
            }.bind(this));
          }

          // For some obscure reasons, iOS may not recognize pikaday library elements as children of dropdown.
          // We need to add a custom "pikaday specific" check
          this._dropDown.shouldClose = function(targetElement) {
            return !targetElement.parent(
              "pika-lendar"); // top pikaday div recognized as (wrongly!) having no parentNode under iOS mobile
          };

          if (isModal) { // MODAL
            // Create button which will close dropdown
            this._buttonCancel = cls.WidgetFactory.createWidget('Button', this.getBuildParameters());
            this._buttonCancel.setParentWidget(this);
            this._buttonCancel.addClass('gbc_DateEditButton');
            this._buttonCancel.setText(i18next.t('gwc.button.cancel'));
            this._buttonCancel.when(context.constants.widgetEvents.click, this._onCancel.bind(this));

            this._buttonOk = cls.WidgetFactory.createWidget('Button', this.getBuildParameters());
            this._buttonOk.setParentWidget(this);
            this._buttonOk.addClass('gbc_DateEditButton');
            this._buttonOk.setText(i18next.t('gwc.button.ok'));
            this._buttonOk.when(context.constants.widgetEvents.click, this._onOk.bind(this));

            this._dropDown.onOpen(this._onCalendarTypeModalOpen.bind(this));
            this._dropDown.onClose(this._onCalendarTypeModalClose.bind(this));

          } else { // DIRECT CLICK
            this._dropDown.onOpen(this._onCalendarTypeDropDownOpen.bind(this));
          }
        },

        /**
         * Destroy calendar container
         * @private
         */
        _destroyCalendarContainer: function() {
          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }
          if (this._buttonOk) {
            this._buttonOk.destroy();
            this._buttonOk = null;
          }
          if (this._buttonCancel) {
            this._buttonCancel.destroy();
            this._buttonCancel = null;
          }
          if (this._themeHandleRegistration) {
            this._themeHandleRegistration();
            this._themeHandleRegistration = null;
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {

          this._pikerIcon = null;

          if (this._inputElement) {
            this._inputElement.remove();
            this._inputElement = null;
          }
          if (this._picker) {
            this._picker.destroy();
            this._picker = null;
          }

          this._destroyCalendarContainer();

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && this._dropDown.isVisible()) {
            let day = null;
            keyProcessed = true;
            switch (keyString) {
              case "home":
                day = context.dayjs(this._picker.getDate()).startOf('month').toDate();
                break;
              case "end":
                day = context.dayjs(this._picker.getDate()).endOf('month').toDate();
                break;
              case "left":
                day = context.dayjs(this._picker.getDate()).subtract(1, 'days').toDate();
                break;
              case "right":
                day = context.dayjs(this._picker.getDate()).add(1, 'days').toDate();
                break;
              case "up":
                day = context.dayjs(this._picker.getDate()).subtract(1, 'weeks').toDate();
                break;
              case "down":
                day = context.dayjs(this._picker.getDate()).add(1, 'weeks').toDate();
                break;
              case "pageup":
                day = context.dayjs(this._picker.getDate()).subtract(1, 'month').toDate();
                break;
              case "pagedown":
                day = context.dayjs(this._picker.getDate()).add(1, 'month').toDate();
                break;
              case "return":
              case "enter":
                this._onOk();
                break;
              case "esc":
                this._onCancel();
                break;
              case "tab":
              case "shift+tab":
                this._onCancel();
                keyProcessed = false;
                break;
              default:
                keyProcessed = false;
            }

            if (keyProcessed && day) {
              this._keyPressed = true;
              this._picker.setDate(day);
            }

            if (!keyProcessed && !this._isModal) {
              // When using dropdown style for the calendar, key pressed should close calendar
              this._mustValid = false;
              this._dropDown.hide();
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled()) {

            keyProcessed = true;
            switch (keyString) {

              case "alt+up":
              case "alt+down":
                this._dropDown.show();
                break;

              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);

          // Manage requestFocus during selection of text
          cls.WidgetBase._onSelect.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus

          if (domEvent.target.isElementOrChildOf(this._pikerIcon)) { // click on calendar icon
            // if widget already has VM focus, we need to explicitly set focus to input when clicking on dateedit icon, otherwise keyboard binding are not trapped.
            // if widget doesn't have VM focus, VM will set focus to input.
            if (this.hasFocus() && this.isEnabled() && !this.isModal()) {
              this._inputElement.domFocus();
            }
            this.emit(context.constants.widgetEvents.openDropDown);
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        openDropDown() {
          if (this.isEnabled()) {
            this._dropDown.show();
          }
        },

        /**
         * Shortcut to close the dropdown
         * @param {Boolean} accept - true to simulate OK button, false for Cancel button
         */
        closeDropDown: function(accept) {
          if (accept) {
            this._onOk();
          } else {
            this._onCancel();
          }
        },

        /**
         * Handler to validate current date and send it to VM
         */
        _onOk: function() {
          this._mustValid = false;
          if (!this.getValue()) { // if empty field with enter key pressed on calendar, we set with date of the day
            this._inputElement.value = this.getDate();
          }
          this._dropDown.hide();
          const newValue = this.getValue();
          this.setEditing(newValue !== this._oldValue);
          this.setCursors(newValue.length, -1); // set cursors to the end to help autonext check happening
          this.triggerValueChangedEvent(newValue);
        },

        /**
         * Handler which cancel date modifications and close calendar
         */
        _onCancel: function() {
          this._dropDown.hide();
        },

        // -- Calendar type (Modal/Dropdown) specific functions --

        /**
         * Synchronize field date and picker date on calendar display
         */
        _onCalendarTypeDropDownOpen: function() {
          // init date picker with field date if possible otherwise we set current day date.
          this._dropDown.setAriaSelection();
          this.setDate(this.getValue());
        },

        /**
         * Add buttons in dropdown bellow calendar and synchronize field date and picker date on calendar display
         */
        _onCalendarTypeModalOpen: function() {
          const inputElement = this.getInputElement();
          if (inputElement) {
            inputElement.setAttribute("readonly", "readonly");
          }
          // add buttons
          if (this._dropDown) {
            this._addButtonsToPicker();
          }
          this._validValue = this.getValue();
          this._onCalendarTypeDropDownOpen();
          this._mustValid = true;
        },

        /**
         * Remove buttons from dropdown, cancel pending changes and close calendar
         */
        _onCalendarTypeModalClose: function() {
          this.setAriaSelection();
          const inputElement = this.getInputElement();
          if (inputElement) {
            inputElement.removeAttribute("readonly");
          }
          if (this._dropDown) {
            this._removeButtonsFromPicker();
          }
          if (this._mustValid) {
            this._mustValid = false;
            this.setLastValidValue();
          }
          this._validValue = null;
        },

        /**
         * Handler use to select and validate date on double click
         * @param {string} date - date to take in string format
         */
        _onDateSelect: function(date) {
          this.getInputElement().value = context.dayjs(date).format(this._getPickerConf().format);
          if (!this._keyPressed) {
            // if not modal or double-clicked
            if ((!this.isModal() && this.hasFocus()) || this._isDoubleClick()) {
              this.setEditing(true);
              this._mustValid = false;
              this._dropDown.hide();
              const newValue = this.getValue();
              this.setCursors(newValue.length, -1);
              this.triggerValueChangedEvent(newValue);
            }
          }
          this._keyPressed = false;
        },

        /**
         * Detect double click
         * @returns {boolean} returns true if user double clicked
         */
        _isDoubleClick: function() {
          const inputValue = this.getValue();
          const isDoubleClick = (new Date() - this._lastClick) < 350 && this._lastClickValue === inputValue;
          this._lastClick = new Date();
          this._lastClickValue = inputValue;
          return isDoubleClick;
        },

        /**
         * Needed by picker plugin to avoid formatting before VM send value
         * @param {string} value - value given by picker plugin
         * @param {string=} format - not used by GBC
         * @return {string} the value is return as it
         * @private
         */
        _parse: function(value, format) {
          return value;
        },

        /**
         * Get configuration object used to generate calendar component using pikaday-time framework
         * @returns {Object} returns pikaday-time js library configuration object
         */
        _getPickerConf: function() {
          const pickerConf = {
            field: this._inputElement,
            bound: false,
            container: this._dropDown.getElement(),
            parse: this._parse,
            format: this._displayFormat,
            firstDay: this._firstDayOfWeek || 0,
            showWeekNumber: Boolean(this._showWeekNumber),
            showTime: false,
            disableDayFn: this._disableDayFn,
            yearRange: 100,
            i18n: {
              previousMonth: i18next.t('gwc.date.previousMonth'),
              nextMonth: i18next.t('gwc.date.nextMonth'),
              months: this._localizedMonthsList,
              weekdays: this._localizedDaysList,
              weekdaysShort: this._localizedWeekdaysShortList,
              midnight: i18next.t('gwc.date.midnight'),
              noon: i18next.t('gwc.date.noon')
            },
            setDefaultDate: false
          };
          if (this._useMingGuoYears) {
            pickerConf.onSelect = function(date) {
              const year = date.getFullYear();
              const mgyear = cls.DateTimeHelper.gregorianToMingGuoYears(date);
              const newVal = this.getValue().replace(year, mgyear);
              this._inputElement.value = newVal;
              if (!this.isModal()) {
                this._dropDown.hide();
                this.setCursors(newVal.length, -1);
                this.triggerValueChangedEvent(newVal);
              }
            }.bind(this);
          } else {
            pickerConf.onSelect = this._onDateSelect.bind(this);
          }

          return pickerConf;
        },

        /**
         * Add OK/Cancel buttons to calendar
         */
        _addButtonsToPicker: function() {
          if (this._buttonCancel && this._buttonOk) {
            this._dropDown.getElement().appendChild(this._buttonOk.getElement());
            this._dropDown.getElement().appendChild(this._buttonCancel.getElement());
          }
        },

        /**
         * Remove OK/Cancel buttons to calendar
         */
        _removeButtonsFromPicker: function() {
          if (this._buttonCancel && this._buttonOk) {
            try {
              this._dropDown.getElement().removeChild(this._buttonOk.getElement());
              this._dropDown.getElement().removeChild(this._buttonCancel.getElement());
            } catch (e) {}
          }
        },

        /**
         * Set calendar type. By default, modal type (4ST style) is used.
         * @param {string} calendarType - calendar type
         * @publicdoc
         */
        setCalendarType: function(calendarType) {
          const modalStyle = calendarType !== 'dropdown';
          if (this._isModal !== modalStyle) {
            this._isModal = modalStyle;
            this._createCalendarContainer(modalStyle);
          }
        },

        /**
         * Return calendar type
         * @returns {boolean} true if calendar has modal style
         * @publicdoc
         */
        isModal: function() {
          return this._isModal;
        },

        /**
         * Create the calendar object component and bind it on the input field
         * @publicdoc
         */
        initDatePicker: function() {
          this._localizedDaysList = i18next.t('gwc.date.dayList').split(',');
          this._localizedMonthsList = i18next.t('gwc.date.monthList').split(',');
          this._localizedWeekdaysShortList = i18next.t('gwc.date.weekdaysShort').split(',');

          if (this._picker) {
            this._picker.destroy();
          }
          const pickerConf = this._getPickerConf();
          this._picker = new Pikaday(pickerConf);
          if (!this.isModal()) {
            this._picker.bound = true;
          }
          if (this._picker._onKeyChange) { // remove unwanted native pikaday library event
            document.removeEventListener('keydown', this._picker._onKeyChange, false);
          }
          if (this._dateObj && this._dateObj.isValid()) {

            this._picker.setDate(this._dateObj.toISOString());
          }

          if (this._disabledDays && this._sortedDays) {
            for (const element of this._disabledDays) {
              const index = this._sortedDays.indexOf(element) + (this._showWeekNumber ? 1 : 0);
              this._picker.el.addClass("disabled" + index);
            }
          }
        },

        /**
         * Define first day of the week of the calendar
         * @param {string} firstDayOfWeek - Localized name of the day to set as first day of the week
         * @publicdoc
         */
        setFirstDayOfWeek: function(firstDayOfWeek) {
          if (firstDayOfWeek) {
            const dayList = cls.DateEditWidget.pikaDaysList;

            this._firstDayOfWeek = dayList.indexOf(firstDayOfWeek);
          } else {
            this._firstDayOfWeek = context.dayjs.localeData(context.StoredSettingsService.getLanguage()).firstDayOfWeek();
          }
          if (this._firstDayOfWeek >= 0) {
            const end = cls.DateEditWidget.pikaDaysList.slice(0, this._firstDayOfWeek);
            this._sortedDays = cls.DateEditWidget.pikaDaysList.slice(this._firstDayOfWeek);
            this._sortedDays = this._sortedDays.concat(end);
          }
        },

        /**
         * Returns first day of the week name
         * @returns {string} English name of the currently set first day of the week
         * @publicdoc
         */
        getFirstDayOfWeek: function() {
          const dayList = cls.DateEditWidget.pikaDaysList;
          return dayList[this._firstDayOfWeek];
        },

        /**
         * Return calendar disabled days list
         * @returns {Array} Array of days that are disabled
         * @publicdoc
         */
        getDisabledDays: function() {
          return this._disabledDays;
        },

        /**
         * Define disabled day of the calendar
         * @param {string} disabledDays - names separated with whitespace
         * @publicdoc
         */
        setDisabledDays: function(disabledDays) {
          if (!disabledDays) {
            disabledDays = "saturday sunday";
          }
          // name of disabled days
          this._disabledDays = disabledDays.split(' ');
        },

        /**
         * Generate dayjs date object from a string and set it for both the calendar component and the input field
         * @param {string} date - date value in string format
         * @publicdoc
         */
        setDate: function(date) {
          $super.setDate.call(this, date);

          // on dropdown opening, check if date is valid and set the calendar with it
          if (this._dropDown.isVisible()) {
            const dateObj = this.getDate();
            if (!dateObj || dateObj === 'Invalid date') { // if invalid date, we set with current day date
              this._dateObj = context.dayjs();
            }
            if (this._picker) {
              this._picker.setDate(this._dateObj.toISOString(), true);
              this._inputElement.value = this._dateObj.format(this.getFormat());
            }
          }
        },

        /**
         * Display or hide week number
         * @param {boolean} show - if true display week number, hide otherwise
         * @publicdoc
         */
        showWeekNumber: function(show) {
          this._showWeekNumber = show;
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (enabled && !this._picker) { // if first time we enable datepicker, we initialize it
            this.initDatePicker();
          }
          if (this._dropDown) {
            this._dropDown.setEnabled(enabled);
          }
          this._setInputReadOnly(!enabled);
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          $super.setMaxLength.call(this, maxLength);
          if (maxLength > 0) {
            //The maxlength is the real input size, so we put the maxlength into the vmWidth
            //to be able to trigger the AutoNext
            this._vmWidth = maxLength;
          }
        },

        /**
         * @inheritDoc
         */
        setVMWidth: function(width) {}

      };
    });
    cls.WidgetFactory.registerBuilder('DateEdit', cls.DateEditWidget);
  });
;

'use strict';

modulum('DateTimeEditWidget', ['DateEditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget.
     * @class DateTimeEditWidget
     * @memberOf classes
     * @extends classes.DateEditWidget
     * @publicdoc Widgets
     */
    cls.DateTimeEditWidget = context.oo.Class(cls.DateEditWidget, function($super) {
      return /** @lends classes.DateTimeEditWidget.prototype */ {
        __name: 'DateTimeEditWidget',

        /**
         * Override dateedit max height coeff
         */
        _coeffMaxHeight: 425,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);
            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);

          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';
        },

        /**
         * @inheritDoc
         */
        _getPickerConf: function() {
          const pickerConf = $super._getPickerConf.call(this);
          pickerConf.showTime = true;
          pickerConf.showSeconds = this._showSeconds;
          return pickerConf;
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          $super.setFormat.call(this, format);
          this._showSeconds = Boolean(~format.toLowerCase().indexOf('s'));
          if (this._picker) {
            this._picker.destroy();
          }
          this.initDatePicker();
        }

      };
    });
    cls.WidgetFactory.registerBuilder('DateTimeEdit', cls.DateTimeEditWidget);
  });
;

"use strict";

modulum('DeprecatedFileUploadEditWidget', ['EditWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DeprecatedFileUploadEdit widget.
     * @class DeprecatedFileUploadEditWidget
     * @memberOf classes
     * @extends classes.EditWidget
     */
    cls.DeprecatedFileUploadEditWidget = context.oo.Class(cls.EditWidget, function($super) {
      return /** @lends classes.DeprecatedFileUploadEditWidget.prototype */ {
        __name: "DeprecatedFileUploadEditWidget",
        __templateName: "EditWidget",
        _initElement: function() {
          $super._initElement.call(this);
          this.setEnabled();
          $super.setValue.call(this, "DEPRECATED: The style='FileUpload' is not supported by GBC. Please use fgl_getfile().");
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {},
      };
    });
    cls.WidgetFactory.registerBuilder('Edit.FileUpload', cls.DeprecatedFileUploadEditWidget);
  });
;

'use strict';

modulum('EditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Edit widget.
     * @class EditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.EditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.EditWidget.prototype */ {

        __name: 'EditWidget',

        _completerCurrentChildrenChangeHandler: null,

        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        _completerWidget: null,
        _inputType: null,
        _inputMode: null,
        _displayFormat: null,

        _title: null,

        /** @type {?number} */
        _completerValueChangedDelayer: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.EditLayoutEngine(this);
            this._layoutInformation.setSingleLineContentOnly(true);

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];

          // needed for completer
          this._inputElement.on('blur.EditWidget', this._onBlur.bind(this));

          this._notEditable = false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._inputElement) {
            this._inputElement.off('blur.EditWidget');
            this._inputElement.remove();
            this._inputElement = null;
          }
          if (this._completerWidget) {
            this._completerWidget.destroy();
            this._completerWidget = null;
            if (this._completerCurrentChildrenChangeHandler) {
              this._completerCurrentChildrenChangeHandler();
              this._completerCurrentChildrenChangeHandler = null;
            }
            this.cancelCompleterValueChangedDelayer();
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        hasFocus: function() {
          const parentWidget = this.getParentWidget();
          if (parentWidget && (
              parentWidget.isInstanceOf(cls.ButtonEditWidget) ||
              parentWidget.isInstanceOf(cls.ComboBoxWidget)
            )) {
            // if edit widget is in composed widget, must check parent focus to know if it has VM focus
            return parentWidget.hasFocus();
          }

          return $super.hasFocus.call(this);
        },

        /**
         * Return completer dropdown if edit is a completer, otherwise returns null
         * @returns {null}
         */
        getDropDown: function() {
          return this._completerWidget;
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);

          // Manage requestFocus during selection of text
          cls.WidgetBase._onSelect.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.hasCompleter()) {
            keyProcessed = this.getCompleterWidget().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }

          this._updateCapsLockWarning();

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        _checkValue: function(text, newTextPart) {
          if (this._dialogType !== 'Input' && this._dialogType !== 'InputArray') {
            return newTextPart;
          }

          if (!this._scroll || this._dataTypeWithNoScroll) {
            newTextPart = this.checkValueDisplayWidth(text, newTextPart);
          }

          if (this._maxLength > 0) {
            if (this.getUserInterfaceWidget().isCharLengthSemantics()) {
              newTextPart = newTextPart.substring(0, this._maxLength - text.length);
            } else {
              newTextPart = this.checkValueByteCount(text, newTextPart, this._maxLength);
            }
          }

          return newTextPart;
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          const text = this.getValue();
          const size = text ? text.length : 0;

          if (this.hasCompleter()) {
            if (this.getCompleterWidget().canAutoNext()) {
              return true;
            }
          }

          if (size > 0) {
            const cursors = this.getCursors();
            const endReached = cursors.start === cursors.end && cursors.start + 1 > size;

            if (endReached) {
              if (!this._scroll || this._dataTypeWithNoScroll) {
                const displayWidth = this._vmWidth;
                const maxLength = this.getUserInterfaceWidget().isCharLengthSemantics() ? this._maxLength : -1;
                const codepoints = Array.from(text);

                if (text.displayWidth() >= displayWidth || (maxLength > 0 && codepoints.length >= maxLength)) {
                  return true;
                }
              }

              if (this._maxLength > 0) {
                if (!this.getUserInterfaceWidget().isCharLengthSemantics()) {
                  return text.countBytes() >= this._maxLength;
                }

                return text.length >= this._maxLength;
              }
            }
          }

          return false;
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          // sometimes we have to display dropdown again without VM interaction
          // case occurs when we select an item, close dropdown and rollback selected item. In this case
          if (this._completerWidget &&
            this.getValue() &&
            this.getValue() === this._oldValue &&
            !this._completerWidget.isVisible()) {
            this._completerWidget.show();
          }

          this.controlValueLength(event);
          if (!this.getInputTextState().isRestored()) {
            if (this.hasCompleter()) {
              this.cancelCompleterValueChangedDelayer();
              this._completerValueChangedDelayer = this._registerTimeout(function() {
                this.triggerValueChangedEvent(this.getValue());
                this._completerValueChangedDelayer = null;
              }.bind(this), 300); // send value after a 300ms delay
            } else {
              this.triggerValueChangedEvent(this.getValue(), false);
            }
          }

          return true;
        },

        /**
         * Cancel valueChanged delayer (when completer)
         * @returns {boolean} true if timer has been cancelled
         */
        cancelCompleterValueChangedDelayer: function() {
          if (this._completerValueChangedDelayer) {
            this._clearTimeout(this._completerValueChangedDelayer); // clear timer
            this._completerValueChangedDelayer = null;
            return true;
          }
          return false;
        },

        /**
         * Blur handler
         * @param {Object} event
         * @private
         */
        _onBlur: function(event) {
          this.emit(context.constants.widgetEvents.blur, event);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          if (this._isReadOnly !== readonly) {
            $super.setReadOnly.call(this, readonly);
            this._setInputReadOnly(readonly || this._notEditable || !this._enabled);
          }
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          this._setElementAttribute('readonly', readonly ? 'readonly' : null, "_inputElement");
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          $super.setMaxLength.call(this, maxLength);
          if (maxLength > 0) {
            this._setElementAttribute('maxlength', maxLength + 1, "_inputElement");
          }
        },

        /**
         * Defines the alignment of the text in the input
         * @see http://www.w3.org/wiki/CSS/Properties/text-align
         * @param {string} align - a CSS text alignment. null restores the default value.
         * @publicdoc
         */
        setTextAlign: function(align) {
          this._textAlign = align;
          this.setStyle('>input', {
            'text-align': align
          });

          this.setStyle('>input:focus', {
            'text-align': align
          });
        },

        /**
         * Define the 'size' attribute of the input
         * @param {number} cols - size attribute
         * @publicdoc
         */
        // TODO: GBC-3740 missing redefinition in buttonedit (unlike all others public methods) ? why ?
        setCols: function(cols) {
          this._inputElement.setAttribute('size', cols);
        },

        /**
         * Get the alignment of the text
         * @see http://www.w3.org/wiki/CSS/Properties/text-align
         * @returns {string} a CSS text alignment
         * @publicdoc
         */
        getTextAlign: function() {
          return this.getStyle('>input', 'text-align');
        },

        /**
         * Check if the widget format is number
         * @return {boolean} true if the widget format is number, false otherwise
         */
        isNumber: function() {
          const regex = /SMALLINT|INTEGER|BIGINT|INT|DECIMAL|MONEY|SMALLFLOAT|FLOAT/g;
          const match = regex.exec(this.getDisplayFormat());
          return Boolean(match);
        },

        /**
         * Get the display format if any
         * @return {?string} the display format
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format - display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * @inheritDoc
         */
        traditionalDisplay: function(letterSpacing, fieldHeight, heightPadding) {
          const layoutInfo = this.getLayoutInformation();

          if (layoutInfo) {
            const left = layoutInfo.getGridX() - 1;
            const top = (layoutInfo.getGridY()) * (fieldHeight + 2 * heightPadding) + heightPadding;
            const width = layoutInfo.getGridWidth() + 1;
            const height = layoutInfo.getGridHeight() * fieldHeight;

            const style = this._element.parentElement.style;
            layoutInfo.getHostElement().toggleClass(layoutInfo.className, true);
            style.left = 'calc(' + left + 'ch + 1ch / 2 + ' + left + ' * ' + letterSpacing + ')';
            style.top = top + 'px';
            style.width = 'calc(' + width + 'ch + ' + width + ' * ' + letterSpacing + ')';
            style.height = height + 'px';
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);
          this._inputElement.value = value;

          try {
            if (cursorPosition !== null && this.isEnabled()) {
              this._inputElement.selectionStart = this._inputElement.selectionEnd = cursorPosition;
            }
          } catch (e) {}
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          let result = null;
          if (this._inputElement) {
            result = this._inputElement.value;
            if (this.isEditing()) {
              if (this.getTextTransform() === 'up') {
                result = result.toLocaleUpperCase();
              }
              if (this.getTextTransform() === 'down') {
                result = result.toLocaleLowerCase();
              }
            } else if (this._editingTime === 0 && this._oldValue) { // not touched by user
              // return exact VM value to avoid bad conversion from \r to \n
              result = this._valueStack[this._valueStackCursor];
            }
          }
          return result;
        },

        /**
         * Set the cursors
         * When cursor2 === cursor, it is a simple cursor set
         * @param {number} cursor - the selection range beginning (-1 for end)
         * @param {number=} [cursor2] - the selection range end, if any
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }

          if (cursor2 && cursor2 < 0) {
            cursor2 = this.getValue() && this.getValue().length || 0;
          }

          if (this.isInTable() && !this.isEnabled()) { // fix for GBC-1170
            cursor = cursor2 = 0;
          }

          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          const cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * Set field as a password (displays bullets instead of value)
         * @param {boolean} isPassword - true if the widget should be in 'password' mode, false otherwise
         * @publicdoc
         */
        setIsPassword: function(isPassword) {
          if (isPassword) {
            this._inputElement.setAttribute('type', 'password');
          } else {
            this._inputElement.setAttribute('type', this._inputType);
            this.setType(this._inputType);
          }
          this.toggleClass("gbc_isPassword", Boolean(isPassword));
        },

        /**
         * Check if field is set as password
         * @returns {boolean} true if the widget is in 'password' mode, false otherwise
         * @publicdoc
         */
        isPassword: function() {
          return this._inputElement.getAttribute('type') === 'password';
        },

        /**
         * Display or not the caps lock warning
         * @private
         */
        _updateCapsLockWarning: function() {
          if (this.isPassword()) {
            // Check if caps lock is on, and display accordingly
            if (!window.browserInfo.isSafari) { // Safari add this by itself
              this.removeClass("capsOn");
              if (window._capsLock) {
                this.addClass("capsOn");
              }
            }
          }
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType the type attribute value to set
         * @publicdoc
         */
        setType: function(valType) {
          if (this._inputType !== valType) {
            this._inputType = valType;
            if (!this.isPassword()) {
              this._inputElement.setAttribute('type', valType);
              if (window.browserInfo.isFirefox) {
                // sad old browser patch
                this._inputElement.setAttribute('step', valType === 'number' ? 'any' : null);
              }
            }
          }
        },

        /**
         * Used to manage the keyboardHint.
         * @param {string} valType the inputmode attribute value to set
         * @publicdoc
         */
        setInputMode: function(valType) {
          if (this._inputMode !== valType) {
            this._inputMode = valType;
            this._inputElement.setAttribute('inputmode', valType);
          }
        },

        /**
         * Get the type of the field
         * @returns {string} this Edit current type
         * @publicdoc
         */
        getType: function() {
          return this._inputType;
        },

        /**
         * Get the inputMode of the field
         * @returns {string} this Edit current type
         * @publicdoc
         */
        getInputMode: function() {
          return this._inputMode;
        },

        /**
         * Sets the focus to the widget
         * @publicdoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);

          this._inputElement.domFocus();
          this._updateCapsLockWarning();

          if (this.isFakePlaceholder() && this._title &&
            ((window.isMobile() && context.ThemeService.getValue("gbc-Edit-mobile-comment-to-placeholder") === '1') ||
              (!window.isMobile() && context.ThemeService.getValue("gbc-Edit-desktop-comment-to-placeholder") === '1'))) {
            this.setPlaceHolder(this._title, true);
          }
        },

        /**
         * @inheritDoc
         */
        setDialogType: function(dialogType) {
          $super.setDialogType.call(this, dialogType);
        },

        /**
         * @inheritDoc
         */
        loseVMFocus: function(vmNewFocusedWidget = null) {
          $super.loseVMFocus.call(this, vmNewFocusedWidget);
          if (this.isFakePlaceholder()) {
            this.setPlaceHolder("", true);
          }
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          if (this.isFakePlaceholder()) {
            this.setPlaceHolder("", true);
          }
          if (this._completerWidget) {
            this._completerWidget.loseFocus();
          }
        },

        /**
         * Check if the Edit Widget has a completer
         * @return {boolean} true if it has a completer, false otherwise
         */
        hasCompleter: function() {
          return this.getCompleterWidget() !== null;
        },

        /**
         * Get the completer widget if any
         * @return {?classes.CompleterWidget} the completer widget, null if none
         * @publicdoc
         */
        getCompleterWidget: function() {
          return this._completerWidget;
        },

        /**
         * Will add a completer to the edit
         * @publicdoc
         */
        addCompleterWidget: function() {
          if (!this._completerWidget) {
            this._completerWidget = cls.WidgetFactory.createWidget('Completer', this.getBuildParameters());
            this._completerWidget.addCompleterWidget(this);
            this._completerCurrentChildrenChangeHandler = this._completerWidget.onCurrentChildrenChange(function(value) {
              this.setEditing(this._oldValue !== value);
              this.setValue(value);
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (this._textAlign) {
            this.setTextAlign(this._textAlign);
          }
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);

          if (title === "") {
            this._inputElement.removeAttribute("aria-label");
            this._title = null;
          } else {
            this._inputElement.setAttribute("aria-label", title);
            this._title = title;
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          if (this._parentWidget instanceof cls.ComboBoxWidget) {
            return this._parentWidget.getClipboardAuthorizedAction();
          }

          return $super.getClipboardAuthorizedAction.call(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Edit', cls.EditWidget);
    cls.WidgetFactory.registerBuilder('EditWidget', cls.EditWidget);
  });
;

"use strict";

modulum('FieldWidgetBase', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Base class for genero formfield widgets
     * @class FieldWidgetBase
     * @memberOf classes
     * @publicdoc Widgets
     * @extends classes.TextWidgetBase
     */
    cls.FieldWidgetBase = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.FieldWidgetBase.prototype */ {
        __name: "FieldWidgetBase",
        /**
         * Flag for augmentedFace
         * @type {boolean}
         */
        __virtual: true,

        /**
         * List of values through time
         * @type {Array}
         */
        _valueStack: null,

        /**
         * Flag to know if the placeholder contain the real one (it could be the comment)
         * @type {boolean}
         */
        _isFakePlaceholder: true,

        /**
         * true if widget has pending changes
         * @type {boolean}
         */
        _editing: false,

        /**
         * true if widget is readOnly and can't be edited nor focused
         * @type {boolean}
         * */
        _isReadOnly: false,

        /**
         * The input element. This variable is not instantiated in this class
         * @protected
         * @type {HTMLInputElement}
         */
        _inputElement: null,

        /***
         * Time of the last widget modification
         * @type {number}
         */
        _editingTime: 0,

        /**
         * Position of the current value in the stack
         * @type {Number}
         */
        _valueStackCursor: -1,

        /**
         * Old value, last value received from VM
         * @type {?string}
         */
        _oldValue: null,

        /**
         * true if widget should not be editable but navigation is possible
         * @type {boolean}
         */
        _notEditable: false,

        /**
         * true if widget requires a value
         * @type {boolean}
         */
        _required: false,

        /**
         * true if widget is set as not Null
         * @type {boolean}
         */
        _notNull: false,

        /**
         * List of possible values for the widget
         * @type {?Array}
         */
        _include: null,

        /**
         * Flag to check if the mouse button is currently pressed
         * @type {boolean}
         */
        _isMousePressed: false,

        /**
         * Input element text state component
         * @type {classes.InputTextStateComponent}
         */
        _inputTextState: null,

        /**
         * Scroll attribute value
         * @type {?boolean}
         */
        _scroll: null,

        /**
         * true if must ignore the scroll attribute (equivalent to scroll = 0)
         * @type {boolean}
         */
        _dataTypeWithNoScroll: false,

        /**
         * Maximum number of characters allowed. By default, 0 indicates no limit.
         * @type {number}
         */
        _maxLength: 0,

        /**
         * widget VM width
         * @type {number}
         */
        _vmWidth: 0,

        /**
         * AutoNext activated ?
         * @type {boolean}
         */
        _autoNext: false,

        /**
         * true if we are between a key down and key yp event
         * @type {?boolean}
         */
        _processingKeyEvent: null,

        /**
         * Input picture component
         * @type {classes.InputPictureWidgetComponent}
         */
        _pictureComponent: null,

        /**
         * @constructs
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setEnabled(false, true);
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._valueStack = [];
          if (window.isMobile()) {
            const inputElement = this._element.getElementsByTagName('input')[0];
            if (inputElement) {
              // Track the focus and mouse down/up events on mobile devices to handle the virtual keyboard's TAB key
              inputElement.on('focus.FieldWidgetBase', this._onMobileFocus.bind(this));
            }
          }

          this._processingKeyEvent = false;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);

          this._valueStack = null;
          this._oldValue = null;

          if (this._pictureComponent) {
            this._pictureComponent.destroy();
            this._pictureComponent = null;
          }

          if (this._inputElement && this.isNotEditable()) {
            this._inputElement.off('drop.FieldWidgetBase_notEditable');
          }

          if (this._inputElement && window.isMobile()) {
            this._inputElement.off('focus.FieldWidgetBase');
          }

          this._inputElement = null;

          if (this._inputTextState) {
            this._inputTextState.destroy();
            this._inputTextState = null;
          }
        },

        /**
         * Get the input part of the widget
         * @return {HTMLElement} the input part of the widget
         * @publicdoc
         */
        getInputElement: function() {
          return this._inputElement;
        },

        /**
         * Check if the widget has an input element
         * @return {boolean} true if widget has an input element
         * @publicdoc
         */
        hasInputElement: function() {
          return Boolean(this.getInputElement());
        },

        /**
         * Trigger valueChanged event if necessary
         * @param {string|number} newValue - new value of the widget // TODO newValue should be always a string
         * @param {boolean} [sendValue] - if true new value must be sent to VM
         */
        triggerValueChangedEvent: function(newValue, sendValue = true) {
          if (sendValue === false || newValue?.toString() !== this._oldValue) {
            this.emit(context.constants.widgetEvents.valueChanged, newValue, sendValue);
          }
        },

        /**
         * Set the value of widget
         * @param {string|number} value - sets the value to display
         * @param {boolean} [fromVM] - true if value comes from the VM
         * @param {?number} [cursorPosition] - set the cursor to this position
         * @publicdoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          if (this.hasCursors() && !fromVM) { // only widgets with cursors manage undo/redo
            this._valueStack.push(value);
            this._valueStackCursor++;
          }

          if (fromVM) {
            if (this.getValue() !== value) {
              this._valueStack = [value];
              this._valueStackCursor = 0;
            } else {
              this._valueStack.push(value);
              this._valueStackCursor++;
            }
            this._oldValue = value;
          }

          if (this._valueStack.length > 30) {
            this._valueStack.shift();
            this._valueStackCursor--;
          }
        },

        /**
         * Internal setValue to change value without any event emitted
         * @param {string} value - the value
         * @private
         */
        _setValue: function(value) {
          if (this.hasInputElement()) {
            this.getInputElement().value = value;
          }
        },

        /**
         * Internal getValue to get simply the string value of input element
         * @return {?string} the value
         * @private
         */
        _getInputElementValue: function() {
          if (this.hasInputElement()) {
            return ( /** @type {HTMLInputElement} */ this.getInputElement()).value;
          }
          return null;
        },

        /**
         * Executed on a mouse down event
         */
        manageMouseDown: function(domEvent) {
          if (window.isMobile()) {
            const inputElement = this._element.getElementsByTagName('input')[0];
            if (inputElement) {
              this._onMobileMouseDown.call(this, domEvent);
            }
          }
          return true;
        },

        /**
         * Executed on a mouse up event
         */
        manageMouseUp: function(domEvent) {
          if (window.isMobile()) {
            const inputElement = this._element.getElementsByTagName('input')[0];
            if (inputElement) {
              this._onMobileMouseUp.call(this, domEvent);
            }
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        manageBeforeInput: function(dataString = "", event = null) {
          // backup current text just before input
          this.getInputTextState().backup();

          return true;
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          // Prevent input event
          // 1. Not editable
          // 2. Android: it has no VM focus
          const preventInput = this.isNotEditable() || (window.isAndroid() && !this.hasFocus());
          if (preventInput) {
            this.getInputTextState().restore("");
            return;
          }

          this._pictureComponent?.manageInput(dataString, event);

          this._editingTime = Date.now();
          this.setEditing(this.isEditing() || this.getValue() !== this._oldValue);
          if (this.isEditing() && this._textTransform !== 'none' && this.hasInputElement()) {
            // TODO what is the purpose of this code ?
            const start = this._inputElement.selectionStart;
            const end = this._inputElement.selectionEnd;
            this._inputElement.value = this.getValue();
            this._inputElement.setCursorPosition(start, end);
          }
        },

        /**
         * Handle drop event
         * @param evt
         * @private
         */
        _onDrop: function(evt) {
          if (this.isNotEditable()) {
            evt.preventCancelableDefault();
          }
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @param {boolean} notEditable - true to set the edit part as read-only
         */
        setNotEditable: function(notEditable) {
          this._notEditable = notEditable;
          if (this._inputElement) {
            if (notEditable) {
              this._inputElement.on('drop.FieldWidgetBase_notEditable', this._onDrop.bind(this));
            } else {
              this._inputElement.off('drop.FieldWidgetBase_notEditable');
            }
          }
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @return {boolean} true if the edit part is not editable
         */
        isNotEditable: function() {
          return this._notEditable;
        },

        /**
         * Set the widget validation to 'required'
         * @param {boolean} required - true if a value is required
         */
        setRequired: function(required) {
          this._required = required;
          this.toggleClass("gbc_Required", required);
        },

        /**
         * Verify if the widget value is required
         * @return {boolean} true if a value is required
         */
        isRequired: function() {
          return this._required;
        },

        /**
         * Verify if the placeholder is the real one
         * @return {boolean} true if it is a fake placeholder
         */
        isFakePlaceholder: function() {
          return this._isFakePlaceholder;
        },

        /**
         * Set the widget validation to noNull
         * @param {boolean} notNull - false if the widget value can be null, true otherwise
         */
        setNotNull: function(notNull) {
          this._notNull = notNull;
          this.toggleClass("gbc_NotNull", notNull);
        },

        /**
         * Verify if the widget can be null
         * @return {boolean} false if the widget value can be null, true otherwise
         */
        isNotNull: function() {
          return this._notNull;
        },

        /**
         * Get the list of allowed values defined by INCLUDE list
         * @param {Array|null} include - list of allowed values or null if not defined
         */
        setAllowedValues: function(include) {
          this._include = include;
        },

        /**
         * Get the list of allowed values defined by INCLUDE list
         * @return {Array|null} list of allowed values or null if not defined
         */
        getAllowedValues: function() {
          return this._include;
        },

        /**
         * Prevent value change but allow navigation
         * @param {Event} evt the browser event
         * @param {string} keyString the string representation of the key sequence
         * @private
         */
        _preventEditAllowNavigation: function(evt, keyString) {
          let prevent = ["ctrl+x", "ctrl+v", "meta+x", "meta+v"].contains(keyString); // CTRL+X & CTRL+V forbidden
          prevent = prevent || (["tab", "home", "end", "left", "right", "up", "down", "shift+left", "shift+right", "ctrl+c",
            "ctrl+a",
            "meta+c", "meta+a"
          ].contains(
            keyString) === false);

          if (prevent) {
            evt.preventCancelableDefault();
            this.flash();
          }
        },

        /**
         * Get the value of the widget
         * @returns {?string|number} the value
         * @publicdoc
         */
        getValue: function() {
          return null;
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          return this.getInputTextState().hasSelectedText() ? this.getInputTextState().getSelectedText() : null;
        },

        /**
         * Manage data to be copied to the clipboard
         * @inheritDoc
         */
        manageClipboardCopy: function(copiedText) {
          // Do whatever with text data you want to be added to the clipboard when copy
          return copiedText;
        },

        /**
         * Manage clipboard on paste data to the widget
         * @param {string} text
         * @inheritDoc
         */
        manageClipboardPaste: function(text) {
          const {
            start,
            end
          } = this.getCursors();

          if (this._enabled) {
            const currentVal = this._getInputElementValue();
            if (currentVal !== null) {
              this._setValue(currentVal.splice(start, end - start, text));
              this.getInputElement()?.setCursorPosition(start + text.length);
            }
          }
        },

        /**
         * Remove characters between start and end
         * @param {string} str - Input string
         * @param {number} start - Begin index
         * @param {number} end - End index
         * @return {string} The new string
         * @inheritDoc
         */
        removeCharacters: function(str, start, end) {
          if (start === end) {
            return str;
          }
          return str.slice(0, start) + str.slice(end);
        },

        /**
         * Manage clipboard on cut data to the widget
         * @param {Selection} selection
         * @inheritDoc
         */
        manageClipboardCut: function(selection) {
          const {
            start,
            end
          } = this.getCursors();

          const oldValue = this.getValue().toString();

          if (this._enabled) {
            gbc.ClipboardService.setClipboardData(selection.toString());
            selection.deleteFromDocument();
            this.setValue(this.removeCharacters(oldValue, start, end), false, start);
          }

          return selection.toString();
        },

        /**
         * Define the widget as readonly or not
         * @param {boolean} readonly - true to set the widget as readonly without possibility of edition, false otherwise
         * @publicdoc
         */
        setReadOnly: function(readonly) {
          this._isReadOnly = readonly;
        },

        /**
         * Check if the widget is readonly or not
         * @returns {boolean} true if the widget is readonly, false otherwise
         * @publicdoc
         */
        isReadOnly: function() {
          return this._isReadOnly;
        },

        /**
         * Define the maximum number of characters allowed
         * @param {number} maxLength - maximum number of characters allowed in the field
         * @publicdoc
         */
        setMaxLength: function(maxLength) {
          this._maxLength = maxLength;
        },

        /**
         * Get the widget max length
         * @returns {number} max length value, 0 for no limit
         * @publicdoc
         */
        getMaxLength: function() {
          return this._maxLength;
        },

        /**
         * Define if autoNext is activated
         * @param {boolean} autoNext - true to activate autoNext
         * @publicdoc
         */
        setAutoNext: function(autoNext) {
          this._autoNext = autoNext;
        },

        /**
         * Returns if autoNext is activated
         * @returns {boolean} true if autoNext is activated
         * @publicdoc
         */
        hasAutoNext: function() {
          return this._autoNext && this._dialogType !== "Construct";
        },

        /**
         * @returns {number} time of the last widget modification
         */
        getEditingTime: function() {
          return this._editingTime;
        },

        /**
         * Check if widget is currently edited
         * It means that the widget have pending value changes
         * @return {boolean}
         */
        isEditing: function() {
          return this._editing;
        },

        /**
         * Flag or unflag widget as having pending value changes
         * @param editing {boolean} the new editing state
         * @publicdoc
         */
        setEditing: function(editing) {
          this._editing = editing;
          if (this.getElement()) {
            this.getElement().toggleClass("editing", Boolean(editing));
          }
        },

        /**
         * Returns if the widget is focusable
         * @return {boolean} State of focusable
         * @publicdoc
         */
        isFocusable: function() {
          return this.hasInputElement() || $super.isFocusable.call(this);
        },

        /**
         * Tests if the widget has really the DOM focus (check document.activeElement)
         * @returns {boolean} true if the widget has the DOM focus
         * @publicdoc
         */
        hasDOMFocus: function() {
          return (this.hasInputElement() && this.getInputElement() === document.activeElement) ||
            $super.hasDOMFocus.call(this);
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled - true if the widget allows user interaction, false otherwise.
         * @param {boolean} noSelectionUpdate - don't update selection
         * @publicdoc
         */
        setEnabled: function(enabled, noSelectionUpdate) {
          if (this._enabled !== Boolean(enabled)) {
            this._enabled = Boolean(enabled);
            if (this._enabled) {
              this.removeClass("disabled");
              if (this.hasInputElement() && !this.isReadOnly()) {
                this.getInputElement().removeAttribute("readonly");
              }
            } else {
              this.addClass("disabled");
              if (!noSelectionUpdate) {
                if (this.hasCursors()) {
                  this.setCursors(0);
                  const selection = window.getSelection();
                  if (selection) {
                    const hasTextSelection = selection.focusNode === this._element;
                    if (hasTextSelection) {
                      selection.removeAllRanges();
                    }
                  }
                }
              }
              if (this.hasInputElement()) {
                this.getInputElement().setAttribute("readonly", "readonly");
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        loseVMFocus: function(vmNewFocusedWidget = null) {
          $super.loseVMFocus.call(this, vmNewFocusedWidget);
          this.setEditing(false);
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          this.setEditing(false);
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && this.hasCursors()) {
            if (keyString === "home") {
              this.setCursors(0);
              keyProcessed = true;
            } else if (keyString === "end") {
              this.setCursors(this.getValue() && this.getValue().toString().length || 0);
              keyProcessed = true;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          this._processingKeyEvent = true;
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            if (keyString === "ctrl+z" || keyString === 'meta+z') {
              this.undo();
              keyProcessed = true;
            } else if (keyString === "ctrl+shift+z" || keyString === 'meta+shift+z') {
              this.redo();
              keyProcessed = true;
            }

            // prevents typed char to appear in input fields if not focused (case occurs if user press mouse down and begins to type chars before releasing mouse cf gbc-3914 or if user clicks in a readonly edit)
            // in other words only prevent default on vm unfocused (but browser focused) editable fields
            if (!this.hasDOMFocus()) {
              const currentActiveWidget = context.WidgetService.getWidgetFromElement(document.activeElement);
              if (currentActiveWidget && currentActiveWidget.isEnabled && currentActiveWidget.isEnabled() && currentActiveWidget.isReadOnly &&
                !currentActiveWidget.isReadOnly()) {
                // cancel default browser behavior if active browser element isn't current vm focused element and is editable
                // let readonly edit accept default browser behaviors (ex: click & ctrl+a in a readonly edit)
                domKeyEvent.preventCancelableDefault();
              }
            }

            if (this.isNotEditable()) {
              this._preventEditAllowNavigation(domKeyEvent, keyString);
            }

            if (!keyProcessed && this._pictureComponent) {
              keyProcessed = this._pictureComponent.manageKeyDown(keyString, domKeyEvent);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);
          this._processingKeyEvent = false;
        },

        /**
         * Cancel the last value
         */
        undo: function() {
          if (this.hasCursors()) { // only widgets with cursors manage undo/redo
            const cursors = this.getCursors();
            const prevValue = this.getValue();
            //go back but store the current as last known value
            if (this._valueStackCursor === this._valueStack.length - 1 && this._valueStack[this._valueStack.length - 1] !==
              this.getValue()) {
              this.setValue(this.getValue());
            }
            this._valueStackCursor--;
            this._valueStackCursor = this._valueStackCursor < 0 ? 0 : this._valueStackCursor;

            this.afterDomMutator(function() {
              const val = this._valueStack[this._valueStackCursor];
              if (typeof val === "string" && this.hasInputElement()) {
                this._setValue(val);
                const diff = prevValue.length - val.length;
                this.setCursors(cursors.start - diff);
              }
            }.bind(this));
          }
        },

        /**
         * Restore the last value
         */
        redo: function() {
          if (this.hasCursors()) { // only widgets with cursors manage undo/redo
            const cursors = this.getCursors();
            const prevValue = this.getValue();
            if (this._valueStackCursor < this._valueStack.length - 1) {
              this._valueStackCursor++;
            }
            this.afterDomMutator(function() {
              const val = this._valueStack[this._valueStackCursor];
              if (typeof val === "string" && this.hasInputElement()) {
                this._setValue(val);
                const diff = prevValue.length - val.length;
                this.setCursors(cursors.start - diff);
              }
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        buildExtraContextMenuActions: function(contextMenu) {
          $super.buildExtraContextMenuActions.call(this, contextMenu);
          const authAction = this.getClipboardAuthorizedAction();

          if (authAction.copy && this.isEnabled() && !this.isReadOnly() && !this.isInTable() && this.hasInputElement()) {

            const value = this.getValue();
            const selectAllAllowed = isNaN(value) ? (value.length > 0) : (value !== null);

            contextMenu.addAction("selectAll", i18next.t("gwc.contextMenu.selectAll"), "font:FontAwesome.ttf:f0ea", "Ctrl+A", {
              clickCallback: function() {
                contextMenu.hide();
                this.setFocus();
                this.selectAllInputText();
              }.bind(this),
              disabled: !selectAllAllowed
            }, true);
          }
        },

        /**
         * Select all the text in the input element
         * @publicdoc
         */
        selectAllInputText: function() {
          if (this.hasInputElement()) {
            const value = this.getValue().toString(); //For SpinEdit value is a number
            const cursor2 = value && value.length || 0;
            this._inputElement.setCursorPosition(0, cursor2);
          }
        },

        /**
         * Defines a placeholder text
         * @param {string} placeholder - placeholder text
         * @param {boolean} fake - true if placeholder come from another attribute
         * @publicdoc
         */
        setPlaceHolder: function(placeholder, fake) {
          if (this.hasInputElement()) {
            this._isFakePlaceholder = fake;
            if (placeholder) {
              this._inputElement.setAttribute('placeholder', placeholder);
            } else {
              this._inputElement.removeAttribute('placeholder');
            }
          }
        },

        /**
         * Method used to validate or not the value, this trigger a rollback if not valid when sending
         * the value to the VM
         * @return {boolean} - true if valid, false otherwise
         */
        validateValue: function() {
          // Implement your own method on widgets
          return true;
        },

        /**
         * This function requests the VM focus if this focus event hasn't been triggered
         * by a mouse or touch event.
         * This happens when the user presses the TAB key of a mobile's virtual keyboard.
         * - TAB generates only a focus event
         * - A tap or click generates a mousedown, focus and mouseup events
         * @param {FocusEvent} event HTML focus event
         * @private
         */
        _onMobileFocus: function(event) {
          if (!this._isMousePressed) {
            this._onRequestFocus(event);
            event.stopPropagation();
          }
        },

        /**
         * @param {MouseEvent} event HTML mouse event
         * @private
         */
        _onMobileMouseDown: function(event) {
          this._isMousePressed = true;
        },

        /**
         * @param {MouseEvent} event HTML mouse event
         * @private
         */
        _onMobileMouseUp: function(event) {
          this._isMousePressed = false;
        },

        /**
         * Fix the char full/half char size according to the widget field width
         * @param {string} text - widget value
         * @param {string} newTextPart - new text part to verify
         * @return {string} a valid newTextPart
         */
        checkValueDisplayWidth: function(text, newTextPart) {
          if (newTextPart.length === 0 || (this._maxLength <= 0 && this._vmWidth <= 0)) {
            return newTextPart;
          }

          const displayWidth = this._vmWidth;
          const maxLength = this.getUserInterfaceWidget().isCharLengthSemantics() ? this._maxLength : -1;

          let fullText = text + newTextPart;
          const textLength = Array.from(text).length;
          let res = newTextPart;
          const codepoints = Array.from(newTextPart);

          while (fullText.displayWidth() > displayWidth || (maxLength > 0 && (textLength + codepoints.length) > maxLength)) {
            codepoints.pop();
            res = codepoints.join('');
            fullText = text + res;
          }

          return res;
        },

        /**
         * Fix the newTextPart according to the requested byte length
         * @param {string} text - old part of the widget value
         * @param {string} newTextPart - new text part to verify
         * @param {number} bytes - requested max bytes length
         * @return {string} a valid newTextPart
         */
        checkValueByteCount: function(text, newTextPart, bytes) {
          const fullText = text + newTextPart;

          if (fullText.length === 0 || fullText.countBytes() <= bytes) {
            return newTextPart;
          }

          if (String.isSingleByteEncoding()) {
            return newTextPart.substring(0, this._maxLength - text.length);
          }

          const codepoints = Array.from(newTextPart);
          const textLength = text.countBytes();
          let res = '';
          do {
            codepoints.pop();
            res = codepoints.join('');
          } while (codepoints.length > 0 && (textLength + res.countBytes()) > bytes);

          return res;
        },

        /**
         * Set to true if we must ignore the scroll attribute
         * @param {boolean} dataTypeWithNoScroll
         */
        setDataTypeWithNoScroll: function(dataTypeWithNoScroll) {
          this._dataTypeWithNoScroll = dataTypeWithNoScroll;
        },

        /**
         * Widget VM width
         * @param {number} width
         */
        setVMWidth: function(width) {
          this._vmWidth = width;
        },

        /**
         * Defines if we can take more char than the widget width
         * @param {boolean} scroll true if the widget can 'scroll' his content (take more char than the widget width)
         * @publicdoc
         */
        setScroll: function(scroll) {
          this._scroll = scroll;
        },

        /**
         * Set the picture
         * @param {string} picture
         */
        setPicture: function(picture) {
          if (this.hasInputElement()) {
            if (this._pictureComponent === null) {
              this._pictureComponent = new cls.InputPictureWidgetComponent(this);
            }
            this._pictureComponent.setPicture(picture);
          }
        },

        /**
         * True if a picture is defined on this field
         * @return {boolean}
         */
        isPictureDefined: function() {
          return this._pictureComponent !== null;
        },

        /**
         * Get the input element text state component
         * @return {classes.InputTextStateComponent}
         */
        getInputTextState: function() {
          if (this._inputTextState === null && this.hasInputElement()) {
            this._inputTextState = new cls.InputTextStateComponent(this);
          }
          return this._inputTextState;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: true,
            copy: true,
            cut: true
          };
        },

        /**
         * Open the associated drop-down if it exists
         */
        openDropDown: function() {
          // each widget must implement this function to open his specific drop down.
        },

        /**
         * Can we trigger autonext event
         * @return {boolean} true if we can trigger autonext event
         */
        canAutoNext: function() {
          return false;
        },

        /**
         * Control the display width, the max length and the encoding according to the char/byte length semantics,
         * the width/max length of the widget and vm encoding
         * @param {KeyboardEvent | InputEvent} domEvent
         */
        controlValueLength: function(domEvent) {
          //Manage display char (full/half) and length semantics constraints
          const widgetText = this.getInputTextState().getBackupTextWithoutSelected();
          const inputValue = this._inputElement.value;

          const newPart = this.getInputTextState().newPart(inputValue);
          //If you need to make some char replacement do something like:
          //newPart = newPart.replace(....)
          let res = '';
          //On mobile isComposing=1 even for regular char
          if (!window.isMobile() && domEvent?.isComposing) {
            //When composing we can use invalid char to create a valid one
            //No need to verify autonext
            return;
          } else {
            res = this._checkValue(widgetText, newPart.removeUnknownChar());
          }

          if (res !== newPart) {
            this.getInputTextState().restore(res);
          }
        },

        /**
         * Fix the newTextPart according to byte/char length and display width
         * @param  {string} text - widget valid value
         * @param {string} newTextPart - new text part
         * @return {string} a valid newTextPart
         * @private
         */
        _checkValue: function(text, newTextPart) {
          return newTextPart;
        },
      };
    });
  });
;

'use strict';

modulum('GbcImageWidget', ['ImageWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * GBC Image widget to create internal images (i.e: with zmdi)
     * @class GbcImageWidget
     * @memberOf classes
     * @extends classes.ImageWidget
     * @publicdoc Widgets
     */
    cls.GbcImageWidget = context.oo.Class(cls.ImageWidget, function($super) {
      return /** @lends classes.GbcImageWidget.prototype */ {
        __name: 'GbcImageWidget',
        __templateName: "ImageWidget",

        /**
         * Update image according to several pre-set parameters
         * @private
         */
        _updateImage: function() {
          if (!this._element) {
            return;
          }
          if (this._hasContent) {
            this._element.empty();
            this._hasContent = false;
          }
          if (this._img) {
            this._img.off('error.ImageWidget');
            this._img.off('load.ImageWidget');
            this._img = null;
          }
          const backgroundImage = null;
          const backgroundSize = null;
          const backgroundRepeat = null;
          const backgroundPosition = null;
          const width = null;

          if (this._src) {

            this._img = document.createElement('i');
            this._img.on('error.ImageWidget', this._onError.bind(this));
            this._img.setAttribute('class', "zmdi " + this._src);
            this._img.on('load.ImageWidget', this._onLoad.bind(this));
            this._element.appendChild(this._img);

            this._element.toggleClass('gbc_autoScale', this._autoScale);
          }
          if (this._standalone) {
            if (!this._border) {
              this._border = document.createElement('div');
              this._border.addClass('gbc_ImageWidget_border');
            }
            this._element.appendChild(this._border);
          }
          this.setStyle({
            'background-image': backgroundImage,
            'background-size': backgroundSize,
            'background-repeat': backgroundRepeat,
            'background-position': backgroundPosition,
            'width': width
          });
          if (this.__charMeasurer) {
            this._element.appendChild(this.__charMeasurer);
          }
        },
      };
    });
    cls.WidgetFactory.registerBuilder('GbcImage', cls.GbcImageWidget);
  });
;

'use strict';

modulum('HLineWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HLine widget.
     * @class HLineWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     */
    cls.HLineWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.HLineWidget.prototype */ {
        __name: 'HLineWidget',

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('HLine', cls.HLineWidget);
  });
;

'use strict';

modulum('ImageWidget', ['ColoredWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Image widget.
     * @class ImageWidget
     * @memberOf classes
     * @extends classes.ColoredWidgetBase
     * @publicdoc Widgets
     */
    cls.ImageWidget = context.oo.Class(cls.ColoredWidgetBase, function($super) {
      return /** @lends classes.ImageWidget.prototype */ {
        __name: 'ImageWidget',
        /**
         * @type {?string}
         */
        _src: null,
        _defaultColor: null,
        /** @type {boolean} */
        _autoScale: false,
        /** @type {String|null} **/
        _scaleIconValue: null,

        /** @type {boolean} */
        _gotFirstInitialImage: false,
        /** @type {boolean} */
        _firstInitialSizing: true,
        /** @type {boolean} */
        _initialAutoscaling: false,
        /** @type {HTMLElement} */
        _img: null,
        /** @type {HTMLElement} */
        _border: null,
        /** @type {boolean} */
        _standalone: false,
        /** @type {boolean} */
        _hasContent: false,
        /** @type {Object} */
        _alignment: null,
        /** @type {number} */
        _rowIndex: -1,

        /**
         * Custom error handler called inside _onError
         * @type {function} */
        _onErrorHandler: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutInformation.shouldFillStack = true;
          this._layoutEngine = new cls.ImageLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._border = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseDblClick: function(domEvent) {
          // request Focus already done by singleClick
          this.emit(context.constants.widgetEvents.doubleClick, domEvent);
          return true;
        },

        /**
         * Define image as a regular standalone widget
         * @param {boolean} standalone - true if standalone, false otherwise
         */
        setStandaloneImage: function(standalone) {
          this._standalone = Boolean(standalone);
          this._element.toggleClass('gbc_withBorder', this._standalone);
          this._element.toggleClass('gbc_selfImage', this._standalone);
        },

        /**
         * If image has action, change cursor
         * @param {boolean} clickable - true if clickable, false otherwise
         * @publicdoc
         */
        setClickableImage: function(clickable) {
          if (clickable) {
            this.addClass('clickable');
          } else {
            this.removeClass('clickable');

          }
        },

        /**
         * ShortCut for setSrc
         * This is used in the context of an Image FormField
         * @param {string} val the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @see setSrc
         * @publicdoc
         */
        setValue: function(val) {
          this.setSrc(val);
        },

        /**
         * Shortcut for getSrc
         * This is used in the context of an Image FormField
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @see getSrc
         * @publicdoc
         */
        getValue: function() {
          return this.getSrc();
        },

        /**
         * ShortCut for setSrc
         * This is used in the context of a Static Image
         * @param {string} image the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @see setSrc
         * @publicdoc
         */
        setImage: function(image) {
          this.setSrc(image);
        },

        /**
         * Shortcut for getSrc
         * This is used in the context of a Static FormField
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @see getSrc
         * @publicdoc
         */
        getImage: function() {
          return this.getSrc();
        },

        /**
         * Check if image is a font image
         * @return {boolean} true if is a font image
         * @publicdoc
         */
        isFontImage: function() {
          if (this._src) {
            return this._src.startsWith('font:');
          } else {
            return false;
          }
        },

        /**
         * Set the source of the image file
         * @param {string} src the URL of the image to display or a font-image URL: font:[fontname]:[character]:[color]
         * @param {boolean?} directApply true to apply src directly (internal use)
         * @publicdoc
         */
        setSrc: function(src, directApply) {
          this.getLayoutInformation().invalidateMeasure();
          if (src !== this._src) {
            const old = this._src;
            const initial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
            this._src = src;
            if (initial && src !== null) {
              if (this._gotFirstInitialImage && old !== null) {
                this._firstInitialSizing = false;
              }
              this._gotFirstInitialImage = true;
            }
            this._updateImage(directApply);
          }
          this.domAttributesMutator(function() {
            if (!this._destroyed && this._img && this.getTitle()) {
              this._img.setAttribute("alt", this.getTitle());
            }
          }.bind(this));
        },

        /**
         * Get the source of the image file
         * @returns {string} the URL of the displayed image or a font-image URL: font:[fontname]:[character]:[color]
         * @publicdoc
         */
        getSrc: function() {
          return this._src;
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          $super.setTitle.call(this, title);
          if (this._img) {
            this._img.setAttribute('alt', title);
          }
        },

        /**
         * Define the image as stretchable
         * @param {boolean} stretch - true if stretchable
         * @publicdoc
         */
        setStretch: function(stretch) {
          this._element.toggleClass('stretch', stretch);
        },

        /**
         * Forces the image to be stretched to fit in the area reserved for the image.
         * @param {boolean} setted true : autoScale , false: default
         * @publicdoc
         */
        setAutoScale: function(setted) {
          if (setted !== this._autoScale) {
            this._autoScale = setted;
            this._updateImage();
          }
        },

        /**
         * Set autoscale value as nnnpx
         * @param {string} value - css string value with valid units
         */
        setScaleIconValue: function(value) {
          this._scaleIconValue = value;
          this.addClass('gbc_scaleIconValue');
          this._updateImage(true);
        },

        /**
         * Se the default color
         * @param {string} color - any CSS compliant color
         */
        setDefaultColor: function(color) {
          this._defaultColor = color;
          this._updateImage(true);
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return "";
          }

          return null;
        },

        /**
         * Align the image
         * @param {number|string} y - y positionsetSrc(imgSrc, true)
         * @param {number|string} x - x
         * @publicdoc
         */
        setAlignment: function(y, x) {
          const rtl = this.getStart() === 'right';

          let hAlign = (x === 'right' && !rtl) || (x !== 'right' && rtl) ? 'right' : 'left';
          hAlign = (x === 'horizontalCenter' || x === 'center') ? 'center' : hAlign;
          let vAlign = (y === 'bottom') ? 'bottom' : 'top';
          vAlign = (y === 'verticalCenter' || y === 'center') ? 'center' : vAlign;
          this._alignment = {
            x: x,
            y: y,
            val: `${hAlign} ${vAlign}`
          };

          const posY = (y === 'bottom') ? 'flex-end' : 'flex-start';
          const posX = (x === 'right') ? 'flex-end' : 'flex-start';
          const pos = {
            'align-items': (y === 'verticalCenter') ? 'center' : posY,
            'justify-content': (x === 'horizontalCenter') ? 'center' : posX,
            'background-position': this._alignment.val
          };
          this.setStyle(pos);
        },

        /**
         * Update image according to several pre-set parameters
         * @param {boolean} directApply true to apply src directly (internal use)
         * @private
         */
        _updateImage: function(directApply) {
          if (!this._element) {
            return;
          }
          if (this._hasContent) {
            this._element.empty();
            this._hasContent = false;
          }
          if (this._img) {
            this._img.off('error.ImageWidget');
            this._img.off('load.ImageWidget');
            this._img = null;
          }
          let style = {
            backgroundImage: null,
            backgroundPosition: null,
            backgroundRepeat: null,
            backgroundSize: null,
            width: null,
          };

          if (this._src) {
            if (this._src.startsWith('font:')) {
              this._applyImageAsFont(directApply);
            } else {

              // /!\ BAD : we update style object values inside this method
              this._applyImage(directApply, style);
            }
            this.toggleClass('gbc_autoScale', this._autoScale);
            if (this._scaleIconValue && this._img) {
              this._img.style.setProperty('--scaleIconValue', this._scaleIconValue);
              this.getLayoutInformation().invalidateMeasure();
            }
          }
          if (this._standalone) {
            if (!this._border) {
              this._border = document.createElement('div');
              this._border.addClass('gbc_ImageWidget_border');
            }
            this._element.appendChild(this._border);
          }
          this.setStyle({
            'background-image': style.backgroundImage,
            'background-position': style.backgroundPosition,
            'background-repeat': style.backgroundRepeat,
            'background-size': style.backgroundSize,
            'width': style.width
          });
          if (this.__charMeasurer) {
            this._element.appendChild(this.__charMeasurer);
          }
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * Apply image and set parameters considering the image is a font
         * @private
         */
        _applyImageAsFont(directApply) {
          const pattern = /font:([^:]+).ttf:([^:]+):?([^:]*)/,
            match = this._src.match(pattern);
          let fontName, sCharCode, color, iCharCode, finalChar;
          if (match) {
            fontName = match[1];
            sCharCode = match[2];
            iCharCode = parseInt('0x' + sCharCode, 16);
            if (0x10000 <= iCharCode && iCharCode <= 0x10FFFF) {
              iCharCode = iCharCode - 0x10000;
              finalChar = String.fromCharCode(0xD800 | (iCharCode >> 10)) +
                String.fromCharCode(0xDC00 | (iCharCode & 0x3FF));
            } else {
              finalChar = String.fromCharCode('0x' + sCharCode);
            }
            color = match[3] || this._defaultColor;
          }
          if (fontName && sCharCode) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 640 512');
            // to left align svg, we need to set xMin, otherwise with a 100% width viewBox it will be centered
            svg.setAttribute('preserveAspectRatio', 'xMinYMid meet');
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            // EDGE & IE doesn't support dominant-baseline central attribute, so we need to center using another way
            if (window.browserInfo.isEdge || window.browserInfo.isIE) {
              text.setAttribute('dy', '0.7ex');
            } else {
              text.setAttribute('dominant-baseline', 'central');
            }
            text.setAttribute('x', '320');
            text.setAttribute('y', '256');
            text.setAttribute('font-size', (this._scaleIconValue ? '44em' : '470'));
            text.setAttribute('font-family', '"image2font_' + fontName.trim() + '"');

            if (this._scaleIconValue) {
              svg.style.setProperty('--scaleIconValue', this._scaleIconValue);
            }
            if (directApply) {
              text.textContent = finalChar;
            } else {
              window.requestAnimationFrame(function(text, character) {
                text.textContent = character;
              }.bind(this, text, finalChar));
            }
            if (color) {
              text.setAttribute('fill', color);
            }
            svg.appendChild(text);
            this._element.appendChild(svg);
            this._hasContent = true;
            this.emit(context.constants.widgetEvents.ready);
          }
          this.getElement().toggleClass('gbc_fixedSvg', !this._autoScale && !this._scaleIconValue);
        },

        _applyImage(directApply, style) {
          const isInitial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
          if (this._inTable || (this._autoScale && !this._inToolBar && (!isInitial || !this._firstInitialSizing))) {
            style.backgroundImage = "url('" + this._src + "')";
            style.backgroundPosition = this._alignment && this._alignment.val || this.getStart();
            style.backgroundRepeat = 'no-repeat';
            style.backgroundSize = 'contain';
            style.width = '100%';
            this.emit(context.constants.widgetEvents.ready);
          } else {
            this._appendImage(directApply);
          }
          this._hasContent = true;
        },

        /**
         * Appends an <img> tag to the element
         * @private
         */
        _appendImage(directApply) {
          this._img = document.createElement('img');
          this._img.on('error.ImageWidget', this._onError.bind(this));
          if (directApply) {
            this._img.setAttribute("src", this._src);
          } else {
            this._setElementAttribute("src", this._src, "_img");
          }
          this._img.on('load.ImageWidget', this._onLoad.bind(this));
          this._element.appendChild(this._img);
        },

        /**
         * Set a custom process in the default error handler
         * @param errorHdl
         */
        setErrorHandler: function(errorHdl) {
          this._onErrorHandler = errorHdl;
        },

        /**
         * Error handler in case of wrong loading and other
         * @private
         */
        _onError: function() {
          this._img.off('error.ImageWidget');
          this._img.off('load.ImageWidget');
          if (this._element) {
            this._element.addClass('hidden');
          }

          if (this._onErrorHandler) {
            this._onErrorHandler();
          }
        },

        /**
         * Load handler to decide what to do after image finished loading
         * @private
         */
        _onLoad: function() {
          this._img.off('error.ImageWidget');
          this._img.off('load.ImageWidget');
          if (this._element) {
            this._element.removeClass('hidden');
            const w = this._img.naturalWidth,
              h = this._img.naturalHeight;
            if (!this.getLayoutEngine().hasNaturalSize()) {
              if (!this._autoScale) {
                this._layoutEngine.invalidateMeasure();
              }
              this.getLayoutEngine()._needMeasure = true;
            }
            this.getLayoutEngine().setNaturalSize(w, h);
            this._element.toggleClass('gbc_ImageWidget_wider', w > h).toggleClass('gbc_ImageWidget_higher', w <= h);

            this.getLayoutInformation()._sizeRatio = h / w;

            const isInitial = this.getLayoutInformation().getSizePolicyConfig().isInitial();
            if (isInitial && this._firstInitialSizing) {
              if (this._autoScale) {
                this._initialAutoscaling = true;
                this.getLayoutInformation()._keepRatio = true;
              } else {
                if (!this.getLayoutEngine().hasNaturalSize()) {
                  this.getLayoutEngine()._needMeasure = true;
                }
              }
            }
            this.emit(context.constants.widgetEvents.ready, this.getLayoutEngine().hasNaturalSize());
            gbc.LogService.ui.log("Image loaded", true, this.__name, this);
          }
        },

        /**
         * Callback once image has been layouted
         * @private
         */
        _whenLayouted: function() {
          if (this._initialAutoscaling) {
            this._initialAutoscaling = false;
            this._firstInitialSizing = false;
            this._updateImage();
          }
        },

        /**
         * @inheritDoc
         */
        setHidden: function(hidden) {
          $super.setHidden.call(this, hidden);
          if (!this._hidden && this._element.parentNode) {
            this._element.parentNode.removeClass('gl_gridElementHidden');
          }
        },

        getStyleSheetId: function() {
          const windowWidget = this.getWindowWidget(),
            windowWidgetId = windowWidget && windowWidget.getUniqueIdentifier();
          return this._uuid || windowWidgetId || "_";
        },

        /**
         * Get the natural dimension of the image
         * @return {{width: number, height: number}}
         */
        getNaturalDimension: function() {
          return {
            width: this._img.naturalWidth,
            height: this._img.naturalHeight
          };
        },

        /**
         * Return current row index if set (parent widget is a scrollgrid)
         * @returns {?number|number|*}
         */
        getRowIndex: function() {
          if (this.getParentWidget().getRowIndex) {
            return this.getParentWidget().getRowIndex();
          }
          return this._rowIndex;
        },

      };
    });
    cls.WidgetFactory.registerBuilder('Image', cls.ImageWidget);
    cls.WidgetFactory.registerBuilder('ImageWidget', cls.ImageWidget);
  });
;

'use strict';

modulum('LabelWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Label widget.
     * @class LabelWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.LabelWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.LabelWidget.prototype */ {
        __name: 'LabelWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * @type {HTMLElement}
         */
        _textContainer: null,
        /** @type {boolean} */
        _hasHTMLContent: false,
        _htmlFilter: null,
        _value: null,
        _displayFormat: null,

        /**
         * true if we must sanitize the html
         * @type {boolean}
         * */
        _sanitize: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.forcedMinimalWidth = 16;
            this._layoutInformation.forcedMinimalHeight = 16;
            if (this.isInTable() && this._layoutInformation.getSizePolicyConfig().mode === "initial") {
              // in a table, widget is measured only one time at start of the application (and after when theme is changing)
              // for label widget "initial" size policy means "dynamic" at first measure and "fixed" after
              // therefore when measuring label in a table, we must always consider widget with size policy "dynamic"
              // to measure correctly the widget especially when the user changes the theme
              this._layoutInformation.setSizePolicyMode("dynamic");
            }
          }
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          if (this._layoutInformation) {
            this._layoutInformation._initialMeasure = false;
            this._layoutInformation.invalidateInitialMeasure(false, this._value !== null && this._value !== '' && this._value !==
              false && this._value !== 0);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._textContainer = this._element.getElementsByTagName('span')[0];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._textContainer = null;
          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent);
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * Get the display format
         * @return {?string} could be null, or 'html'
         * @publicdoc
         */
        getDisplayFormat: function() {
          return this._displayFormat;
        },

        /**
         * Set current display format to use on each set value
         * @param {string} format the display format
         * @publicdoc
         */
        setDisplayFormat: function(format) {
          this._displayFormat = format;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value) {
          const formattedValue = value;
          const hadValue = this._value !== null && this._value !== '' && this._value !== false && this._value !== 0;
          const hasValue = formattedValue !== null && formattedValue !== '' && formattedValue !== false && formattedValue !== 0;
          if (this._layoutInformation) {
            this._layoutInformation.invalidateInitialMeasure(hadValue, hasValue);
          }
          this._value = formattedValue || null;
          this.domAttributesMutator(function() {
            if (this._hasHTMLContent === true) {
              if (this._sanitize) {
                if (!this._htmlFilter) {
                  this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
                }
                this._textContainer.innerHTML = this._htmlFilter.sanitize(formattedValue);
              } else {
                this._textContainer.innerHTML = formattedValue;
              }
            } else {
              let newValue = (formattedValue || formattedValue === 0 || formattedValue === false) ? formattedValue : '';
              if (this.isInTable()) {
                newValue = newValue.replace(/\n/g, " "); // no newline in label in table
              }
              this._textContainer.textContent = newValue;
              this._textContainer.toggleClass("is-empty-label", newValue === "");
            }
          }.bind(this));
          if (this._layoutEngine) {
            if (!hadValue && hasValue) {
              this._layoutEngine.forceMeasurement();
            }
            this._layoutEngine.invalidateMeasure();
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._hasHTMLContent === true) {
            return this._textContainer.innerHTML;
          } else {
            const content = this._textContainer.textContent;
            if (content === '\u00a0') {
              return '';
            }
            return content;
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * Add some html formating
         * @param {HTMLElement} jcontrol - holder for html content
         */
        setHtmlControl: function(jcontrol) {
          jcontrol.innerHTML = this.getValue();
          jcontrol.addClass('gbc-label-text-container');
          this._textContainer.replaceWith(jcontrol);
          this._textContainer = jcontrol;
          this._hasHTMLContent = true;
        },

        /**
         * sanitize = false : Authorize to send html text without control
         * @param {boolean} sanitize
         */
        setSanitize: function(sanitize) {
          this._sanitize = sanitize;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Label', cls.LabelWidget);
  });
;

'use strict';

modulum('MenuLabelWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * MenuLabelWidget widget.
     * @class MenuLabelWidget
     * @memberOf classes
     * @extends classes.LabelWidget
     */
    cls.MenuLabelWidget = context.oo.Class(cls.LabelWidget, function($super) {
      /** @lends classes.MenuLabelWidget.prototype */
      return {
        __name: 'MenuLabelWidget',

        /** @type {HTMLElement}*/
        _imageContainer: null,
        /** @type {string}*/
        _imageSrc: "",
        /** @type {HTMLElement}*/
        _commentContainer: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          this._ignoreLayout = true;
          $super._initElement.call(this);
          this._imageContainer = this._element.querySelector('.gbc-label-image-container');
          this._commentContainer = this._element.querySelector('.gbc-label-comment-container');
          this._textContainer = this._element.querySelector('.gbc-label-text-container');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          // no layout
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._imageContainer = null;
          this._commentContainer = null;
          this._imageSrc = "";
          $super.destroy.call(this);
        },

        /**
         * Defines the image source
         * @param {string} imgSrc - url of the label image
         */
        setImage: function(imgSrc) {
          if (this._imageSrc !== imgSrc) {
            const img = cls.WidgetFactory.createWidget('ImageWidget', this.getBuildParameters());
            img.setSrc(imgSrc, true);
            this._imageSrc = imgSrc;
            this._imageContainer.innerHTML = img._element.innerHTML;
            img.destroy();
          }
        },

        /**
         * Set the text of the label
         * @param {string} text - the text
         * @publicdoc
         */
        setText: function(text) {
          if (this.getValue() !== text) {
            this.setValue(text);
          }
        },

        /**
         * Set the text of the label comment
         * @param {string} comment - text to set as comment
         */
        setComment: function(comment) {
          if (this._commentContainer.innerText !== comment) {
            this._commentContainer.innerText = comment;
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('MenuLabel', cls.MenuLabelWidget);
  });
;

'use strict';

modulum('MessageWidget', ['TextWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Message Widget to display information as toated popups
     * @class MessageWidget
     * @memberOf classes
     * @extends classes.TextWidgetBase
     * @publicdoc Widgets
     */
    cls.MessageWidget = context.oo.Class(cls.TextWidgetBase, function($super) {
      return /** @lends classes.MessageWidget.prototype */ {
        __name: 'MessageWidget',
        $static: /** @lends classes.MessageWidget */ {
          defaultDisplayTime: 10
        },

        /**
         * Content of the message
         * @type {string}
         */
        _text: '',

        /**
         * Is the message is displayed with html formatting
         * @type {boolean}
         */
        _htmlFormat: false,

        /**
         * true if we must sanitize the html
         * @type {boolean}
         * */
        _sanitize: null,

        /** @type {string} */
        _kind: 'message',

        /** @type {?string} */
        _forcedPosition: null,

        /**
         * Timer to handle display time
         * @type {?number}
         */
        _currentTimeout: null,

        /**
         * Time (in seconds) before hiding message
         * 0  : always show
         * -1 : always hide
         */
        _messageDisplayTime: 0,

        /**
         * Close button element
         * @type {HTMLElement}
         */
        _closeButton: null,

        /**
         * Text Element
         * @type {HTMLElement}
         */
        _textElement: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._closeButton = this._element.querySelector('.close-button');
          this._textElement = this._element.querySelector('.message-text');

          const themeDisplayTime = context.ThemeService.getValue('theme-message-display-time');
          this._messageDisplayTime = Object.isNumber(themeDisplayTime) || Object.isString(themeDisplayTime) ?
            parseInt(themeDisplayTime, 10) : cls.MessageWidget.defaultDisplayTime;

          const swipeDirections = this.getPosition().split('-');
          // Interesting on touch device. On desktop click catches all
          this._element.onSwipe('MessageWidget', this._onSwipe.bind(this), {
            direction: swipeDirections
          });

          this.setHidden(true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._closeButton = null;
          this._textElement = null;
          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this.setHidden(true);
          return true;
        },

        /**
         * Set the message text
         * @param {string} text - the text to display
         * @publicdoc
         */
        setText: function(text) {
          if (text !== this._text) {
            this._text = text;
            this._refreshText();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Handle text reformatting
         * @private
         */
        _refreshText: function() {
          this.domAttributesMutator(function() {
            if (this._htmlFormat) {
              if (this._sanitize) {
                if (!this._htmlFilter) {
                  this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
                }
                this._textElement.innerHTML = this._htmlFilter.sanitize(this._text);
              } else {
                this._textElement.innerHTML = this._text;
              }
            } else {
              this._textElement.textContent = this._text;
            }
          }.bind(this));

          if (this._text.trim().length <= 0) {
            this.setHidden(true);
          } else {
            this.setHidden(false);
          }
          if (this.isReversed()) {
            const ui = this.getUserInterfaceWidget();
            if (ui) {
              const left = ui.getElement().getBoundingClientRect().left;
              this.setStyle({
                'left': (left + 12) + 'px'
              });
            }
          }
        },

        /**
         * Get the current text
         * @returns {string} the displayed text
         * @publicdoc
         */
        getText: function() {
          return this._textElement.textContent;
        },

        /**
         * Hide / show the message
         * @param {boolean} hidden - visibility state
         * @publicdoc
         */
        setHidden: function(hidden) {
          // Message text is empty or display time is 0, hide it
          if (this._text.trim().length <= 0 || this._messageDisplayTime < 0) {
            hidden = true;
          }
          if (!hidden) {
            this.removeClass("out-of-view");
          }
          const disp = this._messageDisplayTime * 1000;
          // Handle hide timeout only if display time is positive
          if (this._messageDisplayTime > 0) {
            if (this._hidden !== hidden) {
              $super.setHidden.call(this, hidden);
              if (this._currentTimeout !== null) {
                this._clearTimeout(this._currentTimeout);
                this._currentTimeout = null;
              }
              if (!hidden) {
                this._currentTimeout = this._registerTimeout(this._hide.bind(this), disp);
              }
              this.emit("hide.MessageWidget", hidden);
            }
          } else {
            $super.setHidden.call(this, hidden);
          }
        },

        /**
         * Hide message with a sliding animation
         * @private
         */
        _onSwipe: function() {
          this.getElement().addClass("slideOut");
          this._registerTimeout(function() {
            this.setHidden(true);
            this.getElement().removeClass("slideOut");
          }.bind(this), 350);
        },

        /**
         * do hide
         * @private
         */
        _hide: function() {
          this.setHidden(true);
          this._currentTimeout = null;
        },

        /**
         * Set message formatting as html
         * @param {boolean} html - true if html formatted, false otherwise
         * @publicdoc
         */
        setHtmlFormat: function(html) {
          if (this._htmlFormat !== html) {
            this._htmlFormat = html;
            this._refreshText();
          }
        },

        /**
         * sanitize = false : Authorize to send html text without control
         * @param {boolean} sanitize
         */
        setSanitize: function(sanitize) {
          this._sanitize = sanitize;
        },

        /**
         * Defines the type of message, thus the right customization variables will be used
         * @param {string} kind - could be 'message' or 'error'
         * @publicdoc
         */
        setMessageKind: function(kind) {
          this._kind = kind;
          this._setElementAttribute("data-message-kind", kind);
          if (kind) {
            // Handle display time
            const themeDisplayTime = context.ThemeService.getValue('theme-' + kind + '-display-time');
            this._messageDisplayTime = Object.isNumber(themeDisplayTime) || Object.isString(themeDisplayTime) ?
              parseInt(themeDisplayTime, 10) : cls.MessageWidget.defaultDisplayTime;
            // Handle position
            if (context.ThemeService.getValue("theme-" + kind + "-display-position")) {
              this.addClass(context.ThemeService.getValue("theme-" + kind + "-display-position"));
            }
          }
        },

        /**
         * Get the message kind
         * @return {string} could be 'error' or 'message'
         */
        getMessageKind: function() {
          return this._kind;
        },

        setMessageDisplayTime: function(displayTime) {
          this._messageDisplayTime = displayTime;
        },
        setMessageColor: function(color, bgColor) {
          this._element.style.color = color;
          this._element.style.backgroundColor = bgColor;
        },

        /**
         * Get the 4ST position value for the message
         * @return {string} - something like "bottom-left"
         */
        getPosition: function() {
          const pos = "bottom-right"; // default value
          const kind = this.getMessageKind();
          const themePos = context.ThemeService.getValue("theme-" + kind + "-display-position");
          return themePos ? themePos : pos;
        },

        /**
         * In case of position forced, return it
         * @return {?string} - something like "bottom-left" or null if not forced
         */
        getForcedPosition: function() {
          return this._forcedPosition;
        },

        /**
         * Define a position to ignore theme value
         * @param {String} forcedPosition - same as theme available positions
         */
        setPosition: function(forcedPosition) {
          this._forcedPosition = forcedPosition;
        },

        /**
         * Use this to create a widget in the dom without displaying it
         */
        setDummyMessage: function() {
          this.setText("...");
          this.addClass("out-of-view"); // see: GBC-2187
        },

      };
    });
    cls.WidgetFactory.registerBuilder('Message', cls.MessageWidget);
  });
;

'use strict';

modulum('DateEditMobileWidget', ['DateEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateEdit widget Mobile.
     * Limitations: you cannot use some 4ST : daysOff, firstDayOfWeek, showCurrentMonthOnly, showWeekNumber
     * @class DateEditMobileWidget
     * @memberOf classes
     * @extends classes.DateEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateEditMobileWidget = context.oo.Class(cls.DateEditWidgetBase, function($super) {
      return /** @lends classes.DateEditMobileWidget.prototype */ {
        __name: 'DateEditMobileWidget',

        /**
         * @type {Node}
         */
        _pickerLabel: null,

        // TODO cleaning it should have no pikaday in mobile version ?

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._inputElement.setAttribute("data-date", "");

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];

          this._inputElement.on("change.DateEditMobileWidget", function(event) {
            if (this.isEnabled()) {
              const valueAsDate = event.target.valueAsDate;
              if (valueAsDate) {
                // Ensure the format is YYYY-MM-DD
                const d = {
                  year: valueAsDate.getUTCFullYear(),
                  month: (valueAsDate.getUTCMonth() + 1).toString().padStart(2, "0"),
                  day: (valueAsDate.getUTCDate()).toString().padStart(2, "0")
                };
                const localeDate = gbc.dayjs(d.year + "-" + d.month + "-" + d.day, "YYYY-MM-DD");
                if (localeDate.isValid()) {
                  this.setValue(localeDate.format(this._displayFormat));
                }
              } else {
                this.setValue("");
              }
              this.triggerValueChangedEvent(this.getValue());
            }
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);

          if (enabled) {
            this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");
          } else {
            this._pickerLabel.removeAttribute("for");
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off("change.DateEditMobileWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          return true;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          // if from VM, convert it to good format, so it can open the picker at the right date!
          if (fromVM) {
            const dateObj = context.dayjs(value, this._displayFormat);
            if (dateObj.isValid()) {
              this._inputElement.value = dateObj.format("YYYY-MM-DD");
            } else {
              this._inputElement.value = value;
            }
          }
          this._inputElement.setAttribute("data-date", value);
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-date");
        },

        /**
         * @inheritDoc
         */
        controlValueLength: function(domEvent) {
          return false;
        }
      };
    });
  });
;

'use strict';

modulum('DateTimeEditMobileWidget', ['DateTimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * DateTimeEdit widget.
     * @class DateTimeEditMobileWidget
     * @memberOf classes
     * @extends classes.DateTimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.DateTimeEditMobileWidget = context.oo.Class(cls.DateTimeEditWidgetBase, function($super) {
      return /** @lends classes.DateTimeEditMobileWidget.prototype */ {
        __name: 'DateTimeEditMobileWidget',

        /**
         * @inheritDoc
         */
        __dataContentPlaceholderSelector: '.gbc_dataContentPlaceholder',

        /**
         * Active/disable seconds for the widget. By default, yes.
         * @type {boolean}
         */
        _showSeconds: false,

        /**
         * @inheritDoc
         */
        _displayFormat: null,

        /**
         * @inheritDoc
         */
        _maxLength: -1,

        /**
         * @type {Node}
         */
        _pickerLabel: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this, true);
          // default datetime format
          this._displayFormat = 'MM/DD/YYYY HH:mm:ss';

          this._inputElement.on('touchstart.DateTimeEditWidgetBase', this._onRequestFocus.bind(this));

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];

          this._inputElement.on("change.DateTimeEditWidgetBase", function(event) {
            this.setValue(event.target.value);
            this.triggerValueChangedEvent(this.getValue());
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off("change.DateTimeEditWidgetBase");
          $super.destroy.call(this);
        },

        /**
         * Overrided to prevent pikaday picker to open
         * // TODO it seems to be never called, there is pikaday in mobile
         */
        _onIconClick: function(event) {
          event.stopPropagation();
          // if widget already has VM focus, we need to explicitly set focus to input when clicking on dateedit icon, otherwise keyboard binding are not trapped.
          // if widget doesn't have VM focus, VM will set focus to input.
          if (this.hasFocus() && this.isEnabled() && !this.isModal()) {
            this._inputElement.domFocus();
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);

          if (enabled) {
            this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");
          } else {
            this._pickerLabel.removeAttribute("for");
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          let dateObj;
          // if from VM, convert it to good format, so it can open the picker at the right date
          if (value) {
            if (fromVM) {
              dateObj = context.dayjs(value, this._displayFormat);
              if (dateObj.isValid()) {
                this._inputElement.value = dateObj.format("YYYY-MM-DDTHH:mm:ss");
              }
            } else {
              dateObj = context.dayjs(value, "YYYY-MM-DDTHH:mm:ss");
              if (!dateObj.isValid()) {
                dateObj = context.dayjs(value, "YYYY-MM-DDTHH:mm");
              }
            }
            this._inputElement.setAttribute("data-date", dateObj.format(this._displayFormat));
          } else { // manage null/empty value
            if (fromVM) {
              this._inputElement.value = value;
            }
            this._inputElement.setAttribute("data-date", value);
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-date");
        },

        /**
         * @inheritDoc
         */
        setFormat: function(format) {
          $super.setFormat.call(this, format);
          if (this._showSeconds) {
            // Display seconds
            this.getInputElement().setAttribute("step", "1");
          } else {
            this.getInputElement().removeAttribute("step");
          }
        },

        /**
         * @inheritDoc
         */
        controlValueLength: function(domEvent) {
          return false;
        }

      };
    });
  });
;

'use strict';

modulum('SpinEditMobileWidget', ['SpinEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit Mobile widget.
     * @class SpinEditMobileWidget
     * @memberOf classes
     * @extends classes.SpinEditWidgetBase
     * @publicdoc Widgets
     *
     * ignore step attr
     */
    cls.SpinEditMobileWidget = context.oo.Class(cls.SpinEditWidgetBase, function($super) {
      return /** @lends classes.SpinEditMobileWidget.prototype */ {
        __name: 'SpinEditMobileWidget',

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this.getElement().on('touchstart.SpinEditMobileWidget', this._onTouch.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this.getElement().off('touchstart.SpinEditMobileWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        _onTouch: function(event) {
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          // Check value
          const curVal = this.getValue();
          if (this._max && curVal > this._max) {
            this.setValue(this._max);
          }
          if (this._min && curVal < this._min) {
            this.setValue(this._min);
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          // Use vm value if not defined
          const value = parseInt(this._inputElement.value, 10);
          const isDefined = Object.isNumber(value) && !Object.isNaN(value);
          return isDefined ? value : this._oldValue;
        },

        /**
         * @inheritDoc
         */
        loseFocus: function() {
          if (this._inputElement.value === "") {
            this._inputElement.value = this._oldValue;
          }
        }
      };
    });
  });
;

'use strict';

modulum('TimeEditMobileWidget', ['TimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit Mobile widget.
     * @class TimeEditMobileWidget
     * @memberOf classes
     * @extends classes.TimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditMobileWidget = context.oo.Class(cls.TimeEditWidgetBase, function($super) {
      return /** @lends classes.TimeEditMobileWidget.prototype */ {
        __name: 'TimeEditMobileWidget',

        /**
         * @type {Node}
         */
        _pickerLabel: null,
        _pickerIcon: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._pickerIcon = this._element.getElementsByClassName('widget-decoration')[0];

          this._inputElement = this._element.getElementsByTagName('input')[0];
          this.setValue('00:00:00');

          this._inputElement.on("change.TimeEditMobileWidget", function(event) {
            let val = this._inputElement.value;
            // IOS doesn't support seconds in their native input type='time' browser implementation
            // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/InputTypes.html
            if (window.isIOS() && this._useSeconds) {
              val += ":00";
            }
            this._inputElement.setAttribute("data-time", val);
            this.triggerValueChangedEvent(val);
          }.bind(this));
          this._element.on('touchstart.TimeEditMobileWidget', this._onRequestFocus.bind(this));

          // Trick to open picker when touching icon
          this._inputElement.setAttribute("id", this.getRootClassName() + "_input");
          this._pickerLabel = this._element.getElementsByTagName("label")[0];
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);

          if (enabled) {
            this._pickerLabel.setAttribute("for", this.getRootClassName() + "_input");
          } else {
            this._pickerLabel.removeAttribute("for");
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          const target = domEvent.target;
          if (target.isElementOrChildOf(this._inputElement) || target.isElementOrChildOf(this._pickerIcon)) {
            this._onRequestFocus(domEvent); // request focus
          }
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off('touchstart.TimeEditMobileWidget');
          this._inputElement.off('change.TimeEditMobileWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        setDisplayFormat: function(format) {
          $super.setDisplayFormat.call(this, format);
          this._updateFormat();
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          if (this.getValue() !== value) {
            // first set accuracy on native widgets before the value to avoid seconds being always displayed (issue under android)
            this._setTimeAccuracy(value);
            if (fromVM) {
              this._updateFormat();
            }
            $super.setValue.call(this, value, fromVM, cursorPosition);
            this._inputElement.setAttribute("data-time", value);
          }
        },

        /**
         * Add/remove seconds accuracy from input time picker
         * @private
         */
        _updateFormat: function() {
          if (this._useSeconds) {
            this._inputElement.setAttribute("step", "1");
          } else {
            this._inputElement.removeAttribute("step");
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._inputElement.getAttribute("data-time");
        },

        /**
         * @inheritDoc
         */
        controlValueLength: function(domEvent) {
          return false;
        }

      };
    });
  });
;

'use strict';

modulum('ProgressBarWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Progressbar widget.
     * @class ProgressBarWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.ProgressBarWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.ProgressBarWidget.prototype */ {
        __name: 'ProgressBarWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /** @type {string} */
        _progressSelector: '>div>.mt-progress-level',

        /** @type {HTMLElement} */
        _progressElement: null,
        /** @type {HTMLElement} */
        _percentageElement: null,

        /** @type {number} */
        _value: 0,
        /** @type {number} */
        _valueMin: 0,
        /** @type {number} */
        _valueMax: 100,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this._progressElement = this._element.querySelector('div>div');
          this._percentageElement = this._element.querySelector('.mt-progress-bar-percentage');
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Fixed();
            this._layoutInformation.getSizePolicyConfig().dynamic = cls.SizePolicy.Fixed();

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);

            this._layoutInformation.forcedMinimalHeight = 20;
            this._layoutEngine._shouldFillHeight = true;
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._progressElement = null;
          this._percentageElement = null;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          // in table, we have to request focus on row when clicking on a table column progress bar
          if (this.isInTable()) {
            this._onRequestFocus(domEvent); // request focus
          }
          return true;
        },

        /**
         * Overrided to use mt-progress-color instead of secondary color
         * @inheritDoc
         */
        setColor: function(color) {
          // Hack to fallback on the right color  
          if (color === gbc.ThemeService.getValue("theme-secondary-color")) {
            color = gbc.ThemeService.getValue("gbc-ProgressBarWidget-color");
          }

          this.setStyle(this._progressSelector, {
            'background-color': color ? color + ' !important' : null
          });
        },

        /**
         * Get the color of the progressBar
         * @return {string} the CSS value for the backgrund-color attribute
         * @publicdoc
         */
        getColor: function() {
          return this.getStyle(this._progressSelector, 'background-color');
        },

        /**
         * Set the color of the progressBar
         * @param {string} color - any CSS compliant color
         * @publicdoc
         */
        setBackgroundColor: function(color) {
          this.setStyle({
            'background-color': color ? color + ' !important' : null
          });
        },

        /**
         * Get the color of the progressBar
         * @return {string} the CSS value for the backgrund-color attribute
         * @publicdoc
         */
        getBackgroundColor: function() {
          return this.getStyle('background-color');
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return this._value;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          value = +value;
          // Check if number
          value = Number.isNaN(value) ? this._valueMin : value;
          // Check if value is higher than Max
          value = value > this._valueMax ? this._valueMax : value;
          // Check if value is lower than min
          value = value < this._valueMin ? this._valueMin : value;
          this._value = value;

          const percentValue = Math.round((this._value - this._valueMin) / (this._valueMax - this._valueMin) * 100);
          this.afterDomMutator(function() {
            this.setStyle(this._progressSelector, {
              'width': '' + percentValue + '% !important'
            });
          }.bind(this));
          if (this._percentageElement) {
            this._percentageElement.querySelector("span").innerText = percentValue;
            this.setAriaAttribute("valuetext", percentValue + " %");
          }
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * Set the progressbar as running (with animation)
         * @param {boolean} running - true starts the animation for an unknown progress progressbar, false stops it.
         * @publicdoc
         */
        setRunning: function(running) {
          this._progressElement.toggleClass('running', running);
          this._element.toggleClass('running', running);
        },

        /**
         * Check if the progressBar is running
         * @returns {boolean} true if the animation is running for an unknown progress progressbar, false otherwise.
         * @publicdoc
         */
        isRunning: function() {
          return this._element.hasClass('running');
        },

        /**
         * Set the state of the progressBar as unknown
         * @param {boolean} unknown true to switch to the unknown progress mode, false otherwise
         * @publicdoc
         */
        setProgressUnknown: function(unknown) {
          this._progressElement.toggleClass('mt-progress-level-unknown', unknown);
          if (unknown) {
            this.setStyle(this._progressSelector, {
              'width': '0% !important'
            });
          }
        },

        /**
         * Check if progress status is unknown
         * @returns {boolean} true if the progressbar is in unknown progress mode, false otherwise
         * @publicdoc
         */
        isProgressUnknown: function() {
          return this._progressElement.hasClass('mt-progress-level-unknown');
        },

        /**
         * Set the minimum value of the progressBar
         * @param {number} valueMin - minimum value the progressBar can handle
         * @publicdoc
         */
        setMin: function(valueMin) {
          this._valueMin = parseInt(valueMin, 10);
          this.setAriaAttribute("valuemin", valueMin);
          this.setValue(this._value, false);
        },

        /**
         * Get the minimum value of the progressBar
         * @return {number} minimum value the progressBar can handle
         * @publicdoc
         */
        getMin: function() {
          return this._valueMin;
        },

        /**
         * Set the maximum value of the progressBar
         * @param {number} valueMax - maximum value the progressBar can handle
         * @publicdoc
         */
        setMax: function(valueMax) {
          this._valueMax = parseInt(valueMax, 10);
          this.setAriaAttribute("valuemax", valueMax);
          this.setValue(this._value, false);
        },

        /**
         * Get the maximum value of the progressBar
         * @return {number} maximum value the progressBar can handle
         * @publicdoc
         */
        getMax: function() {
          return this._valueMax;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
        },

        /**
         * Show the percentage in the progressbar
         * @param {string} pos - position of the percentage info: 'left', 'right' or center
         */
        showPercentage: function(pos) {
          if (pos && this._percentageElement) {
            this._percentageElement.removeClass('.percentage-left');
            this._percentageElement.removeClass('.percentage-center');
            this._percentageElement.removeClass('.percentage-right');
            this._percentageElement.addClass('percentage-' + pos);
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          return null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: false,
            cut: false
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ProgressBar', cls.ProgressBarWidget);
  });
;

"use strict";

modulum('RadioGroupWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * RadioGroup widget.
     * @class RadioGroupWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.RadioGroupWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.RadioGroupWidget.prototype */ {
        __name: 'RadioGroupWidget',
        /**
         * currently aimed item
         * @type {number}
         */
        _currentlyAimedIndex: 0,

        /**
         * Widget value
         * @type {string}
         */
        _value: '',
        /**
         * @type {boolean}
         */
        _notNull: false,
        /**
         * @type {boolean}
         */
        _allowNullValue: false,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafDynamicHeightLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },

        /**
         * Manage navigation keys
         * @param {string} keyString - key string representation
         * @returns {boolean} returns if the key has been processed
         * @private
         */
        _manageNavigationKey: function(keyString) {

          if (this.isInArray()) {
            return false;
          }

          let keyProcessed = true;
          switch (keyString) {
            case "down":
              this._onNext();
              break;
            case "up":
              this._onPrevious();
              break;
            default:
              keyProcessed = false;
          }

          return keyProcessed;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = this._manageNavigationKey(keyString);
            if (keyProcessed) {
              return true;
            }

            keyProcessed = true;
            switch (keyString) {
              case this.getEnd():
                this._onNext();
                break;
              case this.getStart():
                this._onPrevious();
                break;
              case "space":
                this._onSpace();
                break;
              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          this._onRequestFocus(domEvent);
          if (domEvent.target.elementOrParent("gbc_RadioGroupItem")) {
            this._onItemClick(domEvent);
          }
          this.emit(context.constants.widgetEvents.click, domEvent);

          return false;
        },

        /**
         * On click handler
         * @param {Object} evt - DOM event
         * @private
         */
        _onItemClick: function(evt) {
          if (!this.isEnabled()) {
            return;
          }

          const clickedIndex = this._indexOf(evt.target.closest('gbc_RadioGroupItem').getAttribute('data-value'));
          if (clickedIndex === -1) {
            return;
          }
          this._currentlyAimedIndex = clickedIndex;

          let newValue = this._getIndexValue(this._currentlyAimedIndex, false);
          this.emit(context.constants.widgetEvents.valueChanged, newValue);
        },

        /**
         * On previous handler : action to do when we want to go to previous value
         * @private
         */
        _onPrevious: function() {
          this._currentlyAimedIndex -= 1;
          if (this._currentlyAimedIndex < 0) {
            this._currentlyAimedIndex = this.getChildItems().length - 1;
          }

          const newValue = this._getIndexValue(this._currentlyAimedIndex, true);
          this.emit(context.constants.widgetEvents.valueChanged, newValue);
        },

        /**
         * On next handler : action to do when we want to go to next value
         * @private
         */
        _onNext: function() {
          this._currentlyAimedIndex += 1;
          if (this._currentlyAimedIndex >= this.getChildItems().length) {
            this._currentlyAimedIndex = 0;
          }

          const newValue = this._getIndexValue(this._currentlyAimedIndex, true);
          this.emit(context.constants.widgetEvents.valueChanged, newValue);
        },

        /**
         * On space Key handler
         * @private
         */
        _onSpace: function() {
          const newValue = this._getIndexValue(this._currentlyAimedIndex, false);
          this.emit(context.constants.widgetEvents.valueChanged, newValue);
        },

        /**
         * Return the index of the item having the value in parameter
         * @param {string} value The value of the item to find
         * @returns The index of the item that have the value. -1 if not found
         * @private
         */
        _indexOf: function(value) {
          return this.getChildItems().findIndex((element) => element.getAttribute('data-value') === value);
        },

        /**
         * Add a choice to the list
         * @param {object} choice - choice to add
         * @private
         */
        _addChoice: function(choice) {
          const button = context.TemplateService.renderDOM('RadioGroupItem');
          button.setAttribute('data-value', choice.value);
          button.getElementsByTagName('span')[0].textContent = choice.text;
          this._element.appendChild(button);
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Removes a choice at the given index
         * @param {number} index
         * @private
         */
        _removeChoiceAt: function(index) {
          this._element.allchild('gbc_RadioGroupItem')[index].remove();
        },

        /**
         * Removes the given choice
         * @param {object} choice
         * @private
         */
        _removeChoice: function(choice) {
          const index = this._indexOf(choice.value);
          if (index >= 0) {
            this._removeChoiceAt(index);
          }
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Adds a single or a list of choices
         * @param {string|string[]} choices - choices to add to the radio ensemble
         * @publicdoc
         */
        setItems: function(choices) {
          this.clearChoices();
          if (choices) {
            if (Array.isArray(choices)) {
              for (const element of choices) {
                this._addChoice(element);
              }
              this.updateValue();
            } else {
              this._addChoice(choices);
            }
            this._addAriaNavigation();
          }
        },

        /**
         * Removes a single or a list of choices
         * @param {(string|string[])} choices - choices to remove
         * @publicdoc
         */
        removeChoices: function(choices) {
          if (choices) {
            if (Array.isArray(choices)) {
              for (const element of choices) {
                this._removeChoice(element);
              }
            } else {
              this._removeChoice(choices);
            }
          }
        },

        /**
         * Clears all choices
         * @publicdoc
         */
        clearChoices: function() {
          while (this.getChildItems().length > 0) {
            this._element.childrenExcept(this.__charMeasurer)[0].remove();
          }
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Set the layout orientation.
         * @param {string} orientation - 'vertical' or 'horizontal' or ''.
         * @publicdoc
         */
        setOrientation: function(orientation) {
          orientation = orientation === "" ? "vertical" : orientation; // default orientation is vertical
          this._element.toggleClass('gbc_RadioGroupWidget_horizontal', orientation === 'horizontal');
          this._element.toggleClass('gbc_RadioGroupWidget_vertical', orientation === 'vertical');
          if (this.getLayoutEngine()) {
            this.getLayoutEngine().forceMeasurement();
            this.getLayoutEngine().invalidateMeasure();
          }
        },

        /**
         * Get the layout orientation.
         * @returns {string} the layout orientation. 'vertical' or 'horizontal'.
         * @publicdoc
         */
        getOrientation: function() {
          if (this._element.hasClass('gbc_RadioGroupWidget_horizontal')) {
            return 'horizontal';
          } else {
            return 'vertical';
          }
        },

        /**
         * Get the value of the radiogroup
         * @returns {string} value - the current value
         * @publicdoc
         */
        getValue: function() {
          return this._value;
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM) {
          $super.setValue.call(this, value, fromVM);
          this._setValue(value);
        },

        /**
         * Internal setValue used to be inherited correctly by DummyWidget
         * @param {string} value - the value to set
         * @private
         */
        _setValue: function(value) {
          this._value = value;
          const indexOfValue = this._indexOf(value);
          this._currentlyAimedIndex = indexOfValue !== -1 ? indexOfValue : this._currentlyAimedIndex;
          this._updateVisual(value, this._currentlyAimedIndex);
        },

        /**
         * Set again the value, can be useful if items have changed
         * @publicdoc
         */
        updateValue: function() {
          if (this._value) {
            this.setValue(this._value);
          }
        },

        /**
         * Update the UI, with the value for the given index.
         * NOT NULL wise
         * !! This method don't change the value of the widget class !!
         * @param {number} index - index of the value
         * @param {boolean} allowKeepNull If true, the value will stay null if it was null before (used for previous and next)
         * @returns {string} The value corresponding to the visual
         * @private
         */
        _getIndexValue: function(index, allowKeepNull) {
          if (!this.isEnabled()) {
            return this.getValue();
          }
          const childItem = this.getChildItems()[index];

          if (childItem === undefined) {
            return this.getValue();
          }

          const wantedValue = childItem.getAttribute('data-value');
          let newValue = this.getValue() === '' && allowKeepNull ? '' : wantedValue;

          if (wantedValue === this.getValue() && (!this._notNull || this._dialogType === "Construct")) {
            newValue = '';
          }

          // Return the value
          return newValue;
        },

        /**
         * Manage RadioGroup visual depending on the values given in parameters
         * @param {string} checkedValue The checked value, used to find the item to check. If null, no item will be checked
         * @param {number|undefined} aimedIndex The index of the aimed item, if set to undefined, it will be the same as the checkedValue item.
         */
        _updateVisual: function(checkedValue, aimedIndex) {
          this.getChildItems().forEach((childElement, index) => {
            const childElementValue = childElement.getAttribute('data-value');
            // Foreach children, toggle 'checked', and 'unchecked' classes
            const zmdiElement = childElement.getElementsByClassName('zmdi')[0];
            zmdiElement.toggleClass('checked', childElementValue === checkedValue);
            zmdiElement.toggleClass('unchecked', childElementValue !== checkedValue);
            childElement.setAttribute('aria-checked', childElementValue === checkedValue);

            childElement.toggleClass('aimed', index === aimedIndex);
            childElement.setAttribute('aria-selected', index === aimedIndex);
          });
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._element.toggleClass('disabled', !enabled);
          for (const element of this.getChildItems()) {
            const zmdiItem = element.getElementsByClassName('zmdi')[0];
            zmdiItem.toggleClass('disabled', !enabled);
          }
        },

        /**
         * Sets the focus to the widget
         * @publicdoc
         */
        setFocus: function(fromMouse) {
          this._element.domFocus();
          this._updateVisual(this.getValue(), this._currentlyAimedIndex);
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Set widget mode. Useful when widget have peculiar behavior in certain mode
         * @param {string} mode the widget mode
         * @param {boolean} active the active state
         */
        setWidgetMode: function(mode, active) {
          this._allowNullValue = mode === "Construct";
        },

        /**
         * Add accessible navigation for radiogroup
         * @private
         */
        _addAriaNavigation: function() {
          this.getChildItems().forEach((item, index, array) => {
            item.setAttribute('aria-posinset', String(index + 1));
            item.setAttribute('aria-setsize', String(array.length));
          });
        },

        getChildItems() {
          return this._element.allchild('gbc_RadioGroupItem');
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          const txt = gbc.ClipboardService.getSelection();

          return txt.length > 0 ? txt : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: true,
            cut: false
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('RadioGroup', cls.RadioGroupWidget);
  });
;

'use strict';

modulum('RichTextWidget', ['WebComponentWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class RichTextWidget
     * @memberOf classes
     * @extends classes.WebComponentWidget
     */
    cls.RichTextWidget = context.oo.Class(cls.WebComponentWidget, function($super) {
      return /** @lends classes.RichTextWidget.prototype */ {
        __name: 'RichTextWidget',
        /**
         * @type {?string}
         */
        _richtextPath: null,

        _richTextProperties: null,

        /**
         * @inheritDoc
         */
        constructor: function(opts) {
          this._richtextPath = context.ThemeService.getResource("webcomponents/fglrichtext/fglrichtext.html");
          $super.constructor.call(this, opts);
          this._richTextProperties = {
            toolbar: true,
          };
          this._cursors = {
            "start": 0,
            "end": 0
          };
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          // Use this line if gbc should use the FGL richtext editor (only for 3.10)
          // this._richtextPath = gbc.WebComponentService.getWebcomponentUrl() + '/fglrichtext/fglrichtext.html';
          this.setWebComponentType('api');
          this.setUrl(this._richtextPath);
        },

        /**
         * Display the toolbar or not
         * @param {boolean|string} show
         */
        showEditToolBox: function(show) {
          this._richTextProperties.toolbar = show !== 'hide';
          this._onReadyExecute(function() {
            this._toICAPI('onProperty', {
              'toolbar': show
            });
          }.bind(this));

          this._toICAPI('onProperty', {
            'toolbar': show
          });
        },

        /**
         * Defines the toolbar items
         * @param {string} items - string representing items
         */
        setToolbarItems: function(items) {
          this._onReadyExecute(function() {
            this._toICAPI('onProperty', {
              'toolbar': items
            });
          }.bind(this));

          this._toICAPI('onProperty', {
            'toolbar': items
          });
        },

        /**
         * @inheritDoc
         */
        _onReady: function() {
          $super._onReady.call(this);
          this._iframeElement.removeClass('hidden');
          //Load Spellchecker and create a default toolbar
          this._onReadyExecute(function() {
            const tb = this._richTextProperties.toolbar ?
              'bold italic underline | alignleft aligncenter alignright alignjustify | bullist numlist | outdent indent | fontsizeselect' :
              'hide';
            this._toICAPI('onProperty', {
              'toolbar': tb,
              'spellcheck': 'browser'
            });
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);

          this._onReadyExecute(function() {
            this._toICAPI('onStateChanged', JSON.stringify({
              'active': readonly,
            }));
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled, noSelectionUpdate) {
          $super.setEnabled.call(this, enabled, noSelectionUpdate);
          // Enable or disable Editor
          this._onReadyExecute(function() {
            this._toICAPI('onStateChanged', JSON.stringify({
              'active': enabled ? 1 : 0,
            }));
          }.bind(this));
        },

        /**
         * NotEditable allows cursor moving, but not a value change
         * @param {boolean} notEditable - true to set the edit part as read-only
         */
        setNotEditable: function(notEditable) {
          this._notEditable = notEditable;
          this._onReadyExecute(function() {
            // Note that noteditable key is in lowercase since properties sent by VM are always in lowercase
            this._toICAPI('onProperty', JSON.stringify({
              'noteditable': notEditable,
            }));
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          if (value === '') {
            value = null;
          }
          this._value = value;
          if (this._isReady && this.value !== this._flushValue) {
            this._toICAPI('onData', this._value ? this._value : '');
          } else {
            this.when(cls.WebComponentWidget.ready, this._onReadyData.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._onReadyExecute(function() {
            if (this._iframeElement !== document.activeElement) {
              this._toICAPI('onFocus', true);
            }
          }.bind(this));
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * Instruct the webcomponent to set cursors
         * @param {Number} start - vm equivalent to cursor0
         * @param {Number} end - vm equivalent to cursor1
         */
        setCursors: function(start, end) {
          this._cursors = {
            "start": start,
            "end": end
          };
          if (end === -1) {
            end = start;
          }
          this._onReadyExecute(function() {
            // Note that noteditable key is in lowercase since properties sent by VM are always in lowercase
            this._toICAPI('onProperty', JSON.stringify({
              'cursors': {
                'cursor': start,
                'cursor2': end - start // quillJS specification
              },
            }));
          }.bind(this));
        },

        /**
         * Get the cursor position of the richtext webcomponent
         * @return {{start: (*|number), end: number}} - an object with cursor positions
         */
        getCursors: function() {
          let rtCursors = null;
          try {
            rtCursors = this._iframeElement.contentWindow.richtext.getSelection();
          } catch (e) {} // When WebComponent is not ready yet

          return {
            start: rtCursors ? rtCursors.index : this._cursors.start,
            end: rtCursors ? rtCursors.index + rtCursors.length : this._cursors.end,
          };
        },

        /**
         * Force webcomponent to get data
         */
        flushWebcomponentData: function() {
          this._toICAPI('onFlushData');
        },

      };
    });
    cls.WidgetFactory.registerBuilder('RichText', cls.RichTextWidget);
  });
;

'use strict';

modulum('RipGraphicWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Label widget.
     * @class RipGraphicWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.RipGraphicWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.RipGraphicWidget.prototype */ {
        __name: 'RipGraphicWidget',

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.LeafLayoutEngine(this);
          }
        },
        setType: function(type) {
          this.addClass(type);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('RipGraphic', cls.RipGraphicWidget);
  });
;

'use strict';

modulum('SliderWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Slider widget.
     * @class SliderWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.SliderWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.SliderWidget.prototype */ {
        __name: 'SliderWidget',
        /**
         * Redefine where the data is located
         * @type {string|Object}
         */
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        /**
         * Slider orientation. Default is horizontal
         * @type {?string}
         */
        _orientation: null,
        /**
         * Flag to indicate if we updated orientation before or after first widget layout
         */
        _afterLayoutFlag: null,

        /**
         * @constructs
         * @param {Object} opts - Options passed to the constructor
         * @publicdoc
         */
        constructor: function(opts) {
          $super.constructor.call(this, opts);
          this.setFocusable(true);
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutEngine = new cls.SliderLayoutEngine(this);
            this._layoutInformation.getSizePolicyConfig().initial = cls.SizePolicy.Dynamic();
            this._layoutInformation.getSizePolicyConfig().fixed = cls.SizePolicy.Dynamic();

            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(false);
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('input')[0];

          this._inputElement.on('touchend.SliderWidget', this._onSlide.bind(this));
          this._inputElement.on('touchstart.SliderWidget', function() {
            this._preventContainerScrolling(true);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._inputElement.off('touchend.SliderWidget');
          this._inputElement.off('touchstart.SliderWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         * @param domEvent
         * @returns {boolean}
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         * @param domEvent
         * @returns {boolean}
         */
        manageMouseUp: function(domEvent) {
          $super.manageMouseUp.call(this, domEvent);

          this._onSlide.call(this, domEvent);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            keyProcessed = true;
            switch (keyString) {
              case "down":
              case this.getStart():
                this.setEditing(true);
                const decVal = this._decrease();
                this.triggerValueChangedEvent(decVal.toString());
                break;
              case "up":
              case this.getEnd():
                this.setEditing(true);
                const incVal = this._increase();
                this.triggerValueChangedEvent(incVal.toString());
                break;
              case "home":
                this.setEditing(true);
                const incValMax = this._decreaseToMin();
                this.triggerValueChangedEvent(incValMax.toString());
                break;
              case "end":
                this.setEditing(true);
                const incValMin = this._increaseToMax();
                this.triggerValueChangedEvent(incValMin.toString());
                break;
              default:
                keyProcessed = false;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Manage key before any action
         * @param {string}  - key string representation
         * @param {Object} domKeyEvent - key event from DOM
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} returns if the domKeyEvent has been processed by the widget
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (this.isInTable()) {
            return this.getTableWidgetBase().managePriorityKeyDown(keyString, domKeyEvent, repeat);
          } else if (this.isInScrollGrid()) {
            let scrollGridWidget = this.getScrollGridWidget() || this.getStretchableScrollGridWidgetBase();
            return scrollGridWidget.managePriorityKeyDown(keyString, domKeyEvent, repeat);
          }
          switch (keyString) {
            case "pagedown":
              this.setEditing(true);
              const decVal = this._decrease();
              this.triggerValueChangedEvent(decVal.toString());
              return true;
            case "pageup":
              this.setEditing(true);
              const incVal = this._increase();
              this.triggerValueChangedEvent(incVal.toString());
              return true;
          }
          return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
        },
        /**
         * Handler executed on mouse click. We update the value depending of pointer location click on the slider
         * and send it to VM
         * @param {UIEvent} evt - DOM event
         */
        _onSlide: function(evt) {
          if (!this.hasFocus()) {
            this._onRequestFocus(evt); // request focus
          }
          // need to emit change because on some browsers, change event is not raised when slider has not yet the focus
          if (this.isEnabled() && !this.isReadOnly()) {
            let total;
            // Vertical sliders are rotated with CSS. evt.offsetX takes this into account. getBoundingClientRect doesn't
            let clickPos = 0;
            const inputRect = this._inputElement.getBoundingClientRect();
            if (evt.offsetX) {
              clickPos = evt.offsetX;
              // on mobile offsetX doesn't exist. We need to calculate the relative click position using global pageX and input position
            } else if (window.isTouchDevice() && evt.changedTouches[0]) {
              if (this.getOrientation() === 'horizontal') {
                clickPos = evt.changedTouches[0].pageX - inputRect.left;
              } else {
                clickPos = inputRect.bottom - evt.changedTouches[0].pageY;
              }
            }
            if (this.getOrientation() === 'horizontal') {
              total = inputRect.width;
            } else {
              total = inputRect.height;
            }
            const expectedTotal = this.getMax() - this.getMin();
            const expectedVal = expectedTotal * (clickPos / total);
            const step = this.getStep();
            let value = this.getMin() + Math.floor(expectedVal / step) * step;
            if ((expectedVal % step) > (step / 2)) {
              value += step;
            }
            value = Math.clamp(value, this.getMin(), this.getMax());
            this.setEditing(true);
            if (this.hasFocus()) {
              this._inputElement.value = value;
            }
            this.triggerValueChangedEvent(value);
          }
          this._preventContainerScrolling(false);
        },

        /**
         * Increase the displayed value
         */
        _increase: function() {
          const newValue = Math.min(((this.getValue() || 0) + this.getStep()), this.getMax());
          if (this.hasFocus()) {
            this.setValue(newValue, false);
          }
          return newValue;
        },

        /**
         * Increase to the maximun the displayed value
         */
        _increaseToMax: function() {
          const newValue = this.getMax();
          if (this.hasFocus()) {
            this.setValue(newValue, false);
          }
          return newValue;
        },

        /**
         * Decrease the displayed value
         */
        _decrease: function() {
          const newValue = Math.max(((this.getValue() || 0) - this.getStep()), this.getMin());
          if (this.hasFocus()) {
            this.setValue(newValue, false);
          }
          return newValue;
        },

        /**
         * Decrease to the minimum the displayed value
         */
        _decreaseToMin: function() {
          const newValue = this.getMin();
          if (this.hasFocus()) {
            this.setValue(newValue, false);
          }
          return newValue;
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          return parseInt(this._inputElement.value, 10);
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);
          value = parseInt(value);
          this._inputElement.value = Object.isNumber(value) && !Number.isNaN(value) ? value : 0;
          this.setAriaAttribute("valuenow", value);
        },

        /**
         * Get minimum possible value of the slider
         * @returns {number} the minimum value
         * @publicdoc
         */
        getMin: function() {
          return this._inputElement.getIntAttribute('min');
        },

        /**
         * Define the minimum possible value of the slider
         * @param {number} value - the minimum value
         * @publicdoc
         */
        setMin: function(value) {
          if (Object.isNumber(value)) {
            this._inputElement.setAttribute('min', value);
          } else {
            this._inputElement.removeAttribute('min');
          }
          this.setAriaAttribute("valuemin", value);
        },

        /**
         * Get maximum possible value of the slider
         * @returns {number} the maximum value
         * @publicdoc
         */
        getMax: function() {
          return this._inputElement.getIntAttribute('max');
        },

        /**
         * Define the maximum possible value of the slider
         * @param {number} value - the maximum value
         * @publicdoc
         */
        setMax: function(value) {
          if (Object.isNumber(value)) {
            this._inputElement.setAttribute('max', value);
          } else {
            this._inputElement.removeAttribute('max');
          }
          this.setAriaAttribute("valuemax", value);
        },

        /**
         * Get slider step when increasing or decreasing value
         * @returns {number} the step value
         * @publicdoc
         */
        getStep: function() {
          return this._inputElement.getIntAttribute('step');
        },

        /**
         * Define the slider step when increasing or decreasing value
         * @param {number} step - the step value
         * @publicdoc
         */
        setStep: function(step) {
          this._inputElement.setAttribute('step', Object.isNumber(step) && step > 0 ? step : 1);
        },

        /**
         * @inheritDoc
         */
        setTitle: function(title) {
          this._inputElement.setAttribute('title', title);
        },

        /**
         * @inheritDoc
         */
        getTitle: function() {
          return this._inputElement.getAttribute('title');
        },

        /**
         * Set the orientation of the slider widget
         * @param {string} orientation can be 'horizontal' or 'vertical'
         * @param {boolean} afterLayout internal
         * @publicdoc
         */
        setOrientation: function(orientation, afterLayout) {
          if (this._orientation !== orientation || this._afterLayoutFlag !== afterLayout) {
            this._orientation = orientation;
            this._afterLayoutFlag = afterLayout;
            let newStyle = {};

            if (orientation === 'vertical' && afterLayout) {
              // Rotate only after layout
              this.setStyle({
                'transform': 'rotate(-90deg)'
              });
            } else {
              newStyle = {
                '-webkit-appearance': null,
                'writing-mode': null
              };
              if (this._inputElement) {
                this._inputElement.removeAttribute('orient');
              }
            }
            this.setStyle('>input[type=range]', newStyle);
            this.setAriaAttribute("orientation", orientation);
          }
        },

        /**
         * Get the current slider orientation. Default is horizontal.
         * @returns {string} current css orientation
         * @publicdoc
         */
        getOrientation: function() {
          return this._orientation ? this._orientation : 'horizontal';
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly);
        },

        /**
         * Set if input element is readonly
         * @param {boolean} readonly
         * @private
         */
        _setInputReadOnly: function(readonly) {
          if (readonly) {
            this._inputElement.setAttribute('readonly', 'readonly');
          } else {
            this._inputElement.removeAttribute('readonly');
          }
        },

        /**
         * Prevent the container to scroll while doing touch to scroll the tab-titles
         * @param {Boolean} prevent - true to prevent it, false otherwise
         * @private
         */
        _preventContainerScrolling: function(prevent) {
          const form = this.getFormWidget();
          if (form) {
            form.getContainerElement().toggleClass("prevent-touch-scroll", prevent);
          }
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          return null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: false,
            copy: false,
            cut: false
          };
        }
      };
    });
    cls.WidgetFactory.registerBuilder('Slider', cls.SliderWidget);
  });
;

'use strict';

modulum('SpinEditWidget', ['SpinEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * SpinEdit widget.
     * @class SpinEditWidget
     * @memberOf classes
     * @extends classes.SpinEditWidgetBase
     * @publicdoc Widgets
     */
    cls.SpinEditWidget = context.oo.Class(cls.SpinEditWidgetBase, function($super) {
      return /** @lends classes.SpinEditWidget.prototype */ {
        __name: 'SpinEditWidget',

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;
          if (this.isEnabled() && !this.isReadOnly()) {

            if (!this.isInArray()) {
              keyProcessed = this._manageNavigationKey(keyString);
            } else {
              if ((keyString === "home" && this.getMin() !== null) || (keyString === "end" && this.getMax() !== null)) {
                return false; // don't process this key
              }
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {
            if (!this.isInArray()) {
              keyProcessed = this._manageNavigationKey(keyString);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Manage navigation keys
         * @param {string} keyString - key string representation
         * @returns {boolean} returns if the key has been processed
         * @private
         */
        _manageNavigationKey: function(keyString) {
          let keyProcessed = false;
          let updateValue = 0;
          switch (keyString) {
            case "down":
              updateValue = -1;
              break;
            case "pagedown":
              updateValue = -10;
              break;
            case "up":
              updateValue = 1;
              break;
            case "pageup":
              updateValue = 10;
              break;
            case "home":
              const min = this.getMin();
              if (min !== null) {
                this.setEditing(this._oldValue !== min);
                this.setValue(min);
                keyProcessed = true;
              }
              break;
            case "end":
              const max = this.getMax();
              if (max !== null) {
                this.setEditing(this._oldValue !== max);
                this.setValue(max);
                keyProcessed = true;
              }
              break;
          }

          if (!keyProcessed && updateValue !== 0) {
            this._updateValue(updateValue);
            keyProcessed = true;
          }

          if (keyProcessed) {
            this.triggerValueChangedEvent(this.getValue());
          }

          return keyProcessed;
        }

      };
    });
    cls.WidgetFactory.registerBuilder('SpinEdit', cls.SpinEditWidget);
  });
;
"use strict";

modulum(
  "StarRatingWidget",
  ["SpinEditWidget", "WidgetFactory"],
  function(context, cls) {
    /**
     * Star Rating Widget.
     * @class StarRatingWidget
     * @memberof classes
     * @extends classes.SpinEditWidget
     * @publicdoc Widgets
     */
    cls.StarRatingWidget = context.oo.Class(
      cls.SpinEditWidget,
      function($super) {
        return /** @lends classes.StarRatingWidget.prototype */ {
          __name: "StarRatingWidget",
          _animationFrameOffset: 0,

          /** @type {HTMLElement[]} */
          _ratingStars: null,
          /**
           * The Css class of the stars HTML elements
           * @type {string}
           */
          _ratingStarClass: "rating_star",
          /**
           * The Css class of checked stars HTML elements
           * @type {string}
           */
          _checkedStarClass: "checked",
          /**
           * The Css class of unchecked stars HTML elements
           * @type {string}
           */
          _uncheckedStarClass: "unchecked",
          /**
           * The Css class of stars that can received the hover aspect
           * This is used for CSS performances by not using :not(.disabled) selector
           */
          _hoverableStarClass: "hoverable",

          /**
           * @inheritDoc
           */
          _initElement: function() {
            $super._initElement.call(this);
            this._ratingStars = [];
          },

          /**
           * Emit a click event when clicking on a star
           * @private
           */
          _initStarRating: function() {
            if (this._ratingStars.length === 0 && this._element) {
              this._ratingStars = [];
              // Generate the stars from the min and max value
              for (let starIndex = 0; starIndex < this._max; starIndex += 1) {
                const ratingStar = document.createElement("i");
                if (this._placeholder) {
                  ratingStar.innerHTML = this._placeholder;
                }
                ratingStar.classList.add(this._ratingStarClass);
                ratingStar.setAttribute("data-value", starIndex + 1);
                if (starIndex < this._min) {
                  ratingStar.classList.add(this._checkedStarClass);
                  ratingStar.classList.add("disabled");
                }
                this._ratingStars.push(ratingStar);
                this._element.appendChild(ratingStar);
              }
              this._updateStarVisual();
            }
          },

          /**
           * Used to init stars once all the behaviors are applied
           * As we need min and max value to initialise the star widget
           * @inheritdoc
           */
          _setDOMAttachedOrDetached: function() {
            $super._setDOMAttachedOrDetached.call(this);

            if (this._animationFrameOffset) {
              this._clearAnimationFrame(this._animationFrameOffset);
            }

            this._animationFrameOffset = this._registerAnimationFrame(
              function() {
                this._animationFrameOffset = 0;
                this._initStarRating();
              }.bind(this)
            );
          },

          /**
           * @returns The Css class of the stars elements
           */
          getRatingStarClass: function() {
            return this._ratingStarClass;
          },

          /**
           * @returns The Css class of checked stars HTML elements
           */
          getCheckedStarClass: function() {
            return this._checkedStarClass;
          },

          /**
           * @returns The Css class of unchecked stars HTML elements
           */
          getUncheckedStarClass: function() {
            return this._uncheckedStarClass;
          },

          /**
           * @returns The Css class of stars that can received the css hover aspect
           */
          getHoverableStarClass: function() {
            return this._hoverableStarClass;
          },

          /**
           * @inheritDoc
           */
          setValue: function(value, fromVM = false, cursorPosition = null) {
            $super.setValue.call(this, value, fromVM, cursorPosition);
            this._updateStarVisual();
          },

          /**
           * @inheritdoc
           */
          setMin: function(min) {
            // Override the setMin to prevent min to be below 0 or null
            if (min < 0) {
              this.throwError("valueMinError");
            }
            min = min ? min : 0;
            $super.setMin.call(this, min);
          },

          /**
           * @inheritdoc
           */
          setMax: function(max) {
            // Override the setMax so if no max is set in the genero program, 5 is used
            if (max > 10) {
              this.throwError("valueMaxError");
            }
            max = max ? max : 5;
            $super.setMax.call(this, max);
          },

          /**
           * @inheritdoc
           */
          setStep: function(step) {
            if (step && step !== 1) {
              this.throwError("stepError");
            }
            $super.setStep.call(this, step);
          },

          /**
           * @inheritdoc
           */
          setEnabled: function(enabled) {
            $super.setEnabled.call(this, enabled);
            this._updateStarVisual();
          },

          /**
           * @inheritDoc
           */
          manageMouseClick: function(domEvent) {
            this._onRequestFocus(domEvent);

            const target = domEvent.target;
            const clickedIndex = this._ratingStars.findIndex(
              (starElem) => starElem === target
            );
            if (clickedIndex > -1 && clickedIndex >= this.getMin()) {
              const clickedValue = Number(target.getAttribute("data-value"));
              this._inputElement.value =
                Number(this._inputElement.value) === clickedValue ?
                this.getMin() :
                clickedValue;
              this.emit(
                context.constants.widgetEvents.valueChanged,
                this.getValue()
              );
            }

            return true;
          },

          /**
           * Update the star visual from the _inputElement value
           */
          _updateStarVisual: function() {
            if (!this._ratingStars && !this._inputElement) {
              return;
            }

            const currentValue = Number(this._inputElement.value);
            for (
              let starIndex = 0; starIndex < this._ratingStars.length; starIndex++
            ) {
              if (starIndex < this.getMin()) {
                continue;
              }

              const starElement = this._ratingStars[starIndex];

              starElement.removeClass(this._uncheckedStarClass);
              starElement.removeClass(this._checkedStarClass);
              starElement.removeClass(this._hoverableStarClass);

              starElement.addClass(
                starIndex < currentValue ?
                this._checkedStarClass :
                this._uncheckedStarClass
              );
              if (this._enabled) {
                starElement.addClass(this._hoverableStarClass);
              }
            }
          },

          /**
           * Stop the with a Fail message
           * @param {string} error The error code under gwc.starRating in the i18next files
           */
          throwError: function(error) {
            const currentApp =
              gbc.SessionService.getCurrent() &&
              gbc.SessionService.getCurrent().getCurrentApplication();
            if (currentApp) {
              currentApp.fail(i18next.t(`gwc.starRating.${error}`));
            }
          },

          /**
           * Destroy Star Rating instances and unbind events
           */
          destroy: function() {
            this._starRating = null;
            $super.destroy.call(this);
          },
        };
      }
    );

    cls.WidgetFactory.registerBuilder(
      "SpinEdit[customWidget=starRating]",
      cls.StarRatingWidget
    );
    cls.WidgetFactory.registerBuilder("StarRating", cls.StarRatingWidget);
  }
);
;

'use strict';

modulum('TextEditWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TextEdit widget.
     * @class TextEditWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */

    cls.TextEditWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {

      return /** @lends classes.TextEditWidget.prototype */ {
        __name: 'TextEditWidget',
        /**
         * true if textedit can contains HTML content
         * @type {boolean}
         */
        _hasHTMLContent: false,
        /**
         * true if we must sanitize the html
         * @type {boolean}
         * */
        _sanitize: null,
        /** @type classes.HtmlFilterWidget **/
        _htmlFilter: null,
        /** @type {boolean} */
        _wantReturns: true,
        /** @type {boolean} */
        _wantTabs: false,
        /** @type {string} */
        _oldInnerHTML: null,
        /** For cache value */
        $static: {
          _sanitisationCache: {},
          _keys: [],
          getCacheValue: function(key) {
            if (!this._sanitisationCache[key]) {
              return null;
            }
            // Update the order
            this._keys.splice(this._keys.indexOf(key), 1);
            this._keys.unshift(key);

            return this._sanitisationCache[key];
          },
          setCacheValue: function(key, value) {
            if (!this._sanitisationCache[key]) {
              // Delete the less recently used value
              if (this._keys.length >= gbc.ThemeService.getValue('gbc-TextEditWidget-capacity')) {
                let oldestKey = this._keys.pop();
                delete this._sanitisationCache[oldestKey];
              }
              this._keys.unshift(key);
            } else {
              // if the key already exist update the order
              this._keys.splice(this._keys.indexOf(key), 1);
              this._keys.unshift(key);
            }
            this._sanitisationCache[key] = value;
          }
        },
        /**
         * Redefine where the data is located
         * @type {string|Object}
         */
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutInformation.shouldFillStack = true;
            this._layoutEngine = new cls.TextEditLayoutEngine(this);
            this._layoutEngine._shouldFillHeight = true;
            // shouldn't support sizepolicy dynamic, so we override it
            this._layoutInformation.getSizePolicyConfig().dynamic = cls.SizePolicy.Initial();
            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(true);
            this._layoutInformation.forcedMinimalWidth = 20;
            this._layoutInformation.forcedMinimalHeight = 20;
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._inputElement = this._element.getElementsByTagName('textarea')[0];
          this._initListeners();
        },

        /**
         * Initialize all widget events listener
         */
        _initListeners: function() {
          if (window.isMobile()) {
            // Track the focus and mouse down/up events on mobile devices to handle the virtual keyboard's TAB key
            this._inputElement.on('focus.FieldWidgetBase', this._onMobileFocus.bind(this));
          }
        },

        /**
         * Clear event listeners of the widget
         */
        _unloadListeners: function() {
          if (window.isMobile()) {
            this._inputElement.off('focus.FieldWidgetBase');
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._unloadListeners();

          if (this._htmlFilter) {
            this._htmlFilter.destroy();
            this._htmlFilter = null;
          }

          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);

          // Manage requestFocus during selection of text
          cls.WidgetBase._onSelect.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._onRequestFocus(domEvent); // request focus
          this.emit(context.constants.widgetEvents.click, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled()) {
            switch (keyString) {
              // Standard navigation : let default
              case "up":
              case "down":
              case "end":
              case "home":
                domKeyEvent.gbcDontPreventDefault = true;
                keyProcessed = true;
                break;

              case "enter":
              case "return":
                if (!this.isNotEditable() && this._wantReturns) {
                  domKeyEvent.gbcDontPreventDefault = true;
                  keyProcessed = true;
                }
                break;

              case "tab":
                if (!this.isNotEditable() && this._wantTabs) {
                  keyProcessed = true;
                  this._insertTab();
                }
                break;
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * @inheritDoc
         */
        _checkValue: function(text, newTextPart) {
          if (this._dialogType !== 'Input' && this._dialogType !== 'InputArray') {
            return newTextPart;
          }

          if (this._maxLength > 0 && !this.getUserInterfaceWidget().isCharLengthSemantics()) {
            newTextPart = this.checkValueByteCount(text, newTextPart, this._maxLength);
          }

          return newTextPart;
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          if (!this._hasHTMLContent) {
            this.controlValueLength(event);
          }
          if (!this.getInputTextState().isRestored()) {
            this.triggerValueChangedEvent(this.getValue(), false);
          }
        },

        /**
         * Insert a TAB char
         * @private
         */
        _insertTab: function() {
          const s = this._inputElement.selectionStart;
          const value = this._inputElement.value.substring(0, this._inputElement.selectionStart) + "\t" + this._inputElement.value
            .substring(this._inputElement.selectionEnd);

          // If Maxlength is not defined, insert tab character anyway
          if (!this.getMaxLength() || value.length <= this.getMaxLength()) {
            this.setValue(value);
            this._inputElement.selectionEnd = s + 1;
          }
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);
          this._setValue(value);

          if (cursorPosition && this.isEnabled()) {
            this._inputElement.selectionStart = this._inputElement.selectionEnd = cursorPosition;
          }
        },

        /**
         * Internal setValue used to be inherited correctly by DummyWidget
         * @param {string} value - the value
         * @private
         */
        _setValue: function(value) {
          if (this._hasHTMLContent) {
            if (this._sanitize) {
              if (value === '') {
                if (value !== this.oldInnerHTML) {
                  this._inputElement.innerHTML = value;
                  this.oldInnerHTML = value;
                }

                // If empty string, then we just ignore
                return;
              }

              // If the value is not in the cache, then we clean it
              if (!cls.TextEditWidget.getCacheValue(value)) {
                // Clean and update the cache
                cls.TextEditWidget.setCacheValue(value, this._htmlFilter.sanitize(value));
              }

              const valueGet = cls.TextEditWidget.getCacheValue(value);
              if (valueGet !== this.oldInnerHTML) {
                this._inputElement.innerHTML = valueGet;
                this.oldInnerHTML = valueGet;
              }
            } else {
              this._inputElement.innerHTML = value;
            }
          } else {
            this._inputElement.value = value;
          }
        },

        /**
         * @inheritDoc
         */
        getValue: function() {
          if (this._hasHTMLContent === true) {
            return this._inputElement.innerHTML;
          } else if (this._editingTime === 0) { // not touched by user
            // return exact VM value to avoid bad conversion from \r to \n
            return this._valueStack[this._valueStackCursor] || "";
          } else {
            let result = this._inputElement.value;
            if (this.isEditing()) {
              if (this.getTextTransform() === 'up') {
                result = result.toLocaleUpperCase();
              }
              if (this.getTextTransform() === 'down') {
                result = result.toLocaleLowerCase();
              }
            }
            return result;
          }
        },

        /**
         * @inheritDoc
         */
        setReadOnly: function(readonly) {
          $super.setReadOnly.call(this, readonly);
          this._setInputReadOnly(readonly || this._notEditable || !this._enabled);
        },

        /**
         * Set input readonly attribute if it doesn't have focus or is noentry.
         * @param {boolean} readonly - true to set the edit part as read-only, false otherwise
         */
        _setInputReadOnly: function(readonly) {
          if (readonly || this._isReadOnly) {
            if (this._hasHTMLContent) {
              if (this._inputElement.hasAttribute("contenteditable")) {
                this._inputElement.removeAttribute('contenteditable');
              }
            } else {
              this._inputElement.setAttribute('readonly', 'readonly');
            }
          } else {
            if (this._hasHTMLContent) {
              if (!this._inputElement.hasAttribute("contenteditable")) {
                this._inputElement.setAttribute('contenteditable', true);
              }
            } else {
              this._inputElement.removeAttribute('readonly');
            }
          }
        },

        /**
         * @inheritDoc
         */
        setMaxLength: function(maxLength) {
          $super.setMaxLength.call(this, maxLength);
          if (maxLength > 0) {
            this._setElementAttribute('maxlength', maxLength, "_inputElement");
          }
        },

        /** Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number} [cursor2] - second cursor position
         * @publicdoc
         */
        setCursors: function(cursor, cursor2) {
          if (!cursor2) {
            cursor2 = cursor;
          }

          this._inputElement.setCursorPosition(cursor, cursor2);
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          const cursors = {
            start: 0,
            end: 0
          };
          if (this._inputElement && this._inputElement.value) {
            try {
              cursors.start = this._inputElement.selectionStart;
              cursors.end = this._inputElement.selectionEnd;
            } catch (ignore) {
              // Some input types don't allow cursor manipulation
            }
          }
          return cursors;
        },

        /**
         * @inheritDoc
         */
        setTextAlign: function(align) {
          $super.setTextAlign.call(this, align);
          this.setStyle(">textarea", {
            "text-align": align
          });
        },

        /**
         * Replace default textarea element used to display text with a html element which can displays HTML
         * @param {HTMLElement} jcontrol - div element
         * @publicdoc
         */
        setHtmlControl: function(jcontrol) {
          if (this._htmlFilter === null) {
            this._htmlFilter = cls.WidgetFactory.createWidget('HtmlFilterWidget', this.getBuildParameters());
          }
          if (this.isEnabled()) {
            jcontrol.setAttribute('contenteditable', true);
          }
          jcontrol.innerHTML = this.getValue();
          // Remove events before replacing the widget
          this._unloadListeners();
          this._inputElement.replaceWith(jcontrol);
          this._hasHTMLContent = true;
          this._inputElement = jcontrol;
          // Initialize events for the new widget
          this._initListeners();
          if (this.hasFocus()) {
            // Force focus again if it has focus
            this.setFocus();
          }
        },

        /**
         * sanitize = false : Authorize to send html text without control
         * @param {boolean} sanitize
         */
        setSanitize: function(sanitize) {
          this._sanitize = sanitize;
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          this._inputElement.domFocus();
          $super.setFocus.call(this, fromMouse);
          this._inputElement.scrollTop = 0;
        },

        /**
         * Set number of editable rows inside the textedit widget
         * @param {number} rows - number of rows
         * @publicdoc
         */
        setRows: function(rows) {
          this._inputElement.setAttribute('rows', rows || 1);
        },

        /**
         * Make the textedit content return the new line breaking the word or not
         * @param {string} format - css value
         * @publicdoc
         */
        setWrapPolicy: function(format) {
          this._inputElement.toggleClass('breakword', format === 'anywhere');
        },

        /**
         * @inheritDoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._setInputReadOnly(!enabled || this._notEditable);
        },

        /**
         * Set if textedit accepts TAB key
         * @param {boolean} wantTabs - true if TAB key should be accepted in the textedit
         * @publicdoc
         */
        setWantTabs: function(wantTabs) {
          this._wantTabs = wantTabs;
        },

        /**
         * Set if textedit accepts RETURN/ENTER key
         * @param {boolean} wantReturns - true if returns/enters should be accepted in the textedit
         * @publicdoc
         */
        setWantReturns: function(wantReturns) {
          this._wantReturns = wantReturns;
        },

        /**
         * Defines the scrollBars to display
         * @param {string} scrollBars - value can be 'auto', 'both', 'none', 'horizontal', 'vertical'
         */
        setScrollBars: function(scrollBars) {
          this.addClass("scrollbars-" + scrollBars);
        },

        /**
         * @inheritDoc
         */
        getClipboardValue: function(ignoreSelection) {
          if (ignoreSelection) {
            return this.getValue();
          }

          if (this._hasHTMLContent) {
            const txt = gbc.ClipboardService.getSelection();

            return txt.length > 0 ? txt : null;
          }

          return this.getInputTextState().hasSelectedText() ? this.getInputTextState().getSelectedText() : null;
        },

        /**
         * @inheritDoc
         */
        getClipboardAuthorizedAction: function() {
          return {
            paste: true,
            copy: true,
            cut: !this._hasHTMLContent //Too much work to cut and maintain a correct HTML
          };
        }

      };
    });
    cls.WidgetFactory.registerBuilder('TextEdit', cls.TextEditWidget);
  });
;

'use strict';

modulum('TimeEditWidget', ['TimeEditWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * TimeEdit widget.
     * @class TimeEditWidget
     * @memberOf classes
     * @extends classes.TimeEditWidgetBase
     * @publicdoc Widgets
     */
    cls.TimeEditWidget = context.oo.Class(cls.TimeEditWidgetBase, function($super) {
      return /** @lends classes.TimeEditWidget.prototype */ {
        __name: 'TimeEditWidget',

        /**
         * Array of time fragment HH, MM and SS
         * @type {DateTimeHelper.timeFragment[]}
         */
        _groups: null,

        /**
         * Current cursor position
         * @type {Object}
         */
        _currentCursors: null,

        /**
         * Flag to indicate if valid number has been entered
         * @type {boolean}
         */
        _numericPressed: false,

        /**
         * Up arrow element
         * @type {Element}
         */
        _upArrow: null,

        /**
         * Down arrow element
         * @type {Element}
         */
        _downArrow: null,

        /**
         * Current group of time being updated
         * @type {number}
         */
        _currentGroup: 0,

        /**
         * Previous group of time being updated
         * @type {number}
         */
        _previousGroup: 0,

        /**
         * Last valid time being set
         * @type {?string}
         */
        _lastValid: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._groups = [
            cls.DateTimeHelper.timeFragment(24),
            cls.DateTimeHelper.timeFragment(60),
            cls.DateTimeHelper.timeFragment(60)
          ];
          this._lastValid = '00:00:00';
          this._inputElement = this._element.getElementsByTagName('input')[0];
          this._upArrow = this._element.getElementsByClassName('up')[0];
          this._downArrow = this._element.getElementsByClassName('down')[0];

          this.setValue(this._lastValid);

          this._currentCursors = {
            start: 0,
            end: 0
          };

          this._inputElement.on("change.TimeEditWidget", function(event) {
            this._inputElement.setAttribute("data-time", this._inputElement.value);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._currentCursors = null;
          this._upArrow = null;
          this._downArrow = null;
          this._inputElement.off('change.TimeEditWidget');
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseDown: function(domEvent) {
          $super.manageMouseDown.call(this, domEvent);

          // Manage requestFocus during selection of text
          cls.WidgetBase._onSelect.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          const target = domEvent.target;
          if (target.isElementOrChildOf(this._upArrow)) {
            this._onUpIcon(domEvent);
          } else if (target.isElementOrChildOf(this._downArrow)) {
            this._onDownIcon(domEvent);
          } else if (target.isElementOrChildOf(this._inputElement)) {
            this._onInputClick(domEvent);
          }

          return true;
        },

        /**
         * @inheritDoc
         */
        manageKeyDown: function(keyString, domKeyEvent, repeat) {
          let keyProcessed = false;

          if (this.isEnabled() && !this.isReadOnly()) {

            const start = this._inputElement.selectionStart;
            const end = this._inputElement.selectionEnd;

            keyProcessed = true;
            switch (keyString) {
              case "down":
                const decVal = this._decrease();
                this.triggerValueChangedEvent(decVal);
                break;
              case "up":
                const incVal = this._increase();
                this.triggerValueChangedEvent(incVal);
                break;
              case this.getStart():
              case this.getEnd():
                this._updateCurrentGroup();
                keyProcessed = false; // let the default behavior, just update current group
                break;
              case ":":
              case "shift+:":
              case "ctrl+" + this.getEnd():
                //Update current group of time being selected
                this._moveGroup(1);
                this._updateSelection();
                break;
              case "ctrl+" + this.getStart():
                this._moveGroup(-1);
                this._updateSelection();
                break;
              case "backspace":
                // only whole text or single group selection deletion are permitted
                if (!this.isEditing() && !this.hasFocus()) { // first keydown in typeahead mode (cursors not ready yet)
                  return true;
                }

                if ((start === 0 && this.getValue().length === end) || this.getValue().charAt(end - 1) !== ':') {
                  keyProcessed = false; // let the default behavior
                }
                break;
              case "del":
              case "delete":
                // only whole text or single group selection deletion are permitted
                if (!this.isEditing() && !this.hasFocus()) { // first keydown in typeahead mode (cursors not ready yet)
                  return true;
                }
                // if 2 digits group selected
                if ((start === 0 && this.getValue().length === end) || this.getValue().charAt(end) !== ':' || start === end - 2) {
                  keyProcessed = false; // let the default behavior
                }
                break;
              default:
                keyProcessed = this._processKey(domKeyEvent, keyString);
            }
          }

          if (keyProcessed) {
            return true;
          } else {
            return $super.manageKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Validate current group of time and eventually update set next group as current
         * @inheritDoc
         */
        manageKeyUp: function(keyString, domKeyEvent) {
          $super.manageKeyUp.call(this, keyString, domKeyEvent);

          // if key pressed was delete or backspace, we do not update current group
          const key = cls.KeyboardApplicationService.keymap[domKeyEvent.which];
          const groupChanged = (key === "del" || key === "delete" || key === "backspace") ? false : this._updateCurrentGroup();
          let groupComplete = true;
          let modificationDone = false;
          if (this._numericPressed) {
            modificationDone = true;
            this._numericPressed = false; // important to set it back to false since keypress event isn't raised for special command
            groupComplete = this._updateGroups(this.getValue());
            if (groupComplete) {
              if (this._currentGroup < this._groups.length - 1) {
                this._moveGroup(1);
                this._updateSelection(); // only highlight group if we are not at the end
              } else { // sync true cursors with saved cursors
                this.setCursors(this._inputElement.selectionStart, this._inputElement.selectionEnd, true);
              }
            }
          }
          if (modificationDone && (groupChanged || groupComplete)) {
            //An autoNext can be done only if the last key is a number in the last group and the value is valid
            this.triggerValueChangedEvent(this.getValue(), false);
          }
        },

        /**
         * Process one key event
         * @param {Object} event
         * @param {string} keyString
         * @returns {boolean} true if key has been processed, false otherwise
         */
        _processKey: function(event, keyString) {
          const isModifier = cls.KeyboardHelper.isSpecialCommand(keyString);
          const isValid = !isModifier && cls.KeyboardHelper.isNumeric(event.gbcKey) && !this._isMaxLength();

          this._numericPressed = isValid;

          // timeedit is empty : we need to initialise its format on first numeric pressed
          if (isValid && this.getValue().length === 0) {
            this._updateFromGroups();
            this._updateSelection();
          }

          if (!isValid && !isModifier && cls.KeyboardHelper.isChar(keyString)) {
            event.preventCancelableDefault();
            return true;
          }

          return false;
        },

        /**
         * @inheritDoc
         */
        canAutoNext: function() {
          const currentValue = this.getValue();
          const size = currentValue ? currentValue.length : 0;

          if (size > 0) {
            const cursors = this.getCursors();
            const endReached = cursors.start === cursors.end && cursors.end + 1 > size && this._groups.length * 2 + this._groups.length -
              1 === currentValue.length && this
              ._previousGroup + 1 === this._groups.length;
            const isLastCharNumeric = cls.KeyboardHelper.isNumeric(currentValue[currentValue.length - 1]);

            return endReached && isLastCharNumeric;
          }
          return false;
        },

        /**
         * @inheritDoc
         */
        manageInput: function(dataString = "", event = null) {
          $super.manageInput.call(this, dataString, event);

          // if input event come is InputText it means control length has already been done by manageKeyDown
          if (!event || event.inputType !== "insertText") {
            this.controlValueLength(event);
          }
        },

        /**
         * @inheritDoc
         */
        _checkValue: function(text, newTextPart) {
          if (this._dialogType !== 'Input' && this._dialogType !== 'InputArray') {
            return newTextPart;
          }

          newTextPart = this.checkValueDisplayWidth(text, newTextPart);

          return newTextPart;
        },

        /**
         * Increase the current group value and update current group selection if needed
         */
        _increase: function() {
          this.setEditing(true);
          if (this._groups[this._currentGroup].increaseValue()) {
            if (this._currentGroup > 0 && this._groups[this._currentGroup - 1].increaseValue()) {
              if (this._currentGroup > 1) {
                this._groups[0].increaseValue();
              }
            }
          }
          const newValue = this._updateFromGroups();
          if (this.hasFocus()) {
            this._updateSelection();
          }
          return newValue;
        },

        /**
         * Decrease the current group value
         */
        _decrease: function() {
          this.setEditing(true);
          if (this._groups[this._currentGroup].decreaseValue()) {
            if (this._currentGroup > 0 && this._groups[this._currentGroup - 1].decreaseValue()) {
              if (this._currentGroup > 1) {
                this._groups[0].decreaseValue();
              }
            }
          }
          const newValue = this._updateFromGroups();
          if (this.hasFocus()) {
            this._updateSelection();
          }
          return newValue;
        },

        /**
         * Changes the current group
         * @param {number} where - group index
         */
        _moveGroup: function(where) {
          if (where < 0) {
            if (this._currentGroup !== 0) {
              this._previousGroup = this._currentGroup;
              this._currentGroup = this._currentGroup + where;
            }
          } else {
            if (this._currentGroup < this._groups.length - 1) {
              this._previousGroup = this._currentGroup;
              this._currentGroup = this._currentGroup + where;
            }
          }
        },

        /**
         * Updates the current group depending on the cursor position
         * @returns {boolean} true if the current group has changed, false otherwise
         */
        _updateCurrentGroup: function() {
          const value = this.getValue(),
            firstColon = value.indexOf(':'),
            secondColon = value.lastIndexOf(':');
          const position = this._inputElement.selectionEnd;
          let newPosition = 0;
          let oldPosition = this._currentGroup;
          if (secondColon !== -1) {
            newPosition = position <= firstColon ? 0 : (firstColon === secondColon || position <= secondColon ? 1 : 2);
          } else {
            oldPosition = 0;
          }
          oldPosition = Math.min(this._currentGroup, oldPosition);

          this._previousGroup = this._currentGroup;
          this._currentGroup = newPosition;
          const hasChanged = newPosition !== oldPosition;
          if (hasChanged && !this._isGroupComplete(oldPosition)) {
            this._updateFromGroups();
          }
          return hasChanged;
        },

        /**
         * Indicates if group is complete
         * @param {number} groupIndex - cursor position of group to test
         * @returns {boolean} true if group is complete
         */
        _isGroupComplete: function(groupIndex) {
          const value = this.getValue().split(':');
          return this._groups[groupIndex].fromText(value[groupIndex]);
        },

        /**
         * Update current group time value
         * @param {string} value - time value
         * @param {boolean} [force] - if true we consider this value is valid
         * @returns {boolean} true if group is complete
         */
        _updateGroups: function(value, force) {
          let complete = true;
          if (!this._useSeconds && this._groups.length === 3) {
            this._groups.pop();
          }
          for (let i = 0; i < this._groups.length; i++) {
            complete = complete && this._isGroupComplete(i);
          }
          if (complete || force) {
            this._updateFromGroups();
            this._lastValid = this.getValue();
          }
          return complete;
        },

        /**
         * Rebuilds the value from groups
         */
        _updateFromGroups: function() {
          let value = '';
          for (let i = 0; i < this._groups.length; i++) {
            value += (i > 0 ? ':' : '') + this._groups[i].getText();
          }
          if (this.hasFocus()) { // do not update value if typeahead is active (mouse click)
            this.setValue(value);
          }
          return value;
        },

        /**
         * Updates the selection range based on current group
         */
        _updateSelection: function() {
          let start = this._currentGroup * 3;
          if (start < 0) {
            start = 0;
          }
          if (start + 2 <= this.getValue().length) {
            this.setCursors(start, start + 2, true);
          }
        },

        /**
         * Handler which updates current group of time being updated
         * @param {UIEvent} event - DOM event
         */
        _onInputClick: function(event) {
          if (this.isEnabled() && !this.isReadOnly() && this.getValue() !== '') {
            // on-click we update current time group and update selection/cursors in consequence
            this._updateCurrentGroup();
            this._updateSelection();
          }
          this._onRequestFocus(event); // request focus
        },

        /**
         * @inheritDoc
         */
        _onUpIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._onRequestFocus(evt); // request focus
            if (this.hasFocus()) { // focus input element before updating its cursors
              this._inputElement.domFocus();
            }
            const newValue = this._increase();
            this.triggerValueChangedEvent(newValue);
          }
        },

        /**
         * @inheritDoc
         */
        _onDownIcon: function(evt) {
          if (this.isEnabled() && !this.isReadOnly()) {
            this._onRequestFocus(evt); // request focus
            if (this.hasFocus()) { // focus input element before updating its cursors
              this._inputElement.domFocus();
            }
            const newValue = this._decrease();
            this.triggerValueChangedEvent(newValue);
          }
        },

        /**
         * Get cursors
         * @return {{start: number, end: number}} object with cursors
         * @publicdoc
         */
        getCursors: function() {
          return this._currentCursors;
        },

        /**
         * Place the cursor at the given position,
         * @param {number} cursor - first cursor position
         * @param {number} cursor2 - second cursor position
         * @param {Boolean} doNotUpdateGroup
         */
        setCursors: function(cursor, cursor2, doNotUpdateGroup) {
          let start = cursor;
          let end = cursor2;
          if (cursor2 === -1) {
            start = 0;
            end = 2;
          } else if (!cursor2) { // if cursor2 isn't defined, start cursor is used as end as well
            end = start;
          }
          this._currentCursors.start = start;
          this._currentCursors.end = end;
          this._inputElement.setCursorPosition(start, end);
          if (!doNotUpdateGroup) {
            this._updateCurrentGroup();
          }
          if (!cursor2) { // if cursor2 isn't defined or set to 0, we need to fallback selection to current group
            this._updateSelection();
          }
        },

        /**
         * @inheritDoc
         */
        setDisplayFormat: function(format) {
          $super.setDisplayFormat.call(this, format);
          this._updateGroups(this.getValue());
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          if (this.getValue() !== value) {
            $super.setValue.call(this, value, fromVM, cursorPosition);
            this._updateGroups(value);
          }
        },

        /**
         * @inheritDoc
         */
        setFocus: function(fromMouse) {
          $super.setFocus.call(this, fromMouse);
          const currentCursors = this.getCursors();
          this.setCursors(currentCursors.start, currentCursors.end);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('TimeEdit', cls.TimeEditWidget);
  });
;

'use strict';

modulum('ToggleCheckBoxWidget', ['CheckBoxWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Toggle Checkbox widget. Like a switch
     * @class ToggleCheckBoxWidget
     * @memberOf classes
     * @extends classes.CheckBoxWidget
     * @publicdoc Widgets
     */
    cls.ToggleCheckBoxWidget = context.oo.Class(cls.CheckBoxWidget, function($super) {
      return /** @lends classes.ToggleCheckBoxWidget.prototype */ {
        __name: 'ToggleCheckBoxWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,

        /** @type {Boolean} **/
        _threeState: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._checkboxElement = this._element.getElementsByClassName('switch')[0];
        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          $super.setValue.call(this, value, fromVM, cursorPosition);
          this._checkboxElement.querySelector('input').checked = (value === this._checkedValue);
          this.setAriaAttribute("checked", value); // ensure it's a stringified boolean
        },

        /**
         * Will get the next value : forced to check / uncheck since toggle is only 2 states
         * @return {string|number} the checked or unchecked value
         * @publicdoc
         */
        getNextValue: function() {
          const current = this._value;
          if (current === this._uncheckedValue) {
            return this._checkedValue;
          } else if (current === this._checkedValue) {
            return this._uncheckedValue;
          }
        },

        /**
         * Get the current value of the widget according to its state
         * @return {string|number} the current value of the widget
         * @publicdoc
         */
        getValue: function() {
          const checkBox = this._checkboxElement.querySelector('input');
          if (checkBox.checked) {
            return this._checkedValue;
          } else {
            return this._uncheckedValue;
          }
        },

        /**
         * Allow/disallow widget user interaction.
         * @param {boolean} enabled - the wanted state
         * @publicdoc
         */
        setEnabled: function(enabled) {
          const checkBox = this._checkboxElement.querySelector('input');
          checkBox.disabled = !enabled;
          $super.setEnabled.call(this, enabled);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          domEvent.preventCancelableDefault(); // click should not change automatically checkbox it is done by manageMouseClick
          return $super.manageMouseClick.call(this, domEvent);
        },

      };
    });

    cls.WidgetFactory.registerBuilder('CheckBox[customWidget=toggleButton]', cls.ToggleCheckBoxWidget);
    cls.WidgetFactory.registerBuilder('ToggleCheckBox', cls.ToggleCheckBoxWidget);
  });
;

"use strict";

modulum('FileInputWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Upload widget.
     * @class FileInputWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.FileInputWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.FileInputWidget.prototype */ {
        __name: "FileInputWidget",

        $static: /** @lends classes.FileInputWidget */ {
          statusChangedEvent: "statusChanged",
          fileSelectionChangedEvent: "fileSelectionChanged",
          progressChangedEvent: "progressChanged"
        },

        _allowMultipleFiles: false,
        /** @type {?string} */
        _rawCaption: null,

        _files: null,

        /**
         * @type {HTMLElement}
         */
        _hiddenInput: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._hiddenInput = this._element.querySelector("input");
          this._element.on("drop.FileInputWidget", this._onDrop.bind(this));
          this._element.on("dragenter.FileInputWidget", this._onDragEnter.bind(this));
          this._element.on("dragleave.FileInputWidget", this._onDragLeave.bind(this));
          this._element.on("dragover.FileInputWidget", this._onDragOver.bind(this));
          this._element.on("mouseover.FileInputWidget", this._onMouseOver.bind(this));
          this._element.on("mouseout.FileInputWidget", this._onMouseOut.bind(this));
          this._hiddenInput.on("change.FileInputWidget", this._onFileChanged.bind(this));
          this.setCaption();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._hiddenInput = null;
          this._element.off("drop.FileInputWidget");
          this._element.off("dragenter.FileInputWidget");
          this._element.off("dragleave.FileInputWidget");
          this._element.off("dragover.FileInputWidget");
          this._element.off("mouseover.FileInputWidget");
          this._element.off("mouseout.FileInputWidget");
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._hiddenInput.click();
          return true;
        },

        /**
         * Handler when a file is dropped on the zone
         * @param {MouseEvent} event
         * @private
         */
        _onDrop: function(event) {
          this._element.removeClass("dropping");
          event.stopPropagation();
          event.stopImmediatePropagation();
          event.preventCancelableDefault();
          this._files = event.dataTransfer.files;
          this._onFileChanged();
        },

        /**
         * Handler on drag enter the zone
         * @param {Object} event - DOM event
         * @private
         */
        _onDragEnter: function(event) {
          this._element.addClass("dropping");
        },

        /**
         * Handler on drag leave the zone
         * @param {Object} event - DOM event
         * @private
         */
        _onDragLeave: function(event) {
          this._element.removeClass("dropping");
        },

        /**
         * Handler while dragging over the zone
         * @param {MouseEvent} event
         * @private
         */
        _onDragOver: function(event) {
          this._element.addClass("dropping");
          event.stopPropagation();
          event.stopImmediatePropagation();
          event.preventCancelableDefault();
          try {
            const effects = event && event.dataTransfer && !window.browserInfo.isIE && event.dataTransfer.effectAllowed;
            event.dataTransfer.dropEffect = 'move' === effects || 'linkMove' === effects ? 'move' : 'copy';
          } catch (e) {}
        },

        /**
         * Handler when mouse is over the drop zone
         * @param {Object} event - DOM event
         * @private
         */
        _onMouseOver: function(event) {
          this._element.addClass("dropping");
        },

        /**
         * Handler when mouse leaves the drop zone
         * @param {Object} event - DOM event
         * @private
         */
        _onMouseOut: function(event) {
          this._element.removeClass("dropping");
        },

        /**
         * Handler when the file has changed
         * @private
         */
        _onFileChanged: function() {
          let result, i;

          //After dropping a file the dialog could still be open but the input widget no longer exist
          if (this._hiddenInput === null) {
            const application = context.SessionService.getCurrent().getCurrentApplication();
            const messageService = application.message;
            const userInterfaceNode = application.getNode(0);
            const userInterfaceWidget = userInterfaceNode.getController().getWidget();
            const msgWidget = userInterfaceWidget.getMessageWidget();
            if (this._allowMultipleFiles) {
              msgWidget.setText(i18next.t('gwc.file.upload.files-already-uploaded'));
            } else {
              msgWidget.setText(i18next.t('gwc.file.upload.file-already-uploaded'));
            }
            msgWidget.setMessageKind("error");

            messageService.addMessage("upload", msgWidget);
            messageService.handlePositions();
            return;
          }

          if (this._allowMultipleFiles) {
            result = [];
            if (this._files) {
              for (i = 0; i < this._files.length; i++) {
                if (this._files[i]) {
                  result.push(this._files[i].name);
                }
              }
            }
            if (this._hiddenInput.files) {
              for (i = 0; i < this._hiddenInput.files.length; i++) {
                if (this._hiddenInput.files[i]) {
                  result.push(this._hiddenInput.files[i].name);
                }
              }
            }
          } else {
            if (this._files && this._files[0] && this._files[0].name) {
              result = this._files[0].name;
            }
            if (this._hiddenInput.files && this._hiddenInput.files[0] && this._hiddenInput.files[0].name) {
              result = this._hiddenInput.files[0].name;
            }
          }
          if (result) {
            this.emit(cls.FileInputWidget.fileSelectionChangedEvent, result);
          }
        },

        /**
         * Set file extension to filter allowed files
         * @param {string} extension - allowed extension
         * @publicdoc
         */
        setExtension: function(extension) {
          if (extension !== ".*") {
            this._hiddenInput.setAttribute("accept", extension);
          }
        },

        /**
         * Set the caption for file upload
         * @param {string} caption - Caption to display
         * @publicdoc
         */
        setCaption: function(caption) {
          this._rawCaption = caption;
          this._updateCaption();
        },

        /**
         * Internal method to set the caption, or fallback on i18n one
         * @private
         */
        _updateCaption: function() {
          if (this._rawCaption) {
            this._element.querySelector("span").textContent = this._rawCaption;
          } else {
            this._element.querySelector("span").textContent = (this._allowMultipleFiles ? i18next.t(
              "gwc.file.upload.droporclick-multiple") : i18next.t("gwc.file.upload.droporclick"));
          }
        },

        /**
         * Allows multiple files to be uploaded at once
         * @param {boolean} allow - true to allow multiple files, false otherwise
         * @publicdoc
         */
        allowMultipleFiles: function(allow) {
          this._allowMultipleFiles = Boolean(allow);
          if (allow) {
            this._hiddenInput.setAttribute("multiple", "multiple");
          } else {
            this._hiddenInput.removeAttribute("multiple");
          }
          this._updateCaption();
        },

        /**
         * Check if multiple files can be uploaded at once
         * @returns {boolean} true if allow multi-upload, false otherwise
         * @publicdoc
         */
        isAllowMultipleFiles: function() {
          return this._allowMultipleFiles;
        },

        /**
         * Event handler called when the files selection has changed
         * @param {function} hook - callback once event is triggered
         * @return {*|HandleRegistration}
         */
        whenFileSelectionChanged: function(hook) {
          return this.when(cls.FileInputWidget.fileSelectionChangedEvent, hook);
        },

        /**
         * Send files to the VM.
         * If you don't understand this method, please don't change it
         * @param {String} filename
         * @param {String} url
         * @param {function} callback - function called when done
         * @param {function} errorCallback - function called when error occurs
         * @param {function} progressHandler - function called when progress occurs
         */
        send: function(filename, url, callback, errorCallback, progressHandler) {
          let formData = null,
            i, file;
          if (this._files) {
            formData = new FormData();
            for (i = 0; i < this._files.length; ++i) {
              file = this._files[i];
              if (file.name === filename) {
                formData.append(file.name, file);
                break;
              }
              //TODO : manage multifile support
            }
          } else {
            formData = new FormData();
            const files = this._element.querySelector("form").file.files;
            for (i = 0; i < files.length; ++i) {
              file = files[i];
              if (file.name === filename) {
                formData.append(file.name, file);
                break;
              }
              //TODO : manage multifile support
            }
          }
          const request = new XMLHttpRequest();
          if (context.ThemeService.getValue("theme-network-use-credentials-headers")) {
            request.withCredentials = true;
          }
          request.onload = function(event) {
            // HTTP 413 : the file is too big for the server: will be handled has error!
            if (event.target.status === 413) {
              errorCallback();
            } else {
              callback();
            }
          }.bind(this);
          request.onerror = function() {
            errorCallback();
          };
          request.open("POST", url);
          request.upload.addEventListener("progress", progressHandler.bind(this));
          request.send(formData);
        }
      };
    });
    cls.WidgetFactory.registerBuilder('FileInput', cls.FileInputWidget);
  });
;

"use strict";

modulum('FilePickerWidget', ['ModalWidget', 'WidgetFactory'],
  function(context, cls) {

    /**
     * @class FilePickerWidget
     * @memberOf classes
     * @extends classes.ModalWidget
     */
    cls.FilePickerWidget = context.oo.Class(cls.ModalWidget, function($super) {
      return /** @lends classes.FilePickerWidget.prototype */ {
        __name: "FilePickerWidget",
        __templateName: "ModalWidget",
        $static: {
          fileSelectionChangedEvent: "fileSelectionChanged"
        },
        /**
         * @type {HTMLElement}
         */
        _headerTitleDom: null,
        /**
         * @type {classes.FileInputWidget}
         */
        _fileInput: null,
        /**
         * @type {?string}
         */
        _rawCaption: null,

        /**
         * @type {Number}
         */
        _selfDestroyTimer: null,
        /**
         * @type {Array<string>}
         */
        _selectedFiles: null,
        /**
         * @type {Array<string>}
         */
        _availableFiles: null,

        /**
         * @inheritDoc
         */
        _initContainerElement: function() {
          $super._initContainerElement.call(this);
          this._element.addClass("gbc_ModalWidget").addClass("mt-dialog-filetransfer");
          const dialogContents = document.createElement("div");

          this._headerTitleDom = document.createElement('span');
          this._headerTitleDom.innerHTML = '<i class="zmdi zmdi-upload"></i> <span>' + i18next.t("gwc.file.upload.select") +
            '<span>';
          this.setHeader(this._headerTitleDom);

          this.setClosable(true);
          this.setContent(dialogContents);

          this._fileInput = cls.WidgetFactory.createWidget("FileInput", this.getBuildParameters());
          dialogContents.appendChild(this._fileInput.getElement());
          this._fileInput.setParentWidget(this);
          this._fileInput.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this));

          this.when(context.constants.widgetEvents.modalOut, function() {
            this.hide(false);
          }.bind(this));
          this.when(context.constants.widgetEvents.close, function() {
            this.hide(false);
          }.bind(this));
        },

        /**
         * @inheritDoc
         */
        destroy: function(force) {
          if (force) {
            this._destroy();
            return;
          }

          context.WidgetService.addDelayedWidgetDestroy(this);
          this._resetSelfDestroy();
        },

        /**
         * Really destroy the widget
         * @private
         */
        _destroy: function() {
          if (this._fileInput) {
            this._fileInput.destroy();
            this._fileInput = null;

            $super.destroy.call(this);
            context.WidgetService.removeDelayedWidgetDestroy(this);
          }
          this._headerTitleDom = null;
        },

        /**
         * @inheritDoc
         */
        show: function() {
          $super.show.call(this);
          this.resizeHandler();
        },
        /**
         * hides the dialog
         * @inheritDoc
         * @param {boolean} gotFile
         */
        hide: function(gotFile) {
          const wasDisplayed = this.isVisible();
          this._resetAsMoved();
          $super.hide.call(this);
          if (wasDisplayed && !gotFile) {
            const emptySelection = this._fileInput && this._fileInput.isAllowMultipleFiles() ? [] : null;
            this.emit(cls.FilePickerWidget.fileSelectionChangedEvent, emptySelection);
          }
        },
        /**
         * sets the file input extension filter
         * @param {string} extension
         */
        setExtension: function(extension) {
          this._fileInput.setExtension(extension);
        },

        /**
         * sets the dialog caption
         * @param {string} caption
         */
        setCaption: function(caption) {
          this._rawCaption = caption;
          this._updateCaption();
        },

        /**
         * updates dialog caption
         * @private
         */
        _updateCaption: function() {
          let caption = this._rawCaption;
          if (!this._rawCaption) {
            if (this._fileInput.isAllowMultipleFiles()) {
              caption = i18next.t("gwc.file.upload.select-multiple");
            } else {
              caption = i18next.t("gwc.file.upload.select");
            }
          }
          this._headerTitleDom.querySelector("span").textContent = caption;
        },

        /**
         * Specify whether to allow multiple file selection or not
         * @param {boolean} allow
         */
        allowMultipleFiles: function(allow) {
          this._fileInput.allowMultipleFiles(allow);
          this._updateCaption();
        },

        /**
         * callback when file input selection changed
         * @param event
         * @param src
         * @param data
         * @private
         */
        _whenFileSelectionChanged: function(event, src, data) {
          // normalize() converts 2 combined diacritical marks into 1 (ex: é encoded as e')
          // For example under Safari a file with name 'Qualité.pdf' has a length of 12 while under
          // chrome length will be 11 because of the special accent char : é
          // for this reason we need to normalize our file name
          // ! IE11 doesn't support normalize.
          if (Array.isArray(data)) {
            this._selectedFiles = data;
          } else {
            const fileName = data.normalize ? data.normalize() : data;
            this._selectedFiles = [fileName];
          }
          this._availableFiles = this._selectedFiles.slice();
          this.emit(cls.FilePickerWidget.fileSelectionChangedEvent, data);
          this._resetSelfDestroy();
          this.hide(true);
        },

        /**
         * register callback when file input selection changed
         * @param {Hook} hook
         * @return {HandleRegistration}
         */
        whenFileSelectionChanged: function(hook) {
          return this.when(cls.FileInputWidget.fileSelectionChangedEvent, hook);
        },

        /**
         * gets the files availables for sending
         * @return {Array<string>}
         */
        getAvailableFiles: function() {
          return this._availableFiles || [];
        },

        /**
         * sends the given filename's resource to the given url
         * @param {string} filename
         * @param {string} url
         * @param {function} callback
         * @param {function} errorCallback
         * @param {function} progressHandler - called while progress event is sent
         */
        send: function(filename, url, callback, errorCallback, progressHandler) {
          this._stopSelfDestroyTimer();
          const cb = function(fn, data) {
            this._startSelfDestroyTimer();
            fn(data);
          };
          this._fileInput.send(filename, url, cb.bind(this, callback), cb.bind(this, errorCallback), cb.bind(this, progressHandler));
        },

        /**
         * free the given filename's resource
         * @param {string} filename
         * @param {boolean} [selfDestroyOnEmpty] if no more files waiting, self-destructs if true
         */
        freeFile: function(filename, selfDestroyOnEmpty) {
          if (this._availableFiles) {
            this._availableFiles.remove(filename);
            if (selfDestroyOnEmpty && !this._availableFiles.length) {
              this._destroy();
            }
          }
        },

        /**
         * stop the self-destruction timer
         * @private
         */
        _stopSelfDestroyTimer: function() {
          if (this._selfDestroyTimer) {
            this._clearTimeout(this._selfDestroyTimer);
            this._selfDestroyTimer = null;
          }
        },
        /**
         * start the self-destruction timer
         * @private
         */
        _startSelfDestroyTimer: function() {
          const timeout = parseInt(context.ThemeService.getValue("$gbc-FilePicker-selfdestroy-timeout"), 10) || 900;
          this._selfDestroyTimer = this._registerTimeout(this._onSelfDestroy.bind(this), timeout * 1000);
        },
        /**
         * reset the self-destruction timer
         * @private
         */
        _resetSelfDestroy: function() {
          this._stopSelfDestroyTimer();
          this._startSelfDestroyTimer();
        },
        /**
         * triggered when self-destruction activates
         * @private
         */
        _onSelfDestroy: function() {
          this._selfDestroyTimer = null;
          this._destroy();
        }
      };
    });
    cls.WidgetFactory.registerBuilder('FilePicker', cls.FilePickerWidget);
  });
;

'use strict';

modulum('WebComponentWidget', ['FieldWidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * WebComponent widget.
     * @class WebComponentWidget
     * @memberOf classes
     * @extends classes.FieldWidgetBase
     * @publicdoc Widgets
     */
    cls.WebComponentWidget = context.oo.Class(cls.FieldWidgetBase, function($super) {
      return /** @lends classes.WebComponentWidget.prototype */ {
        $static: {
          gICAPIVersion: '1.0',
          focusEvent: context.constants.widgetEvents.focus,
          dataEvent: 'wc_data',
          actionEvent: 'wc_action',
          ready: 'wc_ready'
        },

        __name: 'WebComponentWidget',
        __dataContentPlaceholderSelector: cls.WidgetBase.selfDataContent,
        _webComponentType: null,
        /**
         * @type {Window}
         */
        _webComponentWindow: null,
        _webComponentProxy: null,
        _webComponentWindowKeyDown: null,
        _webComponentWindowClick: null,
        _webComponentWindowDblClick: null,
        _webComponentWindowContextMenu: null,
        _flushValue: '',
        _flushingData: false,
        _url: null,
        _isReady: false,
        _value: null,
        _stopOnError: true,

        /**
         * @type HTMLElement
         */
        _iframeElement: null,

        /** @type {Object} */
        _properties: null, // webcomponent properties

        /**
         * @type {Boolean}
         */
        _isWebcomponentFocused: false,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          if (!this._ignoreLayout) {
            this._layoutInformation = new cls.LayoutInformation(this);
            this._layoutInformation.shouldFillStack = true;
            this._layoutEngine = new cls.WebComponentLayoutEngine(this);
            this._layoutEngine._shouldFillHeight = true;
            // should have same rules that TextEdit and shouldn't support sizepolicy dynamic, so we override it
            this._layoutInformation.getSizePolicyConfig().dynamic = cls.SizePolicy.Initial();
            this._layoutInformation.getSizePolicyConfig().setAllShrinkable(true);
            this._layoutInformation.forcedMinimalWidth = 20;
            this._layoutInformation.forcedMinimalHeight = 20;
          }
        },

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._iframeElement = this._element.getElementsByTagName('iframe')[0];
          this._iframeElement.on('load.WebComponentWidget', this._onLoad.bind(this));
          this._properties = "{}";
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._delegatesKeyboard(false);
          this._delegatesMouse(false);
          try {
            this._webComponentWindow.gICAPI = null;
          } catch (e) {}
          this._webComponentWindow = null;
          this._iframeElement.off('load.WebComponentWidget');
          this._iframeElement = null;
          $super.destroy.call(this);
        },

        /**
         * Handler for onData when iframe is loaded
         * @private
         */
        _onReadyData: function() {
          if (this.value !== this._flushValue) {
            this._toICAPI('onData', this._value ? this._value : '');
          }
        },

        /**
         * Handler called once iframe has loaded its content
         * @private
         */
        _onLoad: function() {
          if (this.getUrl()) {
            if (this._webComponentType === 'api') {
              this._injectApi();
              this._delegatesMouse(true);
              this._delegatesKeyboard(true);
            } else if (this._webComponentType === 'url') {
              this.triggerValueChangedEvent(this.getValue());
            }
            this._onReady();
          }
        },

        /**
         * Handler for onFocus when iframe is loaded
         * @private
         */
        _onReadyFocus: function() {
          if (this._uiWidget && this._uiWidget.getFocusedWidget() !== this) {
            this.triggerValueChangedEvent(this.getValue());
            this._updateWebcomponentFocus(false);
          } else {
            if (this._iframeElement !== document.activeElement) {
              this._iframeElement.domFocus();
            }
            this._updateWebcomponentFocus(true);
          }
        },

        /**
         * Handler for onBlur when iframe is loaded
         * @private
         */
        _onReadyBlur: function() {
          this.getValue();
          this.emit(context.constants.widgetEvents.blur);
          this._updateWebcomponentFocus(false);
        },

        /**
         * OnStateChanged handler once iframe is ready
         * @param {boolean} active - form state
         * @param {string} dialogType - form display type (display, input ...)
         * @private
         */
        _onReadyStateChanged: function(active, dialogType) {
          this._toICAPI('onStateChanged', JSON.stringify({
            'active': parseInt(active),
            'dialogType': dialogType.toString()
          }));
        },

        /**
         * Set the property of the webcomponent
         * @param {string} property - stringified json object of properties
         * @private
         */
        setProperty: function(property) {
          if (this._isReady) {
            this._toICAPI('onProperty', property);
          } else {
            this.when(cls.WebComponentWidget.ready, this._onReadyProperty.bind(this, property));
          }
        },

        /**
         * When the iframe is loaded handler
         * @private
         */
        _onReady: function() {
          this._isReady = true;
          this.emit(context.constants.widgetEvents.ready);
        },

        /**
         * onProperty handler once iframe is ready
         * @param {string} property - stringified json object of properties
         * @private
         */
        _onReadyProperty: function(property) {
          this._toICAPI('onProperty', property);
        },

        /**
         * Inject the API on the webcomponent
         * @returns {boolean} false if not applicable
         * @private
         */
        _injectApi: function() {
          //Add a new proxy for this webcomponent
          context.WebComponentService.setProxy(this.getUniqueIdentifier());
          this._webComponentProxy = context.WebComponentService.getProxy(this.getUniqueIdentifier());
          //Get the content of the iframe window to put api on
          this._webComponentWindow = this._iframeElement.contentWindow;

          // This try/catch statement is used to prevent IE to crash too early
          try {
            Function.noop(this._webComponentWindow.DocURL);
          } catch (e) {
            context.LogService.gICAPI.error('Webcomponent not found:', this._url);
            context.LogService.gICAPI.error('onICHostReady no present in webcomponent, cannot continue!');
            this.webComponentNotFound();
            return false;
          } // end IE fix

          try {
            this._webComponentWindow.gICAPIVersion = cls.WebComponentWidget.gICAPIVersion;
            // Bind WebComponent API to the iframe
            this._webComponentWindow.gICAPI = this._gICAPI();
            // Tell the WebComponent that host is ready
            if (this._webComponentWindow.onICHostReady) {
              this._webComponentWindow.onICHostReady('1.0');
            } else {
              context.LogService.gICAPI.error('onICHostReady no present in webcomponent, cannot continue!');
              this.webComponentNotFound();
              return false;
            }
          } catch (e) {
            this.error(e, true);
            return false;
          }
          this.emit(cls.WebComponentWidget.ready);
        },

        /**
         * Api object to bind to the webcomponent window.
         * It will be used inside the webcomponent to interact with the VM
         * @private
         */
        _gICAPI: function() {
          return {
            SetFocus: function() {
              // Generates a focus change request. The focus is entirely managed by the runtime system
              this._webComponentProxy.setFocus(this);
            }.bind(this),
            SetData: function(dataStr) {
              this._webComponentProxy.setData(this, dataStr);
            }.bind(this),
            Action: function(actionName) {
              this._webComponentProxy.action(this, actionName);
            }.bind(this),
            version: '1.0' // Legacy, but mostly not used
          };
        },

        /**
         * Delegate the keyboard management to GBC keyboard service (for accelerators and so)
         * @warning This works only if webcomponent is on the same domain as GBC application
         * @param {boolean} delegate - true to delegate it, false to let the webcomponent live by itself
         * @private
         */
        _delegatesKeyboard: function(delegate) {
          try {
            if (!this._webComponentWindow) {
              this._webComponentWindow = this._iframeElement.contentWindow;
            }
            if (delegate) {
              // If handler already exists, remove it before creating it again
              if (this._webComponentWindowKeyDown) {
                this._webComponentWindow.document.body.removeEventListener('keydown', this._webComponentWindowKeyDown);
              }
              // Define the keyDown handler
              this._webComponentWindowKeyDown = function(evt) {
                this.emit(gbc.constants.widgetEvents.webcomponentKeyDown, evt);
              }.bind(this);
              // Bind the iframe keyDown event to the keyDown handler
              this._webComponentWindow.document.body.addEventListener('keydown', this._webComponentWindowKeyDown);
            } else {
              if (this._webComponentWindowKeyDown) {
                this._webComponentWindow.document.body.removeEventListener('keydown', this._webComponentWindowKeyDown);
                this._webComponentWindowKeyDown = null;
              }
            }
          } catch (error) {
            context.LogService.gICAPI.warn("Can not use GBC accelerators in a cross-domain Webcomponents (" + this._url + ")");
          }
        },

        /**
         * Delegate the mouse management to GBC mouse service (click, contextmenu)
         * @warning This works only if webcomponent is on the same domain as GBC application
         * @param {boolean} delegate - true to delegate it, false to let the webcomponent live by itself
         * @private
         */
        _delegatesMouse: function(delegate) {
          try {
            if (!this._webComponentWindow) {
              this._webComponentWindow = this._iframeElement.contentWindow;
            }
            if (delegate) {
              // If handler already exists, remove it before creating it again
              if (this._webComponentWindowClick) {
                this._webComponentWindow.document.body.removeEventListener('click', this._webComponentWindowClick);
              }
              if (this._webComponentWindowDblClick) {
                this._webComponentWindow.document.body.removeEventListener('dblclick', this._webComponentWindowDblClick);
              }
              if (this._webComponentWindowContextMenu) {
                this._webComponentWindow.document.body.removeEventListener('contextmenu', this._webComponentWindowContextMenu);
              }
              // Define the mouse events handlers
              this._webComponentWindowClick = function(evt) {
                context.MouseService.saveMousePosition(evt, this.getElement());
              }.bind(this);
              this._webComponentWindowDblClick = function(evt) {
                context.MouseService.saveMousePosition(evt, this.getElement());
              }.bind(this);
              this._webComponentWindowContextMenu = function(evt) {
                context.MouseService.saveMousePosition(evt, this.getElement());
              }.bind(this);
              // Bind the iframe mouse events to their respective handlers
              this._webComponentWindow.document.body.addEventListener('click', this._webComponentWindowClick);
              this._webComponentWindow.document.body.addEventListener('dblclick', this._webComponentWindowDblClick);
              this._webComponentWindow.document.body.addEventListener('contextmenu', this._webComponentWindowContextMenu);

            } else {
              if (this._webComponentWindowClick) {
                this._webComponentWindow.document.body.removeEventListener('click', this._webComponentWindowClick);
                this._webComponentWindowClick = null;
              }
              if (this._webComponentWindowDblClick) {
                this._webComponentWindow.document.body.removeEventListener('dblclick', this._webComponentWindowDblClick);
                this._webComponentWindowDblClick = null;
              }
              if (this._webComponentWindowContextMenu) {
                this._webComponentWindow.document.body.removeEventListener('contextmenu', this._webComponentWindowContextMenu);
                this._webComponentWindowContextMenu = null;
              }
            }
          } catch (error) {
            context.LogService.gICAPI.warn("Can not propagate mouse events to GBC context in a cross-domain Webcomponents (" + this._url +
              ")");
          }
        },

        /**
         * Function to transmit gICAPI orders to webcomponent
         * @param {string} verb - onData, onProperty, onChangeState, onFlushData
         * @param {string=} args - arguments passed to the gICAPI if any
         * @private
         */
        _toICAPI: function(verb, args) {
          try {
            let arg = args;
            if (verb === 'onData' && arg === null) {
              arg = [null];
            } else {
              if (!arg && arg !== false && arg !== '' && arg !== 0) {
                arg = [];
              }
              if (arg.prototype !== Array) {
                arg = [arg];
              }
            }
            if (this._webComponentWindow && this._webComponentWindow.gICAPI && this._webComponentWindow.gICAPI[verb]) {
              this._webComponentWindow.gICAPI[verb].apply(this._webComponentWindow.gICAPI, arg);
              if (verb === "onFlushData") {
                this._flushingData = false;
              }
            }
          } catch (e) {
            this.error(e);
          }
        },

        /**
         * Handler to execute a function only once the component is ready
         * @param callback
         * @protected
         */
        _onReadyExecute: function(callback) {
          if (this._isReady) {
            callback();
          } else {
            this.when(cls.WebComponentWidget.ready, function() {
              callback();
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        managePriorityKeyDown: function(keyString, domKeyEvent, repeat) {
          if (keyString === "home" || keyString === "end") {
            return false; // consider home/end key as not processed to keep default from webcomponent
          } else {
            return $super.managePriorityKeyDown.call(this, keyString, domKeyEvent, repeat);
          }
        },

        /**
         * Report an error in webcomponent
         * @param e - error object
         * @param {boolean} stop - will stop the application if true
         */
        error: function(e, stop) {
          context.LogService.gICAPI.error(i18next.t('gwc.app.webcompError.message'));
          context.LogService.gICAPI.error(">>> " + ': ' + e.toString(), e);
          if (this._stopOnError || stop) {
            this.webComponentNotFound(i18next.t('gwc.app.webcompError.message') + ' : "' + e.toString() +
              '"--> see console for more details');
          } else {
            const errorLayer = document.createElement("div");
            const errorStyle =
              'position: fixed;top: 0; color: #721c24; background-color: #f8d7da;border-color: #f5c6cb;border: 1px solid; padding: 10px; border-radius: .25rem;';
            errorLayer.innerHTML = '<b>' + i18next.t('gwc.app.webcompError.message') + ' :</b> <i>' + e.toString() +
              '</i><br> See console for more info';
            errorLayer.setAttribute("style", errorStyle);
            errorLayer.addEventListener("click", function() {
              this.setAttribute("style", "display:none;");
            });
            this._webComponentWindow.document.querySelector("body").appendChild(errorLayer);
          }
        },

        /**
         *@inheritDoc
         */
        setFocus: function(fromMouse) {
          if (!this.hasFocus() || !this
            ._isWebcomponentFocused) { // Call API only if the widget is not focus yet or never focused before
            if (this._isReady) {
              this._iframeElement.domFocus(); //force focus to blur other elements
              this._updateWebcomponentFocus(true);
            } else {
              this.when(cls.WebComponentWidget.ready, this._onReadyFocus.bind(this));
            }
            $super.setFocus.call(this, fromMouse);
          }
        },

        hasDOMFocus: function() {
          return document.activeElement === this._iframeElement;
        },

        /**
         * Tell the WebComponent that it lost the Focus on it
         * @publicdoc
         */
        loseFocus: function() {
          $super.loseFocus.call(this);
          this._onReadyExecute(function() {
            this._onReadyBlur();
          }.bind(this));
        },

        /**
         * Called when the WC formfield's state has changed
         * @param {boolean} active - form state
         * @param {string} dialogType - form display type (display, input ...)
         * @publicdoc
         */
        onStateChanged: function(active, dialogType) {
          this._onReadyExecute(function() {
            this._onReadyStateChanged(active, dialogType);
          }.bind(this));
        },

        /**
         * Defines the address of the WebComponent
         * @param {string} url - address
         * @publicdoc
         */
        setUrl: function(url) {
          this._url = url;
          url = url ? url : 'about:blank';
          this._iframeElement.setAttribute('src', url);
        },

        /**
         * Get the address of the WebComponent
         * If the webcomponent is url based, it will work only if url is on same domain as application
         * @returns {string} address of the webcomponent
         */
        getUrl: function() {
          const url = this._iframeElement.getAttribute('src') || this._url;
          let contentUrl = false;
          if (this._webComponentType === 'url') {
            try {
              contentUrl = this._iframeElement.contentWindow && this._iframeElement.contentWindow.location.href;
            } catch (e) {
              contentUrl = false;
            }
          }
          return contentUrl ? contentUrl : url;

        },

        /**
         * @inheritDoc
         */
        setValue: function(value, fromVM = false, cursorPosition = null) {
          const empty = value === '';
          // Value should be a string to fit GDC/VM specs
          if (typeof value !== 'string') {
            value = JSON.stringify(value);
          }
          this._value = value;
          if (this._webComponentType === 'url') {
            this.setUrl(empty ? '' : value);
          } else {
            this._onReadyExecute(function() {
              this._toICAPI('onData', this._value ? this._value : '');
            }.bind(this));
          }
        },

        /**
         * Get The value of the webComponent
         * @returns {string} value or url of the webcomponent
         */
        getValue: function() {
          this.flushWebcomponentData();
          const result = this._webComponentType === 'api' ? this._flushValue ? this._flushValue : this._value : this.getUrl();
          this._flushValue = null; // reset value
          return result;
        },

        /**
         * Define the type of component
         * @param {string} type - should be 'api' or 'url'
         */
        setWebComponentType: function(type) {
          this._webComponentType = type;
        },

        /**
         * Get the type of component
         * @return {?string} type - should be 'api' or 'url'
         */
        getWebComponentType: function() {
          return this._webComponentType;
        },

        /**
         * Force webcomponent to get data
         * @public
         */
        flushWebcomponentData: function() {
          if (!this._flushingData) {
            this._flushingData = true;
            this._toICAPI('onFlushData');
          }
        },

        /**
         * Update & filter focus (true/false) flag on Webcomponent side
         * @param focus
         * @protected
         */
        _updateWebcomponentFocus: function(focus) {
          if (this._isWebcomponentFocused !== focus) {
            this._toICAPI('onFocus', focus);
            this._isWebcomponentFocused = focus;
          }
        },

        /**
         * Stop VMApplication with a message
         * @param {string=} message - message to give to the app close (default is defined in locales)
         * @public
         */
        webComponentNotFound: function(message) {
          if (!context.bootstrapInfo.ignoreWebComponentFails) {
            //VMApplication stop with a message
            const currentApp = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
            if (currentApp) {
              currentApp.fail(message ? message : i18next.t('gwc.app.webcompNotFound.message'));
            }
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('WebComponent', cls.WebComponentWidget);
  });
;

"use strict";

modulum('HtmlFilterWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Widget used to filter html document values \n Inspired from https://github.com/jitbit/HtmlSanitizer
     * @class HtmlFilterWidget
     * @memberOf classes
     * @extends classes.WidgetBase
     */
    cls.HtmlFilterWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.HtmlFilterWidget.prototype */ {
        __name: "HtmlFilterWidget",

        _tagWhitelist: null,
        _contentTagWhiteList: null,
        _cssWhitelist: null,
        _schemaWhiteList: null,
        _uriAttributes: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          // Authorized tags: a b blockquote br center code div em font h1 h2 h3 h4 h5 h6 hr i img label li ol p pre small source span strong table tbody tr td th thead ul u video
          this._tagWhitelist = {
            'A': true,
            'B': true,
            'BLOCKQUOTE': true,
            'BODY': true,
            'BR': true,
            'CENTER': true,
            'CODE': true,
            'DIV': true,
            'EM': true,
            'FONT': true,
            'H1': true,
            'H2': true,
            'H3': true,
            'H4': true,
            'H5': true,
            'H6': true,
            'HR': true,
            'I': true,
            'IMG': true,
            'LABEL': true,
            'LI': true,
            'OL': true,
            'P': true,
            'PRE': true,
            'SMALL': true,
            'SOURCE': true,
            'SPAN': true,
            'STRONG': true,
            'TABLE': true,
            'TBODY': true,
            'TR': true,
            'TD': true,
            'TH': true,
            'THEAD': true,
            'UL': true,
            'U': true,
            'VIDEO': true
          };

          this._contentTagWhiteList = {
            'FORM': true
          }; //tags that will be converted to DIVs

          // Authorized attributes: align color controls height href src style target title type width
          this._attributeWhitelist = {
            'align': true,
            'color': true,
            'controls': true,
            'height': true,
            'href': true,
            'src': true,
            'style': true,
            'target': true,
            'title': true,
            'type': true,
            'width': true
          };

          // Authorized CSS: color background-color font-size text-align text-decoration font-weight
          this._cssWhitelist = {
            'color': true,
            'background-color': true,
            'font-size': true,
            'text-align': true,
            'text-decoration': true,
            'font-weight': true
          };
          this._schemaWhiteList = ['http:', 'https:', 'data:', 'm-files:', 'file:',
            'ftp:'
          ]; //which "protocols" are allowed in "href", "src" etc
          this._uriAttributes = {
            'href': true,
            'action': true
          };
        },

        /**
         * Sanitize HTML
         * @param {string} input to sanitize
         * @return {string} - the html string corresponding to the body content only, cleaned from unwanted code
         */
        sanitize: function(input) {
          input = input.trim();
          if (input === "") {
            return ""; //to save performance and not create iframe
          }

          // Create a new DOMParser
          const parser = new DOMParser();

          // Parse the input string as a new HTML document
          const doc = parser.parseFromString(input, 'text/html');

          // Retrieve the sanitized HTML string from the document and remove unauthorized tags/attributes
          const resultElement = this._makeSanitizedCopy(doc.body);
          return resultElement.innerHTML
            .replace(/<br[^>]*>(\S)/g, "<br>\n$1")
            .replace(/div><div/g, "div>\n<div"); //replace is just for cleaner code;
        },

        /**
         * Check if string start with another
         * @param {string} str - string to look into
         * @param {string} substrings - string to look for
         * @return {boolean} true if it starts with it false otherwise
         * @private
         */
        _startsWithAny: function(str, substrings) {
          for (const element of substrings) {
            if (str.indexOf(element) === 0) {
              return true;
            }
          }
          return false;
        },

        /**
         * Get a sanitized copy of the htmlNode
         * @param {Node} node to copy clean
         * @return {ActiveX.IXMLDOMNode|Node|DocumentFragment} - cleaned copy of the node
         * @private
         */
        _makeSanitizedCopy: function(node) {
          let newNode = null;
          if (node.nodeType === Node.TEXT_NODE) {
            newNode = node.cloneNode(true);
          } else if (node.nodeType === Node.ELEMENT_NODE && (this._tagWhitelist[node.tagName] || this._contentTagWhiteList[node.tagName])) {
            //remove useless empty spans (lots of those when pasting from MS Outlook)
            if ((node.tagName === "SPAN" || node.tagName === "B" || node.tagName === "I" || node.tagName === "U") && node.innerHTML.trim() ===
              "") {
              return document.createDocumentFragment();
            }
            if (this._contentTagWhiteList[node.tagName]) {
              newNode = document.createElement('DIV'); //convert to DIV
            } else {
              newNode = document.createElement(node.tagName);
            }

            for (const attr of node.attributes) {
              if (this._attributeWhitelist[attr.name]) {
                if (attr.name === "style") {
                  for (const styleName of node.style) {
                    if (this._cssWhitelist[styleName]) {
                      newNode.style.setProperty(styleName, node.style.getPropertyValue(styleName));
                    }
                  }
                } else {
                  if (this._uriAttributes[attr.name]) { //if this is a "uri" attribute, that can have "javascript:" or something
                    if (this._startsWithAny(attr.value, ['http', 'https'])) {
                      if (node.getAttribute("target") === null) {
                        newNode.setAttribute("target", "_blank");
                      }
                    }
                    if (attr.value.indexOf(":") > -1 && !this._startsWithAny(attr.value, this._schemaWhiteList)) {
                      continue;
                    }
                  }
                  newNode.setAttribute(attr.name, attr.value);
                }
              }
            }
            for (const element of node.childNodes) {
              const subCopy = this._makeSanitizedCopy(element);
              newNode.appendChild(subCopy, false);
            }
          } else {
            newNode = document.createDocumentFragment();
          }
          return newNode;
        },

      };
    });
    cls.WidgetFactory.registerBuilder('HtmlFilterWidget', cls.HtmlFilterWidget);

  });
;

"use strict";

modulum('FlowDecoratorWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {
    /**
     * Widget to handle overflowing items in a dropdown
     * @memberOf classes
     * @extends classes.WidgetBase
     * @publicdoc Widgets
     */
    cls.FlowDecoratorWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.FlowDecoratorWidget.prototype */ {
        __name: "FlowDecoratorWidget",

        /** @type {classes.WidgetBase[]} */
        _overflowWidgets: null,

        /** @type {classes.DropDownWidget} */
        _dropDown: null,

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.FlowItemLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        constructor: function(opt) {
          $super.constructor.call(this, opt);
          this._overflowWidgets = [];
          this._dropDown = cls.WidgetFactory.createWidget('DropDown', this.getBuildParameters());
          this._dropDown.addClass("gbc_FlowingDropDown");
          this._dropDown.reverseX = true;
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          this._dropDown.setParentWidget(widget);
          this._dropDown.shouldClose = function(targetElement) {
            const isParentChild = targetElement.isElementOrChildOf(widget.getElement());
            return !isParentChild;
          };
        },

        /**
         * Defines the orientation of the dropdown
         * @param {String} orientation - can be "horizontal" or "vertical"
         */
        setOrientation: function(orientation) {
          this._dropDown.addClass("gbc_orientation_" + orientation);
        },

        /**
         * Defines the rendering of the dropdown
         * @param {String} rendering - can be "list" or "buttons"
         */
        setRendering: function(rendering) {
          this._dropDown.addClass("gbc_rendering_" + rendering);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          if (this._dropDown && this._dropDown.isVisible()) {
            this.closeDropDown();
          } else {
            this.openDropDown();
          }
          return true;
        },

        /**
         * Show the dropdown with flowing items
         */
        openDropDown: function() {
          this._dropDown.show();
        },

        /**
         * Hide the dropdown with flowing items
         */
        closeDropDown: function() {
          this._dropDown.hide();
        },

        /**
         * Check if dropdown is open
         * @return {boolean} - true if dropdown currently open, false otherwise
         */
        isDropDownOpen: function() {
          return !this._dropDown.isHidden();
        },

        /**
         * Flow a given child widget
         * @param {classes.WidgetBase} widget - widget to add to the dropdown
         * @param {boolean} flowing true to add to the dropdown, false to put it back to the toolbar
         */
        flowChild: function(widget, flowing) {
          const opt = {};

          if (flowing) {
            opt.position = 0;
            this._dropDown.adoptChildWidget(widget, opt);
            widget.when(context.constants.widgetEvents.click, function() {
              this._dropDown.hide();
            }.bind(this));
          } else {

            this.getParentWidget().adoptChildWidget(widget, opt);
          }
          if (this._dropDown.getChildren().length <= 0) {
            this.enable(false);
          }
        },

        /**
         * Get a copy of flowing children
         * @return {classes.WidgetBase[]}
         */
        getFlowingChildren: function() {
          return this._dropDown.getChildren().slice(0);
        },

        /**
         * Enable the flowing mechanism by displaying it
         * @param {Boolean} enabled - true to activate it, false to de-activate
         */
        enable: function(enabled) {
          this.setHidden(!enabled);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
          if (this._dropDown) {
            this._dropDown.destroy();
            this._dropDown = null;
          }
        },

      };
    });
    cls.WidgetFactory.registerBuilder('FlowDecorator', cls.FlowDecoratorWidget);

  });
;

"use strict";

modulum('ScrollAreaWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * ScrollArea Widget.
     * Use to catch scrolling event and forward them to a Matrix
     * @class ScrollAreaWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollAreaWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollAreaWidget.prototype */ {
        __name: "ScrollAreaWidget",

        _size: 0,
        _pageSize: 0,
        _lineHeight: 15,

        _totalHeight: 0,

        //ThinScroll vars
        _displayTime: null,
        _mouseIsOver: false,
        _thinTimer: null,
        _scrollbar: null,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on("wheel.ScrollAreaWidget", this._onWheel.bind(this));

          const body = document.getElementsByTagName("body")[0];
          // Using getRootClassName() to qualify event for easier removal on destroy, since we bind it on 'body'
          body.on("touchstart.ScrollAreaWidget." + this.getRootClassName(), this._onTouchStart.bind(this));
          body.on("touchend.ScrollAreaWidget." + this.getRootClassName(), this._onTouchEnd.bind(this));
          body.on("touchmove.ScrollAreaWidget." + this.getRootClassName(), this._onTouchMove.bind(this));

          this._scrollbar = cls.WidgetFactory.createWidget("ScrollBar", this.getBuildParameters());
          this._scrollbar.display(true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._element.off("wheel.ScrollAreaWidget");

          const body = document.getElementsByTagName("body")[0];
          body.off("touchstart.ScrollAreaWidget." + this.getRootClassName());
          body.off("touchend.ScrollAreaWidget." + this.getRootClassName());
          body.off("touchmove.ScrollAreaWidget." + this.getRootClassName());

          this._scrollbar.destroy();
          $super.destroy.call(this);
        },

        /**
         * On wheel handler
         * @param {UIEvent} event
         * @private
         */
        _onWheel: function(event) {
          this.emit(context.constants.widgetEvents.mouseWheel, event);

          event.stopPropagation();
          event.stopImmediatePropagation();
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {

          const gridElement = this._element.parent("g_GridElement");
          // Hide the scrollArea layer
          gridElement.addClass("hidden");
          // Create a click event that will be triggered to the div beyond
          const target = document.elementFromPoint(domEvent.clientX, domEvent.clientY);
          // Focus event is needed to trigger a VM focus request (InputArray)
          let event = document.createEvent('HTMLEvents');
          event.initEvent('focus', true, false);
          target.dispatchEvent(event);
          // Click event is needed to trigger a VM row selection event (DisplayArray)
          event = document.createEvent('HTMLEvents');
          event.initEvent('click', true, false);
          target.dispatchEvent(event);
          // Show back the scrollArea layer
          gridElement.removeClass("hidden");

          return false;
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
          this._layoutEngine._shouldFillHeight = true;
          this.getLayoutInformation()._extraGap = {
            afterX: window.scrollBarSize
          };

          if (this._scrollbar) {
            // position scrollbar according to scrollarea widget
            this._layoutInformation.onGridInfoChanged(function() {
              const scrollAreaLayoutInfo = this.getLayoutInformation();
              const scrollBarLayoutInfo = this._scrollbar.getLayoutInformation();
              scrollBarLayoutInfo.setGridX(scrollAreaLayoutInfo.getGridX() + scrollAreaLayoutInfo.getGridWidth() - 1);
              scrollBarLayoutInfo.setGridY(scrollAreaLayoutInfo.getGridY());
              scrollBarLayoutInfo.setGridWidth(1);
              scrollBarLayoutInfo.setGridHeight(scrollAreaLayoutInfo.getGridHeight());
            }.bind(this));

          }
        },

        /**
         * Handler called when start to touch the screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchStart: function(event) {
          if (this.isTouchEventInScrollArea(event)) {
            this.emit(context.constants.widgetEvents.touchStart, event);
          }
        },

        /**
         * Handler called when stop touching the screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchEnd: function(event) {
          this.emit(context.constants.widgetEvents.touchEnd, event);
        },

        /**
         * Handler called on moving finger on screen
         * @param {UIEvent} event - dom touch event
         * @private
         */
        _onTouchMove: function(event) {
          if (this.isTouchEventInScrollArea(event)) {
            this.emit(context.constants.widgetEvents.touchMove, event);
          }
        },

        /**
         * Check if the given event is located in the scroll area
         * Note that scrollbar is removed from the scrolling area
         * @param {UIEvent} event - dom touch event
         * @return {boolean}
         */
        isTouchEventInScrollArea: function(event) {
          const rect = this._element.getBoundingClientRect();
          const sbRect = this._scrollbar.getElement().getBoundingClientRect();
          return event.touches[0].clientY > rect.top &&
            event.touches[0].clientY < rect.top + rect.height &&
            event.touches[0].clientX > rect.left &&
            event.touches[0].clientX < rect.left + rect.width - sbRect.width;
        },

        /**
         * Get the scroll Widget
         * @return {classes.ScrollAreaWidget}
         */
        getScrollWidget: function() {
          return this;
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          $super.setParentWidget.call(this, widget, options);
          if (this._scrollbar && widget) {
            widget.addChildWidget(this._scrollbar);
            this._scrollbar.setScrollArea(this);
          }
        },

        /**
         * Define the total size of the scrollArea
         * @param size
         */
        setSize: function(size) {
          if (size !== this._size) {
            this._size = size;
            this.setTotalHeight(this._lineHeight * this._size);
            if (this._scrollbar) {
              this._scrollbar.setSize(size);
            }
          }
        },

        /**
         * Define the page size of the scrollArea
         * @param pageSize
         * @param {boolean} force
         */
        setPageSize: function(pageSize, force) {
          if (this._pageSize !== pageSize || force) {
            this._pageSize = pageSize;
            const lineHeight = this._element.clientHeight / pageSize;
            this.setLineHeight(lineHeight);
            if (this._scrollbar) {
              this._scrollbar.setPageSize(pageSize);
            }
          }
        },

        /**
         * Set the offset of the scrollArea
         * @param offset
         */
        setOffset: function(offset) {
          this._offset = offset;
          if (this._scrollbar) {
            this._scrollbar.setOffset(offset);
          }
        },

        /**
         * Set the line height
         * @param lineHeight
         */
        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
          if (this._scrollbar) {
            this._scrollbar.setLineHeight(lineHeight);
          }
        },

        /**
         * Will set the total height of the scrollArea
         * @param {number} height total
         */
        setTotalHeight: function(height) {
          if (!this.isEnabled()) {
            height = 0;
          }
          this.setStyle(".spacer", {
            "height": Math.max(0, height) + "px"
          });
          this._totalHeight = Math.max(0, height);
          if (this._scrollbar) {
            this._scrollbar.setTotalHeight(this._totalHeight);
          }
        },

        /**
         * Defines the scroll area to use thinscrollbar
         * @param {number} displayTime - in second, how long the scrollbar is displayed 0 is always visible, -1 is never
         */
        setThinScrollbar: function(displayTime) {
          this.getLayoutInformation()._extraGap = {
            afterX: 0
          };

          this.addClass("thinScrollBar");
          // get grid parent
          this._displayTime = displayTime;
          this._scrollbar.setDisplayTime(displayTime);
        },

        /**
         * Defines the enabled status of the widget
         * @param {boolean} enabled true if the widget allows user interaction, false otherwise.
         * @publicdoc
         */
        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          this._scrollbar.setEnabled(enabled);
        }

      };
    });
    cls.WidgetFactory.registerBuilder('ScrollArea', cls.ScrollAreaWidget);
  });
;

"use strict";

modulum('ScrollBarWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * Thin ScrollBar Widget.
     * @class ScrollBarWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollBarWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollBarWidget.prototype */ {
        __name: "ScrollBarWidget",
        _scrollArea: null,
        _totalHeight: 0,
        _thumbHeight: 0,
        _displayTime: 1, // default as defined in genero doc
        _displayTimer: null,
        _mouseDown: false,

        /**
         * @inheritDoc
         */
        _initElement: function() {
          $super._initElement.call(this);
          this._thumbElement = this._element.querySelector(".thumb");

          this._element.on('touchstart.scrollBarWidget', this._dragDropManager.bind(this));

          this._element.on("mouseover.scrollBarWidget", this._mouseMove.bind(this));
          this._thumbElement.on("mouseover.scrollBarWidget", this._mouseMove.bind(this));
          this._element.on("mouseleave.scrollBarWidget", this._mouseLeave.bind(this));
          this._thumbElement.on("mouseleave.scrollBarWidget", this._mouseLeave.bind(this));
        },

        /**
         * @inheritDoc
         */
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.LeafLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        manageMouseClick: function(domEvent) {
          this._dragDropManager.call(this, domEvent);
          return true;
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._onDrop();
          this._element.off("touchstart.scrollBarWidget");

          this._element.off("mouseover.scrollBarWidget");
          this._thumbElement.off("mouseover.scrollBarWidget");
          this._element.off("mouseleave.scrollBarWidget");
          this._thumbElement.off("mouseleave.scrollBarWidget");
          $super.destroy.call(this);
        },

        /**
         * Define the thumb height
         * @param {Number} height - total height in px
         * @private
         */
        _setThumbHeight: function(height) {
          this._thumbHeight = height;
          this._thumbElement.style.height = height + "px";
        },

        /**
         * Define the thumb position
         * @param {Number} top - distance from top in px
         * @private
         */
        _setThumbPosition: function(top) {
          // Keep thumb into view
          const max = this._element.clientHeight - this._thumbHeight;
          top = top >= 0 && top < max ? top : top >= max ? max : 0;
          this._thumbElement.style.top = top + "px";
        },

        /**
         * Handler called when the mouse is mooving over the scrollbar
         * @private
         */
        _mouseMove: function() {
          this.display(true);
        },

        /**
         * Handler called when the mouse is leaving the scrollbar
         * @private
         */
        _mouseLeave: function() {
          if (this._displayTime > 0) {
            this.display(false);
          }
        },

        /**
         * Once you start dragging the scrollbar
         * @param ctx
         * @returns {boolean}
         * @private
         */
        _dragDropManager: function(ctx) {
          this._element.classList.add('ss-grabbed');
          document.body.classList.add('ss-grabbed');

          const drag = this._onDrag.bind(this);
          const drop = this._onDrop.bind(this);

          document.body.on('mousemove.scrollBarWidget', drag);
          document.body.on('mouseup.scrollBarWidget', drop);
          document.body.on('touchmove.scrollBarWidget', drag);
          document.body.on('touchend.scrollBarWidget', drop);

          return false;
        },

        /**
         * Scrollbar moving
         * @param e
         * @private
         */
        _onDrag: function(e) {
          this.afterDomMutator(function() {
            e = e.touches ? e.touches[0] : e;
            this._mouseDown = true;
            const newPos = e.pageY - this._element.getClientRects()[0].top - (this._thumbHeight / 2);
            this._setThumbPosition(newPos);

            const size = this._size;
            const pageSize = this._pageSize;
            const thumbTop = parseInt(this._thumbElement.style.top, 10);
            // Take thumb height into account
            const total = parseInt(this._element.clientHeight - this._thumbHeight, 10);
            const thumbRatio = ((thumbTop) / (total));

            // offset should be >= 0
            const maxOffset = (size - pageSize) < 0 ? 0 : size - pageSize;

            //need to update the VM position as well
            const requestedOffset = parseInt(maxOffset * thumbRatio, 10);
            if (requestedOffset >= 0) {
              e.forceOffset = requestedOffset;
              this._scrollArea.emit(context.constants.widgetEvents.scroll, e);
            }
          }.bind(this));
        },

        /**
         * Stop dragging the scrollbar
         * @private
         */
        _onDrop: function() {
          this._mouseDown = false;
          this._element.classList.remove('ss-grabbed');
          document.body.classList.remove('ss-grabbed');
          document.body.off('mousemove.scrollBarWidget');
          document.body.off('mouseup.scrollBarWidget');
          document.body.off('touchmove.scrollBarWidget');
          document.body.off('touchend.scrollBarWidget');
        },

        /**
         * Set delay before hiding the scrollBar
         * @param {number} delay in second
         */
        setDisplayTime: function(delay) {
          this._displayTime = delay;
        },

        /**
         * Show or hide the scrollBar
         * @param {boolean} displayed true:visible, false: hidden
         * @param {boolean=} instant force the delay to 0 if true
         */
        display: function(displayed, instant) {
          if (this._displayTime < 0) {
            this.addClass("thinScrollbar-vanished");
            displayed = false;
          }

          const delay = instant ? 0 : this._displayTime ? this._displayTime : 0;
          if (!displayed) {
            this._displayTimer = this._registerTimeout(function() {
              this._displayTimer = null;
              if (this.isEnabled()) { // Do not vanish if not enabled
                this.addClass("thinScrollbar-vanished");
              }
            }.bind(this), delay * 1000);
          } else {
            if (this._displayTimer) {
              this._clearTimeout(this._displayTimer);
              this._displayTimer = null;
            }
            this.removeClass("thinScrollbar-vanished");
          }
        },

        /**
         * Define the linked scrollArea
         * @param {widget} widget
         */
        setScrollArea: function(widget) {
          this._scrollArea = widget;
        },

        /**
         * Total height of the scrollArea
         * @param {number} height in pixels
         */
        setTotalHeight: function(height) {
          this._totalHeight = height;
        },

        /**
         * Set the line height used for calculations
         * @param {Number} lineHeight
         */
        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
          this._setThumbHeight(lineHeight);
        },

        /**
         * Set the total of element in scroll (linked to scrollArea)
         * @param {number} size
         */
        setSize: function(size) {
          this._size = size;
        },

        /**
         * Set the number of element in scroll Page (linked to scrollArea)
         * @param {number} pageSize
         */
        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        /**
         * Set the current offset (linked to scrollArea)
         * @param {number} offset
         */
        setOffset: function(offset) {
          this.display(true);
          this._offset = offset;
          if (this._lineHeight) {
            const maxPos = this._element.clientHeight - this._thumbHeight;
            const maxOffset = this._size - this._pageSize;
            const pos = (offset * maxPos) / maxOffset;
            this._setThumbPosition(pos);
          }
          if (this._displayTime > 0) {
            this.display(false);
          }
        }
      };
    });
    cls.WidgetFactory.registerBuilder('ScrollBar', cls.ScrollBarWidget);
  });
;

"use strict";

modulum('ScrollTabDecorator',
  function(context, cls) {
    /**
     * Add scroll tab mechanism to widget elements
     * @class ScrollTabDecorator
     * @memberOf classes
     */
    cls.ScrollTabDecorator = context.oo.Class(function($super) {
      return /** @lends classes.ScrollTabDecorator.prototype */ {
        __name: "ScrollTabDecorator",

        _tabsHost: null,
        _tabsTitlesBar: null,
        _tabsTitlesHost: null,
        _tabsTitlesElement: null,
        _previousScroller: null,
        _nextScroller: null,
        _leftScrollInterval: null,
        _rightScrollInterval: null,
        _offsetPos: "offsetLeft",
        _offsetSize: "offsetWidth",
        _scrollPos: "scrollLeft",
        _scrollStep: 6,
        _scrollToId: 0,
        _refreshScrollersId: 0,

        _position: "top",
        _scrollerPosition: 0,

        _scrollSpeed: 10,
        _scrollClickOnly: false,
        _mouseDownStatus: false,

        /**
         * Initializes the scrollTab object. You need to provide a widget instance which will be instrumented
         * @param widget the widget to handle
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;

          if (window.isMobile()) {
            this._widget.addClass("compact");
          }

          this._tabsHost = this._widget.getElement().getElementsByClassName("mt-tabs")[0];
          this._tabsTitlesBar = this._widget.getElement().getElementsByClassName("mt-tab-titles-bar")[0];
          this._tabsTitlesHost = this._widget.getElement().getElementsByClassName("mt-tab-titles")[0];
          this._tabsTitlesElement = this._widget.getElement().getElementsByClassName("mt-tab-titles-container")[0];
          this._previousScroller = this._widget.getElement().getElementsByClassName("mt-tab-previous")[0];
          this._nextScroller = this._widget.getElement().getElementsByClassName("mt-tab-next")[0];

          this._widget.getElement().on("mouseover.FolderWidget", function() {
            this.refreshScrollers();
            this._widget.getElement().off("mouseover.FolderWidget");
          }.bind(this));

          this._previousScroller
            .on("mouseover.FolderWidget", this._beginScrollTabsLeft.bind(this))
            .on("mousedown.FolderWidget", this._beginScrollTabsLeft.bind(this))
            .on("mouseout.FolderWidget", this._endScrollTabsLeft.bind(this))
            .on("mouseup.FolderWidget", this._endScrollTabsLeft.bind(this));

          this._nextScroller
            .on("mouseover.FolderWidget", this._beginScrollTabsRight.bind(this))
            .on("mousedown.FolderWidget", this._beginScrollTabsRight.bind(this))
            .on("mouseup.FolderWidget", this._endScrollTabsRight.bind(this))
            .on("mouseout.FolderWidget", this._endScrollTabsRight.bind(this));

          if (window.isTouchDevice()) {
            if (this._tabsTitlesBar) {
              this._tabsTitlesBar.on("touchstart.scrolltab", this._startTouchScroll.bind(this));
              this._tabsTitlesBar.on("touchend.scrolltab", this._endTouchScroll.bind(this));
              this._tabsTitlesBar.on("touchmove.scrolltab", this._touchMove.bind(this));
            } else if (this._tabsTitlesElement) {
              this._tabsTitlesElement.on("touchstart.scrolltab", this._startTouchScroll.bind(this));
              this._tabsTitlesElement.on("touchend.scrolltab", this._endTouchScroll.bind(this));
              this._tabsTitlesElement.on("touchmove.scrolltab", this._touchMove.bind(this));
            }
          }
          this._scrollSpeed = parseInt(context.ThemeService.getValue("theme-scrollers-speed"), 10);
          this._scrollClickOnly = context.ThemeService.getValue("theme-scrollers-clickonly");
          this._scrollClickOnly = this._scrollClickOnly === true || this._scrollClickOnly === "true";

        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._widget.getElement().off("mouseover.FolderWidget");

          this._previousScroller.off("mouseover.FolderWidget");
          this._previousScroller.off("mousedown.FolderWidget");
          this._previousScroller.off("mouseout.FolderWidget");
          this._previousScroller.off("mouseup.FolderWidget");
          this._nextScroller.off("mouseover.FolderWidget");
          this._nextScroller.off("mousedown.FolderWidget");
          this._nextScroller.off("mouseup.FolderWidget");
          this._nextScroller.off("mouseout.FolderWidget");

          if (this._scrollToId) {
            window.cancelAnimationFrame(this._scrollToId);
            this._scrollToId = 0;
          }
          if (this._refreshScrollersId) {
            window.cancelAnimationFrame(this._refreshScrollersId);
            this._refreshScrollersId = 0;
          }

          this._endScrollTabsLeft();
          this._endScrollTabsRight();

          if (window.isTouchDevice()) {
            if (this._tabsTitlesBar) {
              this._tabsTitlesBar.off("touchstart.scrolltab");
              this._tabsTitlesBar.off("touchend.scrolltab");
              this._tabsTitlesBar.off("touchmove.scrolltab");
            }
            if (this._tabsTitlesElement) {
              this._tabsTitlesElement.off("touchstart.scrolltab");
              this._tabsTitlesElement.off("touchend.scrolltab");
              this._tabsTitlesElement.off("touchmove.scrolltab");
            }
          }
          this._tabsHost = null;
          this._tabsTitlesBar = null;
          this._tabsTitlesHost = null;
          this._tabsTitlesElement = null;
          this._previousScroller = null;
          this._nextScroller = null;
          this._widget = null;
        },

        /**
         * Method to scroll titles to the Left
         * @param event
         * @private
         */
        _beginScrollTabsLeft: function(event) {

          // If click only, quit if event is not a click
          if (this._scrollClickOnly && event.type !== "mousedown") {
            event.preventCancelableDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            return;
          }

          // Do the actual scrolling to the left
          const scrollLeft = function(st) {
            let scroll = st._tabsTitlesHost[st._scrollPos];
            if (scroll > 0) {
              st._tabsTitlesHost[st._scrollPos] = scroll = scroll - st._scrollStep;
            }
            if (scroll <= 0) {
              st._previousScroller.removeClass("overflown-previous");
              st._endScrollTabsLeft();
            } else {
              st._previousScroller.addClass("overflown-previous");
            }
            st._nextScroller.toggleClass("overflown-next",
              scroll + st._tabsTitlesHost[st._offsetSize] < st._tabsTitlesElement[st._offsetSize]
            );
          };

          scrollLeft(this);

          // If we keep mouse over the scroller (or clicked), continue scrolling according to the speed
          if (!this._leftScrollInterval) {
            this._leftScrollInterval = window.setInterval(function() {
              scrollLeft(this);
            }.bind(this), this._scrollSpeed);
          }
        },

        /**
         * Clear the scrolling to the left
         * @private
         */
        _endScrollTabsLeft: function() {
          if (this._leftScrollInterval) {
            window.clearInterval(this._leftScrollInterval);
            this._leftScrollInterval = null;
          }
        },

        /**
         * Method to scroll titles to the Right
         * @param event
         * @private
         */
        _beginScrollTabsRight: function(event) {

          if (this._scrollClickOnly && event.type !== "mousedown") {
            event.preventCancelableDefault();
            event.stopImmediatePropagation();
            event.stopPropagation();
            return;
          }

          // Do the actual scrolling to the right
          const scrollRight = function(st) {
            const scroll = st._tabsTitlesHost[st._scrollPos];
            let now;
            st._tabsTitlesHost[st._scrollPos] = scroll + st._scrollStep;
            if ((now = st._tabsTitlesHost[st._scrollPos]) <= scroll) {
              st._nextScroller.removeClass("overflown-next");
              st._endScrollTabsRight();
            } else {
              st._nextScroller.addClass("overflown-next");
            }
            st._previousScroller.toggleClass("overflown-previous", now > 0);
          };

          scrollRight(this);

          // If we keep mouse over the scroller (or clicked), continue scrolling according to the speed
          if (!this._rightScrollInterval) {
            this._rightScrollInterval = window.setInterval(function() {
              scrollRight(this);
            }.bind(this), this._scrollSpeed);
          }
        },

        /**
         * Clear the scrolling to the right
         * @private
         */
        _endScrollTabsRight: function() {
          if (this._rightScrollInterval) {
            window.clearInterval(this._rightScrollInterval);
            this._rightScrollInterval = null;
          }
        },

        /**
         * Ensure the display state of the scrolling arrows
         */
        refreshScrollers: function() {
          if (this._refreshScrollersId) {
            window.cancelAnimationFrame(this._refreshScrollersId);
          }
          this._refreshScrollersId = window.requestAnimationFrame(function() {
            this._refreshScrollersId = 0;
            if (this._tabsTitlesHost) {
              const scroll = this._tabsTitlesHost[this._scrollPos];
              this._nextScroller.toggleClass("overflown-next",
                scroll + this._tabsTitlesHost[this._offsetSize] < this._tabsTitlesElement[this._offsetSize]
              );
              this._previousScroller.toggleClass("overflown-previous", scroll > 0);
            }
          }.bind(this));
        },

        /**
         * Display or not the scrollers
         * @param display
         */
        showScroller: function(display) {
          if (display) {
            this._previousScroller.removeClass("vanished");
            this._nextScroller.removeClass("vanished");
          } else {
            this._previousScroller.addClass("vanished");
            this._nextScroller.addClass("vanished");
          }
        },

        /**
         * Scroll the title bar to see the given element
         * @param {classes.PageWidget} element
         */
        scrollTo: function(element) {
          if (this._scrollToId) {
            window.cancelAnimationFrame(this._scrollToId);
          }
          this._scrollToId = window.requestAnimationFrame(function() {
            this._scrollToId = 0;
            if (element) {
              const scroll = this._tabsTitlesHost[this._scrollPos];
              const titleLeft = element[this._offsetPos],
                titleWidth = element[this._offsetSize],
                hostWidth = this._tabsTitlesHost[this._offsetSize],
                deltaLeft = titleLeft - scroll;
              if ((deltaLeft) < 0 || (deltaLeft + titleWidth) > hostWidth) {
                this._tabsTitlesHost[this._scrollPos] = titleLeft;
              }
            }
            this.refreshScrollers();
          }.bind(this));
        },

        /**
         *
         * @param position
         * @private
         */
        _updateOffset: function(position) {
          switch (position) {
            case "top":
            case "bottom":
              this._offsetPos = "offsetLeft";
              this._offsetSize = "offsetWidth";
              this._scrollPos = "scrollLeft";
              this._scrollStep = 6;
              break;
            case "left":
            case "right":
              this._offsetPos = "offsetTop";
              this._offsetSize = "offsetHeight";
              this._scrollPos = "scrollTop";
              this._scrollStep = 2;
              break;
          }
        },

        /**
         * Set the tabs position
         * @param {string} tag - tag of the item
         * @param {string} position - could be top, right, bottom or left
         * @publicdoc
         */
        updatePosition: function(tag, position) {
          this._position = position;
          if (this._tabsHost) {
            this._tabsHost.setAttribute(tag, position);
          }
          if (this._tabsTitlesBar) {
            this._tabsTitlesBar.setAttribute(tag, position);
          }
          if (this._tabsTitlesHost) {
            this._tabsTitlesHost.setAttribute(tag, position);
          }
          if (this._tabsTitlesElement) {
            this._tabsTitlesElement.setAttribute(tag, position);
          }
          if (this._previousScroller) {
            this._previousScroller.setAttribute(tag, position);
          }
          if (this._nextScroller) {
            this._nextScroller.setAttribute(tag, position);
          }

          this._updateOffset(position);
        },

        /**
         Touch / Mobile specific methods
         **/

        /**
         * Handler when a finger touches the screen
         * @param evt
         * @private
         */
        _startTouchScroll: function(evt) {
          const styleAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "scrollLeft" : "scrollTop";
          this._scrollTouching = true;
          this._scrollTouchingPos = evt.changedTouches[0];
          this._scrollerPosition = this._tabsTitlesHost[styleAttr];
          this._nextScroller.addClass("overflown-next");
          this._previousScroller.addClass("overflown-previous");
          this._preventContainerScrolling(true);
        },

        /**
         * Handler when a finger stop touching the screen
         * @private
         */
        _endTouchScroll: function() {
          this._scrollTouching = false;
          this._scrollTouchingPos = null;
          this._preventContainerScrolling(false);
          this.refreshScrollers();
        },

        /**
         * Moves the scroller as the finger moves on touchscreen
         * @param evt
         * @private
         */
        _touchMove: function(evt) {
          const styleAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "scrollLeft" : "scrollTop";
          const rectAttr = ["top", "bottom"].indexOf(this._position) >= 0 ? "clientX" : "clientY";
          if (this._scrollTouching) {
            // move to current tabs position minus the drift from touch start to touch current pos
            this._tabsTitlesHost[styleAttr] = this._scrollerPosition - (evt.changedTouches[0][rectAttr] - this._scrollTouchingPos[
              rectAttr]);
          }
        },

        /**
         * Prevent the container to scroll while doing touch to scroll the tab-titles
         * @param {Boolean} prevent - true to prevent it, false otherwise
         * @private
         */
        _preventContainerScrolling: function(prevent) {
          const form = this._widget.getFormWidget();
          if (form) {
            form.getContainerElement().toggleClass("prevent-touch-scroll", prevent);
          }
        },

        /**
         * Gets the tabs host element
         * @returns {Element} the element
         */
        getTabsHost: function() {
          return this._tabsHost;
        }
      };
    });
  });
;

"use strict";

modulum('ScrollWidget', ['WidgetBase', 'WidgetFactory'],
  function(context, cls) {

    /**
     * HBox or VBox widget.
     * @class ScrollWidget
     * @memberOf classes
     * @extends classes.WidgetGroupBase
     */
    cls.ScrollWidget = context.oo.Class(cls.WidgetBase, function($super) {
      return /** @lends classes.ScrollWidget.prototype */ {
        __name: "ScrollWidget",
        _lineHeight: 0,
        _pageSize: 0,
        _size: 0,
        _offset: 0,
        _spacer: null,
        _lastPosition: 0,

        //override default
        _initElement: function() {
          $super._initElement.call(this);

          this._element.on('scroll.ScrollWidget', this._onScroll.bind(this));

          this._spacer = this.getElement().getElementsByTagName("div")[0];
        },
        destroy: function() {
          this._element.off('scroll.ScrollWidget');
          $super.destroy.call(this);

        },
        _onScroll: function(event) {
          this.getParentWidget().emit(context.constants.widgetEvents.scroll, event, this._lineHeight);
        },
        _initLayout: function() {
          this._layoutInformation = new cls.LayoutInformation(this);
          this._layoutEngine = new cls.ScrollLayoutEngine(this);
        },

        /**
         * @inheritDoc
         */
        setParentWidget: function(widget, options) {
          this._detachScrollBar();
          $super.setParentWidget.call(this, widget, options);
          if (widget) {
            this._attachScrollBar();
          }
        },

        setEnabled: function(enabled) {
          $super.setEnabled.call(this, enabled);
          if (!enabled) {
            this.setTotalHeight(0);
          }

        },

        setPageSize: function(pageSize) {
          this._pageSize = pageSize;
        },

        getPageSize: function() {
          return this._pageSize;
        },

        setSize: function(size) {
          this._size = size;
        },

        setLineHeight: function(lineHeight) {
          this._lineHeight = lineHeight;
        },

        getLineHeight: function() {
          return this._lineHeight;
        },

        setOffset: function(offset) {
          this._offset = offset;
        },

        // Refresh the scrollBar
        refreshScroll: function(force) {
          if (this._lastPosition !== this._offset || force) {
            this._lastPosition = this._offset;
            const pixelOffset = this._lineHeight * this._offset;
            this.afterDomMutator(function() {
              this.getElement().scrollTop = pixelOffset;
            }.bind(this));
          }
        },

        /**
         * Will set the visible height of the scroll Area
         * @param {number} height visible
         */
        setVisibleHeight: function(height) {
          this.setStyle({
            "height": height + "px"
          });
        },

        /**
         * Will set the total height of the scrollArea
         * @param {number} height total
         */
        setTotalHeight: function(height) {
          if (!this.isEnabled()) {
            height = 0;
          }
          this.setStyle(".spacer", {
            "height": Math.max(0, height) + "px"
          });
        },

        /**
         * Will add a scrollbar to parent container
         * */
        _attachScrollBar: function() {
          const parentElement = this.getParentWidget().getElement();
          parentElement.appendChild(this.getElement());

          // Add a listener on parent scroll
          // usage of requestAnimationFrame for firefox optimization (ENGGCS-3347)
          this.afterDomMutator(function() {
            const mouseWheelFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.mouseWheel, event, this._lineHeight);
              }
            }.bind(this);
            const touchMoveFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchMove, event, this._lineHeight);
              }
            }.bind(this);
            const touchStartFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchStart, event, this._lineHeight);
              }
            }.bind(this);
            const touchEndFunc = function(event) {
              if (this.isEnabled()) {
                this.getParentWidget().emit(context.constants.widgetEvents.touchEnd, event, this._lineHeight);
              }
            }.bind(this);

            parentElement.on('wheel.ScrollWidget', mouseWheelFunc);
            if (window.isTouchDevice()) {
              parentElement.on('touchstart.ScrollWidget', touchStartFunc);
              parentElement.on('touchend.ScrollWidget', touchEndFunc);
              parentElement.on('touchmove.ScrollWidget', touchMoveFunc);
            }
          }.bind(this));
        },

        /**
         * Will remove scrollbar to parent container
         * */
        _detachScrollBar: function() {
          if (this.getParentWidget()) {
            const parentElement = this.getParentWidget().getElement();
            parentElement.off('wheel.ScrollWidget');
            if (window.isTouchDevice()) {
              parentElement.off('touchstart.ScrollWidget');
              parentElement.off('touchend.ScrollWidget');
              parentElement.off('touchmove.ScrollWidget');
            }
          }
        }

      };
    });
    cls.WidgetFactory.registerBuilder('Scroll', cls.ScrollWidget);
  });
;

"use strict";

modulum('ApplicationListVisible4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Define the applicationListVisible 4ST.
     * Possible values are 'yes', 'no', 'auto'
     * @class ApplicationListVisible4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ApplicationListVisible4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ApplicationListVisible4STBehavior.prototype */ {
        __name: "ApplicationListVisible4STBehavior",

        usedStyleAttributes: ["applicationListVisible"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            applicationListVisible = node.getStyleAttribute('applicationListVisible') || "auto"; // use "auto" as default if not specified
          context.HostLeftSidebarService.setApplicationListVisibility(
            this.isSAYesLike(applicationListVisible) ? true :
            this.isSANoLike(applicationListVisible) ? false :
            "auto");
          context.HostLeftSidebarService.setApplicationListVisible(applicationListVisible);
        }
      };
    });
  });
;

"use strict";

modulum('Border4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Border4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Border4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Border4STBehavior.prototype */ {
        __name: "Border4STBehavior",

        usedStyleAttributes: ["border"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setNoBorder) {
            const border = controller.getAnchorNode().getStyleAttribute('border');
            widget.setNoBorder(this.isSANoLike(border));
          }
        }
      };
    });
  });
;

"use strict";

modulum('BrowserMultiPage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class BrowserMultiPage4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.BrowserMultiPage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.BrowserMultiPage4STBehavior.prototype */ {
        __name: "BrowserMultiPage4STBehavior",

        usedStyleAttributes: ["browserMultiPage"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            app = node?.getApplication(),
            session = app && app.getSession(),
            isAvailable = session &&
            (
              session.hasServerFeature("browser-multi-page") ||
              (cls.ServerHelper.compare(session.info().serverVersion, "GAS/3.00.22") >= 0)
            );

          if (isAvailable) {
            // Session (and GAS) is compatible with the feature
            if (this.isSAYesLike(node.getStyleAttribute('browserMultiPage')) || gbc.browserMultiPage) {
              session.activateBrowserMultiPageMode();
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ButtonType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonType4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ButtonType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ButtonType4STBehavior.prototype */ {
        __name: "ButtonType4STBehavior",

        usedStyleAttributes: ["buttonType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setButtonType) {
            const buttonType = controller.getAnchorNode().getStyleAttribute('buttonType');
            if (buttonType) {
              widget.setButtonType(buttonType);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('CollapserPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * 4ST style used to change collapser position
     * @class CollapserPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.CollapserPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.CollapserPosition4STBehavior.prototype */ {
        __name: "CollapserPosition4STBehavior",

        usedStyleAttributes: ["collapserPosition"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            widget = controller.getWidget();

          if (node && widget && widget.setCollapserPosition) {
            const position = node.getStyleAttribute("collapserPosition");
            // Only left and right positions are allowed, others are ignored
            if (["left", "right"].indexOf(position) >= 0) {
              widget.setCollapserPosition(position);
            }
          }
        },

      };
    });
  });
;

"use strict";

modulum('Collapsible4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Collapsible4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Collapsible4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Collapsible4STBehavior.prototype */ {
        __name: "Collapsible4STBehavior",

        usedStyleAttributes: ["collapsible", "initiallyCollapsed"],

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller.getWidget()) {
            data.toggleClickHandler = controller.getWidget().when(
              context.constants.widgetEvents.toggleClick,
              this._onToggleClick.bind(this, controller, data)
            );
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.toggleClickHandler) {
            data.toggleClickHandler();
            data.toggleClickHandler = null;
          }
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            widget = controller.getWidget();
          const storedSettingsGroupId = this._getIdentifier(controller);
          widget.setGroupIdentifier(storedSettingsGroupId);
          if (node && widget && widget.setCollapsible) {
            const isCollapsible = this.isSAYesLike(node.getStyleAttribute("collapsible")),
              initiallyCollapsedAttr = node.getStyleAttribute("initiallyCollapsed"),
              initiallyCollapsed = this.isSAYesLike(initiallyCollapsedAttr);
            widget.setCollapsible(isCollapsible);

            if (initiallyCollapsedAttr === "always") {
              if (!data.firstApply) {
                widget.setCollapsed(true);
                data.firstApply = true;
              }
            } else if (initiallyCollapsedAttr === "never") {
              if (!data.firstApply) {
                widget.setCollapsed(false);
                data.firstApply = true;
              }
            } else {
              const storedCollapsedState = context.StoredSettingsService
                .getGroupCollapsedState(storedSettingsGroupId.formName, storedSettingsGroupId.id);
              if (typeof storedCollapsedState === "boolean") {
                widget.setCollapsed(storedCollapsedState);
              } else if (initiallyCollapsed && !data.initiallyCollapsed) {
                data.initiallyCollapsed = true;
                widget.setCollapsed(true);
              }
            }
          }
        },
        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {*} data
         * @private
         */
        _onToggleClick: function(controller, data) {
          const node = controller?.getAnchorNode(),
            app = node?.getApplication();
          if (app) {
            app.scheduler.layoutCommand();
          }
        },

        /**
         * Get a unique id for a Group
         * @param controller
         * @returns {{formName:string, id:string}} identifier of the Group
         * @private
         */
        _getIdentifier: function(controller) {
          const identifier = [];
          const bindings = controller.getNodeBindings();
          let anchor = bindings.anchor;
          let form = anchor.getAncestor("Form");
          let siblings = null;
          if (["Group"].indexOf(anchor.getTag()) >= 0) {
            siblings = form.getDescendants(anchor.getTag());
            identifier.push(anchor.getTag() + siblings.indexOf(anchor));
          }
          return {
            formName: form.attribute("name"),
            id: identifier.reverse().join("_")
          };
        }

      };
    });
  });
;

"use strict";

modulum('ButtonIcon4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonIcon4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ButtonIcon4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ButtonIcon4STBehavior.prototype */ {
        __name: "ButtonIcon4STBehavior",

        usedStyleAttributes: ["buttonIcon"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setButtonIcon) {
            const buttonIcon = controller.getAnchorNode().getStyleAttribute('buttonIcon');
            widget.setButtonIcon(buttonIcon);
          }
        }
      };
    });
  });
;

"use strict";

modulum('CalendarType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class CalendarType4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.CalendarType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.CalendarType4STBehavior.prototype */ {
        __name: "CalendarType4STBehavior",

        /**
         * calendarType = { "modal" (default) | "dropdown" }
         */
        usedStyleAttributes: ["calendarType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setCalendarType) {
            const calendarType = controller.getAnchorNode().getStyleAttribute('calendarType');
            widget.setCalendarType(calendarType);
          }
        }
      };
    });
  });
;

"use strict";

modulum('DaysOff4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class DaysOff4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.DaysOff4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.DaysOff4STBehavior.prototype */ {
        __name: "DaysOff4STBehavior",

        usedStyleAttributes: ["daysOff"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setDisabledDays) {
            const daysOff = controller.getAnchorNode().getStyleAttribute('daysOff');
            widget.setDisabledDays(daysOff);
          }
        }
      };
    });
  });
;

"use strict";

modulum('FirstDayOfWeek4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FirstDayOfWeek4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FirstDayOfWeek4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FirstDayOfWeek4STBehavior.prototype */ {
        __name: "FirstDayOfWeek4STBehavior",

        usedStyleAttributes: ["firstDayOfWeek"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFirstDayOfWeek) {
            const firstDayOfWeek = controller.getAnchorNode().getStyleAttribute('firstDayOfWeek');
            widget.setFirstDayOfWeek(firstDayOfWeek);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ShowWeekNumber4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowWeekNumber4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ShowWeekNumber4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowWeekNumber4STBehavior.prototype */ {
        __name: "ShowWeekNumber4STBehavior",

        usedStyleAttributes: ["showWeekNumber"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.showWeekNumber) {
            const showWeekNumber = controller.getAnchorNode().getStyleAttribute('showWeekNumber');
            widget.showWeekNumber(showWeekNumber);
          }
        }
      };
    });
  });
;

"use strict";

modulum('Packed4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Packed4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Packed4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Packed4STBehavior.prototype */ {
        __name: "Packed4STBehavior",

        usedStyleAttributes: ["packed"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setPacked) {
            const packed = controller.getAnchorNode().getStyleAttribute('packed');
            widget.setPacked(this.isSAYesLike(packed));
          }
        }
      };
    });
  });
;

"use strict";
// Temp name: ActivateSdi4STBehavior
modulum('DesktopMultiWindow4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class DesktopMultiWindow4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.DesktopMultiWindow4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.DesktopMultiWindow4STBehavior.prototype */ {
        __name: "DesktopMultiWindow4STBehavior",

        usedStyleAttributes: ["desktopMultiWindow"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            app = node?.getApplication();

          if (this.isSAYesLike(node.getStyleAttribute('desktopMultiWindow'))) {
            context.__wrapper.nativeCall(context.__wrapper.param({
              name: "desktopMultiWindow",
              args: {}
            }, app));
          }
        }
      };
    });
  });
;

"use strict";

modulum('TabPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TabPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TabPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TabPosition4STBehavior.prototype */ {
        __name: "TabPosition4STBehavior",

        usedStyleAttributes: ["position"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setTabPosition) {
            const pos = controller.getAnchorNode().getStyleAttribute('position');
            if (pos) {
              widget.setTabPosition(pos);
            } else {
              widget.setTabPosition('top');
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('FontColor4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FontColor4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FontColor4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FontColor4STBehavior.prototype */ {
        __name: "FontColor4STBehavior",

        usedStyleAttributes: ["textColor"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFontSize) {
            const font = controller.getAnchorNode().getStyleAttribute('textColor');
            widget.setFontColor(this._resolveThemedColor(font));
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;

"use strict";

modulum('FontSize4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FontSize4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FontSize4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FontSize4STBehavior.prototype */ {
        __name: "FontSize4STBehavior",

        usedStyleAttributes: ["fontSize"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFontSize) {
            const font = controller.getAnchorNode().getStyleAttribute('fontSize');
            widget.setFontSize(font);
          }
        }
      };
    });
  });
;

"use strict";

modulum('FontStyle4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FontStyle4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.FontStyle4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FontStyle4STBehavior.prototype */ {
        __name: "FontStyle4STBehavior",

        usedStyleAttributes: ["fontStyle"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFontStyle) {
            const font = controller.getAnchorNode().getStyleAttribute('fontStyle');
            widget.setFontStyle(font);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ForceDefaultSettings4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ForceDefaultSettings4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ForceDefaultSettings4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ForceDefaultSettings4STBehavior.prototype */ {
        __name: "ForceDefaultSettings4STBehavior",

        usedStyleAttributes: ["forceDefaultSettings"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          controller.forceDefaultSettings = this.isSAYesLike(controller.getAnchorNode().getStyleAttribute('forceDefaultSettings'));
          const widget = controller.getWidget();
          if (widget?.setForceDefaultSettings) {
            widget.setForceDefaultSettings(controller.forceDefaultSettings);
          }
        }
      };
    });
  });
;

"use strict";

modulum('GridAutomaticStack4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Defines the render behavior of the grid.
     * Values can be:
     *    "grid": works as a standard Genero grid.
     *    "stack": will stack all elements of the grid on one cojulnm depending on their position in the AUI.
     * @class GridAutomaticStack4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.GridAutomaticStack4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.GridAutomaticStack4STBehavior.prototype */ {
        __name: "GridAutomaticStack4STBehavior",

        usedStyleAttributes: ["customWidget"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.getLayoutInformation) {
            const GridAutomaticStackValue = controller.getAnchorNode().getStyleAttribute('customWidget') === "automaticStack";
            widget.getLayoutInformation().setGridAutomaticStack(GridAutomaticStackValue);
            return true;
          }
        }
      };
    });
  });
;

"use strict";

modulum('Highlight4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Highlight4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.Highlight4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Highlight4STBehavior.prototype */ {
        __name: "Highlight4STBehavior",

        usedStyleAttributes: ["highlightColor", "highlightCurrentCell", "highlightCurrentRow", "highlightTextColor"],
        watchedAttributes: {
          anchor: ['dialogType', 'focusOnField'],
          parent: ['active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (!(widget?.updateHighlight)) {
            return;
          }

          const anchorNode = controller.getAnchorNode();
          // -- TABLE & SCROLLGRID WIDGET -------------------------------------------------
          // In DISPLAY ARRAY without FOCUSONFIELD
          //   highlightCurrentRow is enable by default (yes) but can be explicitly set to yes or no.
          //   highlightCurrentCell is ignored.
          // In DISPLAY ARRAY with FOCUSONFIELD
          //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
          //   highlightCurrentCell is enable by default (yes) but can be explicitly set to yes or no.
          // In INPUT ARRAY
          //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
          //   highlightCurrentCell is disable by default (no) but can be explicitly set to yes or no.
          // ---------------------------------------------------
          // -- LISTVIEW WIDGET -------------------------------------------------
          // In DISPLAY ARRAY
          //   highlightCurrentRow is disable by default (no) but can be explicitly set to yes or no.
          //   highlightCurrentCell is ignored
          // FOCUSONFIELD, INPUT ARRAY --> not managed
          // ---------------------------------------------------

          const highlightColorAttr = anchorNode.getStyleAttribute("highlightColor");
          const highlightCurrentCellAttr = anchorNode.getStyleAttribute("highlightCurrentCell");
          const highlightCurrentRowAttr = anchorNode.getStyleAttribute("highlightCurrentRow");
          const highlightTextColorAttr = anchorNode.getStyleAttribute("highlightTextColor");
          let dialogType = anchorNode.attribute("dialogType");

          if (!dialogType) { // in case of scrollgrid use the dialogType of first Matrix
            const node = anchorNode.findNodeWithAttribute(null, "dialogType");
            dialogType = node ? node.attribute("dialogType") : "DisplayArray";
          }

          const isDisplayArray = (dialogType === "DisplayArray");

          let hasFocusOnField = false;
          if (anchorNode.getTag() === 'Table') {
            hasFocusOnField = anchorNode.attribute('focusOnField') === 1;
          } else {
            const matrix = anchorNode.findNodeWithAttribute('Matrix', 'currentRow', -1);
            hasFocusOnField = matrix && anchorNode.attribute('active') === 1;
          }
          const isListView = controller.isListView ? controller.isListView() : false;

          // set default values
          let highlightCurrentRow = false;
          let highlightCurrentCell = false;
          if (isDisplayArray) {
            if (hasFocusOnField) {
              highlightCurrentCell = true;
            } else if (!isListView) {
              highlightCurrentRow = true;
              highlightCurrentCell = highlightCurrentRow;
            }
          }

          // set 4ST values
          if (highlightCurrentRowAttr !== null) {
            highlightCurrentRow = this.isSAYesLike(highlightCurrentRowAttr);
          }
          if (highlightCurrentCellAttr !== null) {
            highlightCurrentCell = this.isSAYesLike(highlightCurrentCellAttr);
          }

          const isScrollgrid = anchorNode.getTag() === 'ScrollGrid';
          if (isDisplayArray && !hasFocusOnField && !isScrollgrid) {
            highlightCurrentCell = highlightCurrentRow; // highlight cell should be equal at highlight row in this case
          }

          widget.setHighlightCurrentRow(highlightCurrentRow);
          widget.setHighlightCurrentCell(highlightCurrentCell);

          // Defines the highlight color of row
          widget.setHighlightColor(highlightColorAttr);
          // Defines the highlighted text color of row
          widget.setHighlightTextColor(highlightTextColorAttr);

          widget.updateHighlight();
        }
      };
    });
  });
;

"use strict";

modulum('Alignment4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Alignment4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Alignment4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Alignment4STBehavior.prototype */ {
        __name: "Alignment4STBehavior",
        _values: {
          y: ["top", "verticalCenter", "bottom"],
          x: ["left", "horizontalCenter", "right"]
        },

        usedStyleAttributes: ["alignment"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setAlignment) {
            const isButton = controller.getAnchorNode().getTag() === "Button";
            let pos = controller.getAnchorNode().getStyleAttribute('alignment');
            if (pos) {
              if (pos === "center") {
                pos = "verticalCenter horizontalCenter";
              }
              let y = "top";
              let x = "left";
              const positions = pos.split(" ");
              if (this._values.y.indexOf(positions[0]) !== -1) {
                y = positions[0];
                x = positions.length === 2 ? positions[1] : null;
              } else if (this._values.x.indexOf(positions[0]) !== -1) {
                x = positions[0];
                y = positions.length === 2 ? positions[1] : null;
              }
              widget.setAlignment(y, x);
            } else if (!isButton) {
              if (controller.isInTable()) {
                widget.setAlignment('verticalCenter', 'horizontalCenter');
              } else {
                widget.setAlignment('top', 'left');
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ItemsAlignment4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ItemsAlignment4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ItemsAlignment4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ItemsAlignment4STBehavior.prototype */ {
        __name: "ItemsAlignment4STBehavior",

        usedStyleAttributes: ["scrollgridItemsAlign"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const anchorNode = controller.getAnchorNode();

          if (widget?.setItemsAlignment) {
            const itemsAlignmentAttr = anchorNode.getStyleAttribute("itemsAlignment");
            widget.setItemsAlignment(itemsAlignmentAttr);
          }
        }
      };
    });
  });
;

"use strict";

modulum('NavigationArrows4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class NavigationArrows4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.NavigationArrows4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.NavigationArrows4STBehavior.prototype */ {
        __name: "NavigationArrows4STBehavior",

        usedStyleAttributes: ["navigationArrows"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setNavigationArrows) {
            const navigationArrows = controller.getAnchorNode().getStyleAttribute('navigationArrows');
            if (navigationArrows) {
              widget.setNavigationArrows(this.isSAYesLike(navigationArrows));
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('NavigationDots4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class NavigationDots4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.NavigationDots4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.NavigationDots4STBehavior.prototype */ {
        __name: "NavigationDots4STBehavior",

        usedStyleAttributes: ["navigationDots"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setNavigationDots) {
            const navigationDots = controller.getAnchorNode().getStyleAttribute('navigationDots');
            if (navigationDots) {
              widget.setNavigationDots(this.isSAYesLike(navigationDots));
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Percentage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Percentage4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Percentage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Percentage4STBehavior.prototype */ {
        __name: "Percentage4STBehavior",

        usedStyleAttributes: ["percentageVisible"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.showPercentage) {
            const pos = controller.getAnchorNode().getStyleAttribute('percentageVisible');
            widget.showPercentage(pos);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ReduceFilter4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ReduceFilter4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ReduceFilter4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ReduceFilter4STBehavior.prototype */ {
        __name: "ReduceFilter4STBehavior",

        usedStyleAttributes: ["reduceFilter"],
        watchedAttributes: {
          anchor: ['noFilter']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setReduceFilter) {

            let noFilter = controller.getAnchorNode().attribute("noFilter") === 1;
            let reduceFilter = controller.getAnchorNode().getStyleAttribute('reduceFilter');

            if (reduceFilter === null) { // reduceFilter is not defined in 4ST use theme default value
              reduceFilter = context.ThemeService.getValue("theme-default-reduceFilter");
            } else {
              reduceFilter = this.isSAYesLike(reduceFilter);
            }

            widget.setReduceFilter(reduceFilter && !noFilter);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RowActionTrigger4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowActionTrigger4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RowActionTrigger4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RowActionTrigger4STBehavior.prototype */ {
        __name: "RowActionTrigger4STBehavior",

        usedStyleAttributes: ["rowActionTrigger"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setRowActionTriggerByDoubleClick) {
            const node = controller.getAnchorNode();
            const rowActionTriggerStyle = node.getStyleAttribute("rowActionTrigger");

            let rowActionTriggerByDoubleClick;
            if (rowActionTriggerStyle === null) { // if there is no style, default depends on widget type
              rowActionTriggerByDoubleClick = !(controller?.isListView && controller.isListView());
            } else { // if there is a style, use it
              rowActionTriggerByDoubleClick = (rowActionTriggerStyle !== "singleClick");
            }

            widget.setRowActionTriggerByDoubleClick(rowActionTriggerByDoubleClick);
          }
        }
      };
    });
  });
;
"use strict";

modulum('RowAspect4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowAspect4STBehavior
     * @memberof classes
     * @extends classes.StyleBehaviorBase
     */
    cls.RowAspect4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RowAspect4STBehavior */ {
        __name: "RowAspect4STBehavior",

        usedStyleAttributes: ["rowAspect"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (widget?.getRowAspectComponent) {
            const rowAspect = controller.getAnchorNode().getStyleAttribute('rowAspect');
            widget.getRowAspectComponent().setRowAspect(rowAspect);
          }
        }
      };
    });
  });
;

"use strict";

modulum('Sanitize4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Sanitize4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Sanitize4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Sanitize4STBehavior.prototype */ {
        __name: "Sanitize4STBehavior",

        usedStyleAttributes: ["sanitize"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (widget?.setSanitize) {
            const sanitize = controller.getAnchorNode().getStyleAttribute('sanitize');
            widget.setSanitize(sanitize === null || sanitize.toUpperCase() !== "NO");
          }
        }
      };
    });
  });
;

"use strict";

modulum('ScaleIcon4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Defines the scaling behaviors of the associated icon.
     * Values can be:
     *    "no": No scaling occurs and the image is taken as-is.
     *          It is up to the developer to resize the source image to avoid misalignment.
     *          This is the default on GDC/GBC.
     *    "yes": Image are scaled down according to the height of the widget (button or edit field).
     *           Setting a big font can result in a big icon. This is the default on GMA/GMI.
     *    "nnnpx": Image are scaled down according to the specified size.
     *             For example, scaleIcon="128px" will make every icon a maximum of 128*128 pixels.
     *             At least one side equal to 128 pixels, depending on the source image is square or not.
     * @class ScaleIcon4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ScaleIcon4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ScaleIcon4STBehavior.prototype */ {
        __name: "ScaleIcon4STBehavior",

        usedStyleAttributes: ["scaleIcon"],

        /**
         * @param {classes.ControllerBase} controller
         * @param data
         * @param scaleByDefault
         */
        setup: function(controller, data, scaleByDefault) {
          data._scaleByDefault = Boolean(scaleByDefault);
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setAutoScale) {
            const scaleIconValue = controller.getAnchorNode().getStyleAttribute('scaleIcon');
            if (scaleIconValue !== null) {
              widget.setAutoScale(this.isSAYesLike(scaleIconValue));
              if (!this.isSAYesLike(scaleIconValue) && !this.isSANoLike(scaleIconValue)) {
                if (widget.setScaleIconValue) {
                  widget.setScaleIconValue(scaleIconValue);
                }
              }
            } else {
              widget.setAutoScale(data._scaleByDefault);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ShowEditToolBox4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowEditToolBox4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ShowEditToolBox4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowEditToolBox4STBehavior.prototype */ {
        __name: "ShowEditToolBox4STBehavior",

        usedStyleAttributes: ["showEditToolBox"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.showEditToolBox) {
            let show = controller.getAnchorNode().getStyleAttribute('showEditToolBox');
            if (show !== "auto") {
              show = this.isSAYesLike(show) ? "show" : "hide";
            }
            widget.showEditToolBox(show);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ShowVirtualKeyboard4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowVirtualKeyboard4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ShowVirtualKeyboard4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowVirtualKeyboard4STBehavior.prototype */ {
        __name: "ShowVirtualKeyboard4STBehavior",

        usedStyleAttributes: ["showVirtualKeyboard"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (widget?.setShowVirtualKeyboardOnFocus) {
            const showKeyboard = controller.getAnchorNode().getStyleAttribute('showVirtualKeyboard');
            widget.setShowVirtualKeyboardOnFocus(showKeyboard !== null && showKeyboard.toUpperCase() === "ONFOCUS");
          }
        }
      };
    });
  });
;

"use strict";

modulum('StyleBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StyleBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StyleBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.StyleBehaviorBase.prototype */ {
        __name: "StyleBehaviorBase",

        /**
         * Test if style attribute is "yes" like
         * @param {number|string} sa Style attribute
         */
        isSAYesLike: function(sa) {
          return sa === 1 || sa === "yes" || sa === "true";
        },

        /**
         * Test if style attribute is "no" like
         * @param {number|string} sa Style attribute
         */
        isSANoLike: function(sa) {
          return sa === 0 || sa === "no" || sa === "false" || sa === "none";
        }
      };
    });
  });
;

"use strict";

modulum('AllowWebSelection4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class AllowWebSelection4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AllowWebSelection4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.AllowWebSelection4STBehavior.prototype */ {
        __name: "AllowWebSelection4STBehavior",

        usedStyleAttributes: ["allowWebSelection"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tableNode = controller.getAnchorNode();
          if (widget?.setDefaultItemSelection) {
            const allowWebSelection = this.isSAYesLike(tableNode.getStyleAttribute("allowWebSelection"));

            widget.setDefaultItemSelection(allowWebSelection);
          }
        }
      };
    });
  });
;

"use strict";

modulum('AlternateRows4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class AlternateRows4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AlternateRows4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.AlternateRows4STBehavior.prototype */ {
        __name: "AlternateRows4STBehavior",

        usedStyleAttributes: ["alternateRows"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setAlternateRows) {
            let tableNode = controller.getAnchorNode();
            let alternateRows = tableNode.getStyleAttribute("alternateRows");
            if (alternateRows !== null) {
              let applyAlternateRows = this.isSAYesLike(alternateRows);
              widget.setAlternateRows(applyAlternateRows);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('FrozenColumns4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class FrozenColumns4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FrozenColumns4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.FrozenColumns4STBehavior.prototype */ {
        __name: "FrozenColumns4STBehavior",

        usedStyleAttributes: ["leftFrozenColumns", "rightFrozenColumns"],

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tableNode = controller.getAnchorNode();
          if (widget) {

            const storedFrozenLeft = data.firstApply ? controller.getStoredSetting("leftFrozen") : null;
            const storedFrozenRight = data.firstApply ? controller.getStoredSetting("rightFrozen") : null;

            let leftFrozenColumns = null;
            let rightFrozenColumns = null;

            if (storedFrozenLeft !== null) {
              leftFrozenColumns = storedFrozenLeft;
            } else {
              leftFrozenColumns = tableNode.getStyleAttribute("leftFrozenColumns");
            }

            if (storedFrozenRight !== null) {
              rightFrozenColumns = storedFrozenRight;
            } else {
              rightFrozenColumns = tableNode.getStyleAttribute("rightFrozenColumns");
            }

            // NOTE don't reset value from style if it doesn't change because it can reset the value set by the table contextmenu
            if (leftFrozenColumns && (data._leftFrozenDefaultValue !== leftFrozenColumns)) {
              widget.setLeftFrozenColumns(leftFrozenColumns);
              data._leftFrozenDefaultValue = leftFrozenColumns;
            }
            if (rightFrozenColumns && (data._rightFrozenDefaultValue !== rightFrozenColumns)) {
              widget.setRightFrozenColumns(rightFrozenColumns);
              data._rightFrozenDefaultValue = rightFrozenColumns;
            }
          }

          data.firstApply = true;
        }
      };
    });
  });
;

"use strict";

modulum('ResizeFillsEmptySpace4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ResizeFillsEmptySpace4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ResizeFillsEmptySpace4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ResizeFillsEmptySpace4STBehavior.prototype */ {
        __name: "ResizeFillsEmptySpace4STBehavior",

        usedStyleAttributes: ["resizeFillsEmptySpace"],

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tableNode = controller.getAnchorNode();

          if (widget?.setResizeFillsEmptySpace) {
            const resizeFillsEmptySpace = tableNode.getStyleAttribute("resizeFillsEmptySpace");
            widget.setResizeFillsEmptySpace(this.isSAYesLike(resizeFillsEmptySpace));
          }
        }
      };
    });
  });
;

"use strict";

modulum('RowHover4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowHover4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RowHover4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RowHover4STBehavior.prototype */ {
        __name: "RowHover4STBehavior",

        usedStyleAttributes: ["rowHover"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setRowHover) {
            let tableNode = controller.getAnchorNode();
            let rowHover = tableNode.getStyleAttribute("rowHover");
            if (rowHover !== null) {
              let applyRowHover = this.isSAYesLike(rowHover);
              widget.setRowHover(applyRowHover);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ShowGrid4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ShowGrid4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ShowGrid4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ShowGrid4STBehavior.prototype */ {
        __name: "ShowGrid4STBehavior",

        usedStyleAttributes: ["showGrid"],
        watchedAttributes: {
          anchor: ['dialogType']
        },

        /**
         * Indicates if the grid lines must be visible in a table.
         * Values can be "yes" (default when INPUT ARRAY),"no" (default when DISPLAY ARRAY). (1 or 0 on older front-ends).
         *
         * By default, when a Table is in editable mode (INPUT ARRAY), the front-end displays grid lines in the table.
         * You can change this behavior by setting this attribute to "no".
         *
         * By default, when a Table is in editable mode (DISPLAY ARRAY), the front-end does not display grid lines in the table.
         * You can change this behavior by setting this attribute to "yes".
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget) {
            let tableNode = controller.getAnchorNode();
            let showGrid = tableNode.getStyleAttribute("showGrid");
            let dialogType = tableNode.attribute("dialogType");
            let isInputDialog = (dialogType === "Input" || dialogType === "InputArray" || dialogType === "Construct");

            let applyShowGridX = false;
            let applyShowGridY = false;

            // if showGrid is not define
            if (showGrid === null) {
              applyShowGridX = isInputDialog;
              applyShowGridY = isInputDialog;
            } else {
              if (this.isSAYesLike(showGrid)) {
                applyShowGridX = true;
                applyShowGridY = true;
              } else if (showGrid === "horizontal") {
                applyShowGridX = true;
              } else if (showGrid === "vertical") {
                applyShowGridY = true;
              }
            }

            if (widget.setShowGridX && widget.setShowGridY) {
              widget.setShowGridX(applyShowGridX);
              widget.setShowGridY(applyShowGridY);
            } else if (widget.setShowGrid) { // TODO deprecated only for old tables
              widget.setShowGrid(applyShowGridX && applyShowGridY);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('SummaryLine4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableHeader4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.SummaryLine4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.SummaryLine4STBehavior.prototype */ {
        __name: "SummaryLine4STBehavior",

        usedStyleAttributes: ["backgroundColor", "textColor", "fontSize", "fontStyle", "fontWeight", "fontFamily"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget && widget instanceof cls.RTableWidget) {
            if (widget.hasFooter()) { //summaryLine style only applies on table's aggregate line
              let tableRowWidget = widget.getFooterAggregatesRowWidget();
              let tableNode = controller.getAnchorNode();
              let forcedPseudoSelectors = 'summaryLine';
              if (widget.setBackgroundColor) {
                let backgroundColor = tableNode.getStyleAttribute('backgroundColor', forcedPseudoSelectors);
                if (backgroundColor) {
                  tableRowWidget.setBackgroundColor(this._resolveThemedColor(backgroundColor));
                }
              }
              if (widget.setColor) {
                let color = tableNode.getStyleAttribute('textColor', forcedPseudoSelectors);
                if (color) {
                  tableRowWidget.setColor(this._resolveThemedColor(color));
                }
              }
              if (widget.setFontSize) {
                let fontSize = tableNode.getStyleAttribute('fontSize', forcedPseudoSelectors);
                if (fontSize) {
                  tableRowWidget.setFontSize(fontSize);
                }
              }
              if (widget.setFontStyle) {
                let fontStyle = tableNode.getStyleAttribute('fontStyle', forcedPseudoSelectors);
                if (fontStyle) {
                  tableRowWidget.setFontStyle(fontStyle);
                }
              }
              if (widget.setFontWeight) {
                let fontWeight = tableNode.getStyleAttribute('fontWeight', forcedPseudoSelectors);
                if (fontWeight) {
                  tableRowWidget.setFontWeight(fontWeight);
                }
              }
              if (widget.setFontFamily) {
                let fontFamily = tableNode.getStyleAttribute('fontFamily', forcedPseudoSelectors);
                if (fontFamily) {
                  tableRowWidget.setFontFamily(fontFamily);
                }
              }
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          return themedColor || color;
        }

      };
    });
  });
;

"use strict";

modulum('TableHeader4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableHeader4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableHeader4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TableHeader4STBehavior.prototype */ {
        __name: "TableHeader4STBehavior",

        usedStyleAttributes: ["headerHidden", "headerAlignment"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget) {
            let tableNode = controller.getAnchorNode();
            let headerHidden = tableNode.getStyleAttribute("headerHidden");
            let headerAlignment = tableNode.getStyleAttribute("headerAlignment");
            if (widget.setHeaderHidden && headerHidden) {
              widget.setHeaderHidden(this.isSAYesLike(headerHidden));
            }
            if (widget.setHeaderAlignment && headerAlignment) {
              if (headerAlignment === "default") {
                headerAlignment = "left"; // default is left
              }
              widget.setHeaderAlignment(headerAlignment);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableType4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableType4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableType4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TableType4STBehavior.prototype */ {
        __name: "TableType4STBehavior",

        usedStyleAttributes: ["tableType"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tableNode = controller.getAnchorNode();
          const tableType = tableNode.getStyleAttribute("tableType");
          if (widget?.setFrozenTable) {
            widget.setFrozenTable(tableType === "frozenTable");
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextFormat4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TextFormat4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TextFormat4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TextFormat4STBehavior.prototype */ {
        __name: "TextFormat4STBehavior",

        usedStyleAttributes: ["textFormat"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setHtmlControl) {
            const format = controller.getAnchorNode().getStyleAttribute('textFormat');
            if (format === "html") {
              if (controller._widgetType === "TextEdit" &&
                controller.setAsRichText &&
                controller.getAnchorNode().attribute("dialogType") === "Input") {
                controller.setAsRichText(true); //return true to invalidate following behaviors
              } else {
                const control = document.createElement("div");
                control.addClass('textEditHtml');
                widget.setHtmlControl(control);
              }
            }
          } else if (widget?.setHtmlFormat) {
            const htmlFormat = controller.getAnchorNode().getStyleAttribute('textFormat');
            widget.setHtmlFormat(htmlFormat === "html");
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TextPosition4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TextPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TextPosition4STBehavior.prototype */ {
        __name: "TextPosition4STBehavior",

        usedStyleAttributes: ["toolBarTextPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.getElement) {
            const format = controller.getAnchorNode().getStyleAttribute('toolBarTextPosition');
            const element = widget.getElement();
            if (element) {
              if (format === "textBesideIcon") {
                widget.setAspect("iconAndText");

              } else {
                widget.setAspect("iconAboveText");

              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ThinScrollBarDisplayTime4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**

     * @class ThinScrollBarDisplayTime4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.ThinScrollBarDisplayTime4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ThinScrollBarDisplayTime4STBehavior.prototype */ {
        __name: "ThinScrollBarDisplayTime4STBehavior",

        usedStyleAttributes: ["thinScrollbarDisplayTime"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setThinScrollbar) {
            const thinScrollbarDisplayTime = controller.getAnchorNode().getStyleAttribute('thinScrollbarDisplayTime');
            if (thinScrollbarDisplayTime !== null) {
              widget.setThinScrollbar(parseInt(thinScrollbarDisplayTime, 10));
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Aspect4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Aspect 4ST behavior for toolbars and icon / text rendering
     * @class Aspect4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.Aspect4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Aspect4STBehavior.prototype */ {
        __name: "Aspect4STBehavior",

        usedStyleAttributes: ["aspect"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tbNode = controller.getAnchorNode();

          // aspect should be one of those values
          //  - icon: display icons (fallback to text if no icon defined),
          //  - text: display text (fallback to actionname if no display text defined),
          //  - iconAndText: display icon and text beside
          //  - iconAboveText : display icon above text (default)
          const tbAspect = tbNode.getStyleAttribute("aspect");
          if (widget?.setAspect) {
            if (tbAspect) {
              widget.setAspect(tbAspect);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Size4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Size 4ST for toolbar rendering
     * @class Size4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.Size4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Size4STBehavior.prototype */ {
        __name: "Size4STBehavior",

        usedStyleAttributes: ["size"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tbNode = controller.getAnchorNode();

          // size should be one of those values
          //  - small : displays many actions (~7 icons)
          //  - medium: displays some actions (~5 icons) default
          //  - large: display few actions (~3 icons)
          const buttonSize = tbNode.getStyleAttribute("size");
          if (widget?.setButtonSize) {
            if (buttonSize) {
              widget.setButtonSize(buttonSize);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ActionPanelButtonTextAlign4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelButtonTextAlign4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelButtonTextAlign4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelButtonTextAlign4STBehavior.prototype */ {
        __name: "ActionPanelButtonTextAlign4STBehavior",

        usedStyleAttributes: ["actionPanelButtonTextAlign", "ringMenuButtonTextAlign"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const panelNode = controller.getAnchorNode();
          let buttonTextAlign = null;
          if (panelNode.getTag() === 'Menu') {
            buttonTextAlign = panelNode.getStyleAttribute("ringMenuButtonTextAlign");
          } else {
            buttonTextAlign = panelNode.getStyleAttribute("actionPanelButtonTextAlign");
          }
          if (widget && buttonTextAlign && ["left", "right"].indexOf(buttonTextAlign) >= 0) {
            let i = 0;
            const children = widget.getChildren(),
              len = children.length;
            for (; i < len; i++) {
              const child = children[i];
              if (child && child.setContentAlign) {
                child.setContentAlign(buttonTextAlign);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ActionPanelButtonTextHidden4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelButtonTextHidden4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelButtonTextHidden4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelButtonTextHidden4STBehavior.prototype */ {
        __name: "ActionPanelButtonTextHidden4STBehavior",

        usedStyleAttributes: ["actionPanelButtonTextHidden", "ringMenuButtonTextHidden"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const panelNode = controller.getAnchorNode();

          let buttonTextHidden = null;
          if (panelNode.getTag() === 'Menu') {
            buttonTextHidden = panelNode.getStyleAttribute("ringMenuButtonTextHidden");
          } else {
            buttonTextHidden = panelNode.getStyleAttribute("actionPanelButtonTextHidden");
          }
          if (widget) {
            let i = 0;
            const children = widget.getChildren(),
              len = children.length;
            for (; i < len; i++) {
              const child = children[i];
              if (child && child.setTextHidden) {
                child.setTextHidden(buttonTextHidden);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ActionPanelPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionPanelPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionPanelPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ActionPanelPosition4STBehavior.prototype */ {
        __name: "ActionPanelPosition4STBehavior",

        usedStyleAttributes: ["actionPanelPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const panelNode = controller.getAnchorNode();
          const isInChromeBar = controller.isInChromeBar();

          const actionPanelPosition = panelNode.getStyleAttribute("actionPanelPosition");
          if (widget?.setActionPanelPosition) {
            if (!isInChromeBar) {
              if (actionPanelPosition) {
                widget.setActionPanelPosition(actionPanelPosition);
              } else {
                widget.setActionPanelPosition('right');
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('AllowedOrientations4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class AllowedOrientations4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.AllowedOrientations4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.AllowedOrientations4STBehavior.prototype */ {
        __name: "AllowedOrientations4STBehavior",

        usedStyleAttributes: ["allowedOrientations"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            app = node?.getApplication();

          if (app) {
            const allowedOrientations = node.getStyleAttribute('allowedOrientations');
            if (allowedOrientations) {
              context.__wrapper.nativeCall(context.__wrapper.param({
                name: "allowedOrientations",
                args: {
                  "orientations": allowedOrientations
                }
              }, app));
            }

          }

        }
      };
    });
  });
;

"use strict";

modulum('BackgroundImage4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class BackgroundImage4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.BackgroundImage4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.BackgroundImage4STBehavior.prototype */ {
        __name: "BackgroundImage4STBehavior",

        usedStyleAttributes: ["backgroundImage"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const windowNode = controller.getAnchorNode();

          const backgroundImage = windowNode.getStyleAttribute("backgroundImage");
          if (widget?.setBackgroundImage) {
            widget.setBackgroundImage(backgroundImage);
          }
        }
      };
    });
  });
;

"use strict";

modulum('DefaultTTFColor4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class DefaultTTFColor4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DefaultTTFColor4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.DefaultTTFColor4STBehavior.prototype */ {
        __name: "DefaultTTFColor4STBehavior",

        usedStyleAttributes: ["defaultTTFColor"],

        /**
         * Get the defaultTTFColor color to apply to the widget
         * @param {classes.ControllerBase} controller
         * @param {classes.WidgetBase} widget
         * @private
         */
        _getColor: function(controller, widget) {
          let windowColor, anchorColor = null;
          const anchorNode = controller.getAnchorNode();
          let winNode = anchorNode.getAncestor("Window");
          // If the widget is a Window
          if (winNode === null && widget instanceof cls.WindowWidget) {
            winNode = controller.getAnchorNode();
          }

          // For global toolbar that are not inside a window node
          if (winNode === null) {
            const windowId = controller.getAnchorNode().getApplication().getNode(0).attribute('currentWindow');
            winNode = controller.getUINode().getFirstChildWithId(windowId);
          }

          if (winNode) {
            windowColor = winNode.getStyleAttribute('defaultTTFColor');
          }

          // If current node has defaultTTFColor defined, use this one
          if (anchorNode && anchorNode.getStyleAttribute("defaultTTFColor")) {
            anchorColor = anchorNode.getStyleAttribute("defaultTTFColor");
          }

          return anchorColor ? anchorColor : windowColor;
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (widget) {
            const defaultColorFn = widget.setDefaultColor || widget.setDefaultTTFColor;
            if (defaultColorFn) {
              const color = this._getColor(controller, widget);
              if (color) {
                (defaultColorFn.bind(widget))(color);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Position4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Position4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Position4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Position4STBehavior.prototype */ {
        __name: "Position4STBehavior",

        usedStyleAttributes: ["position"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setPosition) {
            let pos = controller.getAnchorNode().getStyleAttribute('position');
            if (pos !== widget._position) {
              widget._position = pos;
              if (pos === "field") { // get ref field widget
                // Get the previous focused node or value node if table or matrix
                const previousId = controller.getUINode().previousAttribute("focus");
                let previousNode = controller.getUINode().getApplication().getNode(previousId);
                if (previousNode) {
                  if (previousNode.getCurrentValueNode) {
                    const currentValueNode = previousNode.getCurrentValueNode(true);
                    if (currentValueNode) {
                      previousNode = currentValueNode;
                    }
                  }
                  pos = previousNode.getController().getWidget();
                }
              }
              widget.setPosition(pos);
              // Refresh Window or UserInterface's toolbar positions
              if (widget instanceof cls.ToolBarWidget) {
                let parentNode = controller.getAnchorNode().getParentNode();
                while (parentNode) {
                  let parentWidget = parentNode.getController().getWidget();
                  if (parentWidget?.setToolBarPosition) {
                    parentWidget.setToolBarPosition();
                  }
                  parentNode = parentNode.getParentNode();
                }
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Reverse4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Reverse4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Reverse4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Reverse4STBehavior.prototype */ {
        __name: "Reverse4STBehavior",

        usedStyleAttributes: ["reverse"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setReverse) {
            const reverse = controller.getUINode().getStyleAttribute('reverse');
            widget.setReverse(this.isSAYesLike(reverse));
          }
        }
      };
    });
  });
;

"use strict";

modulum('RingMenuPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class RingMenuPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RingMenuPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.RingMenuPosition4STBehavior.prototype */ {
        __name: "RingMenuPosition4STBehavior",

        usedStyleAttributes: ["ringMenuPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const menuNode = controller.getAnchorNode();
          const isInChromeBar = controller.isInChromeBar();

          const ringMenuPosition = menuNode.getStyleAttribute("ringMenuPosition");
          if (widget?.setActionPanelPosition) {
            if (!isInChromeBar) {
              if (ringMenuPosition) {
                widget.setActionPanelPosition(ringMenuPosition);
              } else {
                widget.setActionPanelPosition('right');
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('Sizable4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class Sizable4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.Sizable4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.Sizable4STBehavior.prototype */ {
        __name: "Sizable4STBehavior",

        usedStyleAttributes: ["sizable", "border"],

        /**
         *
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            widget = controller?.getWidget();
          if (widget) {
            const isSizable = node.getStyleAttribute('sizable') ? !this.isSANoLike(node.getStyleAttribute('sizable')) : true,
              modal = widget.getModal && widget.getModal();
            if (!modal) {
              widget.getLayoutInformation().setSizable(isSizable);
            } else {
              const noBorder = node.getStyleAttribute('border') === "none";
              if (!noBorder && modal.setSizable) {
                widget.getLayoutInformation().setSizable(isSizable);
                modal.setSizable(isSizable);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('StartMenuPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class StartMenuPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StartMenuPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.StartMenuPosition4STBehavior.prototype */ {
        __name: "StartMenuPosition4STBehavior",

        usedStyleAttributes: ["startMenuPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const node = controller.getAnchorNode();

          const type = node.getStyleAttribute("startMenuPosition");
          if (widget?.setStartMenuType) {
            if (type) {
              widget.setStartMenuType(type);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TabbedContainer4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class TabbedContainer4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.TabbedContainer4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TabbedContainer4STBehavior.prototype */ {
        __name: "TabbedContainer4STBehavior",

        usedStyleAttributes: ["tabbedContainer"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode(),
            app = node?.getApplication();

          if (app) {
            const isTabbedContainer = this.isSAYesLike(node.getStyleAttribute('tabbedContainer'));
            if (isTabbedContainer) {
              const widget = node.getController() && node.getController().getWidget();
              if (widget && !(widget.getModal && widget.getModal()) && node.getApplication().getNode(0).getChildren("StartMenu").length) {
                app.setTabbedContainerMode(isTabbedContainer, node);
                context.__wrapper.nativeCall(context.__wrapper.param({
                  name: "activateTabbedContainer"
                }, app));
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ToolBarItemsAlignment4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ToolBarItemsAlignment4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ToolBarItemsAlignment4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ToolBarItemsAlignment4STBehavior.prototype */ {
        __name: "ToolBarItemsAlignment4STBehavior",

        usedStyleAttributes: ["itemsAlignment"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tbNode = controller.getAnchorNode();

          const align = tbNode.getStyleAttribute("itemsAlignment");
          tbNode.getApplication().layout.when(context.constants.widgetEvents.afterLayout,
            function() {
              if (widget?.setToolBarItemsAlignment) {
                if (align) {
                  widget.setToolBarItemsAlignment(align);
                } else {
                  widget.setToolBarItemsAlignment('left');
                }
              }
            }.bind(this), true);

        }
      };
    });
  });
;

"use strict";

modulum('ToolBarPosition4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class ToolBarPosition4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ToolBarPosition4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.ToolBarPosition4STBehavior.prototype */ {
        __name: "ToolBarPosition4STBehavior",

        usedStyleAttributes: ["toolBarPosition"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const tbNode = controller.getAnchorNode();

          const tbPosition = tbNode.getStyleAttribute("toolBarPosition");
          if (widget?.setToolBarPosition) {
            if (tbPosition) {
              widget.setToolBarPosition(tbPosition);
            } else {
              widget.setToolBarPosition('top');
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TopmenuRendering4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * Used to set the Topmenu Rendering ('classic'[default] or 'sidebar')
     * @class TopmenuMobileRendering4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TopmenuRendering4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.TopmenuRendering4STBehavior.prototype */ {
        __name: "TopmenuRendering4STBehavior",

        usedStyleAttributes: ["topmenuDesktopRendering", "topmenuMobileRendering"],

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const windowNode = controller.getAnchorNode();
          const winWidget = controller.getWidget();
          const uiNode = windowNode.getAncestor("UserInterface");
          const uiWidget = uiNode.getWidget();

          const topmenuRendering = {
            desktop: windowNode.getStyleAttribute("topmenuDesktopRendering") || 'classic',
            mobile: windowNode.getStyleAttribute("topmenuMobileRendering") || 'sidebar'
          };

          if (winWidget && winWidget.setTopmenuRendering) {
            // Handle window's topmenus
            winWidget.setTopmenuRendering(topmenuRendering.desktop, topmenuRendering.mobile);
          }
          if (uiWidget && uiWidget.setTopmenuRendering) {
            // Handle UserInterface's topmenus
            uiWidget.setTopmenuRendering(topmenuRendering.desktop, topmenuRendering.mobile);
          }

        }
      };
    });
  });
;

"use strict";

modulum('WindowOptionClose4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowOptionClose4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowOptionClose4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WindowOptionClose4STBehavior.prototype */ {
        __name: "WindowOptionClose4STBehavior",

        watchedAttributes: {
          ui: ['currentWindow']
        },
        usedStyleAttributes: ["windowOptionClose"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const windowNode = controller.getAnchorNode();

          const windowOptionClose = windowNode.getStyleAttribute("windowOptionClose");
          if (widget) {
            if (this.isSAYesLike(windowOptionClose)) {
              const currentWindow = controller.getAnchorNode() &&
                controller.getAnchorNode().getParentNode() &&
                controller.getAnchorNode().getParentNode().attribute("currentWindow");
              context.HostService.setClosableWindowActionActive(widget, currentWindow === controller.getAnchorNode().getId());
            } else if (windowOptionClose !== null) {
              context.HostService.setClosableWindowActionActive(widget, false);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('WindowState4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowState4STBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowState4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WindowState4STBehavior.prototype */ {
        __name: "WindowState4STBehavior",

        usedStyleAttributes: ["windowState"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const windowNode = controller.getAnchorNode(),
            windowState = windowNode.getStyleAttribute("windowState");
          context.HostService.setWindowState(windowState);
        }
      };
    });
  });
;

"use strict";

modulum('WindowListVisible4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowListVisible4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.WindowListVisible4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WindowListVisible4STBehavior.prototype */ {
        __name: "WindowListVisible4STBehavior",

        usedStyleAttributes: ["windowListVisible"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller?.getAnchorNode();
          let windowListVisible = node.getStyleAttribute('windowListVisible');
          if (windowListVisible === null) {
            windowListVisible = true;
          } else {
            windowListVisible = this.isSAYesLike(windowListVisible);
          }
          context.HostLeftSidebarService.setWindowListVisibility(windowListVisible);
        }
      };
    });
  });
;

"use strict";

modulum('WrapPolicy4STBehavior', ['StyleBehaviorBase'],
  function(context, cls) {
    /**
     * @class WrapPolicy4STBehavior
     * @memberOf classes
     * @extends classes.StyleBehaviorBase
     */
    cls.WrapPolicy4STBehavior = context.oo.Singleton(cls.StyleBehaviorBase, function($super) {
      return /** @lends classes.WrapPolicy4STBehavior.prototype */ {
        __name: "WrapPolicy4STBehavior",

        usedStyleAttributes: ["wrapPolicy"],
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setWrapPolicy) {
            const format = controller.getAnchorNode().getStyleAttribute('wrapPolicy');
            widget.setWrapPolicy(format);
          }
        }
      };
    });
  });
;

"use strict";

modulum('NavigationAriaBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * // TODO comment
     * @class NavigationAriaBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NavigationAriaBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NavigationAriaBehavior.prototype */ {
        __name: "NavigationAriaBehavior",

        watchedAttributes: {
          anchor: ['tabIndexRt']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const parent = bindings.parent;
          const anchor = bindings.anchor;
          const widget = anchor.getWidget();
          const visibleChildren = parent.getChildrenWithAttribute("MenuAction", "hidden", 0);
          const posInSet = anchor.attribute('tabIndexRt');
          widget.setAriaAttribute("posinset", posInSet);
          widget.setAriaAttribute("setsize", visibleChildren.length);
          widget.setAriaRole("menuitem");
        },

        /**
         * @inheritDoc
         */
        destroy: function(controller, data) {
          $super.destroy.call(this, controller, data);
        }
      };
    });
  });
;

"use strict";

modulum('BehaviorBase', ['EventListener'],
  /**
   * @namespace Behaviors
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * Base class for all behaviors
     * @class BehaviorBase
     * @memberOf classes
     */
    cls.BehaviorBase = context.oo.Class(function($super) {
      return /** @lends classes.BehaviorBase.prototype */ {
        __name: "BehaviorBase",
        /**
         * List of watched attributes
         * @type {Object}
         * @protected
         */
        _watchedAttributes: null,
        /**
         * List of watched style attributes
         * @type {string[]}
         * @protected
         */
        usedStyleAttributes: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          this.watchedBindings = this.watchedAttributes && Object.keys(this.watchedAttributes);
          this.watchedBindingsCount = this.watchedBindings && this.watchedBindings.length;
        },
        //TODO see if this return value is used somewhere
        /**
         * Applies the behavior on the widget
         * @param {classes.ControllerBase} controller The controller to apply the behavior
         * @param {*} data data to pass to the behavior
         * @return {boolean} bool
         */
        apply: function(controller, data) {
          data.dirty = false;
          let res = this._apply(controller, data);
          data.appliedOnce = true;
          return res;
        },

        /**
         * internal method to be overriden in behaviors
         * @protected
         * @param {classes.ControllerBase} controller The controller to apply the behavior
         * @param {*} data data to pass to the behavior
         * @return {boolean} bool
         */
        _apply: function(controller, data) {
          context.LogService.error("Behavior " + this.__name + " must override apply()");
          return false;
        },
        /**
         * Attaches the needed observers to the AUI tree.
         * This is the top level implementation. Checks that the behavior isn't already attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        attach: function(controller, data) {
          this.detach(controller, data);
          this._attach(controller, data);
        },

        /**
         * Attaches the needed observers to the AUI tree
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _attach: function(controller, data) {},
        /**
         * Detached all AUI tree observers*
         * This is the top level implementation. Checks that the behavior is attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        detach: function(controller, data) {
          this._detach(controller, data);
        },
        /**
         * Detached all AUI tree observers
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _detach: function(controller, data) {},
        /**
         * Attaches the needed observers Widget.
         * This is the top level implementation. Checks that the behavior isn't already attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        attachWidget: function(controller, data) {
          this.detachWidget(controller, data);
          this._attachWidget(controller, data);
        },
        /**
         * Attaches the needed observers to Widget
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _attachWidget: function(controller, data) {},
        /**
         * Detached all Widget observers*
         * This is the top level implementation. Checks that the behavior is attached
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        detachWidget: function(controller, data) {
          this._detachWidget(controller, data);
        },
        /**
         * Detached all Widget observers
         * @protected
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        _detachWidget: function(controller, data) {},
        /**
         * Attach the behavior to the controller
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        firstAttach: function(controller, data) {
          this.attach(controller, data);
          this.attachWidget(controller, data);
        },
        /**
         * get a list of pair node/attribute names
         * @return {Object} the watched attributes
         * @protected
         */
        _getWatchedAttributes: function() {
          return this._watchedAttributes;
        },
        /**
         * test if the behavior can apply to the controller
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {boolean} true if behavior can apply to the controller
         */
        canApply: function(controller, data, treeModificationTrack) {
          if (data.dirty) {
            return true;
          }

          if (this.watchedAttributes) {
            const len = this.watchedBindingsCount;
            for (let i = 0; i < len; ++i) {
              const nodeBinding = this.watchedBindings[i];
              const node = controller._nodeBindings[nodeBinding];
              if (node) {
                if (treeModificationTrack.isNodeCreated(node)) {
                  return true;
                }
                const modifiedAttributes = treeModificationTrack.getChangedAttributes(node._id);
                const nodeWatchedAttributes = this.watchedAttributes[nodeBinding],
                  attrLen = nodeWatchedAttributes.length;
                for (let j = 0; j < attrLen; ++j) {
                  if (modifiedAttributes[nodeWatchedAttributes[j]]) {
                    return true;
                  }
                }
              }
            }
          }

          const watched = this._getWatchedAttributes();
          if (watched) {
            let xi = 0;
            const xlen = watched.length;

            for (; xi < xlen; xi++) {
              const current = watched[xi];
              if (!current.node) {
                continue;
              }
              if (treeModificationTrack.isNodeCreated(current.node._id)) {
                return true;
              }
              if (treeModificationTrack.isNodeAttributeChanged(current.node._id, current.attribute)) {
                return true;
              }
            }
          }
          return false;
        },
        /**
         * Cleans up the behavior
         * @param {classes.ControllerBase} controller the controller
         * @param {*} data the data
         */
        cleanup: function(controller, data) {
          this.detachWidget(controller, data);
          this.detach(controller, data);
        }
      };
    });
  });
;

"use strict";

modulum('ActivePseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class ActivePseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.ActivePseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.ActivePseudoSelectorBehavior.prototype */ {
        __name: "ActivePseudoSelectorBehavior",

        activeChanged: function(controller, data, event, eventData) {
          const node = controller.getAnchorNode();

          //Menu is detached/attached in the DOM and the behaviours are not reapplied
          //so the virtual widget could be not correctly initialized
          if (node.getTag() === "Menu" && Boolean(node.attribute("active"))) {
            let children = node.getChildren();

            children.forEach(n => {
              let controller = n.getController(),
                widget = n.getWidget();

              if (controller && widget) {
                controller.reapplyBehaviourToVirtualWidgets();
              }
            });
          }

          if (node._pseudoSelectorsUsedInSubTree.active ||
            node._pseudoSelectorsUsedInSubTree.inactive) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          const node = controller.getNodeBindings().container || controller.getAnchorNode();
          data.onActiveAttributeChanged = node.onAttributeChanged('active', this.activeChanged.bind(this, controller, data));
          data.onActionActiveAttributeChanged = node.onAttributeChanged('actionActive', this.activeChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onActiveAttributeChanged) {
            data.onActiveAttributeChanged();
            data.onActiveAttributeChanged = null;
          }
          if (data.onActionActiveAttributeChanged) {
            data.onActionActiveAttributeChanged();
            data.onActionActiveAttributeChanged = null;
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('DialogTypePseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class DialogTypePseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.DialogTypePseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.DialogTypePseudoSelectorBehavior.prototype */ {
        __name: "DialogTypePseudoSelectorBehavior",

        dialogTypeChanged: function(controller, data, event, eventData) {
          const node = controller.getNodeBindings().container;
          if (node._pseudoSelectorsUsedInSubTree.display ||
            node._pseudoSelectorsUsedInSubTree.input ||
            node._pseudoSelectorsUsedInSubTree.display) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          const node = controller.getNodeBindings().container;
          data.onDialogTypeAttributeChanged = node.onAttributeChanged('dialogType', this.dialogTypeChanged.bind(this, controller,
            data));
        },

        _detach: function(controller, data) {
          if (data.onDialogTypeAttributeChanged) {
            data.onDialogTypeAttributeChanged();
            data.onDialogTypeAttributeChanged = null;
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('FocusCurrentCellPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusCurrentCellPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.FocusCurrentCellPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.FocusCurrentCellPseudoSelectorBehavior.prototype */ {
        __name: "FocusCurrentCellPseudoSelectorBehavior",

        currentCellChanged: function(controller, data) {
          const node = controller.getAnchorNode();
          if (node._pseudoSelectorsUsedInSubTree.focus) {
            const offset = node.attribute('offset');
            const currentRowIndex = node.attribute('currentRow') - offset;
            if (node.getTag() === 'Table') {
              const currentColumn = node.attribute('currentColumn');
              if (data.previousCurrentRowIndex !== undefined && data.previousCurrentColumn !== undefined) {
                this._setTableCellStyleBasedBehaviorsDirty(node, data.previousCurrentRowIndex, data.previousCurrentColumn);
              }
              this._setTableCellStyleBasedBehaviorsDirty(node, currentRowIndex, currentColumn);
              data.previousCurrentRowIndex = currentRowIndex;
              data.previousCurrentColumn = currentColumn;
            } else {
              if (data.previousCurrentRowIndex !== undefined) {
                this._setColumnCellStyleBasedBehaviorsDirty(node, data.previousCurrentRowIndex);
              }
              this._setColumnCellStyleBasedBehaviorsDirty(node, currentRowIndex);
              data.previousCurrentRowIndex = currentRowIndex;
            }
          }
        },

        _setTableCellStyleBasedBehaviorsDirty: function(table, rowIndex, columnIndex) {
          const column = table.getChildren('TableColumn')[columnIndex];
          if (column) {
            this._setColumnCellStyleBasedBehaviorsDirty(column, rowIndex);
          }
        },

        _setColumnCellStyleBasedBehaviorsDirty: function(container, rowIndex) {
          const valueList = container.getFirstChild('ValueList');
          if (valueList) {
            const value = valueList.getChildren()[rowIndex];
            if (value) {
              const ctrl = value.getController();
              if (ctrl) {
                ctrl.setStyleBasedBehaviorsDirty(container, null, true);
              }
            }
          }
        },

        _attach: function(controller, data) {
          const node = controller.getAnchorNode();
          const updateFunction = this.currentCellChanged.bind(this, controller, data);
          data.onCurrentRowAttributeChanged = node.onAttributeChanged('currentRow', updateFunction);
          data.onOffsetAttributeChanged = node.onAttributeChanged('offset', updateFunction);
          if (node.getTag() === 'Table') {
            data.onCurrentColumnAttributeChanged = node.onAttributeChanged('currentColumn', updateFunction);
          }
        },

        _detach: function(controller, data) {
          if (data.onCurrentColumnAttributeChanged) {
            data.onCurrentColumnAttributeChanged();
            data.onCurrentColumnAttributeChanged = null;
          }
          if (data.onOffsetAttributeChanged) {
            data.onOffsetAttributeChanged();
            data.onOffsetAttributeChanged = null;
          }
          if (data.onCurrentRowAttributeChanged) {
            data.onCurrentRowAttributeChanged();
            data.onCurrentRowAttributeChanged = null;
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('FocusPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.FocusPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.FocusPseudoSelectorBehavior.prototype */ {
        __name: "FocusPseudoSelectorBehavior",

        watchedAttributes: {
          ui: ["focus"]
        },

        focusChanged: function(controller, data, event, node, eventData) {
          const uiNode = controller.getAnchorNode();
          if (uiNode._pseudoSelectorsUsedInSubTree.focus) {
            if (eventData.old) {
              const oldFocusedNode = uiNode.getApplication().getNode(eventData.old);
              // Previously focused node may have been removed from the AUI tree.
              if (oldFocusedNode) {
                if (oldFocusedNode._pseudoSelectorsUsedInSubTree.focus) {
                  this.setStyleBasedBehaviorsDirty(oldFocusedNode);
                }
              }
            }
            const newFocusedWidget = uiNode.getApplication().getNode(eventData.new);
            if (newFocusedWidget && newFocusedWidget._pseudoSelectorsUsedInSubTree.focus) {
              this.setStyleBasedBehaviorsDirty(newFocusedWidget);
            }
          }
        },

        _attach: function(controller, data) {
          const uiNode = controller.getAnchorNode();
          data.onFocusAttributeChanged = uiNode.onAttributeChanged('focus', this.focusChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onFocusAttributeChanged) {
            data.onFocusAttributeChanged();
            data.onFocusAttributeChanged = null;
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('OffsetPseudoSelectorBehavior', ['PseudoSelectorBehaviorBase'],
  function(context, cls) {
    /**
     * @class OffsetPseudoSelectorBehavior
     * @memberOf classes
     * @extends classes.PseudoSelectorBehaviorBase
     */
    cls.OffsetPseudoSelectorBehavior = context.oo.Singleton(cls.PseudoSelectorBehaviorBase, function($super) {
      return /** @lends classes.OffsetPseudoSelectorBehavior.prototype */ {
        __name: "OffsetPseudoSelectorBehavior",

        offsetChanged: function(controller, data, event, eventData) {
          const node = controller.getAnchorNode();
          if (node._pseudoSelectorsUsedInSubTree.even ||
            node._pseudoSelectorsUsedInSubTree.odd) {
            this.setStyleBasedBehaviorsDirty(node);
          }
        },

        _attach: function(controller, data) {
          const node = controller.getAnchorNode();
          data.onOffsetAttributeChanged = node.onAttributeChanged('offset', this.offsetChanged.bind(this, controller, data));
        },

        _detach: function(controller, data) {
          if (data.onOffsetAttributeChanged) {
            data.onOffsetAttributeChanged();
            data.onOffsetAttributeChanged = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('PseudoSelectorBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class PseudoSelectorBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PseudoSelectorBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.PseudoSelectorBehaviorBase.prototype */ {
        __name: "PseudoSelectorBehaviorBase",
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {},

        /**
         * set node and all its descendants controllers dirty
         * @param {classes.NodeBase} rootNode main node
         */
        setStyleBasedBehaviorsDirty: function(rootNode) {
          rootNode.forThisAndEachDescendant(function(node) {
            const controller = node.getController();
            if (controller) {
              controller.setStyleBasedBehaviorsDirty(null, null, true);
            }
          });
        }
      };
    });
  });
;

"use strict";

modulum('ButtonRequestFocusUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonRequestFocusUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ButtonRequestFocusUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ButtonRequestFocusUIBehavior.prototype */ {
        __name: "ButtonRequestFocusUIBehavior",

        /**
         *
         * @protected
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.focusListener = widget.when(context.constants.widgetEvents.click, this._onRequestFocus.bind(this, controller));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.focusListener) {
            data.focusListener();
            data.focusListener = null;
          }
        },
        /**
         * @todo : Refactor this when making the scrollgrid line controller disapear
         * @param controller
         * @param {Object} event - DOM event
         * @param src
         * @param domEvent
         * @private
         */
        _onRequestFocus: function(controller, event, src, domEvent) {
          if (controller.isInScrollGrid()) {
            if (event.data[0]) {
              event.data[0].currentRow = controller.scrollGridLineController.getIndex();
            }
            controller.getAnchorNode().getAncestor("ScrollGrid").getController()._onRequestFocus(event);
          }
        }
      };
    });
  });
;

"use strict";

modulum('CanvasItemOnClickUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class CanvasItemOnClickUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.CanvasItemOnClickUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.CanvasItemOnClickUIBehavior.prototype */ {
        /** @type {string} */
        __name: "CanvasItemOnClickUIBehavior",

        anchor: ['acceleratorKey1', 'acceleratorKey3'],
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller,
              false));
            data.rightClickHandle = controller.getWidget().when(gbc.constants.widgetEvents.rightClick, this._onClick.bind(this,
              controller, true));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
          if (data.rightClickHandle) {
            data.rightClickHandle();
            data.rightClickHandle = null;
          }
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller) {
          const anchorNode = controller.getAnchorNode();
          if (!anchorNode.attribute('acceleratorKey1') && !anchorNode.attribute('acceleratorKey3')) {
            controller.getWidget().addClass("gbc_noPointerEvents");
          }
        },
        /**
         *
         * @param controller
         * @param isRightClick
         * @private
         */
        _onClick: function(controller, isRightClick) {
          const anchorNode = controller.getAnchorNode();

          let acceleratorKey = null;
          if (!isRightClick) {
            acceleratorKey = anchorNode.attribute('acceleratorKey1');
            // Left mouse button
          } else {
            // Right mouse button
            acceleratorKey = anchorNode.attribute('acceleratorKey3');
          }
          if (acceleratorKey) {
            const app = anchorNode.getApplication();
            const vmEvent = new cls.VMKeyEvent(acceleratorKey, anchorNode.getId());
            app.scheduler.eventVMCommand(vmEvent, anchorNode);
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('ChangePageUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ChangePageUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ChangePageUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ChangePageUIBehavior.prototype */ {
        /** @type {string} */
        __name: "ChangePageUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.changeHandle = widget.when(context.constants.widgetEvents.change, this._pageChanged.bind(this, controller, data));
            data.requestFocusHandle = widget.when(context.constants.widgetEvents.requestFocus, this._requestFocus.bind(this,
              controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.changeHandle) {
            data.changeHandle();
            data.changeHandle = null;
          }
          if (data.requestFocusHandle) {
            data.requestFocusHandle();
            data.requestFocusHandle = null;
          }
        },

        /**
         * Page changed
         * @param controller
         * @param data
         * @param evt
         * @param folder
         * @param page
         * @param {boolean=} executeAction - true if we need to execute action on page change, false otherwise
         * @param {boolean} [refreshLayoutImmediately]
         * @private
         */

        _pageChanged: function(controller, data, evt, folder, page, executeAction, refreshLayoutImmediately = false) {
          const node = controller.getAnchorNode();
          const app = node.getApplication();

          app.getUI().getWidget().getLayoutInformation().invalidateMeasure();
          // Force direct refresh to ensure page layout is executed before VM's response
          if (refreshLayoutImmediately) {
            app.layout.refreshLayout();
          }
          // Queue layout command to be executed once VM answered
          app.scheduler.layoutCommand();

          // If not specified, execute action
          executeAction = typeof executeAction !== "undefined" ? executeAction : true;
          if (app && app.action && executeAction) {
            const currentPageWidget = node.getWidget().getCurrentPage();
            const options = {};
            if (currentPageWidget) {
              app.action.execute(currentPageWidget._auiTag, null, options);
            }
          }
        },

        /**
         * If current focused node is child of previous page, request focus on first focusable widget of the current page
         * @private
         */
        _requestFocus: function(controller, data) {
          const node = controller.getAnchorNode();
          const folderWidget = controller.getWidget();
          let focusedWidget = null;
          const focusedNode = node.getApplication().getFocusedVMNodeAndValue(true);
          if (focusedNode) {
            focusedWidget = focusedNode.getController().getWidget();
          }
          if (!focusedWidget || focusedWidget.isChildOf(folderWidget)) {
            const pageIndex = folderWidget.getCurrentPage() ? folderWidget.getCurrentPage().getPageIndex() : -1;
            if (pageIndex >= 0 && pageIndex < node.getChildren().length) {
              const pageNode = node.getChildren()[pageIndex];

              const pageHasActiveAction = pageNode.attribute("actionActive") !== 0;

              //1. When no action is associated to a folder page,
              //   the front-end can choose to set the focus to the next focusable element (here inside a sub-page).
              //2. When an action is associated to a folder page,
              //   it's typically in the hands of the program to decide what to do,
              //   and the front-end should not overwrite this.
              if (!pageHasActiveAction) {
                // request focus on the first active widget
                let firstActiveNode = this._getFirstFocusableField(pageNode);
                if (firstActiveNode) {
                  if (firstActiveNode.getCurrentValueNode && firstActiveNode.getCurrentValueNode(false)) {
                    firstActiveNode = firstActiveNode.getCurrentValueNode(false);
                  }
                  const firstActiveController = firstActiveNode.getController();
                  if (firstActiveController) {
                    const firstActiveWidget = firstActiveController.getWidget();
                    if (firstActiveWidget) {
                      if (firstActiveNode.isInTable()) {
                        // if we land in a table, this one should ask the VM rather than the field
                        firstActiveWidget.getTableWidgetBase().emit(context.constants.widgetEvents.requestFocus);
                      } else {
                        firstActiveWidget.emit(context.constants.widgetEvents.requestFocus);
                      }
                    }
                  }
                }
              }
            }
          }
        },

        /**
         *
         * @param node
         * @return {*}
         * @private
         */
        _getFirstFocusableField: function(node) {
          if (['FormField', 'Table', 'Matrix', 'Button'].indexOf(node.getTag()) !== -1 &&
            (node.attribute("active") > 0 || node.attribute("actionActive") > 0) &&
            (!node.isAttributeSetByVM("tabIndex") || node.attribute("tabIndex") !== 0)) {
            return node;
          }
          // get first active field sorted by tabindex
          const nodeChildren = node.getTabIndexSortedChildren();
          for (const currentNode of nodeChildren) {
            if (currentNode.attribute('hidden') !== 1) { // exclude hidden nodes from being focusable
              const focusableNode = this._getFirstFocusableField(currentNode);
              if (focusableNode) {
                return focusableNode;
              }
            }
          }
          return null;
        }
      };
    });
  });
;

"use strict";

modulum('HasWebComponentUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class HasWebComponentUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.HasWebComponentUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.HasWebComponentUIBehavior.prototype */ {
        /** @type {string} */
        __name: "HasWebComponentUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget() && controller.getWidget()._iframeElement) {
            let parentNode = controller.getAnchorNode().getParentNode();
            while (parentNode) {
              if (parentNode.getWidget() && parentNode.getWidget().setHasChildWebComponent) {
                parentNode.getWidget().setHasChildWebComponent(true);
              }
              parentNode = parentNode.getParentNode();
            }
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          //TODO many Webcomp

        }

      };
    });
  });
;

"use strict";

modulum('InterruptUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class InterruptUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.InterruptUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.InterruptUIBehavior.prototype */ {
        /** @type {string} */
        __name: "InterruptUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const node = controller.getAnchorNode();
          if (node.attribute('name') === 'interrupt') {
            const widget = controller.getWidget();
            if (widget) {
              const application = node?.getApplication();
              if (application && application.action) {
                application.action.registerInterruptWidget(widget);
              }
              if (!application.action.hasAction("interrupt")) {
                widget.setInterruptable(true);
                if (widget instanceof cls.TopMenuCommandWidget) {
                  let parentNode = node.getParentNode();
                  while (parentNode && parentNode.getController().getWidget() && parentNode.getController().getWidget() instanceof cls
                    .TopMenuGroupWidget) {
                    parentNode.getController().getWidget().setInterruptable(true);
                    parentNode = parentNode.getParentNode();
                  }
                }
                data.actionHandle = widget.when(gbc.constants.widgetEvents.click, this._onAction.bind(this, controller, data));
              }
            }
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            const node = controller.getAnchorNode();
            const application = node?.getApplication();
            if (application && application.action) {
              application.action.unregisterInterruptWidget(widget);
            }
            widget.setInterruptable(false);
          }
          if (this.actionHandle) {
            this.actionHandle();
            this.actionHandle = null;
          }
        },
        /**
         * Creates an action event and sends it to the VM
         */
        _onAction: function(controller) {
          const node = controller.getAnchorNode(),
            application = node?.getApplication();
          if (application) {
            if (application.isIdle()) {
              application.action.executeByName("interrupt");
            } else if (!application.action.hasAction("interrupt")) {
              application.interrupt();
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('NativeScrollUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class NativeScrollUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.NativeScrollUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.NativeScrollUIBehavior.prototype */ {
        __name: "NativeScrollUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          controller.requestOffsetPending = false;
          const widget = /** @type classes.TableWidgetBase|classes.StretchableScrollGridWidget */ controller.getWidget();
          if (widget) {
            data.scrollHandle = widget.when(context.constants.widgetEvents.scroll, this._onScroll.bind(this, controller, data));
            widget.getScrollableArea().on('wheel.NativeScrollUIBehavior', this._preventWhenRequestOffsetPending.bind(this, controller));
            widget.getScrollableArea().on('scroll.NativeScrollUIBehavior', this._preventWhenRequestOffsetPending.bind(this, controller));
          }
          data.requestedOffset = null;
        },

        /**
         * Prevent event when an offset request is pending
         * @param {classes.ControllerBase} controller
         * @param {Object} event - DOM event
         * @private
         */
        _preventWhenRequestOffsetPending: function(controller, event) {
          // for perf, prevent default when a requestoffset is pending
          if (controller.requestOffsetPending) {
            event.stopPropagation();
            event.stopImmediatePropagation();
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.scrollHandle) {
            data.scrollHandle();
            data.scrollHandle = null;
          }

          const widget = /** @type classes.TableWidgetBase|classes.StretchableScrollGridWidget */ controller.getWidget();
          if (widget) {
            widget.getScrollableArea().off('wheel.NativeScrollUIBehavior');
            widget.getScrollableArea().off('scroll.NativeScrollUIBehavior');
          }
        },

        /**
         * Handle scroll event
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param {Object} event
         * @return {boolean}
         * @private
         */
        _onScroll: function(controller, data, event) {
          const widget = controller.getWidget();
          if (!widget.isEnabled()) {
            return true;
          }
          data.lateEvent = event;
          this.requestOffset(controller, data);
        },

        /**
         * Ask the VM for offset
         * @param {classes.ControllerBase} controller - controller
         * @param {Object} data
         */
        requestOffset: function(controller, data) {
          const node = controller?.getAnchorNode();
          if (!node) {
            return;
          }
          /** 
           * @type {classes.TableWidgetBase|classes.StretchableScrollGridWidget}
           */
          const widget = controller.getWidget();
          if (!widget) {
            return;
          }

          if (data.lateEvent) {
            this._updateScrollData(controller, data);
            data.lateEvent = null;
          }

          const oldOffset = widget.getOffset();
          if (oldOffset !== data.requestedOffset) {

            const app = node.getApplication();
            const offsetChanged = data.requestedOffset !== widget.lastSentOffset;
            // if a request offset already sent to VM, don't send value
            // because the value node will change when VM receive new offset
            // also, do not send value if we are currently processing scroll commands meaning that we may be anticipating values and be desynchronized with VM
            if (!controller.requestOffsetPending && !app.scheduler.hasScrollCommandsToProcess(node)) {
              controller.sendWidgetValue();
            }

            if (app.getFocusedVMNode() === node) {
              widget.setFocus();
            }

            // if requestedOffset is the same as lastSentOffset don't send it again
            if (offsetChanged) {

              controller.requestOffsetPending = true;
              app.scheduler.scrollVMCommand(node, data.requestedOffset);
              widget.setOffset(data.requestedOffset);

              const upScrolling = (oldOffset > data.requestedOffset);
              widget.setScrolling(upScrolling, !upScrolling);

              if (widget.isAnticipateScrollingEnabled()) {
                widget.anticipateScrolling();
              }
              widget.lastSentOffset = data.requestedOffset;
            }
          }

          data.lateEvent = null;
          data.requestedOffset = null;
        },

        /**
         * Update data object with offset info
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @private
         */
        _updateScrollData: function(controller, data) {
          let scrollData = data.lateEvent;
          let scrollTop = scrollData.data[0].target.scrollTop;
          let lineHeight = scrollData.data[1] ? scrollData.data[1] : 1; //prevent division by 0

          // get floor of one decimal rounded value
          // means if 0.9 < scrollTop/lineHeight < 1.0 means offset will be 1
          data.requestedOffset = Math.floor(Math.round(scrollTop / lineHeight * 10) / 10);

          let size = controller.getAnchorNode().attribute("size");
          let pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

          // request offset must not be greater than (size - pageSize)
          data.requestedOffset = Math.min(data.requestedOffset, Math.abs(size - pageSize));
        }
      };
    });
  });
;

"use strict";

modulum('OnActionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnActionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnActionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnActionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnActionUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.actionHandle = controller.getWidget().when(cls.WebComponentWidget.actionEvent, this._onAction.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.actionHandle) {
            data.actionHandle();
            data.actionHandle = null;
          }
        },
        /**
         * Creates an action event and sends it to the VM
         * @private
         */
        _onAction: function(controller, data, event, src, actionName) {
          const node = controller.getAnchorNode();
          node.getApplication().scheduler.startGroupCommand();

          const widget = node.getWidget();
          const widgetValue = widget.getValue();

          // Pass the Webcomponent node to ensure its value is flushed
          node.getApplication().scheduler.valueVMCommand(node, widgetValue);
          // No node given here since we don't know the action node yet (only the action name)
          node.getApplication().scheduler.actionVMCommand(null, {
            actionName: actionName
          });

          node.getApplication().scheduler.finishGroupCommand();

        }
      };
    });
  });
;

"use strict";

modulum('OnClickStartMenuCommandUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnClickStartMenuCommandUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnClickStartMenuCommandUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnClickStartMenuCommandUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnClickStartMenuCommandUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Creates an action event and sends it to the VM
         */
        _onClick: function(controller, data) {
          const node = controller.getAnchorNode();
          node.getApplication().action.execute(node.getId());
          context.HostLeftSidebarService.hideSidebar();
        }
      };
    });
  });
;

"use strict";

modulum('OnClickUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnClickUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnClickUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnClickUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnClickUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.click, this._onClick.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Creates an action command
         */
        _onClick: function(controller, data, gbcEvent, element, domEvent, actionOnly) {
          const bindings = controller.getNodeBindings();
          const app = bindings.anchor.getApplication();
          const actionNode = bindings.decorator ? bindings.decorator : bindings.anchor;

          const options = {};
          if (!actionOnly) {
            options.sendValue = true;
          }

          app.action.execute(actionNode.getId(), null, options);
        }
      };
    });
  });
;

"use strict";

modulum('OnDataUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnDataUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnDataUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnDataUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnDataUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.dataHandle = controller.getWidget().when(cls.WebComponentWidget.dataEvent, this._onData.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.dataHandle) {
            data.dataHandle();
            data.dataHandle = null;

          }
        },

        /**
         * On data widget event
         * @private
         */
        _onData: function(controller, data, event, widget, eventData) {
          if (widget._flushValue !== eventData) {
            widget._flushValue = eventData;
          }
        }
      };
    });
  });
;

"use strict";

modulum('OnLayoutPagedUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnLayoutPagedUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnLayoutPagedUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnLayoutPagedUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnLayoutPagedUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const node = controller.getAnchorNode();
          data.afterLayoutHandler = node.getApplication().layout.afterLayout(this._onLayout.bind(this, controller, data));
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.afterLayoutHandler) {
            data.afterLayoutHandler();
            data.afterLayoutHandler = null;
          }
        },

        /**
         * On layout widget event: send new page size to vm
         * @private
         */
        _onLayout: function(controller, data) {
          const node = controller.getAnchorNode();
          const pageSize = node.attribute('pageSize');

          const widget = controller.getWidget();
          const app = node.getApplication();

          if (app) {
            const dataAreaWidth = widget.getDataAreaWidth();
            const dataAreaHeight = widget.getDataAreaHeight();

            let isVisible = widget.isElementInDOM() && widget.isVisibleRecursively();
            isVisible = isVisible && !isNaN(dataAreaHeight) && !isNaN(dataAreaWidth) && dataAreaHeight > 0 && dataAreaWidth > 0;
            // if widget is in a page which is not visible it is not necessary to send a pageSize
            if (isVisible) {
              const rowWidth = widget.getRowWidth();
              const rowHeight = widget.getRowHeight();

              let newPageSize = 1;
              if (rowHeight !== 0 && rowWidth !== 0) {
                const gutter = context.ThemeService.getGutterY();
                const margin = context.ThemeService.getValue("theme-margin-ratio") * 8; // Account for margin around each item
                // for small screens minimum should be 1
                const lines = Math.floor(dataAreaHeight / (rowHeight + (margin * 2 + gutter * 2))) || 1;
                const cols = Math.floor(dataAreaWidth / (rowWidth + 2 * margin)) || 1; // for small screens minimum should be 1
                newPageSize = lines * cols;
              }

              if (app.isIdle() && app.scheduler.hasNoCommandToProcess() && newPageSize !== data.requestedPageSize && (pageSize !==
                  newPageSize)) {
                let event = new cls.VMConfigureEvent(node.getId(), {
                  pageSize: newPageSize,
                  bufferSize: newPageSize
                });
                app.scheduler.eventVMCommand(event, node);
                data.requestedPageSize = newPageSize;
                event = new cls.VMConfigureEvent(node.getId(), {
                  offset: Math.floor(node.attribute('offset') / newPageSize) * newPageSize
                });
                app.scheduler.eventVMCommand(event, node);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('OnLayoutUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnLayoutUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnLayoutUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnLayoutUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnLayoutUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          let node = controller.getAnchorNode();
          data.afterLayoutHandler = node.getApplication().layout.afterLayout(this._onLayout.bind(this, controller, data));

          let widget = controller.getWidget();
          if (widget) {
            data.layoutHandler = widget.when(context.constants.widgetEvents.layout, this._onLayout.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.afterLayoutHandler) {
            data.afterLayoutHandler();
            data.afterLayoutHandler = null;
          }
          if (data.layoutHandler) {
            data.layoutHandler();
            data.layoutHandler = null;
          }
        },

        /**
         * On layout widget event: send new page size to vm
         * @private
         */
        _onLayout: function(controller, data) {
          let widget = controller.getWidget();

          let isVisible = widget.isPageVisible ? widget.isPageVisible() : true;
          isVisible = isVisible && widget.isElementInDOM() && widget.isVisibleRecursively();
          // if widget is in a page which is not visible it is not necessary to send a pageSize
          if (isVisible && widget.getDataAreaHeight && widget.getRowHeight) {
            let dataAreaHeight = widget.getDataAreaHeight();
            let rowHeight = widget.getRowHeight();
            if (!isNaN(dataAreaHeight) && dataAreaHeight > 0 && rowHeight > 0) {

              let newPageSize = Math.floor(dataAreaHeight / rowHeight + 0.1); // add 0.1 for values like 9,99
              newPageSize = Number.isNaN(newPageSize) ? 1 : Math.max(newPageSize, 1);
              // if rowHeight is > 40px it is better to have a bigger bufferSize
              // to be sure to not see blank after the last table row
              let newBufferSize = newPageSize + (rowHeight > 40 ? 2 : 1);

              let node = controller.getAnchorNode();
              let app = node.getApplication();

              if (app && !app.scheduler.hasPendingFunctionCallResultCommands(true)) {
                let pageSize = node.attribute('pageSize');
                let bufferSize = node.attribute('bufferSize');
                if (pageSize !== newPageSize || bufferSize !== newBufferSize) {
                  app.scheduler.pageSizeVMCommand(node, newPageSize, newBufferSize);
                }
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('OnSplitterUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class OnSplitterUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OnSplitterUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OnSplitterUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OnSplitterUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.splitterHandle = widget.when(context.constants.widgetEvents.splitter, this._onSplitter.bind(this,
              controller,
              data));
          }

        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.splitterHandle) {
            data.splitterHandle();
            data.splitterHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _onSplitter: function(controller, data) {
          controller.getWidget().getLayoutEngine().invalidateAllocatedSpace();
          controller.getAnchorNode().getApplication().scheduler.layoutCommand();
        }
      };
    });
  });
;

"use strict";

modulum('OpenDropDownUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Handling open drop down on a widget
     *
     *
     * @class OpenDropDownUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.OpenDropDownUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.OpenDropDownUIBehavior.prototype */ {
        /** @type {string} */
        __name: "OpenDropDownUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.openDropDownHandle = controller.getWidget().when(gbc.constants.widgetEvents.openDropDown, this._onOpenDropDown.bind(
              this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.openDropDownHandle) {
            data.openDropDownHandle();
            data.openDropDownHandle = null;
          }
        },

        /**
         * Create a command to open drop down
         * @param controller
         * @param data
         * @private
         */
        _onOpenDropDown: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.openDropDown) {
            const anchorNode = controller.getAnchorNode();
            const app = anchorNode.getApplication();
            app.scheduler.openDropDownCommand(anchorNode);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RequestFocusUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RequestFocusUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RequestFocusUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RequestFocusUIBehavior.prototype */ {
        __name: "RequestFocusUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.focusListener = widget.when(context.constants.widgetEvents.requestFocus, this._onRequestFocus.bind(this,
              controller,
              data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.focusListener) {
            data.focusListener();
            data.focusListener = null;
          }
          if (data.focusReadyListener) {
            data.focusReadyListener();
            data.focusReadyListener = null;
          }
        },
        /**
         *
         * @param controller
         * @param data
         * @param opt
         * @private
         */
        _onRequestFocus: function(controller, data, opt) {
          const anchorNode = controller.getAnchorNode();
          const app = anchorNode.getApplication();

          // Keep capture allowed value when the event is received.
          const restoringFocus = app.focus.isRestoringVMFocus();
          if (restoringFocus) {
            return;
          }

          if (controller.isInMatrix()) {
            if (!this._requestFocusInMatrix(controller, anchorNode)) {
              return;
            }
          }

          if (controller.isInTable()) {
            if (!this._requestFocusInTable(controller, anchorNode)) {
              return;
            }
          }

          const originWidgetNode = app.getFocusedVMNodeAndValue(true);
          const widget = controller.getWidget();
          if (originWidgetNode !== anchorNode) {
            this._requestFocusFromAnotherOrigin(controller, anchorNode, opt, originWidgetNode);
          } else if (widget.hasFocus() && !widget.hasDOMFocus()) {
            widget.setFocus(true);
          }
        },

        /**
         * @returns {boolean} True if we should request the focus
         * @private
         */
        _requestFocusInMatrix: function(controller, anchorNode) {
          const matrixNode = controller.getNodeBindings().container;
          if (matrixNode.attribute("dialogType") === "DisplayArray") {
            const valueNodeIndex = anchorNode.getIndex();
            const offset = matrixNode.attribute('offset');
            const size = matrixNode.attribute('size');
            const currentRow = valueNodeIndex + offset;

            return currentRow < size;
          }
          return true;
        },

        /**
         * @returns {boolean} True if we should request the focus
         * @private
         */
        _requestFocusInTable: function(controller, anchorNode) {
          const tableColumnNode = controller.getNodeBindings().container;
          const tableNode = tableColumnNode.getParentNode();
          if (tableNode.attribute("active") === 0) {
            return false;
          }
          if (tableColumnNode.attribute("active") === 0) {
            // if column is not active don't request focus if currentRow doesn't change
            const currentRow = tableNode.attribute("currentRow");
            const valueNodeIndex = anchorNode.getIndex();
            const offset = tableNode.attribute('offset');
            const anchorNodeRow = valueNodeIndex + offset;
            return currentRow !== anchorNodeRow;
          }
          return true;
        },

        /**
         * @private
         */
        _requestFocusFromAnotherOrigin: function(controller, anchorNode, opt, originWidgetNode) {
          const widget = controller.getWidget();
          if (originWidgetNode) {
            const originWidgetController = originWidgetNode.getController();
            if (
              originWidgetController
            ) { // check if controller exists. In come case we could have a MenuAction node which doesn't have a controller
              const originWidget = originWidgetController.getWidget();
              if (originWidget) {
                originWidgetController.sendWidgetCursors();
                originWidgetController.sendWidgetValue();
              }
            }
          }

          let cursors = { // for widgets which don't support cursors send 0,0 to VM to set focus
            start: 0,
            end: 0
          };
          if (widget.hasCursors()) {
            cursors = widget.getCursors();
          }
          let rowIndex = -1;
          // check if widget has a defined row index
          if (widget.getRowIndex) {
            rowIndex = widget.getRowIndex();
          }
          const app = anchorNode.getApplication();
          app.scheduler.focusVMCommand(anchorNode, cursors.start, cursors.end, rowIndex);

          // indicates in the event that a focus has been requested
          let event = opt.data.length > 0 && opt.data[0];
          if (event) {
            event.gbcFocusRequested = true;
          }

          // needed to trigger & bubble focus when clicking on a webcomponent even if it's not focusable (gbc-1984)
          if (widget instanceof cls.WebComponentWidget) {
            widget.setFocus(true);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RowActionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Handling row action (double-click on table/scrollgrid)
     * @class RowActionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowActionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowActionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "RowActionUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.rowActionHandle = controller.getWidget().when(gbc.constants.widgetEvents.rowAction, this._onRowAction.bind(
              this, controller, data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.rowActionHandle) {
            data.rowActionHandle();
            data.rowActionHandle = null;
          }
        },

        /**
         * Creates an action event and sends it to the VM
         * @param controller
         * @param data
         * @param opt index of table column (if necessary)
         * @private
         */
        _onRowAction: function(controller, data, opt) {
          let anchorNode = controller.getAnchorNode();

          // Table case
          if (anchorNode.getTag().startsWith('Table')) {
            const tableNode = anchorNode.getTag() === 'Table' ? anchorNode : anchorNode.getParentNode();
            const colIndex = opt.data.length > 0 && opt.data[0];
            if (colIndex) {
              // if there is a colIndex must check attributes on TableColumnNode
              let tableColumnNode = tableNode.getChildren()[colIndex];
              anchorNode = tableColumnNode || anchorNode;
            }
            const active = tableNode.attribute('actionActive');
            const tableWidget = tableNode.getController().getWidget();
            const noEntry = anchorNode.attribute('noEntry');
            const doubleClickEnable = tableNode.attribute('doubleClick').length > 0 || tableWidget.isDisplayMode();

            if (tableWidget && active && doubleClickEnable && (tableWidget.isDisplayMode() || noEntry === 1)) {
              anchorNode.getApplication().action.execute(tableNode.getId());
            }
          }
          // Scrollgrid case
          else if (anchorNode.getTag() === 'ScrollGrid') {
            if (anchorNode.isAttributeSetByVM("doubleClick")) {
              anchorNode.getApplication().action.execute(anchorNode.getId());
            } else {
              const matrix = anchorNode.getFirstChild('Matrix');
              if (matrix && matrix.attribute('dialogType').indexOf('Display') !== -1) {
                // TODO GBC-1760 we should use ActionApplicationService to search an action
                const dialog = anchorNode.getAncestor('Window').getActiveDialog();
                const acceptAction = dialog.getFirstChildWithAttribute(null, 'name', 'accept');
                if (acceptAction) {
                  anchorNode.getApplication().action.execute(acceptAction.getId());
                }
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('RowAndSelectionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowAndSelectionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowAndSelectionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowAndSelectionUIBehavior.prototype */ {
        /** @type {string} */
        __name: "RowAndSelectionUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          data.lastEvent = null;
          const widget = controller.getWidget();
          if (widget) {
            data.downHandle = widget.when(gbc.constants.widgetEvents.keyArrowDown, this._onNavigationKey.bind(this, controller,
              "nextrow"));
            data.upHandle = widget.when(gbc.constants.widgetEvents.keyArrowUp, this._onNavigationKey.bind(this, controller,
              "prevrow"));
            data.pageDownHandle = widget.when(gbc.constants.widgetEvents.keyPageDown, this._onNavigationKey.bind(this, controller,
              "nextpage"));
            data.pageUpHandle = widget.when(gbc.constants.widgetEvents.keyPageUp, this._onNavigationKey.bind(this, controller,
              "prevpage"));
            data.homeHandle = widget.when(gbc.constants.widgetEvents.keyHome, this._onNavigationKey.bind(this, controller,
              "firstrow"));
            data.endHandle = widget.when(gbc.constants.widgetEvents.keyEnd, this._onNavigationKey.bind(this, controller,
              "lastrow"));

            data.leftHandle = widget.when(gbc.constants.widgetEvents.keyArrowLeft, this._onKeyLeft.bind(this, controller, data));
            data.rightHandle = widget.when(gbc.constants.widgetEvents.keyArrowRight, this._onKeyRight.bind(this, controller, data));

            data.spaceHandle = widget.when(gbc.constants.widgetEvents.keySpace, this._onKeySpace.bind(this, controller, data));
            data.selectAllHandle = widget.when(gbc.constants.widgetEvents.selectAll, this._onSelectAll.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.downHandle) {
            data.downHandle();
            data.downHandle = null;
          }
          if (data.upHandle) {
            data.upHandle();
            data.upHandle = null;
          }
          if (data.leftHandle) {
            data.leftHandle();
            data.leftHandle = null;
          }
          if (data.rightHandle) {
            data.rightHandle();
            data.rightHandle = null;
          }
          if (data.pageDownHandle) {
            data.pageDownHandle();
            data.pageDownHandle = null;
          }
          if (data.pageUpHandle) {
            data.pageUpHandle();
            data.pageUpHandle = null;
          }
          if (data.homeHandle) {
            data.homeHandle();
            data.homeHandle = null;
          }
          if (data.endHandle) {
            data.endHandle();
            data.endHandle = null;
          }
          if (data.spaceHandle) {
            data.spaceHandle();
            data.spaceHandle = null;
          }
          if (data.selectAllHandle) {
            data.selectAllHandle();
            data.selectAllHandle = null;
          }
        },

        /**
         * On navigation key widget event
         * @private
         */
        _onNavigationKey: function(controller, actionName, event, sender, domEvent) {
          const node = controller.getAnchorNode();
          const app = node.getApplication();
          const focusedNode = app.getFocusedVMNodeAndValue(true);
          const focusedNodeController = focusedNode && focusedNode.getController();

          // when using a navigation key, a new currentRow is sent to VM, so we must also send value/cursor of current focused widget
          app.scheduler.startGroupCommand();
          if (focusedNodeController) {
            focusedNodeController.sendWidgetCursors();
            focusedNodeController.sendWidgetValue();
          }
          this._sendCommands(controller, actionName, domEvent.ctrlKey || domEvent.metaKey, domEvent.shiftKey);

          app.scheduler.finishGroupCommand();
        },

        /**
         * Creates, configures and sends commands
         * @param {classes.TableController} controller
         * @param {string} actionName - action name (nextrow, prevrow, ...)
         * @param {boolean} ctrlKey - true if ctrl or meta key is pressed
         * @param {boolean} shiftKey - true if shift key is pressed
         */
        _sendCommands: function(controller, actionName, ctrlKey, shiftKey) {
          const node = controller.getAnchorNode();
          const app = node.getApplication();
          const widget = controller.getWidget();

          if (widget.isMultiRowSelectionEnabled && widget.isMultiRowSelectionEnabled()) {
            const sendSelect = !(ctrlKey && !shiftKey);
            if (sendSelect) {
              app.scheduler.rowSelectionVMCommand(node, ctrlKey, shiftKey, cls.RowSelectionVMCommand.currentRow, actionName);
            }
          }

          app.scheduler.currentRowVMCommand(node, actionName, ctrlKey, shiftKey);
        },

        /**
         * On keyLeft widget event
         * @private
         */
        _onKeyLeft: function(controller, data, event, sender, domEvent) {
          const widget = controller.getWidget();
          if (widget.hasFocusOnField()) {
            const keyEvent = new cls.VMKeyEvent("Left");
            const node = controller.getAnchorNode();
            node.getApplication().scheduler.eventVMCommand(keyEvent, node);
          } else if (widget.isDisplayMode() && !widget.isTreeView()) {
            widget.doHorizontalScroll("left");
          }
        },

        /**
         * On keyRight widget event
         * @private
         */
        _onKeyRight: function(controller, data, event, sender, domEvent) {
          const widget = controller.getWidget();
          if (widget.hasFocusOnField()) {
            const keyEvent = new cls.VMKeyEvent("Right");
            const node = controller.getAnchorNode();
            node.getApplication().scheduler.eventVMCommand(keyEvent, node);
          } else if (widget.isDisplayMode() && !widget.isTreeView()) {
            widget.doHorizontalScroll("right");
          }
        },

        /**
         * On keySpace widget event
         * @private
         */
        _onKeySpace: function(controller, data, event, sender, domEvent) {
          const node = controller.getAnchorNode();
          const app = node.getApplication();
          app.scheduler.rowSelectionVMCommand(node, domEvent.ctrlKey, domEvent.shiftKey, cls.RowSelectionVMCommand.toggle);

        },

        /**
         * On selectAll widget event
         * @private
         */
        _onSelectAll: function(controller, data, event, sender) {
          const node = controller.getAnchorNode();
          const app = node.getApplication();
          app.scheduler.rowSelectionVMCommand(node, false, false, cls.RowSelectionVMCommand.selectAll);
        }
      };
    });
  });
;

"use strict";

modulum('RowBoundUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Handling rowbound
     *
     *
     * @class RowBoundUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowBoundUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowBoundUIBehavior.prototype */ {
        /** @type {string} */
        __name: "RowBoundUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.rowBoundMenuHandle = controller.getWidget()
              .when(
                gbc.constants.widgetEvents.rowBoundMenu,
                this._onRowBoundMenu.bind(this, controller, data)
              );
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.rowBoundMenuHandle) {
            data.rowBoundMenuHandle();
            data.rowBoundMenuHandle = null;
          }
        },

        /**
         * Create a scheduler command to open rowbound menu
         * @param controller
         * @param data
         * @private
         */
        _onRowBoundMenu: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.getRowBoundMenu) {
            let anchorNode = controller.getAnchorNode();
            let app = anchorNode.getApplication();
            app.scheduler.callbackCommand(widget.getRowBoundMenu().show.bind(widget.getRowBoundMenu()));
          }
        }
      };
    });
  });
;

"use strict";

modulum('RowSelectionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class RowSelectionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.RowSelectionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.RowSelectionUIBehavior.prototype */ {
        __name: "RowSelectionUIBehavior",

        /**
         * @inheritDoc
         * @protected
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.onClickHandle = widget.when(context.constants.widgetEvents.tableClick, this._onClick.bind(this, controller, data));
          }
        },
        /**
         * @inheritDoc
         * @protected
         */
        _detachWidget: function(controller, data) {
          if (data.onClickHandle) {
            data.onClickHandle();
            data.onClickHandle = null;
          }
        },

        _onClick: function(controller, data, event, sender, domEvent) {
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;
          const tableNode = bindings.container.getParentNode();

          if (tableNode.attribute('multiRowSelection') !== 0) {
            const offset = tableNode.attribute('offset');
            const index = anchorNode.getIndex();
            const clickedRow = offset + index;

            // If right click on selected row, just ignore it
            if (domEvent.which === 3 && tableNode.getWidget().getRows()[clickedRow].isSelected()) {
              return;
            }

            const vmEvent = tableNode.getController().buildRowSelectionEvent(clickedRow, domEvent.ctrlKey || domEvent.metaKey,
              domEvent.shiftKey);

            tableNode.getApplication().scheduler.eventVMCommand(vmEvent, anchorNode, true);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ScrollOffsetUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Dataset scroll behavior. Moves the dataset directly to the requested offset
     * @class ScrollOffsetUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ScrollOffsetUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ScrollOffsetUIBehavior.prototype */ {
        __name: "ScrollOffsetUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          data.scrollHandle = widget.when(context.constants.widgetEvents.offset, this._onScrollOffset.bind(this, controller, data));
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.scrollHandle) {
            data.scrollHandle();
            data.scrollHandle = null;
          }
        },

        /**
         * Send the requested scroll offset to the VM
         * @param controller Widget controller
         * @param data Behavior data
         * @param event source event
         * @private
         */
        _onScrollOffset: function(controller, data, event) {
          const offset = event.data[0];
          const node = controller.getAnchorNode();
          node.getApplication().scheduler.scrollVMCommand(node, offset);
        }
      };
    });
  });
;

"use strict";

modulum('ScrollUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ScrollUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ScrollUIBehavior.prototype */ {
        __name: "ScrollUIBehavior",

        _throttleTimeout: 180,

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          controller.requestOffsetPending = false;
          const widget = controller.getWidget();
          if (widget) {
            data.scrollHandle = widget.when(context.constants.widgetEvents.scroll, this._onScroll.bind(this, controller, data));
            data.mouseWheelHandle = widget.when(context.constants.widgetEvents.mouseWheel, this._onMousewheel.bind(this, controller, data));
            data.touchMoveHandle = widget.when(context.constants.widgetEvents.touchMove, this._onTouchMove.bind(this, controller, data));
            data.touchStartHandle = widget.when(context.constants.widgetEvents.touchStart, this._onTouchStart.bind(this, controller, data));
          }
          data.requestedOffset = null;
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.throttleScroll) {
            window.clearTimeout(data.throttleScroll);
            data.throttleScroll = null;
          }

          if (data.scrollHandle) {
            data.scrollHandle();
            data.scrollHandle = null;
          }
          if (data.mouseWheelHandle) {
            data.mouseWheelHandle();
            data.mouseWheelHandle = null;
          }
          if (data.touchMoveHandle) {
            data.touchMoveHandle();
            data.touchMoveHandle = null;
          }
          if (data.touchStartHandle) {
            data.touchStartHandle();
            data.touchStartHandle = null;
          }
          if (data.touchEndHandle) {
            data.touchEndHandle();
            data.touchEndHandle = null;
          }
        },

        /**
         * Handle scroll event
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param {Object} e
         * @return {boolean}
         * @private
         */
        _onScroll: function(controller, data, e) {
          const widget = controller.getWidget();
          if (!widget.isEnabled()) {
            return true;
          } else {
            data.lateEvent = e;
            this._updateScrollData(controller, data);
            this._postRequest(controller, data);
          }
        },

        /**
         * Update data object with offset info
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @private
         */
        _updateScrollData: function(controller, data) {
          const scrollData = data.lateEvent;
          const forceOffset = scrollData.data[0].forceOffset; // case of scrollbar widget
          if (forceOffset) {
            data.requestedOffset = forceOffset;
          } else {
            const scrollTop = scrollData.data[0].target.scrollTop;
            const lineHeight = scrollData.data[1] ? scrollData.data[1] : 1; //prevent division by 0
            data.requestedOffset = Math.round(scrollTop / lineHeight);

            const size = controller.getAnchorNode().attribute("size");
            const pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);
            // request offset must not be greater than (size - pageSize)
            data.requestedOffset = Math.min(data.requestedOffset, Math.abs(size - pageSize));
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @return {boolean}
         * @private
         */
        _onMousewheel: function(controller, data, e) {
          const widget = controller.getWidget();
          const event = e.data[0];
          if (!widget.isEnabled()) {
            event.stopImmediatePropagation();
            return false;
          } else {
            //event.preventCancelableDefault(); // Not allowed since passive:true
            //throttle events...
            if (data.requestedOffset === null) {
              data.requestedOffset = controller.getAnchorNode().attribute("offset");
            }
            const original = data.requestedOffset;
            const delta = (window.browserInfo.isFirefox ? (53 / 3) : 1) * event.deltaY;

            const size = controller.getAnchorNode().attribute("size");
            const pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

            data.requestedOffset += Math.round(delta / 16);
            data.requestedOffset = Math.max(0, Math.min(data.requestedOffset, size - pageSize));

            if (original !== data.requestedOffset) {
              this._postRequest(controller, data);
            }
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @return {boolean}
         * @private
         */
        _onTouchMove: function(controller, data, e) {
          // Don't do anything if the VM offset order is pending
          if (!controller.requestOffsetPending) {
            const widget = controller.getWidget();
            const event = e.data[0];
            if (!widget.isEnabled()) {
              event.stopImmediatePropagation();
              return false;
            } else {
              //throttle events...
              if (data.requestedOffset === null) {
                data.requestedOffset = controller.getAnchorNode().attribute("offset");
              }
              const original = data.requestedOffset;

              if (this._initialTouchPos && event.touches[0]) {
                const deltaY = event.touches[0].clientY;
                const deltaX = event.touches[0].clientX;

                // If scrolling verticaly : continue, horizontaly: do nothing
                if (Math.abs(this._initialTouchPos.x - deltaX) < Math.abs(this._initialTouchPos.y - deltaY)) {
                  let delta = (window.browserInfo.isFirefox ? (53 / 3) : 1) * deltaY;

                  const size = controller.getAnchorNode().attribute("size");
                  const pageSize = Math.max(controller.getAnchorNode().attribute("pageSize"), 1);

                  const move = this._initialTouchPos.y - delta;
                  delta = Math.sign(move) * delta / 8;

                  data.requestedOffset += Math.round(delta / 16);
                  data.requestedOffset = Math.max(0, Math.min(data.requestedOffset, size - pageSize));

                  if (original !== data.requestedOffset) {
                    this._postRequest(controller, data);
                  }
                }
              }
            }
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param e
         * @private
         */
        _onTouchStart: function(controller, data, e) {
          const event = e.data[0];
          this._initialTouchPos = {
            x: event.touches[0] ? event.touches[0].clientX : 0,
            y: event.touches[0] ? event.touches[0].clientY : 0
          };
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _postRequest: function(controller, data) {
          if (!data.throttleScroll) {
            data.throttleScroll = window.setTimeout(function(controller, data) {
              this.requestOffset(controller, data);
            }.bind(this, controller, data), this._throttleTimeout);
          }
          return this;
        },

        /**
         * Ask the VM for offset
         * @param {classes.ControllerBase} controller - controller
         * @param {Object} data
         */
        requestOffset: function(controller, data) {
          const node = controller?.getAnchorNode();
          if (!node) {
            return;
          }
          const widget = controller.getWidget();
          if (!widget) {
            return;
          }

          // before requestOffset (clear current throttle timeout)
          window.clearTimeout(data.throttleScroll);
          data.throttleScroll = null;

          if (data.lateEvent) {
            this._updateScrollData(controller, data);
            data.lateEvent = null;
          }

          const oldOffset = node.attribute("offset");
          if (oldOffset !== data.requestedOffset) {
            const app = node.getApplication();

            // if a request offset already sent to VM, don't send value
            // because the value node will change when VM receive new offset
            if (!controller.requestOffsetPending) {
              controller.sendWidgetValue();
            }
            if (app.getFocusedVMNode() === node) {
              widget.setFocus();
            }

            controller.requestOffsetPending = true;
            app.scheduler.scrollVMCommand(node, data.requestedOffset);
            widget.setOffset(data.requestedOffset);
            widget.lastSentOffset = data.requestedOffset;
          }

          data.lateEvent = null;
          data.requestedOffset = null;
        },
      };
    });
  });
;

"use strict";

modulum('StartMenuPositionUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the switch of widget by controller
     * @class StartMenuPositionUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.StartMenuPositionUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.StartMenuPositionUIBehavior.prototype */ {
        __name: "StartMenuPositionUIBehavior",

        usedStyleAttributes: ["startMenuPosition"],
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const node = controller.getAnchorNode(),
            app = node?.getApplication(),
            appUI = app && app.getUI();
          if (appUI) {
            data.startMenuPositionHandle = appUI.when(context.constants.applicationEvents.startMenuPositionUpdate,
              (event, sender, windowIdRef) => this._onStartMenuPositionChanged(controller, data, event, sender, windowIdRef));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.startMenuPositionHandle) {
            data.startMenuPositionHandle();
            data.startMenuPositionHandle = null;
          }
        },
        /**
         *
         * @param controller
         * @param data
         * @param {Object} event - DOM event
         * @param sender
         * @param windowIdRef
         * @private
         */
        _onStartMenuPositionChanged: function(controller, data, event, sender, windowIdRef) {
          const app = controller.getAnchorNode().getApplication();
          const uiNode = app.uiNode();
          const startMenu = uiNode.getFirstChild('StartMenu');
          if (startMenu) {
            const windowNode = app.getNode(windowIdRef);
            if (windowNode) {
              const kind = windowNode.getStyleAttribute('startMenuPosition');
              if (kind) {
                startMenu.getController().changeWidgetKind(kind);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableClickOnContainerUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableClickOnContainerUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableClickOnContainerUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableClickOnContainerUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableClickOnContainerUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          let widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableClickOnContainer, this._onClick.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param eventData
         * @private
         */
        _onClick: function(controller, data, eventData) {
          let tableNode = controller.getAnchorNode();
          let app = tableNode.getApplication();
          let originWidgetNode = app.getFocusedVMNodeAndValue(true);

          if (originWidgetNode && originWidgetNode !== tableNode) {
            let originWidgetController = originWidgetNode.getController();

            // check if controller exists. In come case we could have a MenuAction node which doesn't have a controller
            if (originWidgetController) {
              originWidgetController.sendWidgetValue();
            }
          }

          if (tableNode.attribute('dialogType') === "DisplayArray") {
            app.scheduler.focusVMCommand(tableNode); // only set the focus on the table
            return; // Nothing to do
          }

          let tableWidget = controller.getWidget();
          let columns = tableWidget.getOrderedColumns();
          let columnIndex = eventData.data[0];
          let firstLoop = true;
          let allColumnTested = false;
          while (!allColumnTested) {
            let columnWidget = columns[columnIndex];
            let columnNode = tableNode.getChildren()[columnWidget.getColumnIndex()];
            if (columnNode.attribute('noEntry') === 1 || columnNode.attribute('active') === 0) {
              // Select Next Column
              columnIndex = firstLoop ? 0 : columnIndex + 1;
              allColumnTested = columnIndex === columns.length;
              firstLoop = false;
            } else {
              // send current value node value of the table if not already done before requesting focus change
              controller.sendWidgetValue();

              let rowIndex = tableNode.attribute("size");

              let event = new cls.VMConfigureEvent(tableNode.getId(), {
                currentColumn: columnIndex,
                currentRow: rowIndex
              });

              app.scheduler.eventVMCommand(event, columnNode);
              return;
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnDnDUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnDndUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnDndUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnDndUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnDnDUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.dndStartHandle = widget.when(gbc.constants.widgetEvents.tableDragStart, this._onTableDragStart.bind(this,
              controller,
              data));
            data.dndEndHandle = widget.when(gbc.constants.widgetEvents.tableDragEnd, this._onTableDragEnd.bind(this, controller,
              data));
            data.dndDropHandle = widget.when(gbc.constants.widgetEvents.tableDrop, this._onTableDrop.bind(this, controller, data));
            data.dndOverHandle = widget.when(gbc.constants.widgetEvents.tableDragOver, this._onTableDragOver.bind(this, controller,
              data));
            data.dndLeaveHandle = widget.when(gbc.constants.widgetEvents.tableDragLeave, this._onTableDragLeave.bind(this,
              controller,
              data));
            data.dndEnterHandle = widget.when(gbc.constants.widgetEvents.tableDragEnter, this._onTableDragEnter.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.dndStartHandle) {
            data.dndStartHandle();
            data.dndStartHandle = null;
          }
          if (data.dndEndHandle) {
            data.dndEndHandle();
            data.dndEndHandle = null;
          }
          if (data.dndDropHandle) {
            data.dndDropHandle();
            data.dndDropHandle = null;
          }
          if (data.dndOverHandle) {
            data.dndOverHandle();
            data.dndOverHandle = null;
          }
          if (data.dndLeaveHandle) {
            data.dndLeaveHandle();
            data.dndLeaveHandle = null;
          }
          if (data.dndEnterHandle) {
            data.dndEnterHandle();
            data.dndEnterHandle = null;
          }
        },

        /**
         * Get value node corresponding to index in the column
         * @param columnNode
         * @param index
         * @returns {*|classes.NodeBase}
         * @private
         */
        _getValueNode: function(columnNode, index) {
          const valueListNode = columnNode.getFirstChild("ValueList");
          return valueListNode && valueListNode.getChildren()[index];
        },

        /**
         * Handle tableDragStart event
         * @private
         */
        _onTableDragStart: function(controller, data, event, sender, index, evt) {
          const node = controller.getAnchorNode();
          context.DndService.onDragStart(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragEnd event
         * @private
         */
        _onTableDragEnd: function(controller, data) {
          context.DndService.onDragEnd();
        },

        /**
         * Handle tableDrop event
         * @private
         */
        _onTableDrop: function(controller, data, event, sender, index) {
          const node = controller.getAnchorNode();
          context.DndService.onDrop(this._getValueNode(node, index));
        },

        /**
         * Handle tableDragOver event
         * @private
         */
        _onTableDragOver: function(controller, data, event, sender, index, evt) {
          const node = controller.getAnchorNode();
          context.DndService.onDragOver(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragLeave event
         * @private
         */
        _onTableDragLeave: function(controller, data, event, sender, index, evt) {
          const node = controller.getAnchorNode();
          context.DndService.onDragLeave(node.getParentNode(), this._getValueNode(node, index), evt);
        },

        /**
         * Handle tableDragEnter event
         * @private
         */
        _onTableDragEnter: function(controller, data, event, sender, index, evt) {
          const node = controller.getAnchorNode();
          context.DndService.onDragEnter(node.getParentNode(), this._getValueNode(node, index), evt);
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnHideUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnHideUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnHideUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnHideUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnHideUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableShowHideCol, this._showHideColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Show or hide table column (send event to VM)
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt true to show the column, false to hide it, empty to toggle it
         * @private
         */
        _showHideColumn: function(controller, data, opt) {
          const node = controller.getAnchorNode();
          const widget = controller.getWidget();
          const columnIndex = widget.getColumnIndex();
          let hidden = context.constants.visibility.hiddenByUser;
          if (opt.data.length > 0 && opt.data[0] !== "toggle") {
            hidden = opt.data[0] === "show" ? context.constants.visibility.visible : context.constants.visibility.hiddenByUser;
          } else if (columnIndex > -1) {
            hidden = node.attribute('hidden') === context.constants.visibility.hiddenByUser ? context.constants.visibility.visible :
              hidden;
          }

          const event = new cls.VMConfigureEvent(node.getId(), {
            hidden: hidden
          });

          if (hidden === context.constants.visibility.visible || this._getNbColumnsVisible(node.getParentNode()) > 1) {
            node.getApplication().scheduler.eventVMCommand(event, node);

            controller.setStoredSetting("hidden", hidden === context.constants.visibility.hiddenByUser);
          }
        },

        /**
         * Returns the number of columns which are not hidden
         * @returns {number} number of visible columns
         */
        _getNbColumnsVisible: function(tableNode) {
          let nb = 0;
          const children = tableNode.getChildren();
          for (const n of children) {
            if (n._tag === "TableColumn" && n.attribute('hidden') === 0) {
              nb++;
            }
          }
          return nb;
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnOrderUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnOrderUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnOrderUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnOrderUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnOrderUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.orderHandle = widget.when(gbc.constants.widgetEvents.tableOrderColumn, this._orderColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.orderHandle) {
            data.orderHandle();
            data.orderHandle = null;
          }
        },

        /**
         * Order table column (send event to VM)
         * @private
         */
        _orderColumn: function(controller, data, opt) {

          let columnNode = controller.getAnchorNode();
          let tableNode = columnNode.getParentNode();
          let order = opt.data[0];

          controller.setStoredSetting("order", order);

          let oldTabIndex = columnNode.attribute("tabIndex");
          if (oldTabIndex === 0) {
            return; // don't change tabIndex if === 0
          }

          let tableColumns = tableNode.getChildren("TableColumn");
          const tableColumnsWithoutTabIndex = tableColumns.filter(col => col.getInitialTabIndex() === 0);

          // Search the number of col without tabIndex which are placed before the column
          let ignoreColWithoutTabIndexCount = 0;
          for (const col of tableColumnsWithoutTabIndex) {
            if (col !== columnNode) {
              let colWidget = col.getController().getWidget();
              let colOrder = colWidget.getOrder();
              if (colOrder < order) {
                ignoreColWithoutTabIndexCount++;
              }
            }
          }
          const tableColumnsWithTabIndex = tableColumns.filter(col => col.getInitialTabIndex() > 0);

          let idx = order - ignoreColWithoutTabIndexCount;
          if (idx >= tableColumnsWithTabIndex.length) {
            return; // wrong order ignore and return
          }
          let newTabIndex = tableColumnsWithTabIndex[idx].getInitialTabIndex();

          if (oldTabIndex !== newTabIndex) {
            let event = new cls.VMConfigureEvent(columnNode.getId(), {
              tabIndex: newTabIndex
            });
            columnNode.getApplication().scheduler.eventVMCommand(event, columnNode);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnResizeUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnResizeUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableColumnResizeUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableColumnResizeUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableColumnResizeUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          let widget = controller.getWidget();
          if (widget) {
            data.resizeHandle = widget.when(gbc.constants.widgetEvents.tableResizeCol, this._resizeColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.resizeHandle) {
            data.resizeHandle();
            data.resizeHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt new width of the column
         * @private
         */
        _resizeColumn: function(controller, data, opt) {

          // Save new width in stored settings
          let width = opt.data[0];
          controller.setStoredSetting("width", width);
        }
      };
    });
  });
;

"use strict";

modulum('TableFrozenUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableFrozenUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableFrozenUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableFrozenUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableFrozenUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.leftFrozenHandle = widget.when(gbc.constants.widgetEvents.tableLeftFrozen, this._leftFrozen.bind(this, controller,
              data));
            data.rightFrozenHandle = widget.when(gbc.constants.widgetEvents.tableRightFrozen, this._rightFrozen.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.leftFrozenHandle) {
            data.leftFrozenHandle();
            data.leftFrozenHandle = null;
          }
          if (data.rightFrozenHandle) {
            data.rightFrozenHandle();
            data.rightFrozenHandle = null;
          }
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt left frozen column count
         * @private
         */
        _leftFrozen: function(controller, data, opt) {

          // Save left frozen columns count in stored settings
          const count = opt.data[0];
          controller.setStoredSetting("leftFrozen", count);
        },

        /**
         *
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param opt right frozen column count
         * @private
         */
        _rightFrozen: function(controller, data, opt) {

          // Save right frozen columns count in stored settings
          const count = opt.data[0];
          controller.setStoredSetting("rightFrozen", count);
        }
      };
    });
  });
;

"use strict";

modulum('TableResetToDefaultUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableResetToDefaultUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableResetToDefaultUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableResetToDefaultUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableResetToDefaultUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableResetToDefault, this._resetToDefault.bind(this,
              controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Reset table settings
         * @private
         */
        _resetToDefault: function(controller, data, opt) {
          controller.resetStoredSetting();

          let tableNode = controller.getAnchorNode();
          let tableNodeColumns = tableNode.getChildren("TableColumn");

          let i = 0;
          for (const columnNode of tableNodeColumns) {
            let controller = columnNode.getController();
            let widget = controller.getWidget();

            // will reset order: ordering by AUI tree position
            widget.setOrder(i);

            //will reset size on each column
            widget.resetWidth();

            //will reset visible/hidden columns
            widget.emit(gbc.constants.widgetEvents.tableShowHideCol, controller.isInitiallyHidden() ? "hide" : "show");

            i++;
          }

          i = 0;
          for (const columnNode of tableNodeColumns) {
            let widget = columnNode.getController().getWidget();

            // emit tableOrderColumn to send tabIndex to VM
            // must be done after all widgets have the right order
            widget.emit(context.constants.widgetEvents.tableOrderColumn, i);
            i++;
          }

          let tableWidget = tableNode.getController().getWidget();

          //will reset sort
          tableWidget.emit(context.constants.widgetEvents.tableHeaderSort, -1);
        }
      };
    });
  });
;

"use strict";

modulum('TableSortUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TableSortUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TableSortUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TableSortUIBehavior.prototype */ {
        /** @type {string} */
        __name: "TableSortUIBehavior",
        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          let widget = controller.getWidget();
          if (widget) {
            data.clickHandle = widget.when(gbc.constants.widgetEvents.tableHeaderSort, this._sortColumn.bind(this, controller,
              data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         * Sort table column (send event to VM)
         * @private
         */
        _sortColumn: function(controller, data, opt) {
          let tableNode = controller.getAnchorNode();
          let columnIndex = opt.data[0]; // -1 means reset sort

          let sortType = "";
          if (columnIndex > -1) {
            if (columnIndex === tableNode.attribute('sortColumn')) {
              sortType = tableNode.attribute('sortType') === "asc" ? "desc" : "asc";
            } else { // if sorting a new column, always start with ascending
              sortType = "asc";
            }
          }

          let event = new cls.VMConfigureEvent(tableNode.getId(), {
            sortColumn: columnIndex,
            sortType: sortType
          });
          tableNode.getApplication().scheduler.eventVMCommand(event, tableNode);

          if (columnIndex === -1) {
            tableNode.getController().removeStoredSetting("sortColumn");
          } else {
            tableNode.getController().setStoredSetting("sortColumn", columnIndex);
          }

          if (sortType === "") {
            tableNode.getController().removeStoredSetting("sortType");
          } else {
            tableNode.getController().setStoredSetting("sortType", sortType);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TreeItemKeyExpandUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemKeyExpandUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TreeItemKeyExpandUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TreeItemKeyExpandUIBehavior.prototype */ {
        __name: "TreeItemKeyExpandUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.rightHandle = controller.getWidget().when(context.constants.widgetEvents.keyArrowRight, this._expandOrCollapse.bind(this,
              controller,
              data, 1));
            data.leftHandle = controller.getWidget().when(context.constants.widgetEvents.keyArrowLeft, this._expandOrCollapse.bind(this,
              controller,
              data,
              0));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.rightHandle) {
            data.rightHandle();
            data.rightHandle = null;
          }
          if (data.leftHandle) {
            data.leftHandle();
            data.leftHandle = null;
          }
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         * @param {number} expand
         * @param eventType
         * @param source
         * @param event
         * @private
         */
        _expandOrCollapse: function(controller, data, expand, eventType, source, event) {
          const tableNode = controller.getAnchorNode();
          const offset = tableNode.attribute('offset');
          const currentRow = tableNode.attribute('currentRow');
          const treeItemNode = tableNode.findNodeWithAttribute("TreeItem", "row", currentRow - offset);
          if (treeItemNode &&
            (expand === 1 || (source.getScrollableArea() && source.getScrollableArea().scrollLeft === 0))
          ) { // if we have previously horizontally scrolled, we need to scroll back before collapsing nodes
            let vmEvent = null;
            if (expand && (treeItemNode.attribute("expanded") === 1)) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              vmEvent = new cls.VMConfigureEvent(tableNode.getId(), {
                currentRow: treeItemNode.attribute("row") + offset + 1
              });
            } else if (!expand && (treeItemNode.attribute("expanded") === 0)) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              const parent = treeItemNode.getParentNode();
              if (parent._tag === "TreeItem") {
                vmEvent = new cls.VMConfigureEvent(tableNode.getId(), {
                  currentRow: treeItemNode.attribute("row") - (parent.getChildren().indexOf(treeItemNode) + 1) + offset
                });
              }
            } else if (treeItemNode.attribute("hasChildren")) {
              event.preventCancelableDefault(); // preventDefault avoid horizontal scroll

              vmEvent = new cls.VMConfigureEvent(treeItemNode.getId(), {
                expanded: expand
              });
            }
            if (vmEvent) {
              treeItemNode.getApplication().scheduler.eventVMCommand(vmEvent, tableNode);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TreeItemToggleUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemToggleUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.TreeItemToggleUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.TreeItemToggleUIBehavior.prototype */ {
        __name: "TreeItemToggleUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const treeViewWidget = controller.getWidget();
          if (treeViewWidget) {
            data.onClickHandle = treeViewWidget.when(context.constants.widgetEvents.toggleClick, this._toggleState.bind(this,
              controller, data));
          }

        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.onClickHandle) {
            data.onClickHandle();
            data.onClickHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @param event
         * @param sender
         * @param {number} index
         * @private
         */
        _toggleState: function(controller, data, event, sender, index) {
          const tableNode = controller.getAnchorNode();
          const treeItemNode = tableNode.findNodeWithAttribute("TreeItem", "row", index);

          if (treeItemNode.attribute('hasChildren') !== 0) {
            let expanded = treeItemNode.attribute('expanded');
            if (expanded === 0) {
              expanded = 1;
            } else {
              expanded = 0;
            }
            const vmEvent = new cls.VMConfigureEvent(treeItemNode.getId(), {
              expanded: expanded
            });
            treeItemNode.getApplication().scheduler.eventVMCommand(vmEvent, treeItemNode);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ValueChangedUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior which reacts when there are inputs on a widget
     * @class ValueChangedUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.ValueChangedUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.ValueChangedUIBehavior.prototype */ {
        __name: "ValueChangedUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.valueChangedHandle = controller.getWidget().when(context.constants.widgetEvents.valueChanged, this._onValueChanged.bind(this,
              controller, data));
          }
        },
        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.valueChangedHandle) {
            data.valueChangedHandle();
            data.valueChangedHandle = null;
          }
        },

        /**
         * Method called when the widget emits a 'valueChanged' event.
         * @param {classes.ValueContainerControllerBase} controller - widget controller
         * @param {object} data - dom event data
         * @param {object} event - dom event
         * @param {HTMLElement} sender - source element
         * @param {string} newValue - new value of the widget
         * @param {boolean} [sendValue] - if true new value must be sent to VM
         * @private
         */
        _onValueChanged: function(controller, data, event, sender, newValue, sendValue = true) {

          // 1. search if there is a dialogtouched action
          const anchorNode = controller.getAnchorNode();
          const windowNode = /** @type classes.WindowNode */ anchorNode.getAncestor("Window");
          const dialogNode = windowNode.getActiveDialog();
          let dialogTouchedNode = null;
          if (dialogNode) {
            dialogTouchedNode = dialogNode.getFirstChildWithAttribute('Action', 'name', 'dialogtouched');
          }

          // 2. if there is a dialogtouched action, execute it
          if (dialogTouchedNode && dialogTouchedNode.attribute('active') === 1) {

            anchorNode.getApplication().action.executeById(dialogTouchedNode.getId(), anchorNode, newValue);
            // The widget value is send automatically by executeById function, so no need to send it after
            sendValue = false;
          }

          // 3. send value to VM
          if (sendValue) {
            const containerNode = controller.getNodeBindings().container;
            if (!containerNode.isAttributePresent("active") || containerNode.attribute("active") === 1) {
              controller.sendWidgetCursors();
              controller.sendWidgetValue(newValue);
            }
          }

          // 4. Send Tab key if autonext
          const widget = /** @type {classes.FieldWidgetBase} */ controller.getWidget();
          if (widget.hasAutoNext() && widget.canAutoNext()) {
            controller.getAnchorNode().getApplication().keyboard.processKey("Tab");
          }
        }
      };
    });
  });
;

"use strict";

modulum('WebComponentKeyboardUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * Behavior used to delegates keyboard keydowns from webcomponents to the GBC
     * @class WebComponentKeyboardUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.WebComponentKeyboardUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.WebComponentKeyboardUIBehavior.prototype */ {
        __name: "WebComponentKeyboardUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            data.keyboardListener = widget.when(context.constants.widgetEvents.webcomponentKeyDown, this._onWebcomponentKeyDown
              .bind(
                this, controller));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.keyboardListener) {
            data.keyboardListener();
            data.keyboardListener = null;
          }
        },

        /**
         * Handler for webcomponent key down
         * @param {classes.ControllerBase} controller
         * @param {Object} event - event
         * @param {classes.EventListener} src
         * @param {KeyboardEvent} domEvent
         * @private
         */
        _onWebcomponentKeyDown: function(controller, event, src, domEvent) {
          const anchor = controller.getAnchorNode();
          const app = anchor.getApplication();
          Event.prototype.normalizeEventForGBC(domEvent);
          app.keyboard._onKeyDown(domEvent);
        }
      };
    });
  });
;

"use strict";

modulum('WindowCloseUIBehavior', ['UIBehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowCloseUIBehavior
     * @memberOf classes
     * @extends classes.UIBehaviorBase
     */
    cls.WindowCloseUIBehavior = context.oo.Singleton(cls.UIBehaviorBase, function($super) {
      return /** @lends classes.WindowCloseUIBehavior.prototype */ {
        /** @type {string} */
        __name: "WindowCloseUIBehavior",

        /**
         * @inheritDoc
         */
        _attachWidget: function(controller, data) {
          if (controller?.getWidget()) {
            data.clickHandle = controller.getWidget().when(gbc.constants.widgetEvents.close, this._windowClose.bind(this,
              controller,
              data));
          }
        },

        /**
         * @inheritDoc
         */
        _detachWidget: function(controller, data) {
          if (data.clickHandle) {
            data.clickHandle();
            data.clickHandle = null;
          }
        },

        /**
         *
         * @param controller
         * @param data
         * @private
         */
        _windowClose: function(controller, data) {
          let node = controller.getAnchorNode();
          if (node.getTag() !== "Window") {
            node = node.getAncestor("Window");
          }
          const dialog = node.getActiveDialog();
          if (dialog) {
            const closeActionNodes = dialog.getChildrenWithAttribute(null, "name", "close");
            if (closeActionNodes && closeActionNodes.length > 0) {
              const closeActionNode = closeActionNodes[0];
              controller.getAnchorNode().getApplication().action.execute(closeActionNode.getId());
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('UIBehaviorBase', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UIBehaviorBase
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UIBehaviorBase = context.oo.Class(cls.BehaviorBase, function($super) {
      return /** @lends classes.UIBehaviorBase.prototype */ {
        __name: "UIBehaviorBase",
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {}
      };
    });
  });
;

"use strict";

modulum('ActionDefaultAcceleratorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class ActionDefaultAcceleratorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionDefaultAcceleratorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ActionDefaultAcceleratorVMBehavior.prototype */ {
        __name: "ActionDefaultAcceleratorVMBehavior",

        watchedAttributes: {
          anchor: ['acceleratorName', 'acceleratorName2', 'acceleratorName3', 'acceleratorName4']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();

          // register action default
          const app = bindings.anchor.getApplication();
          if (app) {
            const actionService = app.getActionApplicationService();
            if (actionService) {
              actionService.destroyActionDefault(bindings.anchor);
              actionService.registerActionDefault(bindings.anchor);
            }
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          const anchorNode = controller.getAnchorNode();
          const actionService = anchorNode.getApplication().getActionApplicationService();
          actionService.destroyActionDefault(anchorNode);
        }
      };
    });
  });
;

"use strict";

modulum('ActionEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class ActionEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ActionEnabledVMBehavior.prototype */ {
        __name: "ActionEnabledVMBehavior",

        watchedAttributes: {
          anchor: ['active'],
          parent: ['active']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const activeValue = bindings.anchor.attribute('active');
          const parentActiveValue = bindings.parent.attribute('active');

          // enable/disable accelerators
          const appService = bindings.anchor.getApplication().getActionApplicationService();
          if (activeValue && parentActiveValue) {
            appService.registerAction(bindings.anchor);
          } else {
            appService.destroyAction(bindings.anchor);
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          const anchorNode = controller.getAnchorNode();
          const actionService = anchorNode.getApplication().getActionApplicationService();
          actionService.destroyAction(anchorNode);
        }
      };
    });
  });
;

"use strict";

modulum('ActionTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ActionTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ActionTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ActionTitleVMBehavior.prototype */ {
        __name: "ActionTitleVMBehavior",

        watchedAttributes: {
          decorator: ['comment', 'action', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setActionTitle) {
            const commentNode = controller.getNodeBindings().decorator;
            let comment = commentNode.attribute('comment');
            // TODO : see to add comment2 on FGL side to be able to display buttonedit button message without having to trick by searching in active dialog actions
            const actionName = commentNode.attribute('action');
            if (actionName) {
              const actionNode = commentNode.getApplication().getActionApplicationService().getActiveDialogAction(actionName);
              if (actionNode) {
                comment = actionNode.attribute('comment');
              }
            }
            widget.setActionTitle(comment);
          }
        }
      };
    });
  });
;

"use strict";

modulum('AggregateVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AggregateVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AggregateVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AggregateVMBehavior.prototype */ {
        __name: "AggregateVMBehavior",

        watchedAttributes: {
          anchor: ['aggregateText', 'aggregateValue'],
          parent: ['aggregateText']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let bindings = controller.getNodeBindings();
          if (!(bindings.anchor.isAttributeSetByVM("aggregateText") ||
              bindings.anchor.isAttributeSetByVM("aggregateValue") ||
              bindings.parent.isAttributeSetByVM("aggregateText"))) {
            return;
          }
          let widget = controller.getWidget();
          if (widget?.setAggregate) {
            if (widget.getColumnIndex() === 0) {
              let globalText = bindings.parent.attribute('aggregateText');
              widget.getTableWidgetBase().setAggregateGlobalText(globalText);
            }

            let text = bindings.anchor.attribute('aggregateText');
            let value = bindings.anchor.attribute('aggregateValue');

            if (text !== "") {
              text = text + " ";
            }

            widget.setAggregate(text + value);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ApplicationImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ApplicationImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ApplicationImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ApplicationImageVMBehavior.prototype */ {
        __name: "ApplicationImageVMBehavior",

        watchedAttributes: {
          anchor: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const anchor = controller.getAnchorNode(),
            application = anchor.getApplication(),
            image = anchor.attribute('image'),
            widget = anchor.getWidget(),
            currentImage = application.getImage(),
            // If image was set but is now empty, fallback on Theme Icon
            useThemeIcon = (currentImage?.length > 0 && image.length === 0);

          application.setImage(application.wrapResourcePath(image));
          widget.setImage(application.wrapResourcePath(image));

          // Tell native part to update icon as well
          context.__wrapper.nativeCall(context.__wrapper.param({
            name: "applicationIcon",
            args: {
              "type": useThemeIcon ? "theme" : "userInterface",
              "icon": useThemeIcon ? context.ThemeService.getResource("img/gbc_logo.ico") : image,
            }
          }, application));

        }
      };
    });
  }
);
;

"use strict";

modulum('ApplicationTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ApplicationTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ApplicationTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ApplicationTitleVMBehavior.prototype */ {
        __name: "ApplicationTitleVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'text']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          const anchor = controller.getAnchorNode();
          let application = anchor.getApplication();
          const text = anchor.attribute('text');
          const name = anchor.attribute('name');
          application.setTitle(text || name);
        }
      };
    });
  });
;

"use strict";

modulum('AuiNameVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AuiNameVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AuiNameVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AuiNameVMBehavior.prototype */ {
        __name: "AuiNameVMBehavior",

        watchedAttributes: {
          anchor: ['name'],
          container: ['name']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const node = bindings.container || bindings.anchor;
          const widget = controller.getWidget();
          if (widget?.setAuiName) {
            const name = node.attribute('name') || node.attribute('tabName');
            widget.setAuiName(name);
          }
        }
      };
    });
  });
;

"use strict";

modulum('AutoScaleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class AutoScaleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.AutoScaleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.AutoScaleVMBehavior.prototype */ {
        __name: "AutoScaleVMBehavior",

        watchedAttributes: {
          decorator: ['autoScale', 'sizePolicy', 'stretch']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setAutoScale) {
            const bindings = controller.getNodeBindings();
            const node = bindings.decorator ? bindings.decorator : bindings.anchor;
            const autoScale = node.attribute('autoScale');
            const sizePolicy = node.attribute('sizePolicy');
            const hasStretch = node.isAttributeSetByVM('stretch');
            if (widget.setStretch) {
              widget.setStretch(hasStretch);
            }
            widget.setAutoScale(((sizePolicy === 'fixed' || hasStretch) && Boolean(autoScale)) || (sizePolicy === 'initial' &&
              Boolean(autoScale)));
          }
        }
      };
    });
  });
;

"use strict";

modulum('BackgroundColorMessageVMBehavior', ['BackgroundColorVMBehavior'],
  function(context, cls) {
    /**
     * @class BackgroundColorMessageVMBehavior
     * @memberOf classes
     * @extends classes.BackgroundColorVMBehavior
     */
    cls.BackgroundColorMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.BackgroundColorMessageVMBehavior.prototype */ {
        __name: "BackgroundColorMessageVMBehavior",

        watchedAttributes: {
          anchor: ['color', 'reverse', 'type']
        },

        /**
         * Applies the background color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          const messageNode = controller.getAnchorNode();
          const widget = controller.getWidget();
          if (widget) {
            widget.getElement().setAttribute("__" + widget.__name + "_type", messageNode.attribute('type'));
          }
          const isError = messageNode.attribute('type') === 'error';
          const kind = isError ? 'error' : 'message';
          const color = messageNode.getStyleAttribute("backgroundColor", [kind]);
          if (color) {
            controller.getWidget().setBackgroundColor(color);
          } else {
            if (messageNode.isAttributeSetByVM('color')) {
              cls.BackgroundColorVMBehavior._apply(controller, data);
            } else {
              if (isError) {
                widget.setBackgroundColor(context.ThemeService.getValue("theme-error-background-color"));
                widget.setColor(context.ThemeService.getValue("theme-error-color"));
              } else {
                widget.setBackgroundColor(context.ThemeService.getValue("theme-message-background-color"));
                widget.setColor(context.ThemeService.getValue("theme-message-color"));
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('BackgroundColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class BackgroundColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.BackgroundColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.BackgroundColorVMBehavior.prototype */ {
        __name: "BackgroundColorVMBehavior",

        usedStyleAttributes: ["backgroundColor"],

        watchedAttributes: {
          anchor: ['color', 'reverse'],
          decorator: ['color', 'reverse'],
          container: ['dialogType', 'currentRow', 'offset']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setBackgroundColor) {
            const bindings = controller.getNodeBindings();
            const anchorNode = bindings.anchor;
            let colorNode = anchorNode;
            let useDecoratorNode = false;

            if (bindings.container && bindings.container.getTag() === "TableColumn") {
              // in table apply bg color on table item
              widget = widget.getParentWidget();
            }

            if (bindings.decorator && !anchorNode.isAttributeSetByVM('color')) {
              colorNode = bindings.decorator;
              useDecoratorNode = true;
            }

            const isReverse = colorNode.attribute('reverse') === 1;
            let color = null;
            let bgColor = null;
            let notImportant = false;
            if (isReverse && colorNode.isAttributeSetByVM('color')) {
              color = colorNode.attribute('color');
              if (color === "white") {
                color = context.ThemeService.getValue("theme-field-disabled-background-color");
              }
              if (useDecoratorNode && bindings.container && bindings.container.getTag() === "Matrix") {
                //Cell default color (not important)
                bgColor = this._resolveThemedColor(color);
                notImportant = true;
              } else {
                bgColor = this._resolveThemedColor(color);
              }
            } else {
              color = controller.getAnchorNode().getStyleAttribute('backgroundColor');
              if (color) {
                color = color.trim();
                bgColor = this._resolveThemedColor(color);
              } else {
                bgColor = isReverse ? "lightgrey" : null;
              }
            }

            // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
            if (anchorNode.isInTable()) {
              const tableWidget = widget.getTableWidgetBase();
              const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
              if (isAnticipateScrollingEnabled) {
                const tableCachedDataModel = tableWidget.getCachedDataModel();
                tableCachedDataModel.updateDataFromValueNode(anchorNode, "backgroundColor", bgColor);

                const tableNode = anchorNode.getAncestor("Table");
                if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                  // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                  return;
                }
              }
            }

            if (widget?.setBackgroundColor) {
              widget.setBackgroundColor(bgColor, notImportant);
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          return themedColor || color;
        }
      };
    });
  });
;

"use strict";

modulum('ButtonTextHiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ButtonTextHiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ButtonTextHiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ButtonTextHiddenVMBehavior.prototype */ {
        __name: "ButtonTextHiddenVMBehavior",

        watchedAttributes: {
          anchor: ['buttonTextHidden']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setButtonTextHidden) {
            const buttonTextHidden = controller.getAnchorNode().attribute('buttonTextHidden');
            widget.setButtonTextHidden(buttonTextHidden);
          }
        }
      };
    });
  });
;

"use strict";

modulum('CanvasArcParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasArcParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasArcParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasArcParametersVMBehavior.prototype */ {
        __name: "CanvasArcParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'diameter', 'startDegrees', 'extentDegrees']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const diameter = node.attribute('diameter');
          const startDegrees = node.attribute('startDegrees');
          const extentDegrees = node.attribute('extentDegrees');

          const startAngle = (extentDegrees >= 0 ? startDegrees : startDegrees + extentDegrees) * Math.PI / 180;
          const endAngle = (extentDegrees >= 0 ? startDegrees + extentDegrees : startDegrees) * Math.PI / 180;

          const d2 = diameter / 2;
          const r = Math.abs(d2);
          const cx = startX + d2;
          const xy = startY - d2;

          const x1 = cx + r * Math.cos(startAngle);
          const y1 = cx + r * Math.sin(startAngle);
          const x2 = cx + r * Math.cos(endAngle);
          const y2 = cx + r * Math.sin(endAngle);

          const largeArcFlag = Math.abs(extentDegrees) < 180 ? 0 : 1;
          const sweepFlag = largeArcFlag === 0 ? 1 : 0;

          controller.getWidget().setParameters(startX, startY, diameter, startDegrees, extentDegrees);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasCircleParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasCircleParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasCircleParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasCircleParametersVMBehavior.prototype */ {
        __name: "CanvasCircleParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'diameter']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const diameter = node.attribute('diameter');
          const radius = diameter / 2;
          controller.getWidget().setParameters(startX + radius, startY - radius, Math.abs(radius));
        }
      };
    });
  });
;

"use strict";

modulum('CanvasFillColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasFillColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasFillColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasFillColorVMBehavior.prototype */ {
        __name: "CanvasFillColorVMBehavior",

        watchedAttributes: {
          anchor: ['fillColor']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let color = controller.getAnchorNode().attribute('fillColor');
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (themedColor) {
            color = themedColor;
          }
          controller.getWidget().setColor(color);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasLineParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasLineParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasLineParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasLineParametersVMBehavior.prototype */ {
        __name: "CanvasLineParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const endX = node.attribute('endX');
          const endY = node.attribute('endY');

          controller.getWidget().setParameters(startX, startY, endX, endY);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasOvalParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasOvalParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasOvalParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasOvalParametersVMBehavior.prototype */ {
        __name: "CanvasOvalParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const endX = node.attribute('endX');
          const endY = node.attribute('endY');

          const cx = (startX + endX) / 2;
          const cy = (startY + endY) / 2;
          const rx = Math.abs(endX - startX) / 2;
          const ry = Math.abs(endY - startY) / 2;
          controller.getWidget().setParameters(cx, cy, rx, ry);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasPolygonParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasPolygonParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasPolygonParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasPolygonParametersVMBehavior.prototype */ {
        __name: "CanvasPolygonParametersVMBehavior",

        SPACES_RE: /\s+/,

        watchedAttributes: {
          anchor: ['xyList']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const xyList = node.attribute('xyList').split(this.SPACES_RE);
          controller.getWidget().setParameters(xyList);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasRectangleParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasRectangleParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasRectangleParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasRectangleParametersVMBehavior.prototype */ {
        __name: "CanvasRectangleParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'endX', 'endY']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const endX = node.attribute('endX');
          const endY = node.attribute('endY');
          // Normalize
          const x = Math.min(startX, endX);
          const y = Math.min(startY, endY);
          const width = Math.abs(endX - startX);
          const height = Math.abs(endY - startY);
          controller.getWidget().setParameters(x, y, width, height);
        }
      };
    });
  });
;

"use strict";

modulum('CanvasTextParametersVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class CanvasTextParametersVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CanvasTextParametersVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CanvasTextParametersVMBehavior.prototype */ {
        __name: "CanvasTextParametersVMBehavior",

        watchedAttributes: {
          anchor: ['startX', 'startY', 'anchor', 'text']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const startX = node.attribute('startX');
          const startY = node.attribute('startY');
          const anchor = node.attribute('anchor');
          const text = node.attribute('text');

          const xTextAnchor = anchor.indexOf('e') !== -1 ? 'end' : anchor.indexOf('w') !== -1 ? 'start' : 'middle';
          const yTextAnchor = anchor.indexOf('s') !== -1 ? 'end' : anchor.indexOf('n') !== -1 ? 'start' : 'middle';

          const canvasWidget = controller.getWidget().getParentWidget();
          const box = canvasWidget.getLayoutInformation().getAvailable();
          let canvasWidth = box.getWidth();
          let canvasHeight = box.getHeight();
          if (typeof canvasWidth !== 'number') {
            canvasWidth = 0;
          }
          if (typeof canvasHeight !== 'number') {
            canvasHeight = 0;
          }

          controller.getWidget().setParameters(canvasWidth, canvasHeight, startX, startY, xTextAnchor, yTextAnchor, text);
        }
      };
    });
  });
;

"use strict";

modulum('CheckBoxValuesVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CheckBoxValuesVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CheckBoxValuesVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CheckBoxValuesVMBehavior.prototype */ {
        __name: "CheckBoxValuesVMBehavior",

        watchedAttributes: {
          decorator: ['valueChecked', 'valueUnchecked']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const decorator = controller.getNodeBindings().decorator;
          if (widget?.setCheckedValue) {
            const checkedValue = decorator.attribute('valueChecked');
            widget.setCheckedValue(checkedValue);
          }
          if (widget?.setUncheckedValue) {
            const uncheckedValue = decorator.attribute('valueUnchecked');
            widget.setUncheckedValue(uncheckedValue);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ClickableImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ClickableImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ClickableImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ClickableImageVMBehavior.prototype */ {
        __name: "ClickableImageVMBehavior",

        watchedAttributes: {
          decorator: ['action', "actionActive"],
          anchor: ['action', "actionActive"]
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setClickableImage) {
            const imgNode = controller.getNodeBindings().decorator || controller.getNodeBindings().anchor;
            let active = imgNode.attribute("actionActive") === 1;
            // Make image visually clickable when in scrollgrid
            if (imgNode.isInScrollGrid()) {
              active = imgNode.getParentNode().attribute("active") === 1;
            }
            if (imgNode.isAttributeSetByVM('action') && imgNode.isAttributeSetByVM('actionActive')) {
              widget.setClickableImage(imgNode.attribute("action") && active);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ColorMessageVMBehavior', ['ColorVMBehavior'],
  function(context, cls) {
    /**
     * @class ColorMessageVMBehavior
     * @memberOf classes
     * @extends classes.ColorVMBehavior
     */
    cls.ColorMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ColorMessageVMBehavior.prototype */ {
        __name: "ColorMessageVMBehavior",

        watchedAttributes: {
          anchor: ['color', 'reverse', 'type']
        },

        /**
         * Applies the color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          const messageNode = controller.getAnchorNode();
          const kind = messageNode.attribute('type') === 'error' ? 'error' : 'message';
          let color = messageNode.getStyleAttribute("textColor", [kind]);
          const widget = controller.getWidget();
          if (widget.setMessageKind) {
            widget.setMessageKind(kind);
          }

          if (color) {
            widget.setColor(color);
          } else {
            if (messageNode.isAttributeSetByVM('color')) {
              const isReverse = messageNode.attribute('reverse') === 1;

              if (messageNode.attribute('color') === "white") {
                color = context.ThemeService.getValue("theme-message-color");
              } else {
                color = isReverse ? messageNode.getStyleAttribute('textColor') : messageNode.attribute('color');
              }
              widget.setColor(this._resolveThemedColor(color));
            } else {
              widget.setColor(context.ThemeService.getValue("theme-message-color"));
            }
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;

"use strict";

modulum('ColorVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ColorVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ColorVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ColorVMBehavior.prototype */ {
        __name: "ColorVMBehavior",

        usedStyleAttributes: ["textColor"],

        watchedAttributes: {
          anchor: ['color', 'reverse'],
          decorator: ['color', 'reverse']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;
          let colorNode = anchorNode;
          if (bindings.decorator && !anchorNode.isAttributeSetByVM('color')) {
            colorNode = bindings.decorator;
          }

          const isReverse = colorNode.attribute('reverse') === 1;
          let color = null;
          if (!isReverse && colorNode.isAttributeSetByVM('color')) {
            color = colorNode.attribute('color');
            // Weird choice but what is white should be black if not reverse on modern UI
            if (color === 'white') {
              color = controller.getAnchorNode().getStyleAttribute('textColor');
              if (!color) {
                color = context.ThemeService.getValue("theme-secondary-color");
              }
            }
            color = this._resolveThemedColor(color);
          } else {
            color = controller.getAnchorNode().getStyleAttribute('textColor');
            if (color) {
              color = this._resolveThemedColor(color);
            }
          }

          // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
          if (anchorNode.isInTable()) {
            const tableWidget = widget.getTableWidgetBase();
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();
              tableCachedDataModel.updateDataFromValueNode(anchorNode, "textColor", color);

              const tableNode = anchorNode.getAncestor("Table");
              if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                return;
              }
            }
          }

          if (widget?.setColor) {
            widget.setColor(color);
          }
        },

        /**
         * Get defined themed color corresponding to color name passed as argument
         * @param {string} color - color name
         * @returns {string} returns the color hexadecimal code
         * @private
         */
        _resolveThemedColor: function(color) {
          const themedColor = context.ThemeService.getValue("gbc-genero-" + color);
          if (themedColor) {
            return themedColor;
          } else {
            return color;
          }
        }
      };
    });
  });
;

"use strict";

modulum('CompleterVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the completer items
     * @class CompleterVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CompleterVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CompleterVMBehavior.prototype */ {
        __name: "CompleterVMBehavior",

        watchedAttributes: {
          anchor: ['value']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const completerNode = controller.getNodeBindings().completer;
          const anchorNode = controller.getAnchorNode();
          const focusedNode = anchorNode.getApplication().getFocusedVMNodeAndValue(true);
          const hasFocus = focusedNode === anchorNode;
          if (completerNode && widget) { // only display completer if widget has focus and has completer
            if (widget.addCompleterWidget) {
              widget.addCompleterWidget();
            }

            if (hasFocus) {
              let completerWidget = null;
              if (widget.getCompleterWidget) {
                completerWidget = widget.getCompleterWidget();
              }

              if (completerWidget) {

                const children = completerNode.getChildren();
                const size = completerNode.attribute("size");
                completerWidget.clearChoices();
                completerWidget.setSize(size);

                for (let i = 0; i < size; i++) {
                  completerWidget.addChoice(children[i].attribute("text"));
                }

                if (size > 0) {
                  completerWidget.showDropDown();
                } else {
                  completerWidget.hideDropDown();
                }
              }
            }
          }
        },

        /**
         * @inheritDoc
         * @protected
         */
        _attach: function(controller, data) {
          const decoratorNode = controller.getNodeBindings().decorator;

          //on new Item node
          data._onNodeCreateHandle = decoratorNode.onNodeCreated(this._onItemsCountChanged.bind(this, controller, data),
            "Item");
          data._onNodeRemoveHandle = decoratorNode.onNodeRemoved(this._onItemsCountChanged.bind(this, controller, data),
            "Item");
        },

        /**
         * Handler executed each time a node is created or removed
         * @param controller
         * @param data
         * @param event
         * @param src
         * @param node
         * @private
         */
        _onItemsCountChanged: function(controller, data, event, src, node) {
          const nodeBindings = controller.getNodeBindings();

          if (nodeBindings) {
            const completerNode = nodeBindings.completer;

            data._watchedAttributes = [{
              node: completerNode,
              attribute: 'size'
            }];
            for (const element of completerNode._children) {
              data._watchedAttributes.push({
                node: element,
                attribute: 'text'
              });
            }
            data.dirty = true;
          }

        },

        /**
         * @inheritDoc
         * @protected
         */
        _detach: function(controller, data) {
          if (data._onNodeCreateHandle) {
            data._onNodeCreateHandle();
            data._onNodeCreateHandle = null;
          }
          if (data._onNodeRemoveHandle) {
            data._onNodeRemoveHandle();
            data._onNodeRemoveHandle = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('ComponentTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ComponentTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ComponentTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ComponentTypeVMBehavior.prototype */ {
        __name: "ComponentTypeVMBehavior",

        watchedAttributes: {
          decorator: ['componentType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const decoratorNode = controller.getNodeBindings().decorator;
          const app = decoratorNode.getApplication();
          const widget = controller.getWidget();
          if (widget?.setWebComponentType) {
            const componentType = decoratorNode.attribute('componentType');
            const isApi = Boolean(componentType);
            widget.setWebComponentType(componentType ? "api" : "url");
            if (isApi) {
              // if application info has webComponent prefix, use it
              const componentUrlPart = app.info().webComponent ?
                (app.info().webComponent + "/" + componentType + "/" + componentType + ".html") :
                (componentType + "/" + componentType + ".html"),
                webcompUrl = app.wrapResourcePath(
                  componentUrlPart,
                  "webcomponents",
                  app.info().webComponent);
              widget.setUrl(webcompUrl);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('CurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CurrentRowVMBehavior.prototype */ {
        __name: "CurrentRowVMBehavior",

        watchedAttributes: {
          anchor: ['currentRow']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (!controller.getCurrentRow || !controller.getOffset) {
            return;
          }
          const widget = controller.getWidget();
          if (!widget?.setCurrentRow) {
            return;
          }

          let newCurrentRow = controller.getCurrentRow() - controller.getOffset();
          widget.setCurrentRow(newCurrentRow);
        }
      };
    });
  });
;

"use strict";

modulum('CurrentTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CurrentTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CurrentTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CurrentTitleVMBehavior.prototype */ {
        __name: "CurrentTitleVMBehavior",

        watchedAttributes: {
          ui: ['currentWindow'],
          anchor: ['name', 'text', 'image']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode(),
            app = anchorNode.getApplication(),
            session = app.getSession();
          if (app === session.getCurrentApplication() || app === session.getHostApplication() || session.isInTabbedContainerMode()) {
            const uiNode = app.getNode(0),
              uiTitle = uiNode.attributeByVM("text") || uiNode.attributeByVM("name"),
              uiImage = uiNode.attributeByVM("image"),
              windowNode = (anchorNode.getTag() === "Window" ? anchorNode : anchorNode.getAncestor("Window")) ||
              uiNode.getFirstChildWithId(uiNode.attribute("currentWindow"));
            if (windowNode) {
              const formNode = windowNode.getFirstChild("Form"),
                menuNode = windowNode.getLastChild("Menu"),
                menuStyle = menuNode && menuNode.attribute("style"),
                title = (formNode || menuStyle === "winmsg" || menuStyle === "dialog") ?
                (windowNode.attributeByVM("text") || windowNode.attributeByVM("name")) :
                (menuNode ? (menuNode.attributeByVM("text") ||
                  windowNode.attributeByVM("text") ||
                  uiNode.attributeByVM("text") ||
                  menuNode.attributeByVM("name") ||
                  windowNode.attributeByVM("name") ||
                  uiNode.attributeByVM("name")) : null),
                image = (formNode && formNode.attributeByVM("image")) ||
                (menuNode && menuNode.attributeByVM("image")) ||
                windowNode.attributeByVM("image");

              const windowWidget = windowNode.getController().getWidget();
              if (title) {
                if (windowWidget.setText) {
                  windowWidget.setText(title);
                }
              }

              const windowType = windowNode.getStyleAttribute('windowType');
              if (context.HostService.getCurrentWindowNode() === windowNode && windowType !== 'modal') {
                const tabbedPage = windowNode.getApplication().getUI().getWidget()._tabbedPage;
                if (tabbedPage) {
                  if (!windowWidget.isModal) {
                    tabbedPage.setText(title);
                    // this is typical rule which enforces to manage title icon directly here and not in widgets
                    if (image || uiImage) {
                      tabbedPage.setImage(app.wrapResourcePath(image ? image : uiImage));
                    }
                  }
                  //} else {
                  //  console.log("x");
                  //A                  context.HostService.setCurrentTitle(title);
                  // this is typical rule which enforces to manage title icon directly here and not in widgets
                  //A                  context.HostService.setCurrentIcon(app.wrapResourcePath(image ? image : uiImage));
                }
              }
            } else {
              const userInterfaceWidget = uiNode.getController().getWidget();
              if (userInterfaceWidget.setText) {
                userInterfaceWidget.setText(uiTitle);
              }
              if (userInterfaceWidget.setImage) {
                userInterfaceWidget.setImage(uiImage);
              }
              //A              context.HostService.setCurrentIcon(uiImage ? app.wrapResourcePath(uiImage) : "", true);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('CurrentWindowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CurrentWindowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CurrentWindowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CurrentWindowVMBehavior.prototype */ {
        __name: "CurrentWindowVMBehavior",

        watchedAttributes: {
          anchor: ['currentWindow']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode(),
            currentWindowId = node.attribute('currentWindow'),
            app = node?.getApplication(),
            appUI = app && app.getUI();
          if (appUI) {
            app.getSession().getNavigationManager().setLastActiveWindow(app, currentWindowId);
            appUI.setCurrentWindow(currentWindowId);
          }
        }
      };
    });
  });
;

"use strict";

modulum('CursorsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class CursorsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.CursorsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.CursorsVMBehavior.prototype */ {
        __name: "CursorsVMBehavior",

        watchedAttributes: {
          container: ['cursor', 'cursor2', 'currentRow', 'offset', 'currentColumn', 'dialogType'],
          ui: ['focus'],
          table: ['currentRow', 'currentColumn', 'offset', 'dialogType']
        },

        /**
         * Get container node
         * @param {classes.NodeBase} containerNode - basic container node
         * @returns {classes.NodeBase} returns container node
         * @private
         */
        _getMainArrayContainer: function(containerNode) {
          switch (containerNode.getTag()) {
            case 'TableColumn':
              return containerNode.getParentNode();
            case 'Matrix':
              return containerNode;
            default:
              return null;
          }
        },

        /**
         * Set cursors position to the widget input field
         * @param controller
         * @param data
         * @private
         */
        _apply: function(controller, data) {
          let widget = null;
          const anchorNode = controller.getAnchorNode();
          const containerNode = controller.getNodeBindings().container;
          const app = anchorNode.getApplication();
          const uiNode = app.uiNode();
          const focusedNodeId = uiNode.attribute('focus');

          const arrayContainer = this._getMainArrayContainer(containerNode);
          if (arrayContainer) {
            // Table or Matrix
            if (focusedNodeId === arrayContainer._id) {
              const currentRow = arrayContainer.attribute("currentRow");
              const offset = arrayContainer.attribute("offset");
              const anchorRowIndex = anchorNode.getIndex();
              if (anchorRowIndex === currentRow - offset) {
                if (arrayContainer.getTag() === "Table") { // consider also currentColumn for table
                  const currentColumn = arrayContainer.attribute("currentColumn");
                  const anchorColumnIndex = containerNode.getIndex();
                  if (anchorColumnIndex === currentColumn) {
                    widget = controller.getWidget();
                  }
                } else {
                  widget = controller.getWidget();
                }
              }
            }
          } else {
            // FormField
            if (focusedNodeId === anchorNode.getId()) {
              widget = controller.getWidget();
            }
          }

          if (widget?.hasCursors()) {

            const cursor = containerNode.attribute('cursor');
            const cursor2 = containerNode.attribute('cursor2');

            let widgetValue = "";
            let auiValue = "";
            // convert both widget and aui value as string to compare without any type conflict
            if (controller.getAuiValue && controller.getWidgetValue) { // focus on a ValueContainerBaseController
              auiValue = controller.getAuiValue();
              widgetValue = controller.getWidgetValue();
            }
            if (widget?.isEnabled() && widgetValue === auiValue) {
              if (widget?.getInputElement && document.activeElement !== widget?.getInputElement()) {
                // if cursors have been updated and focused field doesn't have dom focus anymore (can happen if user clicked somewhere else before) then we flag the next restore focus command to restore dom focus
                app.scheduler.restoreFocusCommand(true);
              }
              widget?.setCursors(cursor, cursor2);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('DateTimeValueVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Manage both value and DBDATE format.
     * @class DateTimeValueVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DateTimeValueVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DateTimeValueVMBehavior.prototype */ {
        __name: "DateTimeValueVMBehavior",

        watchedAttributes: {
          anchor: ['value'],
          container: ['varType']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) { // for label the function to change text is setValue
            const bindings = controller.getNodeBindings();
            const anchorNode = bindings.anchor;
            const type = bindings.container.attribute('varType');
            let value = anchorNode.attribute('value');
            if (type || value) {
              // true if minute not found, false otherwise
              const sec = !type || !~type.toLowerCase().indexOf("minute");

              const isConstruct = bindings.container.attribute('dialogType') === "Construct";
              let displayFormat = "";
              if (isConstruct) { // in construct, we display ISO format. No conversion is done.
                displayFormat = cls.DateTimeHelper.getISOFormat(sec);
              } else { // Use DBDATE format
                const anchorNode = controller.getAnchorNode();
                const userInterfaceNode = anchorNode.getApplication().getNode(0);
                const userInterfaceWidget = userInterfaceNode.getController().getWidget();

                const dbDate = userInterfaceWidget.getDbDateFormat();
                displayFormat = cls.DateTimeHelper.parseDbDateFormat(dbDate);
                displayFormat += (sec ? " HH:mm:ss" : " HH:mm");
              }

              if (widget.setFormat) {
                widget.setFormat(displayFormat);
              }

              if (value && !isConstruct) {
                value = cls.DateTimeHelper.toDbDateFormat(value, displayFormat);
              }

              // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
              if (anchorNode.isInTable()) {
                const tableWidget = widget.getTableWidgetBase();
                const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
                if (isAnticipateScrollingEnabled) {
                  const tableCachedDataModel = tableWidget.getCachedDataModel();
                  tableCachedDataModel.updateDataFromValueNode(anchorNode, "value", value);

                  const tableNode = anchorNode.getAncestor("Table");
                  if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                    // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                    return;
                  }
                }
              }

              if (widget.setValue) {
                widget.setValue(value, true);
              }

            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('DBDateVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DBDateVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DBDateVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DBDateVMBehavior.prototype */ {
        __name: "DBDateVMBehavior",

        watchedAttributes: {
          anchor: ['dbDate']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setDbDateFormat) {
            const anchorNode = controller.getAnchorNode();
            if (anchorNode.isAttributeSetByVM('dbDate')) {
              const dbDate = anchorNode.attribute('dbDate');
              widget.setDbDateFormat(dbDate);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('DialogTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the switch of widget by controller
     * @class DialogTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DialogTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DialogTypeVMBehavior.prototype */ {
        __name: "DialogTypeVMBehavior",

        watchedAttributes: {
          container: ['dialogType', 'active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (controller?.changeWidgetKind) {
            const containerNode = controller.getNodeBindings().container;
            const dialogType = containerNode.attribute('dialogType');
            const active = containerNode.attribute('active') === 1;
            const hasWidgetKindChanged = controller.changeWidgetKind(dialogType,
              active); // return true to force apply of next behaviors
            const widget = controller.getWidget();
            if (widget?.setDialogType && dialogType !== widget.getDialogType()) {
              widget.setDialogType(dialogType);
            }
            return hasWidgetKindChanged;
          }
          return false;
        }
      };
    });
  });
;

"use strict";

modulum('DisabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the StartMenuCommand's 'Disable' state
     * @class DisabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisabledVMBehavior.prototype */ {
        __name: "DisabledVMBehavior",

        watchedAttributes: {
          anchor: ['disabled']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setEnabled) {
            const disabled = controller.getAnchorNode().attribute('disabled');
            widget.setEnabled(!disabled);
          }
        }
      };
    });
  });
;

"use strict";

modulum('DisplayFormatVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DisplayFormatVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisplayFormatVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisplayFormatVMBehavior.prototype */ {
        __name: "DisplayFormatVMBehavior",

        watchedAttributes: {
          container: ['keyboardHint', 'varType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setDisplayFormat) {
            const containerNode = controller.getNodeBindings().container;
            if (containerNode) {
              const varType = containerNode.attribute('varType');
              if (varType) {
                widget.setDisplayFormat(varType);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('DisplayMessageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DisplayMessageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DisplayMessageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DisplayMessageVMBehavior.prototype */ {
        __name: "DisplayMessageVMBehavior",

        watchedAttributes: {
          anchor: ['count', 'hidden']
        },

        _hideHandler: null,

        /**
         * Re-applies all controller's behaviors as all messages share the same widget
         */
        _apply: function(controller, data) {
          if (!data.isApplying) {
            data.isApplying = true;
            const widget = controller.getWidget();
            controller.applyBehaviors(null, true);
            widget.setHidden(false);
            data.isApplying = false;

            const bindings = controller.getNodeBindings();
            const messageService = bindings.anchor.getApplication().message;

            // No need to keep track of this, it is executed once (last param of "when" method set to 'true')
            controller.getAnchorNode().getApplication().layout.when(context.constants.widgetEvents.afterLayout,
              function() {
                messageService.handlePositions();
              }.bind(this), true);

            if (this._hideHandler) {
              this._hideHandler();
            }
            this._hideHandler = widget.when("hide.MessageWidget", function() {
              messageService.handlePositions();
            }.bind(this));
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (this._hideHandler) {
            this._hideHandler();
            this._hideHandler = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('DndAcceptedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class DndAcceptedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.DndAcceptedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.DndAcceptedVMBehavior.prototype */ {
        __name: "DndAcceptedVMBehavior",

        watchedAttributes: {
          anchor: ['dndAccepted', 'dndIdRef']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {*} data
         */
        setup: function(controller, data) {
          data.count = 0;
        },
        /**
         *
         */
        _apply: function(controller, data) {
          const dndAccepted = controller.getAnchorNode().attribute('dndAccepted');
          // to avoid flickering, ignore first dndAccepted return by the VM just after the DragStart event
          if (data.count > 0) {
            context.DndService.dndAccepted = dndAccepted;
          } else {
            context.DndService.dndAccepted = false;
          }
          data.count++;
        }
      };
    });
  });
;

"use strict";

modulum('EnabledButtonVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's 'enabled' state
     * @class EnabledButtonVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.EnabledButtonVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.EnabledButtonVMBehavior.prototype */ {
        __name: "EnabledButtonVMBehavior",

        watchedAttributes: {
          parent: ['active'],
          anchor: ['active', 'actionActive', 'defaultView'],
          ui: ['runtimeStatus']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const anchorNode = controller.getAnchorNode();
          const uiNode = anchorNode.getApplication().uiNode();
          const parentNode = controller.getNodeBindings().parent;

          const isInterrupt = anchorNode.attribute("name") === "interrupt";
          const isProcessing = uiNode.attribute("runtimeStatus") === "processing";

          if (widget?.setEnabled) {
            let hidden = anchorNode.isAttributePresent("hidden") ? anchorNode.attribute('hidden') : false;
            let activeValue = anchorNode.attribute('active');
            if (anchorNode.getParentNode().attribute("style") === "popup") {
              hidden = !activeValue;
            }

            if (anchorNode.isAttributePresent('actionActive')) {
              activeValue = activeValue || anchorNode.attribute('actionActive');
            }

            // When chromeBar theme is on, it changes some visibility behavior
            if (controller.isInChromeBar()) {
              const formNode = anchorNode.getAncestor("Form");
              if (formNode && formNode.attribute('hidden') === 1) {
                hidden = true;
              } else {
                const windowNode = anchorNode.getAncestor("Window");
                if (windowNode && !windowNode.isCurrentWindowNode()) {
                  // Do not display actions of a window that is not the current one
                  hidden = 1;
                }

                if (parentNode.isAttributePresent('active')) {
                  hidden = hidden ? hidden : parentNode.attribute("active") === 0;
                }
                if (anchorNode.isAttributePresent('defaultView')) {
                  hidden = hidden ? hidden : anchorNode.attribute("defaultView") === "no";
                  hidden = hidden ? hidden : anchorNode.attribute("hidden") === 1;
                }
                if (window.isMobile()) {
                  // on mobile, action with context='row' should not be visible outside of rowbound
                  hidden = hidden ? hidden : anchorNode.attribute('context') === 'row';
                }
              }
            }

            let enabled = activeValue === 1;
            if (isInterrupt && !anchorNode.getApplication().action.hasAction("interrupt")) {
              enabled = isProcessing || enabled;
            }

            widget.setEnabled(enabled);

            //hide it if menu popup
            if (widget.setHidden && (hidden || controller.isInChromeBar())) {
              widget.setHidden(hidden);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('EnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's 'enabled' state
     * @class EnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.EnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.EnabledVMBehavior.prototype */ {
        __name: "EnabledVMBehavior",

        watchedAttributes: {
          anchor: ['active', 'actionActive', 'notEditable'],
          container: ['active', 'dialogType', 'noEntry']
        },

        /**
         * Sets the widget 'enabled' or  'disabled' depending on the AUI tree state.
         */
        _apply: function(controller, data) {
          let activeNode = null;
          let dialogTypeNode = null;
          let actionActiveNode = null;
          let isConstruct = false;

          const bindings = controller.getNodeBindings();
          if (bindings.container) {
            activeNode = bindings.container;
            dialogTypeNode = bindings.container;
            isConstruct = (dialogTypeNode.attribute('dialogType') === context.constants.dialogType.construct);
          } else if (bindings.anchor.isAttributePresent('active')) {
            activeNode = bindings.anchor;
          }
          if (bindings.anchor.isAttributePresent('actionActive')) {
            actionActiveNode = bindings.anchor;
          }

          const widget = controller.getWidget();
          if (widget?.setEnabled) {
            let activeValue = false;
            if (activeNode) {
              activeValue = activeNode.attribute('active');
            }
            if (actionActiveNode) {
              activeValue = activeValue || actionActiveNode.attribute('actionActive');
            }
            let enabled = activeValue === 1;

            if (dialogTypeNode) {
              const dialogTypeValue = dialogTypeNode.attribute('dialogType');
              enabled = enabled &&
                dialogTypeValue !== context.constants.dialogType.display &&
                dialogTypeValue !== context.constants.dialogType.displayArray;
            }

            if (!enabled) { //isConstruct must be applied only on enabled elements
              isConstruct = false;
            }

            const noEntry = (activeNode && !isConstruct) ? activeNode.attribute('noEntry') :
              0; // In construct ignore noEntry attribute
            const notEditable = bindings.decorator ? bindings.decorator.attribute("notEditable") : 0;
            widget.getElement().toggleClass("readonly", noEntry === 1);
            if ((!enabled || noEntry === 1) && widget.setReadOnly) {
              widget.setReadOnly(true);
            } else if (notEditable === 1 && (widget.setReadOnly || widget.setNotEditable)) {
              if (widget.setNotEditable) {
                widget.setNotEditable(true);
                if (window.isMobile()) {
                  widget.setReadOnly(true);
                }
              } else {
                widget.setReadOnly(true);
              }
            } else {
              if (widget.setReadOnly) {
                widget.setReadOnly(false);
              }
            }
            if (enabled !== widget.isEnabled()) {
              widget.setEnabled(enabled); // note that a noentry field is inactive
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('FieldButtonEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handles the enabled / disabled state of a button included in a field (ex. ButtonEdit)
     * @class FieldButtonEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FieldButtonEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FieldButtonEnabledVMBehavior.prototype */ {
        __name: "FieldButtonEnabledVMBehavior",

        watchedAttributes: {
          container: ['active'],
          decorator: ['actionActive']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setButtonEnabled) {
            const bindings = controller.getNodeBindings();
            const isEnabled = bindings.container.attribute('active') === 1 &&
              bindings.decorator.attribute('actionActive') === 1;
            widget.setButtonEnabled(isEnabled);
          }
        }
      };
    });
  });
;

"use strict";

modulum('FlippedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FlippedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FlippedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FlippedVMBehavior.prototype */ {
        __name: "FlippedVMBehavior",

        watchedAttributes: {
          anchor: ['flipped']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setViewType && !widget.isTreeView()) {
            let flipped = controller.getNodeBindings().anchor.attribute('flipped') === 1;
            widget.setViewType(flipped ? "flipped" : "classic", true);
          }
        }
      };
    });
  });
;

"use strict";

modulum('FocusOnFieldVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FocusOnFieldVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FocusOnFieldVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FocusOnFieldVMBehavior.prototype */ {
        __name: "FocusOnFieldVMBehavior",

        watchedAttributes: {
          anchor: ['focusOnField']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFocusOnField) {
            const focusOnField = (controller.getAnchorNode().attribute('focusOnField') === 1);
            widget.setFocusOnField(focusOnField);
          }

        }
      };
    });
  });
;

"use strict";

modulum('FontFamilyVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FontFamilyVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FontFamilyVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FontFamilyVMBehavior.prototype */ {
        __name: "FontFamilyVMBehavior",

        usedStyleAttributes: ['fontFamily'],

        watchedAttributes: {
          anchor: ['fontPitch'],
          decorator: ['fontPitch']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFontFamily) {
            const bindings = controller.getNodeBindings();
            let fontPitchNode = null;
            if (bindings.decorator) {
              fontPitchNode = bindings.decorator;
            } else if (bindings.anchor.isAttributePresent('fontPitch')) {
              fontPitchNode = bindings.anchor;
            }
            if (fontPitchNode && fontPitchNode.isAttributeSetByVM('fontPitch')) {
              const fontPitch = fontPitchNode.attribute('fontPitch');
              widget.setFontFamily(fontPitch === "fixed" ? context.ThemeService.getValue("html-font-family-monospace") : null);
            } else {
              const font = controller.getAnchorNode().getStyleAttribute('fontFamily');
              if (font) {
                widget.setFontFamily(font);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('FontWeightVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class FontWeightVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FontWeightVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FontWeightVMBehavior.prototype */ {
        __name: "FontWeightVMBehavior",

        watchedAttributes: {
          anchor: ['bold'],
          decorator: ['bold']
        },

        usedStyleAttributes: ["fontWeight"],

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;
          let fontWeight = null;
          let boldNode = null;
          if (bindings.anchor.isAttributeSetByVM('bold')) {
            boldNode = bindings.anchor;
          } else if (bindings.decorator?.isAttributeSetByVM('bold')) {
            boldNode = bindings.decorator;
          }

          if (boldNode) {
            fontWeight = boldNode.attribute('bold') === 1 ? "bold" : null;
          } else {
            fontWeight = controller.getAnchorNode().getStyleAttribute('fontWeight');
          }

          // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
          if (anchorNode.isInTable()) {
            const tableWidget = widget.getTableWidgetBase();
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();
              tableCachedDataModel.updateDataFromValueNode(anchorNode, "fontWeight", fontWeight);

              const tableNode = anchorNode.getAncestor("Table");
              if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                return;
              }
            }
          }

          if (widget?.setFontWeight) {
            widget.setFontWeight(fontWeight);
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('FormatVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Manage both DBDATE and Format attribute. If a Format attribute is specified it replaces DBDATE format
     * @class FormatVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FormatVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FormatVMBehavior.prototype */ {
        __name: "FormatVMBehavior",

        watchedAttributes: {
          decorator: ['format']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFormat) {
            const decoratorNode = controller.getNodeBindings().decorator;
            if (decoratorNode.isAttributeSetByVM('format') && decoratorNode.attribute('format')) {
              // BDL format convention has uppercase equivalent in web conventions
              // except for day abbreviation which has to stay lowercase
              let format = decoratorNode.attribute('format').toUpperCase();
              // day abbreviation exception
              format = format.replace(/(DDD)/g, "ddd");
              widget.setFormat(format);
            } else {
              const uiWidget = widget.getUserInterfaceWidget();
              if (uiWidget) {
                const dbDate = uiWidget.getDbDateFormat();
                const tradionalFormat = cls.DateTimeHelper.parseDbDateFormat(dbDate);
                widget.setFormat(tradionalFormat);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('FormRelatedHiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the ToolBar's visibility
     * @class FormRelatedHiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.FormRelatedHiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.FormRelatedHiddenVMBehavior.prototype */ {
        __name: "FormRelatedHiddenVMBehavior",

        watchedAttributes: {
          parent: ['hidden'],
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode();
          const formNode = anchorNode.getParentNode();
          const windowNode = formNode.getParentNode();
          const hidden = formNode.attribute('hidden');
          const visible = hidden === context.constants.visibility.visible;
          const inDisplayedWindow = windowNode === context.HostService.getCurrentWindowNode();
          const widget = controller.getWidget();
          const toolBarInVisiblePosition = anchorNode.getTag() === 'ToolBar' ?
            (widget.getPosition() !== 'none') && (anchorNode.getStyleAttribute('toolBarPosition') !== 'none') :
            true;
          widget.setHidden(!inDisplayedWindow || !(visible && toolBarInVisiblePosition));
        }
      };
    });
  });
;

"use strict";

modulum('HaveRowActionsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class HaveRowActionsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.HaveRowActionsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.HaveRowActionsVMBehavior.prototype */ {
        __name: "HaveRowActionsVMBehavior",

        watchedAttributes: {
          anchor: ['haveRowActions', 'dialogType', 'active']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();

          if (widget.setHaveRowBoundActions) {
            let node = controller.getAnchorNode();
            let dialogType = node.attribute("dialogType");

            widget.setHaveRowBoundActions(
              dialogType !== "Construct" &&
              node.attribute("active") !== 0 &&
              node.attribute("haveRowActions") === 1
            );
          }
        },
      };
    });
  });
;

"use strict";

modulum('HiddenVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's visibility
     * @class HiddenVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.HiddenVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.HiddenVMBehavior.prototype */ {
        __name: "HiddenVMBehavior",

        watchedAttributes: {
          anchor: ['hidden', 'defaultView'],
          container: ['hidden', 'pageSize', 'bufferSize']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          const bindings = controller.getNodeBindings();
          let hiddenNode = null;
          let defaultViewNode = null;
          if (bindings.container) {
            hiddenNode = bindings.container;
          } else {
            hiddenNode = bindings.anchor;
          }
          if (bindings.anchor.isAttributePresent('defaultView')) {
            defaultViewNode = bindings.anchor;
          }

          // Handle visibility in case of Matrix
          const isMatrix = hiddenNode.getTag() === "Matrix";
          if (isMatrix) {
            const valueList = hiddenNode.getFirstChild("ValueList");
            // A matrix initially set to hidden has no value list until it is shown for the first time
            if (!valueList) {
              return;
            }
            // Call scrollgrid's PagesizeVMbehavior to create controllers and widgets if needed
            const scrollGridNode = hiddenNode.getAncestor("ScrollGrid");
            if (scrollGridNode && !controller._isValueListCreationForced) {
              // flag to not re apply behaviors multiple times on each attribute change
              controller._isValueListCreationForced = true;
              const scrollGridController = scrollGridNode.getController();
              scrollGridController.applyBehaviors(null, true);
            }
            const pageSize = hiddenNode.attribute('pageSize');
            const bufferSize = hiddenNode.attribute('bufferSize');

            // Hide if Valuelist is bigger than pageSize
            if (valueList._children.indexOf(controller.getAnchorNode()) >= Math.max(pageSize, bufferSize)) {
              if (widget?.setHidden) {
                widget.setHidden(true);
                return;
              }
            }
          }

          if (widget?.setHidden) {
            const hidden = hiddenNode.attribute('hidden');
            let visible = hidden === context.constants.visibility.visible;
            const parentStyle = hiddenNode.getParentNode().attribute('style');
            if (visible && defaultViewNode && parentStyle !== "popup" && parentStyle !==
              "dialog") { // defaultView is not taken into account when in menu style is not popup and not dialog (GBC-600)
              const defaultView = defaultViewNode.attribute('defaultView');
              visible = defaultView === context.constants.viewType.showAlways;
              if (window.isMobile()) {
                // on mobile, action with context='row' should not be visible outside of rowbound
                visible = defaultViewNode.attribute('context') === 'row' ? false : visible;
              }
            }

            // Table column specific code
            const isTableColumn = hiddenNode.getTag() === "TableColumn";
            if (isTableColumn && widget.setAlwaysHidden) {
              widget.setAlwaysHidden(hidden === context.constants.visibility.hiddenByProgram);

              if (data.firstApply) {

                controller.setInitiallyHidden(hidden === context.constants.visibility.hiddenByProgram || hidden === context.constants
                  .visibility.hiddenByUser);

                // Stored settings columns
                let storedHidden = controller.getStoredSetting("hidden");
                if (storedHidden !== null && (hidden === context.constants.visibility.hiddenByUser) !== storedHidden) {
                  visible = !storedHidden;
                  // Send order to hide/show column
                  const event = new cls.VMConfigureEvent(hiddenNode.getId(), {
                    hidden: visible ? context.constants.visibility.visible : context.constants.visibility.hiddenByUser
                  });
                  hiddenNode.getApplication().dvm.onOrdersManaged(function() {
                    hiddenNode.getApplication().scheduler.eventVMCommand(event, hiddenNode);
                  }.bind(this), true);
                }
              }

            }

            widget.setHidden(!visible);

            data.firstApply = false;
          }
        }
      };
    });
  });
;

"use strict";

modulum('ImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ImageVMBehavior.prototype */ {
        __name: "ImageVMBehavior",

        watchedAttributes: {
          anchor: ['image'],
          decorator: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setImage) {
            const bindings = controller.getNodeBindings();
            let imageNode = null;
            if (bindings.decorator?.isAttributePresent('image')) {
              imageNode = bindings.decorator;
            } else {
              imageNode = bindings.anchor;
            }
            const image = imageNode.attribute('image');
            widget.setImage(imageNode.getApplication().wrapResourcePath(image));
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('IncludeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: Include (list of allowed values)
     * @class IncludeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.IncludeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.IncludeVMBehavior.prototype */ {
        __name: "IncludeVMBehavior",

        watchedAttributes: {
          container: ['include']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setAllowedValues) {
            const containerNode = controller.getNodeBindings().container;
            let include = containerNode.attribute('include');
            include = include.split("|");
            widget.setAllowedValues(include.length ? include : null);
          }
        }
      };
    });
  });
;

"use strict";

modulum('IsPasswordVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class IsPasswordVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.IsPasswordVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.IsPasswordVMBehavior.prototype */ {
        __name: "IsPasswordVMBehavior",

        watchedAttributes: {
          anchor: ['isPassword', 'active'],
          decorator: ['isPassword', 'active']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setIsPassword) {
            const bindings = controller.getNodeBindings();
            let isPasswordNode = null;
            if (bindings.anchor.isAttributeSetByVM('isPassword')) {
              isPasswordNode = bindings.anchor;
            } else {
              isPasswordNode = bindings.decorator;
            }
            const isPassword = isPasswordNode.attribute('isPassword');
            widget.setIsPassword(isPassword);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ItemVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the completer items
     * @class ItemVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ItemVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ItemVMBehavior.prototype */ {
        __name: "ItemVMBehavior",

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();

          if (widget?.setItems) {
            const children = controller.getNodeBindings().decorator.getChildren(),
              needUpdate = data.widget !== widget || (!data.lastItems || data.lastItems.length !== children.length ||
                Boolean(data.lastItems.find(function(item, i) {
                  return children[i].attribute("name") !== item.value ||
                    children[i].attribute("text") !== item.text;
                })));

            if (needUpdate) {
              data.widget = widget;
              data.lastItems = children.map(function(child) {
                return {
                  text: child.attribute("text"),
                  value: child.attribute("name"),
                  nullItem: child.attribute("name") === ""
                };
              });
              widget.setItems(data.lastItems);
            }
          }
        },

        _onItemsCountChanged: function(controller, data, event, src, node) {
          data.dirty = true;
        },

        /**
         * @inheritDoc
         * @protected
         */
        _attach: function(controller, data) {
          const decoratorNode = controller.getNodeBindings().decorator;
          //on new Item node
          data._onNodeCreateHandle = decoratorNode.onNodeCreated(this._onItemsCountChanged.bind(this, controller, data), "Item");
          data._onNodeRemoveHandle = decoratorNode.onNodeRemoved(this._onItemsCountChanged.bind(this, controller, data), "Item");
        },

        /**
         * @inheritDoc
         * @protected
         */
        _detach: function(controller, data) {
          if (data._onNodeCreateHandle) {
            data._onNodeCreateHandle();
            data._onNodeCreateHandle = null;
          }
          if (data._onNodeRemoveHandle) {
            data._onNodeRemoveHandle();
            data._onNodeRemoveHandle = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('KeyboardHintVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class KeyboardHintVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.KeyboardHintVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.KeyboardHintVMBehavior.prototype */ {
        __name: "KeyboardHintVMBehavior",

        watchedAttributes: {
          container: ['varType'],
          decorator: ['keyboardHint']
        },

        usedStyleAttributes: ["dataTypeHint"],

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setType) {
            const bindings = controller.getNodeBindings();
            let keyboardHint = null;
            const keyboardVal = bindings.decorator.attribute('keyboardHint');
            if (keyboardVal) {
              keyboardHint = keyboardVal.toLowerCase();
            }

            let varType = bindings.container.attribute('varType');

            if (varType) {
              varType = varType.toLowerCase();
            } else {
              varType = "";
            }

            if (widget.setDataTypeWithNoScroll) {
              if (varType.startsWith("varchar") || varType.startsWith("char") ||
                varType.startsWith("string") || varType.startsWith("text")) {
                widget.setDataTypeWithNoScroll(false);
              } else {
                widget.setDataTypeWithNoScroll(true);
              }
            }

            widget.setInputMode("");

            switch (keyboardHint) {
              case "email":
                widget.setType("email");
                break;
              case "number":
              case "decimal":
                widget.setType("text");
                widget.setInputMode("decimal");
                break;
              case "numeric":
                widget.setType("text");
                widget.setInputMode("numeric");
                break;
              case "phone":
                widget.setType("tel");
                break;
              case "url":
                widget.setType("url");
                break;
              case "text":
                widget.setType("text");
                break;
              case "none":
                widget.setType("text");
                widget.setInputMode("none");
                break;
              case "search":
                widget.setType("text");
                widget.setInputMode("search");
                break;
              case "default":
              default:
                widget.setType("text");

                if (varType.startsWith("integer") || varType.startsWith("boolean") ||
                  varType.startsWith("bigint") || varType.startsWith("smallint") ||
                  varType.startsWith("tinyint")) {
                  widget.setInputMode("numeric");
                } else if (varType.startsWith("decimal") || varType.startsWith("float") ||
                  varType.startsWith("money") || varType.startsWith("smallfloat")) {
                  widget.setInputMode("decimal");
                }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('LayoutInfoVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class LayoutInfoVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.LayoutInfoVMBehavior = context.oo.Singleton(cls.BehaviorBase, function() {
      return /** @lends classes.LayoutInfoVMBehavior.prototype */ {
        __name: "LayoutInfoVMBehavior",

        widgetsIgnoringSizePolicy: ["ButtonEdit", "DateEdit", "DateTimeEdit", "Edit", "ProgressBar", "Slider", "SpinEdit",
          "TextEdit", "TimeEdit"
        ],

        watchedAttributes: {
          anchor: ['width', 'gridWidth', 'height', 'gridHeight', 'posX', 'posY', 'sizePolicy', 'gridChildrenInParent',
            'minWidth', 'minHeight', 'autoScale'
          ],
          container: ['gridChildrenInParent', 'stepX', 'stepY', 'columnCount'],
          decorator: ['width', 'gridWidth', 'height', 'gridHeight', 'posX', 'posY', 'sizePolicy',
            'gridChildrenInParent',
            'minWidth', 'minHeight', 'autoScale'
          ]
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const nodeBindings = controller.getNodeBindings(),
            anchorNode = nodeBindings.anchor,
            layoutInfoNode = nodeBindings.decorator || anchorNode,
            containerNode = nodeBindings.container,
            widget = controller.getWidget(),
            layoutInformation = widget && widget.getLayoutInformation(),
            rawLayoutInformation = layoutInformation && layoutInformation.getRawInformation(),
            layoutEngine = widget && widget.getLayoutEngine();

          let doUpdate = false;

          if (rawLayoutInformation) {
            // we look if some raw info is updated
            const onChange = rawLayoutInformation.onRawLayoutInformationChanged(function() {
              doUpdate = true;
            }, true);
            if (layoutInfoNode) {
              rawLayoutInformation.setSizePolicy(layoutInfoNode.attribute('sizePolicy'));
              rawLayoutInformation.setWidth(layoutInfoNode.attribute('width'));
              rawLayoutInformation.setHeight(layoutInfoNode.attribute('height'));
              rawLayoutInformation.setGridWidth(layoutInfoNode.attribute('gridWidth'));
              rawLayoutInformation.setGridHeight(layoutInfoNode.attribute('gridHeight'));
              rawLayoutInformation.setPosX(layoutInfoNode.attribute('posX'));
              rawLayoutInformation.setPosY(layoutInfoNode.attribute('posY'));
              rawLayoutInformation.setMinWidth(layoutInfoNode.attribute('minWidth'));
              rawLayoutInformation.setMinHeight(layoutInfoNode.attribute('minHeight'));

              rawLayoutInformation.setAutoScale(layoutInfoNode.attribute('autoScale'));

              rawLayoutInformation.setWantFixedPageSize(layoutInfoNode.attribute("wantFixedPageSize"));
              rawLayoutInformation.setGridChildrenInParent(layoutInfoNode.attribute('gridChildrenInParent'));
            }
            if (containerNode) {
              rawLayoutInformation.setChildOfGridChildrenInParent(containerNode.attribute('gridChildrenInParent'));
              rawLayoutInformation.setStepX(containerNode.attribute('stepX'));
              rawLayoutInformation.setStepY(containerNode.attribute('stepY'));
              rawLayoutInformation.setColumnCount(containerNode.attribute('columnCount'));
            }
            // if nothing changed, don't forget to free the event hook
            if (!doUpdate) {
              onChange();
            }
          }

          if (layoutInformation && doUpdate) {
            doUpdate = false;
            let sizePolicy = rawLayoutInformation.getSizePolicy();
            if (this.widgetsIgnoringSizePolicy.indexOf(layoutInfoNode.getTag()) !== -1) {
              sizePolicy = "initial";
            }
            if (layoutEngine && layoutEngine.setHint) {
              let widthHint = rawLayoutInformation.getWidth();
              let heightHint = rawLayoutInformation.getHeight();
              if (sizePolicy === 'fixed') {
                if (!widthHint) {
                  widthHint = rawLayoutInformation.getGridWidth();
                }
                if (!heightHint) {
                  heightHint = rawLayoutInformation.getGridHeight();
                }
              }
              layoutEngine.setHint(widthHint, heightHint);
            }

            if (layoutInformation.setMinSizeHint) {
              const minWidthHint = rawLayoutInformation.getMinWidth();
              const minHeightHint = rawLayoutInformation.getMinHeight();
              layoutInformation.setMinSizeHint(minWidthHint, minHeightHint);
            }

            const autoscale = rawLayoutInformation.getAutoScale();
            layoutInformation.setSizePolicyMode(controller.isInMatrix() || (sizePolicy === "dynamic" && autoscale) ? "fixed" :
              sizePolicy);

            doUpdate = layoutInformation.setGridWidth(rawLayoutInformation.getGridWidth(), true) || doUpdate;
            if (widget.setCols) {
              const rawWidth = rawLayoutInformation.getWidth();
              if (!rawLayoutInformation.getGridWidth() && cls.Size.isCols(rawWidth)) {
                widget.setCols(parseInt(rawWidth, 10));
              } else {
                widget.setCols(rawLayoutInformation.getGridWidth() || 1);
              }
            }
            doUpdate = layoutInformation.setGridHeight(rawLayoutInformation.getGridHeight(), true) || doUpdate;

            const position = {
              x: rawLayoutInformation.getPosX() || 0,
              y: rawLayoutInformation.getPosY() || 0
            };
            let isInNormalScrollGrid = false;
            if (containerNode && containerNode.getTag() === "Matrix") {
              const scrollGrid = containerNode.getAncestor("ScrollGrid");
              isInNormalScrollGrid = scrollGrid === null || scrollGrid.attribute("wantFixedPageSize") !== 0;
            }
            if (containerNode && (containerNode !== anchorNode) && isInNormalScrollGrid) {
              const index = anchorNode.getParentNode()._children.indexOf(anchorNode),
                columnCount = rawLayoutInformation.getColumnCount() || 1,
                stepX = (rawLayoutInformation.getStepX() || 0),
                stepY = (rawLayoutInformation.getStepY() || 0);
              const shiftX = index % columnCount;
              const shiftY = Math.floor(index / columnCount);

              position.x += (shiftX * stepX);
              position.y += (shiftY * stepY);
            }

            doUpdate = layoutInformation.setGridX(position.x, true) || doUpdate;
            doUpdate = layoutInformation.setGridY(position.y, true) || doUpdate;

            if (layoutInfoNode.getTag() === "ScrollGrid" && rawLayoutInformation.getWantFixedPageSize() === 0) {
              layoutInformation.getStretched().setY(true);
            }

            const gridChildrenInParent = +(rawLayoutInformation.getGridChildrenInParent() || 0);
            if (widget.setGridChildrenInParent) {
              widget.setGridChildrenInParent(Boolean(gridChildrenInParent));
            }
            if (doUpdate) {
              layoutInformation.invalidateInfos();
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ListViewPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ListViewPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ListViewPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ListViewPageSizeVMBehavior.prototype */ {
        __name: "ListViewPageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['bufferSize', 'pageSize', 'size', 'dialogType']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const tableNode = controller.getAnchorNode();

          if (this._checkListViewSupport(controller, data)) {
            const bufferSize = tableNode.attribute('bufferSize');
            const tableColumns = tableNode.getChildren("TableColumn");
            const listViewWidget = controller.getWidget();
            let lineIndex;
            for (lineIndex = 0; lineIndex < bufferSize; ++lineIndex) {

              const rowWidget = cls.WidgetFactory.createWidget("ListViewRow", listViewWidget.getBuildParameters());
              listViewWidget.addChildWidget(rowWidget);

              // Add widgets for first column
              if (tableColumns.length > 0) {
                this._createControllersAndWidgets(tableColumns[0], lineIndex, listViewWidget, 0);
              }
              // Add widgets for second column
              if (tableColumns.length > 1) {
                this._createControllersAndWidgets(tableColumns[1], lineIndex, listViewWidget, 1);
              }
            }
            listViewWidget.updateHighlight();
          }
        },

        /**
         * Check if list view is supported and close app if it is not the case
         * @param controller
         * @param data
         * @private
         */
        _checkListViewSupport: function(controller, data) {
          const tableNode = controller.getAnchorNode();
          const dialogType = tableNode.attribute('dialogType');
          const isTree = tableNode.isTreeView();

          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }

          const support = (dialogType.startsWith("Display") && !isTree);
          if (!support) {
            data.animationFrameOffset = window.requestAnimationFrame(function() { // let finish the behavior works and close app after
              data.animationFrameOffset = 0;
              const currentApp = gbc.SessionService.getCurrent() && gbc.SessionService.getCurrent().getCurrentApplication();
              if (currentApp) {
                currentApp.close();
                currentApp.stop("ListView widget not supported in INPUT, INPUT ARRAY, CONSTRUCT, TREE");
              }
            }.bind(this));
          }
          return support;
        },

        _createControllersAndWidgets: function(node, lineIndex, listViewWidget, columnIndex) {
          const valueList = node.getFirstChild("ValueList");
          if (valueList) {
            const valueNode = valueList.getChildren()[lineIndex];
            let ctrl = valueNode.getController();

            if (ctrl && ctrl.getWidget()) {
              return; // if the controller and the widget are already created --> nothing to do
            }

            if (!ctrl) {
              ctrl = valueNode._createController();
              valueNode._controller = ctrl;
              ctrl.setAutoCreateWidget(false);
            }

            const widget = ctrl.createWidgetFromType("Label");
            if (widget) {
              const row = listViewWidget.getRows()[lineIndex];
              row.addChildWidget(widget);
              ctrl._attachWidget(); // attach widget to controller for UI behavior
              if (columnIndex === 1) {
                const decorator = ctrl.getNodeBindings().decorator;
                row.setHorizontalLayout(decorator.attribute("justify") === "right");
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }
        },
      };
    });
  }
);
;

"use strict";

modulum('MatrixCurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MatrixCurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MatrixCurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MatrixCurrentRowVMBehavior.prototype */ {
        __name: "MatrixCurrentRowVMBehavior",

        watchedAttributes: {
          container: ['currentRow', 'offset', 'size'],
          ui: ['focus']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const bindings = controller.getNodeBindings();
          const matrixNode = bindings.container;
          const app = matrixNode.getApplication();

          if (!widget || app.scheduler.hasPendingNavigationCommands()) {
            return;
          }

          const uiNode = app.uiNode();
          const currentRow = matrixNode.attribute("currentRow");
          const offset = matrixNode.attribute("offset");
          const size = matrixNode.attribute("size");
          const hasFocus = matrixNode.getId() === uiNode.attribute("focus");

          let addCurrentRowOnField = currentRow !== -1 && (currentRow < size && currentRow - offset === bindings.anchor.getIndex());

          let newCurrentRow = -1;
          // case of scrollgrid
          let matrixParent = matrixNode.getParentNode();
          let matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();

          // Get the parent matrix that have the setCurrentRow method
          while (matrixParent && matrixParentWidget && !matrixParentWidget.setCurrentRow) {
            matrixParent = matrixParent.getParentNode();
            matrixParentWidget = matrixParent && matrixParent.getController() && matrixParent.getController().getWidget();
          }

          // If the parent matrix does have setCurrentRow method
          if (matrixParentWidget && matrixParentWidget.setCurrentRow) {

            // if one matrix in scrollgrid has a currentRow equal to -1 --> focusOnField activated
            if (currentRow === -1 && matrixParent.attribute("active") === 1) {
              matrixParentWidget.setFocusOnField(true);
            }

            // scrollgrid
            const scrollGridCurrentRow = matrixParent.attribute('currentRow');
            const scrollGridOffset = matrixParent.attribute('offset');

            newCurrentRow = scrollGridCurrentRow - scrollGridOffset;
            matrixParentWidget.setCurrentRow(newCurrentRow);

            const isDisplayArray = (matrixNode.attribute("dialogType") === "DisplayArray");
            if (isDisplayArray && matrixParentWidget.hasFocusOnField()) {
              addCurrentRowOnField = addCurrentRowOnField && matrixParentWidget.isHighlightCurrentCell();
            } else if (!isDisplayArray) {
              if (!matrixParentWidget.isHighlightCurrentRow() || matrixParentWidget.isHighlightCurrentCell()) {
                addCurrentRowOnField = addCurrentRowOnField && hasFocus && matrixParentWidget.isHighlightCurrentCell();
              } else {
                addCurrentRowOnField = addCurrentRowOnField && !hasFocus;
              }
            }
          } else if (matrixNode.getController().updateAllSiblingMatrixCurrentRow) {
            // synchronize processed currentRow with VM currentRow
            newCurrentRow = currentRow - offset;
            matrixNode.getController().updateAllSiblingMatrixCurrentRow(newCurrentRow);
          }

          // no hightlight row for alone matrix on input
          const dialogType = matrixNode.attribute("dialogType");
          if (dialogType === 'InputArray' && !matrixNode.isInScrollGrid() && !matrixNode.isInTable()) {
            addCurrentRowOnField = false;
          }

          widget.toggleClass("currentRow", addCurrentRowOnField);

          const parentForm = matrixNode.getAncestor("Form");
          let visibleId = null;
          if (parentForm) {
            visibleId = parentForm.attribute("visibleId");
          }
          // if matrix has vm focus and no visibleId is set on its parent form, then we display it
          if (hasFocus && (!visibleId || visibleId === -1)) {
            controller.ensureVisible();
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('MaxLengthVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MaxLengthVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MaxLengthVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MaxLengthVMBehavior.prototype */ {
        __name: "MaxLengthVMBehavior",

        watchedAttributes: {
          decorator: ['maxLength', 'autoNext', 'scroll', 'width']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {

          if (controller.getWidget() instanceof cls.LabelWidget) {
            // Table display array uses Label instead of edit
            // Label is not a FieldWidgetBase, it does not support maxLength, scroll, vmWidth, autoNext
            return;
          }

          const widget = /** @type {classes.FieldWidgetBase} */ controller.getWidget();
          const decoratorNode = controller.getNodeBindings().decorator;
          widget.setScroll(decoratorNode.attribute('scroll') === 1);
          widget.setVMWidth(decoratorNode.attribute('width'));
          widget.setMaxLength(decoratorNode.attribute('maxLength'));
          widget.setAutoNext(decoratorNode.attribute('autoNext') === 1);
        }
      };
    });
  });
;

"use strict";

modulum('MenuEnabledVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class MenuEnabledVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MenuEnabledVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MenuEnabledVMBehavior.prototype */ {
        __name: "MenuEnabledVMBehavior",

        usedStyleAttributes: ["actionPanelPosition", "ringMenuPosition"],

        watchedAttributes: {
          anchor: ['active']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const thisWidget = controller.getWidget();
          if (!thisWidget) {
            return;
          }
          const anchorNode = controller.getAnchorNode();
          const isActive = anchorNode.attribute('active') === 1;

          if (thisWidget.setEnabled) {
            thisWidget.setEnabled(isActive);

            const nodeId = anchorNode.getId();
            controller.getPlaceholderControllers().forEach((controllerPlaceholder) => {
              if (isActive) {
                controllerPlaceholder.setActiveParentId(nodeId);
              } else if (nodeId === controllerPlaceholder.getWidget().getActiveParentId()) {
                controllerPlaceholder.setActiveParentId(0);
              }
            });

            const isHidden = anchorNode.attribute('hidden') === 1;
            if (isActive && !isHidden) {
              context.SessionService.getCurrent().getCurrentApplication().layout.afterLayout(function() {
                thisWidget.showModal();
              }, true);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('MessageTextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MessageTextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MessageTextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MessageTextVMBehavior.prototype */ {
        __name: "MessageTextVMBehavior",

        watchedAttributes: {
          anchor: ['text'],
          decorator: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setText) {
            const bindings = controller.getNodeBindings();
            const textNode = bindings.decorator?.isAttributeSetByVM('text') ? bindings.decorator : bindings.anchor;
            const text = textNode.attribute('text');
            widget.setText(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('MultiRowSelectionVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class MultiRowSelectionVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.MultiRowSelectionVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.MultiRowSelectionVMBehavior.prototype */ {
        __name: "MultiRowSelectionVMBehavior",

        watchedAttributes: {
          anchor: ['multiRowSelection']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const tableWidget = controller.getWidget();
          if (tableWidget && tableWidget.setMultiRowSelectionEnabled) {
            const anchorNode = controller.getAnchorNode();
            tableWidget.setMultiRowSelectionEnabled(anchorNode.attribute('multiRowSelection') !== 0);
          }
        }
      };
    });
  });
;

"use strict";

modulum('NativeScrollVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class NativeScrollVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NativeScrollVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NativeScrollVMBehavior.prototype */ {
        __name: "NativeScrollVMBehavior",

        watchedAttributes: {
          anchor: ['offset', 'size', 'pageSize', 'active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const widget = controller.getWidget();

          if (!widget?.setVerticalScroll) {
            return;
          }

          controller.requestOffsetPending = false;
          const active = node.attribute('active');
          const pageSize = node.attribute('pageSize');
          // If the container isn't active, consider it as empty.
          // The DVM doesn't set size and offset to 0 when exiting the current dialog (DISPLAY ARRAY or INPUT ARRAY)
          // This avoids the container to remain scrollable on inactive Tables and ScrollGrids
          const size = active ? node.attribute('size') : 0;
          const offset = active ? node.attribute('offset') : 0;
          const bufferSize = active ? node.attribute('bufferSize') : 0;

          /** @type {classes.RTableWidget} */
          const tableWidget = widget.getTableWidgetBase();

          if (tableWidget && !controller.isListView()) {
            // we are in a table
            if (!node.getApplication().scheduler.hasPendingScrollCommands()) {

              const tableWidgetLayout = /** @type classes.RTableLayoutEngine */ tableWidget.getLayoutEngine();

              tableWidget.setSize(size);
              tableWidget.setPageSize(pageSize);

              if (size !== null && tableWidgetLayout.isLayoutDone()) {
                node.getApplication().dvm.onOrdersManaged(function() {
                  tableWidget.setVerticalScroll(offset);
                  tableWidget.setScrolling(false, false);
                }.bind(this), true);
              }

              const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();

              const tableCachedDataModel = tableWidget.getCachedDataModel();
              if (tableCachedDataModel) {
                // flag all visible rows as VM validated to avoid future blur on them
                tableCachedDataModel.vmFlagRows(offset, bufferSize);
                node.getApplication().dvm.onOrdersManaged(function() {
                  // sync current offset of the data model with value list values (valueNodes)
                  tableCachedDataModel.syncModel(offset, bufferSize);
                  if (isAnticipateScrollingEnabled) {
                    // sync model data with table items
                    widget.applyDataFromModel(false);
                  }
                }.bind(this), true);
              }
            }
          } else if (tableWidget && controller.isListView()) {
            // listview
            tableWidget.setSize(size);
            tableWidget.setPageSize(pageSize);
            tableWidget.setVerticalScroll(offset);
          } else {
            // we are in a scroll grid
            widget.setVerticalScroll(size, pageSize, offset);
          }
        }
      };
    });
  });
;

"use strict";

modulum('NoSwipeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class NoSwipeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NoSwipeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NoSwipeVMBehavior.prototype */ {
        __name: "NoSwipeVMBehavior",

        watchedAttributes: {
          anchor: ['noswipe']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setNoSwipe) {
            const anchorNode = controller.getNodeBindings().anchor;
            widget.setNoSwipe(anchorNode.isAttributeSetByVM("noswipe") && anchorNode.attribute("noswipe") === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('NotNullVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: NotNull
     * @class NotNullVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.NotNullVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.NotNullVMBehavior.prototype */ {
        __name: "NotNullVMBehavior",

        watchedAttributes: {
          container: ['notNull']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setNotNull) {
            const containerNode = controller.getNodeBindings().container;
            const notNull = containerNode.attribute('notNull') === 1;
            widget.setNotNull(notNull);
          }
        }
      };
    });
  });
;

"use strict";

modulum('OrientationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class OrientationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.OrientationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.OrientationVMBehavior.prototype */ {
        __name: "OrientationVMBehavior",

        watchedAttributes: {
          decorator: ['orientation'],
          anchor: ['orientation']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setOrientation) {
            let decoratorNode = controller.getNodeBindings().decorator;
            let anchor = controller.getNodeBindings().anchor;
            let attrNode = decoratorNode ? decoratorNode : anchor;
            let orientation = attrNode.attribute('orientation');
            widget.setOrientation(orientation);

            if (widget.isInstanceOf(cls.SliderWidget)) {
              let node = controller.getAnchorNode();
              let layoutService = node.getApplication().layout;

              if (data._afterLayoutHandler) {
                data._afterLayoutHandler();
                data._afterLayoutHandler = null;
              }
              data._afterLayoutHandler = layoutService.afterLayout(function() {
                widget.setOrientation(orientation, true);
              }.bind(this));
            }
          }
        },

        _detach: function(controller, data) {
          if (data._afterLayoutHandler) {
            data._afterLayoutHandler();
            data._afterLayoutHandler = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('PagedScrollGridCurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class PagedScrollGridCurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PagedScrollGridCurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PagedScrollGridCurrentRowVMBehavior.prototype */ {
        __name: "PagedScrollGridCurrentRowVMBehavior",

        watchedAttributes: {
          anchor: ['currentRow']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {

          let pagedScrollGridNode = controller.getAnchorNode();
          let currentRow = pagedScrollGridNode.attribute('currentRow');
          let pageSize = pagedScrollGridNode.attribute('pageSize');
          let offset = pagedScrollGridNode.attribute('offset');

          // if VM changes the currentRow need to display the correct page by changing offset
          let newOffset = Math.floor(currentRow / pageSize) * pageSize;
          if (newOffset !== offset) {
            let offsetEventData = {
              offset: newOffset
            };
            pagedScrollGridNode.getApplication().scheduler.eventVMCommand(new cls.VMConfigureEvent(pagedScrollGridNode.getId(),
                offsetEventData),
              pagedScrollGridNode);
          }
        }
      };
    });
  });
;

"use strict";

modulum('PageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior
     * @class PageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PageSizeVMBehavior.prototype */ {
        __name: "PageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['pageSize', 'bufferSize']
        },

        /**
         * Updates pageSize
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setPageSize) {
            let anchorNode = controller.getAnchorNode();
            let pageSize = anchorNode.attribute('pageSize');
            widget.setPageSize(pageSize);

            if (widget.setBufferSize) {
              let bufferSize = anchorNode.attribute('bufferSize');
              widget.setBufferSize(bufferSize);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('PictureVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class PictureVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PictureVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PictureVMBehavior.prototype */ {
        __name: "PictureVMBehavior",

        watchedAttributes: {
          decorator: ['picture'],
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const decoratorNode = controller.getNodeBindings().decorator;
          const pictureSet = decoratorNode.isAttributeSetByVM('picture');
          const pictureString = pictureSet ? decoratorNode.attribute("picture") : null;

          if (pictureString === null || pictureString.length <= 0) {
            // Picture not defined
            return;
          }

          const widget = controller.getWidget();
          if (widget.setPicture) { // On table (display array) edits are transformed into Labels and labels has no setPicture function
            widget.setPicture(pictureString);
          }
        }
      };
    });
  });
;

"use strict";

modulum('PlaceholderVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class PlaceholderVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PlaceholderVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PlaceholderVMBehavior.prototype */ {
        __name: "PlaceholderVMBehavior",

        watchedAttributes: {
          container: ['active', 'dialogType', 'currentRow', 'offset'],
          table: ['currentRow', 'offset'],
          decorator: ['placeholder']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          let activeNode = null;

          if (widget?.setPlaceHolder) {
            const decoratorNode = controller.getNodeBindings().decorator;
            if (decoratorNode && decoratorNode.isAttributeSetByVM('placeholder')) {
              const bindings = controller.getNodeBindings();
              if (bindings.container) {
                activeNode = bindings.container;
              } else if (bindings.anchor.isAttributePresent('active')) {
                activeNode = bindings.anchor;
              }
              let placeholder = "";
              if (activeNode) {
                const activeValue = activeNode.attribute('active');
                const dialogType = bindings.container.attribute("dialogType");

                // Only enabled widget in Input, Construct or InputArray should have placeholder visible. In InputArray only current row widget does
                if (activeValue === 1 && dialogType !== "Display" && dialogType !== "DisplayArray") {
                  // only widget being in focused in current should have its placeholder visible
                  if (controller.isInTable() || controller.isInMatrix()) {
                    const container = controller.isInTable() ? bindings.table : bindings.container;
                    const currentRow = container.attribute("currentRow");
                    const offset = container.attribute("offset");
                    const size = container.attribute("size");
                    if (currentRow - offset === bindings.anchor.getIndex()) {
                      placeholder = decoratorNode.attribute('placeholder');
                    }
                  } else {
                    placeholder = decoratorNode.attribute('placeholder');
                  }
                }
              }
              widget.setPlaceHolder(placeholder);
            }
          }
        },

      };
    });
  });
;

"use strict";

modulum('PropertyVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Property
     * @class PropertyVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.PropertyVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.PropertyVMBehavior.prototype */ {
        __name: "PropertyVMBehavior",

        _attrChangedHandlers: [],
        /**
         * Updates the widget's visibility depending on the AUI tree information
         * @param {classes.WebComponentController} controller
         * @param {*} data
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setProperty) {
            const webComponentNode = controller.getNodeBindings().decorator;
            const children = webComponentNode.getChildren();
            if (children.length > 0) {
              const property = this._propertyToJson(children[0]);
              controller.bufferizeProperties(property);
            }
          }
        },

        _attach: function(controller, data) {
          const node = controller.getNodeBindings().decorator;
          data.nodeCreatedHandler = node.onNodeCreated(this._onNodeCreated.bind(this, controller, data), "Property");
          const webComponentNode = controller.getNodeBindings().decorator;
          const children = webComponentNode.getDescendants("Property");
          if (children.length > 0) {
            children.forEach(function(propChild) {
              this._attrChangedHandlers.push(propChild.onAttributeChanged("value", function(event, node, data) {
                this._apply(controller, data);
              }.bind(this)));

            }.bind(this));
          }
        },

        _detach: function(controller, data) {
          this._attrChangedHandlers.forEach(function(attrChangedHandle) {
            attrChangedHandle();
          });
          this._attrChangedHandlers.length = 0;
          if (data.nodeCreatedHandler) {
            data.nodeCreatedHandler();
            data.nodeCreatedHandler = null;
          }
        },

        _onNodeCreated: function(controller, data, event, src, node) {
          node.onNodeCreated(this._onNodeCreated.bind(this, controller, data));
          this._attrChangedHandlers.push(node.onAttributeChanged("value", function(event, node, data) {
            this._apply(controller, data);
          }.bind(this)));
          this._apply(controller, data);
        },

        /**
         * Convert PropertyDict node to JSON property
         * @param node
         * @returns {{}}
         * @private
         */
        _propertyToJson: function(node) {
          const jsonProperties = {};
          let childNode = null;
          const children = node.getChildren();
          const count = children && children.length || 0;
          for (let i = 0; i < count; i++) {
            childNode = children[i];
            if (childNode._tag === "Property") {
              jsonProperties[childNode.attribute("name")] = childNode.attribute("value");
            } else if (childNode._tag === "PropertyArray") {
              jsonProperties[childNode.attribute("name")] = this._propertyArrayToJson(childNode);
            } else if (childNode._tag === "PropertyDict") {
              jsonProperties[childNode.attribute("name")] = this._propertyToJson(childNode);
            }
          }
          return jsonProperties;
        },

        /**
         * Convert PropertyArray node to JSON property
         * @param node
         * @returns {Array}
         * @private
         */
        _propertyArrayToJson: function(node) {
          const propertyArray = [];
          let childNode = null;
          const children = node.getChildren();
          const count = children && children.length || 0;
          for (let i = 0; i < count; i++) {
            childNode = children[i];
            propertyArray.push(childNode.attribute("value"));
          }
          return propertyArray;
        }
      };
    });
  });
;

"use strict";

modulum('QAInfoVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class QAInfoVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.QAInfoVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.QAInfoVMBehavior.prototype */ {
        __name: "QAInfoVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'value'],
          container: ['name'],
          table: ['offset']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const node = bindings.container || bindings.anchor;
          const widget = controller.getWidget();
          if (widget?.setQAInfo) {
            const name = node.attribute('name') || node.attribute('tabName');
            widget.setQAInfo('name', name);
            const value = bindings.anchor.attribute('value');
            widget.setQAInfo('value', value);

            if (bindings.container && bindings.container.getTag() === 'TableColumn' &&
              bindings.anchor && bindings.anchor.getTag() === 'Value') {
              // for value in table column use value node id instead of tablecol id
              widget.setQAInfo('aui-id', bindings.anchor._id);
            } else {
              widget.setQAInfo('aui-id', node._id);
            }

            let offsetNode = null;
            if (bindings.container &&
              (bindings.container.getTag() === 'TableColumn' || bindings.container.getTag() === 'Matrix')) {
              offsetNode = bindings.container.getParentNode();
            }
            if (offsetNode) {
              const offset = offsetNode.attribute('offset') || 0;
              widget.setQAInfo('index', offset + controller.getAnchorNode().getParentNode().getChildren().indexOf(controller
                .getAnchorNode()));
            }
            const tabIndex = node.attribute('tabIndex');
            if (tabIndex) {
              widget.setQAInfo('tabindex', tabIndex);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('QueryEditableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class QueryEditableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.QueryEditableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.QueryEditableVMBehavior.prototype */ {
        __name: "QueryEditableVMBehavior",

        watchedAttributes: {
          decorator: ['queryEditable'],
          container: ['dialogType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setQueryEditable) {
            const bindings = controller.getNodeBindings();
            const dialogType = bindings.container.attribute("dialogType");

            if (dialogType === 'Construct') {
              const queryEditableNode = bindings.decorator ? bindings.decorator : bindings.anchor;
              const queryEditable = Boolean(queryEditableNode.attribute('queryEditable'));

              //Only valid on construct mode
              widget.setQueryEditable(queryEditable);
            } else {
              widget.setQueryEditable(false);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('RangeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RangeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RangeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RangeVMBehavior.prototype */ {
        __name: "RangeVMBehavior",

        watchedAttributes: {
          decorator: ['valueMin', 'valueMax', 'step']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const decoratorNode = controller.getNodeBindings().decorator;
          if (widget?.setMax) {
            const valueMax = decoratorNode.attribute('valueMax');
            widget.setMax(valueMax);
          }
          if (widget?.setMin) {
            const valueMin = decoratorNode.attribute('valueMin');
            widget.setMin(valueMin);
          }
          if (widget?.setStep) {
            const step = decoratorNode.attribute('step');
            widget.setStep(step);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RequiredVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Handle field validation: Required
     * @class RequiredVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RequiredVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RequiredVMBehavior.prototype */ {
        __name: "RequiredVMBehavior",

        watchedAttributes: {
          container: ['required']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setRequired) {
            const containerNode = controller.getNodeBindings().container;
            const required = containerNode.attribute('required') === 1;
            widget.setRequired(required);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RipGraphicTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RipGraphicTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RipGraphicTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RipGraphicTypeVMBehavior.prototype */ {
        __name: "RipGraphicTypeVMBehavior",

        watchedAttributes: {
          anchor: ['type']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          controller.getWidget().setType(controller.getAnchorNode().attribute('type'));
        }
      };
    });
  });
;

"use strict";

modulum('RowSelectedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RowSelectedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RowSelectedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RowSelectedVMBehavior.prototype */ {
        __name: "RowSelectedVMBehavior",

        watchedAttributes: {
          anchor: ['selected'],
          table: ['multiRowSelection']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;

          const tableWidget = bindings.table.getController().getWidget();
          if (tableWidget && tableWidget.setRowSelected) {

            const multiRowSelection = bindings.table.attribute('multiRowSelection');
            const selected = multiRowSelection && bindings.anchor.attribute('selected');

            // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();

              const tableOffset = bindings.table.attribute('offset');
              const rowIndex = bindings.anchor.getIndex() + tableOffset;
              tableCachedDataModel.updateRowData(rowIndex, tableOffset, "selected", selected === 1);

              const tableNode = anchorNode.getAncestor("Table");
              if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                return;
              }
            }

            tableWidget.setRowSelected(bindings.anchor.getIndex(), selected === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('RuntimeStatusVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class RuntimeStatusVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.RuntimeStatusVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.RuntimeStatusVMBehavior.prototype */ {
        __name: "RuntimeStatusVMBehavior",

        watchedAttributes: {
          anchor: ['runtimeStatus']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const uiNode = controller.getAnchorNode();
          const app = uiNode.getApplication();
          if (app) {
            const runtimeStatus = uiNode.attribute('runtimeStatus');
            if (runtimeStatus !== "childstart" && runtimeStatus !== "processing") {
              app.setIdle();
            }
            if (runtimeStatus === "childstart") {
              app.newTask();
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ScrollBarsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollBarsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ScrollBarsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ScrollBarsVMBehavior.prototype */ {
        __name: "ScrollBarsVMBehavior",

        watchedAttributes: {
          decorator: ['scrollBars']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setScrollBars) {
            const decoratorNode = controller.getNodeBindings().decorator;
            const scrollBars = decoratorNode.isAttributeSetByVM('scrollBars') ? decoratorNode.attribute('scrollBars').toLowerCase() :
              'auto';
            widget.setScrollBars(scrollBars);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ScrollVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ScrollVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ScrollVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ScrollVMBehavior.prototype */ {
        __name: "ScrollVMBehavior",

        watchedAttributes: {
          anchor: ['offset', 'size', 'pageSize']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const node = controller.getAnchorNode();
          const widget = controller.getWidget();

          if (!widget?.setPageSize || !widget?.setSize) {
            return;
          }

          controller.requestOffsetPending = false;
          const pageSize = node.attribute('pageSize');
          const size = node.attribute('size');
          const offset = node.attribute('offset');
          widget.setOffset(offset);
          widget.setSize(size);
          widget.setPageSize(pageSize);
          widget.setTotalHeight((widget.getRowHeight ? widget.getRowHeight() : widget._lineHeight) * size);
          if (widget.refreshScroll) {
            widget.refreshScroll();
          }

          if (data.onScrollHandler) {
            data.onScrollHandler();
            data.onScrollHandler = null;
          }
          const layoutService = node.getApplication().layout;

          data.onScrollHandler = layoutService.afterLayout(function() {
            widget.setPageSize(pageSize, true);
            // Beware setPageSize function change the value of widget._lineHeight !!!!
            widget.setTotalHeight((widget.getRowHeight ? widget.getRowHeight() : widget._lineHeight) * size);
            widget.setSize(size);

            // update scrollarea & scroller height & refresh scrollWidget
            if (widget.refreshScroll) {
              widget.refreshScroll();
            }
            layoutService.prepareApplyLayout(widget);

            if (data.onScrollHandler) {
              data.onScrollHandler();
              data.onScrollHandler = null;
            }
          });
        },
        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.onScrollHandler) {
            data.onScrollHandler();
            data.onScrollHandler = null;
          }
        }
      };
    });
  });
;

"use strict";

modulum('SplitterVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class SplitterVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.SplitterVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.SplitterVMBehavior.prototype */ {
        __name: "SplitterVMBehavior",

        watchedAttributes: {
          anchor: ['splitter']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.switchSplitters) {
            const activateSplitters = controller.getAnchorNode().attribute('splitter');
            const storedSettingsSplitterId = this._getIdentifier(controller);
            //Check if we force default Settings
            const forcedSettings = controller.getNodeBindings().parent.getStyleAttribute("forceDefaultSettings");
            widget.ignoreStoredSettings(forcedSettings === 1 || forcedSettings === "yes" || forcedSettings === "true");
            widget.switchSplitters(activateSplitters, storedSettingsSplitterId);
          }
        },

        /**
         * Get an unique id for a Hbox / Vbox node
         * @param controller
         * @returns {{formName:string, id:string}} identifier of the splitter (i.e: "Grid0_VBox0")
         * @private
         */
        _getIdentifier: function(controller) {
          const identifier = [];
          const bindings = controller.getNodeBindings();
          let anchor = bindings.anchor;
          let index = 0;
          let parentNode = anchor.getParentNode();
          let siblings = null;
          let formName = "";

          // Goes up in AUI tree to get position of each splitter in VBox, HBox and Grid
          while (parentNode !== null) {
            if (["VBox", "HBox", "Grid"].indexOf(anchor.getTag()) >= 0) {
              siblings = parentNode.getDescendants(anchor.getTag());
              //more than one sibling
              if (siblings.length > 1) {
                index = siblings.indexOf(anchor);
                identifier.push(anchor.getTag() + index);
              } else {
                //only one sibling
                identifier.push(anchor.getTag() + "0");
              }
            } else if (anchor.getTag() === "Form") {
              formName = anchor.attribute("name");
            }

            anchor = parentNode;
            parentNode = anchor.getParentNode();
          }
          return {
            formName: formName,
            id: identifier.reverse().join("_")
          };
        }

      };
    });
  });
;

"use strict";

modulum('SplitVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class SplitVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.SplitVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.SplitVMBehavior.prototype */ {
        __name: "SplitVMBehavior",

        watchedAttributes: {
          anchor: ['split']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.getOrientation && widget
            .setSplit) { // only horizontal boxes can be split at the moment
            const anchorNode = controller.getNodeBindings().anchor;
            widget.setSplit(anchorNode.isAttributeSetByVM("split") && anchorNode.attribute("split") === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('StackLabelVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StackLabelVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StackLabelVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StackLabelVMBehavior.prototype */ {
        __name: "StackLabelVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.getParentWidget() && widget.getParentWidget().setStackLabelText) {
            const bindings = controller.getNodeBindings();
            const textNode = bindings.anchor;
            const text = textNode.attribute('text');
            widget.getParentWidget().setStackLabelText(widget, text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('StretchableScrollGridPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StretchableScrollGridPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StretchableScrollGridPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StretchableScrollGridPageSizeVMBehavior.prototype */ {
        __name: "StretchableScrollGridPageSizeVMBehavior",

        _previousValueListsAmount: 0,

        watchedAttributes: {
          anchor: ['wantFixedPageSize', 'size', 'offset', 'pageSize', 'bufferSize']
        },
        /**
         *
         * @param controller
         * @param data
         */
        setup: function(controller, data) {
          data.linesCount = 0;
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
          }
          // This requestAnimationFrame is needed as we have to create lines only once the layout has been done
          data.animationFrameOffset = window.requestAnimationFrame(
            function() { // TODO Check if we can use LayoutApplicationService.onAfterLayout
              data.animationFrameOffset = 0;
              context.styler.bufferize();
              const scrollGridNode = controller.getAnchorNode();
              const valueListNode = scrollGridNode.getDescendants("ValueList");

              if (scrollGridNode && valueListNode.length > 0) {
                const size = scrollGridNode.attribute('size');
                const pageSize = scrollGridNode.attribute('pageSize');
                const bufferSize = scrollGridNode.attribute('bufferSize');
                const offset = scrollGridNode.attribute('offset');
                const count = Math.max(pageSize, bufferSize);
                let lineIndex;
                let lineController;
                const linesCount = controller.getLineControllersCount();

                // If a widget was initially set hidden, the matrix starts with no value list
                const hasNewValueLists = (valueListNode.length > this._previousValueListsAmount);
                if (hasNewValueLists) {
                  // Create the corresponding controllers and widgets
                  for (lineIndex = 0; lineIndex < controller.getLineControllersCount(); ++lineIndex) {
                    controller.getLineController(lineIndex).updateControllers();
                  }
                }
                if (linesCount !== count) {
                  for (lineIndex = linesCount; lineIndex < count; ++lineIndex) {
                    // Add widgets
                    lineController = new cls.ScrollGridLineController(scrollGridNode, lineIndex);
                    scrollGridNode.getController().getWidget().addChildWidget(lineController.getWidget());
                    controller.pushLineController(lineController);
                  }
                  for (lineIndex = linesCount - 1; lineIndex >= count; --lineIndex) {
                    // Remove Widgets
                    lineController = controller.popLineController();
                    lineController.destroy();
                  }
                  controller.getWidget().updateHighlight();

                  //Needed to correct updateHighlight actions
                  if (this._previousValueListsAmount === 0) {
                    const ctrl = controller.getLineController(controller.getCurrentRow() > 0 ? controller.getCurrentRow() : controller
                      .getWidget().getCurrentRow());

                    if (ctrl) {
                      ctrl._applyBehaviors();
                    }
                  }
                }

                // we need to detect cases when stretchable scrollgrid is being setuped (bufferSize, pageSize, size returned by VM) from the case where only offset is changed
                // on first launches (setuping) we need to hide images to avoid flickering but once we scroll we don't want to hide them anymore to avoid flickering as well
                // to detect stretchable setuping we listen and compare bufferSize attribute (supposed to be set at the beginning only and not during scrolls anymore
                const firstLaunch = bufferSize !== controller.getWidget().getBufferSize();
                controller.getWidget().setBufferSize(bufferSize);

                // Add the new line to the DOM but set its visibility to hidden.
                // It will be displayed in the after layout handler below.
                // This avoids flashs with SVG images during the initial render.
                for (lineIndex = 0; lineIndex < controller.getLineControllersCount(); ++lineIndex) {
                  lineController = controller.getLineController(lineIndex);
                  const hidden = offset + lineIndex >= size;
                  lineController.getWidget().setHidden(hidden);
                  // hide images when scrollgrid is building until layout is finished
                  // only do that on first setup and not anymore during scrolling to avoid image flickering by hiding/showing it very quickly
                  if (firstLaunch) {
                    lineController.getWidget().addClass('loading-line');
                  }
                }

                context.styler.flush();
                scrollGridNode.getApplication().layout.afterLayout(function(isFirstLaunch) {
                  if (controller.getWidget()) {
                    if (isFirstLaunch) {
                      for (lineIndex = 0; lineIndex < controller.getLineControllersCount(); ++lineIndex) {
                        lineController = controller.getLineController(lineIndex);
                        if (lineController) {
                          const lineWidget = lineController.getWidget();
                          if (lineWidget && lineWidget.getElement()) {
                            lineWidget.removeClass('loading-line');
                          }
                        }
                      }
                    }
                    //We must recalculate the scroll div height after gridline count update
                    if (controller.getWidget().isInstanceOf(cls.StretchableScrollGridWidget)) {
                      controller.getWidget().updateVerticalScroll(false);
                    }
                  }
                }.bind(this, firstLaunch), true);
                scrollGridNode.getApplication().scheduler.layoutCommand({
                  resize: true
                });

                this._previousValueListsAmount = valueListNode.length;
              }
            }.bind(this));
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller, data) {
          if (data.animationFrameOffset) {
            window.cancelAnimationFrame(data.animationFrameOffset);
            data.animationFrameOffset = 0;
          }
        },
      };
    });
  }
);
;

"use strict";

modulum('StretchVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StretchVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StretchVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StretchVMBehavior.prototype */ {
        __name: "StretchVMBehavior",

        onlyXStretchWidget: ["ButtonEdit", "CheckBox", "DateEdit", "DateTimeEdit", "Edit", "Label", "ProgressBar",
          "RadioGroup", "Slider", "SpinEdit", "TimeEdit"
        ],

        watchedAttributes: {
          anchor: ['stretch'],
          decorator: ['stretch', 'stretchMin', "stretchMax"],
          form: ['stretch'],
          table: ['stretchColumns']
        },

        _apply: function(controller, data) {
          let widget = controller.getWidget(),
            layoutInformation = widget && widget.getLayoutInformation(),
            rawLayoutInformation = layoutInformation && layoutInformation.getRawInformation();

          if (widget && rawLayoutInformation) {
            let bindings = controller.getNodeBindings();
            let stretchNode = bindings.decorator ? bindings.decorator : bindings.anchor;
            let stretch = stretchNode.attribute('stretch');
            let stretchMin = stretchNode.attribute('stretchMin');
            let stretchMax = stretchNode.attribute('stretchMax');
            rawLayoutInformation.setStretch(stretch);
            rawLayoutInformation.setStretchMin(stretchMin);
            rawLayoutInformation.setStretchMax(stretchMax);

            // TODO @ALTR why not using isAttributeSetByVM function, why === undefined
            // TODO "" is not a value admitted by stretch attribute...
            if (stretch === "" || stretch === undefined) {
              let stretched = layoutInformation.getStretched();
              stretched.setX(stretched.getDefaultX()); //Reset to default value
              this._calculateStretch(bindings.form, stretchNode, widget);
            } else if (stretch && widget.getLayoutInformation()) {
              layoutInformation.getStretched().setX((stretch === 'x' || stretch === 'both'));
              if (this.onlyXStretchWidget.indexOf(stretchNode.getTag()) === -1) {
                layoutInformation.getStretched().setY(stretch === 'y' || stretch === 'both');
              }
            }

            let windowWidget = widget.getWindowWidget();
            if (windowWidget) {
              windowWidget.getLayoutEngine().invalidateAllocatedSpace();
            } else {
              widget.getLayoutEngine().invalidateAllocatedSpace();
            }
          }
        },

        /**
         * Define if the widget must be automatically stretched.
         * On mobile the default layout is stretch=X
         */
        _calculateStretch: function(formNode, stretchNode, widget) {
          let layout = widget.getLayoutInformation();
          if (!layout) {
            return;
          }

          if (stretchNode.isInTable()) {
            // in a table, stretch default value is computed from stretchColumns attribute of table node
            let tableNode = stretchNode.getAncestor("Table");
            if (tableNode.isAttributeSetByVM("stretchColumns")) {
              let stretchColumns = tableNode.attribute("stretchColumns") === 1;
              // Apply stretch from table node definition
              layout.getStretched().setX(stretchColumns);
            }
            return;
          }

          if (widget instanceof cls.LabelWidget || widget instanceof cls.CheckBoxWidget ||
            widget instanceof cls.RadioGroupWidget) {
            //This widget don't take the default value from FORM or on Mobile
            return;
          }

          if (formNode && formNode.isAttributeSetByVM("stretch")) {
            let currentFormStretch = formNode.attribute("stretch");
            //Apply stretch form node definition
            layout.getStretched().setX(currentFormStretch === 'x');
            return;
          }

          if (window.isMobile()) {
            //On mobile default value is STRETCH=X
            if (this.onlyXStretchWidget.indexOf(stretchNode.getTag()) >= 0) {
              layout.getStretched().setX(true);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('StyleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class StyleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.StyleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.StyleVMBehavior.prototype */ {
        __name: "StyleVMBehavior",

        watchedAttributes: {
          anchor: ['style'],
          decorator: ['style']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const bindings = controller.getNodeBindings();
          const styleNode = bindings.decorator ? bindings.decorator : bindings.anchor;
          if (widget) {
            const style = styleNode.attribute('style');
            if (widget.getRawStyles() === style) {
              return;
            }

            if (style !== undefined) {
              widget.setApplicationStyles(style);
            }
          }

          controller.setStyleBasedBehaviorsDirty();
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnTabIndexVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnTabIndexVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableColumnTabIndexVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableColumnTabIndexVMBehavior.prototype */ {
        __name: "TableColumnTabIndexVMBehavior",

        watchedAttributes: {
          anchor: ['tabIndex']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget?.setOrder) {

            if (data.firstApply) {

              // first time we receive tabIndex we load visual index from stored settings and resent new index to VM
              let storedOrder = controller.getStoredSetting("order");
              storedOrder = storedOrder === false ? 0 : storedOrder; // TODO bug stored settings "false" means "0"
              if (storedOrder !== null && storedOrder >= 0) {
                widget.setOrder(storedOrder);

                // use request animation frame to be sure all setOrder of all columns are done
                // before send tableOrderColumn signal
                window.requestAnimationFrame(function() {
                  widget.emit(context.constants.widgetEvents.tableOrderColumn,
                    storedOrder); // Emit an event to send the col tabIndex to VM
                }.bind(this));
              }
            }
          }
          data.firstApply = false;
        }
      };
    });
  });
;

"use strict";

modulum('TableColumnTextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableColumnTextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableColumnTextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableColumnTextVMBehavior.prototype */ {
        __name: "TableColumnTextVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setTitleText) {
            const bindings = controller.getNodeBindings();
            const text = bindings.anchor.attribute('text');
            widget.setTitleText(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableCurrentVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableCurrentVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableCurrentVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableCurrentVMBehavior.prototype */ {
        __name: "TableCurrentVMBehavior",

        watchedAttributes: {
          anchor: ['currentRow', 'currentColumn', 'offset']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setCurrentRow) {
            const tableNode = controller.getAnchorNode();
            const app = tableNode.getApplication();
            const uiNode = app.uiNode();
            const currentRow = tableNode.attribute('currentRow');

            if (!app.scheduler.hasPendingNavigationCommands()) {
              const offset = tableNode.attribute('offset');
              const size = tableNode.attribute('size');
              const localCurrentRow = currentRow - offset;

              if (!app.scheduler.hasPendingScrollCommands()) {
                const ensureRowVisible = (currentRow !== data.oldCurrentRow && localCurrentRow === 0 && size > 0);
                widget.setCurrentRow(localCurrentRow, ensureRowVisible, currentRow);
              }

              if (widget.setCurrentColumn) {
                let hasChanged = false;
                const currentColumn = tableNode.attribute('currentColumn');
                if (widget.getCurrentColumn) {
                  hasChanged = currentColumn !== widget.getCurrentColumn();
                }
                widget.setCurrentColumn(currentColumn);
                // look to manually scroll to the new column if not currenty visible
                if (hasChanged) {
                  if (widget.scrollToCurrentColumn) {
                    widget.scrollToCurrentColumn();
                  }
                }
              }

              if (widget.updateCurrentItem) {
                widget.updateCurrentItem();
              }
            }

            const hasFocus = tableNode.getId() === uiNode.attribute("focus");
            const parentForm = tableNode.getAncestor("Form");
            let visibleId = null;
            if (parentForm) {
              visibleId = parentForm.attribute("visibleId");
            }
            // if table has vm focus and no visibleId is set on its parent form, then we display it
            if (hasFocus && (!visibleId || visibleId === -1)) {
              controller.ensureVisible();
            }

            // =====================================
            if (controller.updateMultiRowSelectionRoot && data.oldCurrentRow !== currentRow) {
              controller.multiRowSelectionRoot = currentRow;
            }

            controller.updateMultiRowSelectionRoot = true;
            // =====================================

            data.oldCurrentRow = currentRow;
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableDialogTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableDialogTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableDialogTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableDialogTypeVMBehavior.prototype */ {
        __name: "TableDialogTypeVMBehavior",

        watchedAttributes: {
          anchor: ['dialogType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget) {
            const dialogType = controller.getAnchorNode().attribute('dialogType');
            const isInputMode = !(dialogType === "Display" || dialogType === "DisplayArray");
            const tableWidget = widget.getTableWidgetBase();
            const tableCachedDataModel = tableWidget.getCachedDataModel();
            if (tableCachedDataModel) {
              // if we are switching from display to input or vice versa, we re-init data model
              if (tableWidget.isDisplayMode && (tableWidget.isDisplayMode() === isInputMode)) {
                tableCachedDataModel.init(tableWidget.getSize());
              }
            }

            if (widget._resetItemsSelection) {
              widget._resetItemsSelection();
            }

            if (widget.setDialogType) {
              widget.setDialogType(dialogType);
            }
            if (widget.setDndItemEnabled) {
              widget.setDndItemEnabled(dialogType === "DisplayArray");
            }

          }

        }
      };
    });
  });
;

"use strict";

modulum('TableImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableImageVMBehavior.prototype */ {
        __name: "TableImageVMBehavior",

        watchedAttributes: {
          anchor: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (!widget) {
            return;
          }
          const tableItemWidget = widget.getParentWidget();
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;

          const auiImage = anchorNode.attribute('image');
          let image = null;
          const tableColumnNode = controller.getNodeBindings().container;
          const tableNode = tableColumnNode.getParentNode();
          const isListView = tableNode.getController().isListView();
          // for list view use only first column for images
          if (!isListView || tableNode.getChildren("TableColumn").indexOf(tableColumnNode) === 0) {
            image = tableNode.getApplication().wrapResourcePath(auiImage);
          }

          // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
          if (anchorNode.isInTable()) {
            const tableWidget = widget.getTableWidgetBase();
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();
              tableCachedDataModel.updateDataFromValueNode(anchorNode, "image", image);

              const tableNode = anchorNode.getAncestor("Table");
              if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                return;
              }
            }
          }

          if (tableItemWidget && tableItemWidget.setImage && image !== null) {
            tableItemWidget.setImage(image);
          }
        }

      };
    });
  });
;

"use strict";

modulum('TableItemCurrentRowVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TableItemCurrentRowVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableItemCurrentRowVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableItemCurrentRowVMBehavior.prototype */ {
        __name: "TableItemCurrentRowVMBehavior",

        watchedAttributes: {
          table: ['currentRow', 'offset', 'dialogType', 'active']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setEnabled) {
            const tableNode = controller.getNodeBindings().table;
            const dialogType = tableNode.attribute('dialogType');

            if (dialogType === "Input" || dialogType === "Construct") {
              const currentRow = tableNode.attribute('currentRow');
              const offset = tableNode.attribute('offset');
              const itemNode = controller.getAnchorNode();
              const index = itemNode.getParentNode().getChildren().indexOf(itemNode);
              const enabled = (index === (currentRow - offset)) && (itemNode.getParentNode().getParentNode().attribute('active') ===
                1);
              widget.setEnabled(enabled);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableRowHeightVMBehavior', ['BehaviorBase'],
  /**
   * Manage "height" attribute on widgets to set table row height
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TableRowHeightVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableRowHeightVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableRowHeightVMBehavior.prototype */ {
        __name: "TableRowHeightVMBehavior",

        watchedAttributes: {
          decorator: ['height']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setRowHeight) {
            const decoratorNode = controller.getNodeBindings().decorator;
            let height = decoratorNode.attribute('height');
            if (data.savedHeight !== height && height > 1) {
              data.savedHeight = height;
              // Transform nb of characters to pixels
              const fontInfo = cls.Measurement.fontInfo(widget.getElement());
              height = cls.Measurement.measuredHeight(fontInfo["font-family"], fontInfo["font-size"], height);

              widget.setRowHeight(height);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TableSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the change of size in a table
     * @class TableSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableSizeVMBehavior.prototype */ {
        __name: "TableSizeVMBehavior",

        watchedAttributes: {
          table: ['size']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          if (controller?.changeWidgetKind) {
            const tableColumnNode = controller.getNodeBindings().container;
            const dialogType = tableColumnNode.attribute('dialogType');
            const active = tableColumnNode.attribute('active');
            const hasChanged = controller.changeWidgetKind(dialogType, active);
            const treeItem = controller.getNodeBindings().treeItem;
            if (treeItem) { // what is done here ?
              treeItem.applyBehaviors(null, true, true);
            }
            return hasChanged; // return true to force apply of next behaviors
          }
          return false;
        }
      };
    });
  });
;

"use strict";

modulum('TableSortVMBehavior', ['BehaviorBase'],
  /**
   * Manage "sortType" & "sortColumn" attribute
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TableSortVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TableSortVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TableSortVMBehavior.prototype */ {
        __name: "TableSortVMBehavior",

        watchedAttributes: {
          anchor: ['sortType', 'sortColumn']
        },

        /**
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.firstApply = true;
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setSort) {
            const tableNode = controller.getAnchorNode();

            let sortType = null;
            let sortColumn = null;

            const storedSortType = data.firstApply ? controller.getStoredSetting("sortType") : null;
            const storedSortColumn = data.firstApply ? controller.getStoredSetting("sortColumn") : null;

            if (storedSortType !== null && storedSortColumn !== null) {
              sortType = storedSortType;
              sortColumn = storedSortColumn;

              // Send stored sort values to VM
              const event = new cls.VMConfigureEvent(tableNode.getId(), {
                sortColumn: sortColumn,
                sortType: sortType
              });
              tableNode.getApplication().dvm.onOrdersManaged(function() {
                tableNode.getApplication().scheduler.eventVMCommand(event, tableNode);
              }.bind(this), true);
            } else {
              sortType = tableNode.attribute('sortType');
              sortColumn = tableNode.attribute('sortColumn');
            }

            widget.setSort(sortType, sortColumn);
          }
          data.firstApply = false;
        }
      };
    });
  });
;

"use strict";

modulum('TextActionVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Action widgets
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextActionVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextActionVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextActionVMBehavior.prototype */ {
        __name: "TextActionVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'text', 'actionIdRef', "image", "hidden"],
          decorator: ['action', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let widget = controller.getWidget();
          if (widget && (widget.setText)) {
            let anchorNode = controller.getAnchorNode();
            let actionName = anchorNode.attribute('name');
            let text = anchorNode.attribute('text');
            let isTextDefined = anchorNode.isAttributeSetByVM('text');
            let isIconDefined = anchorNode.isAttributeSetByVM('image');

            if (context.ThemeService.getValue("theme-action-name-backward-compatibility")) {
              // if there is no text defined for action
              if (!isTextDefined) {
                let chromeBarTheme = controller.isInChromeBar();
                // case where we always fall back to name when no text
                let defaultActionsTags = ["Action", "Menu", "MenuAction"];
                let forceName = chromeBarTheme || defaultActionsTags.includes(anchorNode.getTag());
                if (!isIconDefined || forceName) {
                  text = anchorNode.attribute('name');
                }
              }
            } else {
              // if no text and no icon use name as text
              if (!isTextDefined && !isIconDefined) {
                text = anchorNode.attribute('name');
              }
            }

            // for topmenu
            let accelerator = anchorNode.attribute('acceleratorName');
            if (accelerator && !window.isMobile() && widget.setComment) { // don't show accelerator on mobile devices
              widget.setComment(accelerator);
            }

            //remove first occurence of & symbol (quick shortcut not available in webclient)
            text = text ? text.toString().replace(/&(.)/g, "$1") : "";

            if (widget.setText) {
              widget.setText(text);
            }

            if (anchorNode.getTag() === "Action") {
              let contextMenuAttribute = anchorNode.attribute('contextMenu');
              let isInContextMenu = (contextMenuAttribute === 'yes' || contextMenuAttribute === 'auto');

              let contextAttribute = anchorNode.attribute('context');
              let isInRowBoundMenu = (contextAttribute === 'row');

              let hiddenAttr = anchorNode.attribute('hidden');
              const application = anchorNode.getApplication();
              let imageAttr = application.wrapResourcePath(anchorNode.attribute('image'));

              if (isInContextMenu) {
                // update contextmenu corresponding action
                let contextMenuWidget = widget.getApplicationWidget().getContextMenu();
                contextMenuWidget.updateAction(actionName, text, imageAttr, accelerator, {
                  hidden: hiddenAttr
                });
              }
              if (isInRowBoundMenu) {
                // update rowboundmenu corresponding action
                let rowBoundMenuWidget = widget.getApplicationWidget().getRowBoundMenu();
                rowBoundMenuWidget.updateAction(actionName, text, imageAttr, accelerator, {
                  hidden: hiddenAttr
                });
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextAlignVMBehavior', ['BehaviorBase'],
  function(context, cls) {

    /**
     * @class TextAlignVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextAlignVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextAlignVMBehavior.prototype */ {
        __name: "TextAlignVMBehavior",

        watchedAttributes: {
          anchor: ['numAlign'],
          container: ['numAlign'],
          decorator: ['justify']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const bindings = controller.getNodeBindings();
          const justifyNode = bindings.decorator ? bindings.decorator : bindings.anchor;
          const numAlignNode = bindings.container ? bindings.container : bindings.anchor;
          const widget = controller.getWidget();

          if (widget?.setTextAlign) {
            let textAlign = null;

            if (justifyNode.isAttributeSetByVM('justify')) {
              textAlign = justifyNode.attribute('justify');
            } else if (numAlignNode.attribute('numAlign') === 1) {
              textAlign = 'right';
            }

            widget.setTextAlign(textAlign);

          }
        }
      };
    });
  });
;

"use strict";

modulum('TextButtonVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Button
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextButtonVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextButtonVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextButtonVMBehavior.prototype */ {
        __name: "TextButtonVMBehavior",

        watchedAttributes: {
          anchor: ['text', 'name', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setText) {
            const anchorNode = controller.getAnchorNode();
            let text = anchorNode.attribute('text');
            //remove first occurence of & symbol (quick shortcut not available in webclient)
            text = text.toString().replace(/&(.)/g, "$1");
            widget.setText(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextDecorationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextDecorationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextDecorationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextDecorationVMBehavior.prototype */ {
        __name: "TextDecorationVMBehavior",

        watchedAttributes: {
          anchor: ['underline'],
          decorator: ['underline']
        },

        usedStyleAttributes: ["textDecoration"],

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const bindings = controller.getNodeBindings();
          const anchorNode = bindings.anchor;

          let underlineNode = null;
          let textDecoration = null;
          if (bindings.anchor.isAttributeSetByVM('underline')) {
            underlineNode = bindings.anchor;
          } else if (bindings.decorator) {
            if (bindings.decorator.isAttributeSetByVM('underline')) {
              underlineNode = bindings.decorator;
            }
          }
          if (underlineNode) {
            textDecoration = underlineNode.attribute('underline') === 1 ? "underline" : null;
          } else {
            textDecoration = controller.getAnchorNode().getStyleAttribute('textDecoration');
          }

          // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
          if (anchorNode.isInTable()) {
            const tableWidget = widget.getTableWidgetBase();
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();
              tableCachedDataModel.updateDataFromValueNode(anchorNode, "textDecoration", textDecoration);

              const tableNode = anchorNode.getAncestor("Table");
              if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                return;
              }
            }
          }

          if (widget?.setTextDecoration) {
            widget.setTextDecoration(textDecoration);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextEditRowsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextEditRowsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextEditRowsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextEditRowsVMBehavior.prototype */ {
        __name: "TextEditRowsVMBehavior",

        watchedAttributes: {
          decorator: ['gridHeight']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setRows) {
            const decoratorNode = controller.getNodeBindings().decorator;
            const gridHeight = decoratorNode.attribute('gridHeight');
            widget.setRows(gridHeight);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextLabelVMBehavior', ['BehaviorBase'],
  /**
   * Manage "Text" attribute only for Label widgets
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class TextLabelVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextLabelVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextLabelVMBehavior.prototype */ {
        __name: "TextLabelVMBehavior",

        watchedAttributes: {
          anchor: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setValue) { // for label the function to change text is setValue
            const textNode = controller.getAnchorNode();
            const text = textNode.attribute('text');
            widget.setValue(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextTransformVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextTransformVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextTransformVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextTransformVMBehavior.prototype */ {
        __name: "TextTransformVMBehavior",

        watchedAttributes: {
          decorator: ['shift']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setTextTransform && widget.removeTextTransform) {
            const bindings = controller.getNodeBindings();
            const shiftNode = bindings.decorator ? bindings.decorator : bindings.anchor;
            const shift = shiftNode.attribute('shift');
            widget.removeTextTransform();
            if (shift !== "none") {
              widget.setTextTransform(shift);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TextVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TextVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TextVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TextVMBehavior.prototype */ {
        __name: "TextVMBehavior",

        watchedAttributes: {
          anchor: ['text'],
          decorator: ['text']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setText) {
            const bindings = controller.getNodeBindings();
            const textNode = bindings.decorator?.isAttributeSetByVM('text') ? bindings.decorator : bindings.anchor;
            const text = textNode.attribute('text');
            widget.setText(text);
          }
        }
      };
    });
  });
;

"use strict";

modulum('TitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TitleVMBehavior.prototype */ {
        __name: "TitleVMBehavior",

        watchedAttributes: {
          anchor: ['comment', 'name', 'actionIdRef'],
          decorator: ['comment', 'actionIdRef']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (!widget) {
            return;
          }
          const bindings = controller.getNodeBindings();
          const commentNode = bindings.decorator ? bindings.decorator : bindings.anchor;
          const isDefined = commentNode.isAttributeSetByVM('comment');
          if (isDefined) {
            const text = commentNode.attribute('comment');
            widget.setTitle(text);

            /**
             * If the widget is in an array,
             * tell the column header that it should have a title too
             */
            if (widget.isInArray() && widget.getParentWidget()?.getColumnWidget) {
              // It will return a row
              widget.getParentWidget().getColumnWidget().setTitle(text);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('TraditionalFormSizingVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TraditionalFormSizingVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TraditionalFormSizingVMBehavior = context.oo.Singleton(cls.BehaviorBase, function() {
      return /** @lends classes.TraditionalFormSizingVMBehavior.prototype */ {
        __name: "TraditionalFormSizingVMBehavior",

        watchedAttributes: {
          parent: ['width', 'height', 'posX', 'posY']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const window = controller.getAnchorNode().getParentNode();
          const widget = controller.getWidget();
          const baseheight =
            parseFloat(context.ThemeService.getValue("theme-field-default-height")) +
            2 * parseFloat(context.ThemeService.getValue("theme-field-height-ratio"));
          const left = window.attribute("posX");
          const top = Math.round(window.attribute("posY") * baseheight);
          const width = window.attribute("width");
          const height = Math.round(window.attribute("height") * baseheight);
          const letterSpacing = context.ThemeService.getValue("theme-traditional-mode-letter-spacing");
          const winStyle = window.attribute("style");

          const style = {
            top: top + 'px !important',
            left: 'calc(' + left + 'ch + ' + left + ' * ' + letterSpacing + ') !important',
            'min-height': height + 'px !important',
            'min-width': 'calc(' + width + 'ch + ' + width + ' * ' + letterSpacing + ') !important'
          };

          if (winStyle !== 'dialog') {
            style.position = 'absolute';
          }

          widget.setStyle(style);
        }
      };
    });
  }
);
;

"use strict";

modulum('TreeItemDecorationVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class TreeItemDecorationVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.TreeItemDecorationVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.TreeItemDecorationVMBehavior.prototype */ {
        __name: "TreeItemDecorationVMBehavior",

        watchedAttributes: {
          anchor: ['expanded', 'hasChildren', 'row']
        },

        /**
         * Setup Behavior
         * @param {classes.ControllerBase} controller
         * @param {Object} data
         */
        setup: function(controller, data) {
          data.depth = 0;
          let n = controller.getAnchorNode().getParentNode();
          while (n && n.getTag() === 'TreeItem') {
            n = n.getParentNode();
            ++data.depth;
          }
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const treeItemNode = controller.getAnchorNode();
          const tableColumnNode = treeItemNode.getAncestor('Table').getFirstChild('TableColumn');
          const tableNode = treeItemNode.getAncestor('Table');
          tableNode.getWidget().setAriaRole("tree");

          const treeItemChildren = treeItemNode.getParentNode().getChildren();
          const row = treeItemNode.attribute('row');

          if (row !== -1) {
            const valueList = tableColumnNode.getFirstChild("ValueList");
            if (valueList) {
              const valueNode = valueList.getChildren()[row];
              if (valueNode) {
                valueNode.getController().getNodeBindings().treeItem = treeItemNode; // set treeItem binding for value node
                valueNode.getController().updateNodeBindingsIds();
                const hasChildren = treeItemNode.attribute('hasChildren') !== 0;
                const isExpanded = hasChildren && treeItemNode.attribute('expanded') !== 0;
                const tableColumnWidget = tableColumnNode.getWidget();
                const tableWidget = tableNode.getWidget();

                // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
                const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
                if (isAnticipateScrollingEnabled) {
                  const tableCachedDataModel = tableWidget.getCachedDataModel();

                  const tableOffset = tableNode.attribute('offset');
                  const rowIndex = valueNode.getIndex() + tableOffset;
                  tableCachedDataModel.updateRowData(rowIndex, tableOffset, "treeDepth", data.depth);
                  tableCachedDataModel.updateRowData(rowIndex, tableOffset, "treeLeaf", !hasChildren);
                  tableCachedDataModel.updateRowData(rowIndex, tableOffset, "treeExpanded", hasChildren && isExpanded);

                  if (valueNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                    // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                    return;
                  }
                }

                const tableItemWidget = tableColumnWidget.getItem(row);
                if (tableItemWidget) {
                  tableItemWidget.setAriaRole("treeitem");
                  tableItemWidget.setAriaAttribute("setsize", treeItemChildren.length);
                  tableItemWidget.setAriaAttribute("posinset", treeItemChildren.indexOf(treeItemNode) + 1);
                  tableItemWidget.setDepth(data.depth);
                  tableItemWidget.setLeaf(!hasChildren);
                  if (hasChildren) {
                    tableItemWidget.setAriaExpanded(isExpanded.toString());
                    tableItemWidget.setExpanded(isExpanded);
                  }
                }
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('UnhidableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnhidableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnhidableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnhidableVMBehavior.prototype */ {
        __name: "UnhidableVMBehavior",

        watchedAttributes: {
          anchor: ['unhidable'],
          parent: ['unhidableColumns']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode();
          const parentNode = anchorNode.getParentNode();

          // All table set unhidableColumn: apply on tableWidget
          const unhidableColumns = parentNode.attribute('unhidableColumns') === 1;
          if (unhidableColumns) {
            const tableWidget = parentNode.getWidget();
            if (tableWidget && tableWidget.setUnhidable) {
              tableWidget.setUnhidable(unhidableColumns);
            }
          }

          // If we reach this point, the column is unhidable
          const columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setUnhidable) {
            columnWidget.setUnhidable(anchorNode.attribute('unhidable') !== 0 || parentNode.attribute('unhidableColumns') !== 0);
          }
        }
      };
    });
  });
;

"use strict";

modulum('UnmovableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnmovableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnmovableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnmovableVMBehavior.prototype */ {
        __name: "UnmovableVMBehavior",

        watchedAttributes: {
          anchor: ['unmovable'],
          parent: ['unmovableColumns']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setMovable) {
            const anchorNode = controller.getAnchorNode();
            const parentNode = anchorNode.getParentNode();
            columnWidget.setMovable(anchorNode.attribute('unmovable') === 0 && parentNode.attribute('unmovableColumns') === 0);
          }
        }
      };
    });
  });
;

"use strict";

modulum('UnsizableVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class UnsizableVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.UnsizableVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.UnsizableVMBehavior.prototype */ {
        __name: "UnsizableVMBehavior",

        watchedAttributes: {
          anchor: ['unsizable'],
          parent: ['unsizableColumns']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const columnWidget = controller.getWidget();
          if (columnWidget && columnWidget.setSizable) {
            const anchorNode = controller.getAnchorNode();
            const parentNode = anchorNode.getParentNode();
            columnWidget.setSizable(anchorNode.attribute('unsizable') === 0 && parentNode.attribute('unsizableColumns') === 0);
          }
        }
      };
    });
  });
;

"use strict";

modulum('ValuePrefixedVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Prefix value according to UR spec for images or webcomponents
     * @class ValuePrefixedVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ValuePrefixedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ValuePrefixedVMBehavior.prototype */ {
        __name: "ValuePrefixedVMBehavior",

        watchedAttributes: {
          anchor: ['value'],
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setValue) {
            const anchorNode = controller.getAnchorNode();
            const auiValue = anchorNode.attribute('value');

            let value;
            if (widget.getWebComponentType && widget.getWebComponentType() === "api") {
              value = auiValue;
            } else {
              value = anchorNode.getApplication().wrapResourcePath(auiValue);
            }

            // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
            if (anchorNode.isInTable()) {
              const tableWidget = widget.getTableWidgetBase();
              const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
              if (isAnticipateScrollingEnabled) {
                const tableCachedDataModel = tableWidget.getCachedDataModel();
                tableCachedDataModel.updateDataFromValueNode(anchorNode, "value", value);

                const tableNode = anchorNode.getAncestor("Table");
                if (anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode)) {
                  // if there are some scroll commands to process, widget update will be done in the NativeScrollVMBehavior
                  return;
                }
              }
            }

            if (widget?.setValue) {
              widget.setValue(value, true);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('ValueVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class ValueVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.ValueVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.ValueVMBehavior.prototype */ {
        __name: "ValueVMBehavior",

        watchedAttributes: {
          anchor: ['value'],
          completer: ['size']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          const anchorNode = controller.getAnchorNode();
          const auiValue = anchorNode.attribute('value');

          let doSetValue = true;
          // TODO GBC-3554 GBC-4180 update table cached data model should not be done by VM behavior but directly in manageAUIOrder
          if (anchorNode.isInTable()) {
            const tableWidget = widget.getTableWidgetBase();
            const isAnticipateScrollingEnabled = tableWidget.isAnticipateScrollingEnabled();
            if (isAnticipateScrollingEnabled) {
              const tableCachedDataModel = tableWidget.getCachedDataModel();
              tableCachedDataModel.updateDataFromValueNode(anchorNode, "value", auiValue);
              const tableNode = anchorNode.getAncestor("Table");
              const hasScrollCommandsToProcess = anchorNode.getApplication().scheduler.hasScrollCommandsToProcess(tableNode);
              doSetValue = !hasScrollCommandsToProcess;
            }
          }

          if (widget?.setValue) {
            const anchorNode = controller.getAnchorNode();

            if (!widget.isEditing) { // if widget is not a TextWidgetBase, simply setValue and return
              if (doSetValue) {
                widget.setValue(auiValue, true);
              }
              return;
            }

            // TODO : is lastCommandTime still needed with predictive deletion ?
            const lastCommandTime = anchorNode.getApplication().scheduler.getLastCommandTime();
            if (!widget.isEditing() || lastCommandTime >= widget.getEditingTime()) {
              if (doSetValue) {
                widget.setValue(auiValue, true);
              }
              if (widget.hasFocus() && widget.hasCursors()) { // need to set correct cursor (QA GBC-937)
                const containerNode = controller.getNodeBindings().container;
                const cursor = containerNode.attribute('cursor');
                const cursor2 = containerNode.attribute('cursor2');
                widget.setCursors(cursor, cursor2);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('VisibleIdVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class VisibleIdVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleIdVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleIdVMBehavior.prototype */ {
        __name: "VisibleIdVMBehavior",

        watchedAttributes: {
          anchor: ['visibleId']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const formNode = controller.getAnchorNode();
          const visibleId = formNode.attribute('visibleId');
          if (visibleId >= 0) {
            const visibleNode = formNode.getApplication().getNode(visibleId);
            if (visibleNode) {
              let ctrl = visibleNode.getController();
              let parentNode = visibleNode.getParentNode();
              while (!ctrl && parentNode) {
                ctrl = parentNode.getController();
                parentNode = parentNode.getParentNode();
              }
              if (ctrl) {
                ctrl.ensureVisible(true);
              }
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('VisibleMenuVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's visibility
     * @class VisibleMenuVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleMenuVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleMenuVMBehavior.prototype */ {
        __name: "VisibleMenuVMBehavior",

        watchedAttributes: {
          anchor: ['hidden']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const thisWidget = controller.getWidget();
          if (!thisWidget) {
            return;
          }
          const anchorNode = controller.getAnchorNode();
          const isHidden = anchorNode.attribute('hidden') === 1;

          if (thisWidget.setHidden) {
            thisWidget.setHidden(isHidden);
          }
        }
      };
    });
  });
;

"use strict";

modulum('VisibleRowsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class VisibleRowsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.VisibleRowsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.VisibleRowsVMBehavior.prototype */ {
        __name: "VisibleRowsVMBehavior",

        watchedAttributes: {
          anchor: ['size', 'offset', 'bufferSize', 'dialogType']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          let tableWidget = controller.getWidget();
          if (tableWidget && tableWidget.setVisibleRows) {
            let tableNode = controller.getAnchorNode();
            let size = tableNode.attribute('size');
            let offset = tableNode.attribute('offset');
            let bufferSize = tableNode.attribute('bufferSize');
            let currentRow = tableNode.attribute('currentRow');

            let visibleRows = Math.min(bufferSize, size - offset);
            let dialogType = tableNode.attribute('dialogType');
            if ((dialogType === "Construct" || dialogType === "Input" || (dialogType === "InputArray" && currentRow === 0)) &&
              visibleRows === 0) {
              visibleRows = 1;
            }
            tableWidget.setVisibleRows(visibleRows);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WantFixedPageSizeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the stretchable scrollGrid
     * @class WantFixedPageSizeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantFixedPageSizeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantFixedPageSizeVMBehavior.prototype */ {
        __name: "WantFixedPageSizeVMBehavior",

        watchedAttributes: {
          anchor: ['wantFixedPageSize']
        },

        /**
         * Updates the widget's visibility depending on the AUI tree information
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setFixedPageSize) {
            const anchorNode = controller.getAnchorNode();
            const wantFixedPageSize = anchorNode.attribute('wantFixedPageSize');
            widget.setFixedPageSize(wantFixedPageSize === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WantReturnsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling wantTabs attribute in textedit
     * @class WantReturnsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantReturnsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantReturnsVMBehavior.prototype */ {
        __name: "WantReturnsVMBehavior",

        watchedAttributes: {
          anchor: ['wantReturns']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setWantReturns) {
            const decoratorNode = controller.getNodeBindings().decorator;
            const wantReturns = decoratorNode.attribute('wantReturns');
            widget.setWantReturns(wantReturns === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WantTabsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling wantTabs attribute in textedit
     * @class WantTabsVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WantTabsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WantTabsVMBehavior.prototype */ {
        __name: "WantTabsVMBehavior",

        watchedAttributes: {
          anchor: ['wantTabs']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.setWantTabs) {
            const decoratorNode = controller.getNodeBindings().decorator;
            const wantTabs = decoratorNode.attribute('wantTabs');
            widget.setWantTabs(wantTabs === 1);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WebComponentCursorsVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WebComponentCursorsVMBehavior
     * Will override the cursor behavior since it's handled differently for webcomponents
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WebComponentCursorsVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WebComponentCursorsVMBehavior.prototype */ {
        __name: "WebComponentCursorsVMBehavior",

        watchedAttributes: {
          container: ['cursor', 'cursor2']
        },

        /**
         * Set cursors position to the widget input field
         * @param controller
         * @param data
         * @private
         */
        _apply: function(controller, data) {
          const widget = null;
          const containerNode = controller.getNodeBindings().container;

          // impossible condition ??
          if (widget?.hasCursors()) {
            const cursor = containerNode.attribute('cursor');
            const cursor2 = containerNode.attribute('cursor2');
            widget?.setCursors(cursor, cursor2);
          }
        },

      };
    });
  });
;

"use strict";

modulum('WebComponentStateChangedVMBehavior', ['BackgroundColorVMBehavior'],
  function(context, cls) {
    /**
     * @class WebComponentStateChangedVMBehavior
     * @memberOf classes
     * @extends classes.BackgroundColorVMBehavior
     */
    cls.WebComponentStateChangedVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WebComponentStateChangedVMBehavior.prototype */ {
        __name: "WebComponentStateChangedVMBehavior",

        watchedAttributes: {
          container: ['active', 'dialogType']
        },

        /**
         * Applies the background color only if it has been defined by the VM, use default value otherwise.
         */
        _apply: function(controller, data) {
          const widget = controller.getWidget();
          if (widget?.onStateChanged) {
            const containerNode = controller.getNodeBindings().container;
            const active = containerNode.attribute('active');
            const dialogType = containerNode.attribute('dialogType');
            widget.onStateChanged(active, dialogType);
          }

        }
      };
    });
  });
;

"use strict";

modulum('WindowCanCloseVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowCanCloseVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowCanCloseVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowCanCloseVMBehavior.prototype */ {
        /** @type {string} */
        __name: "WindowCanCloseVMBehavior",

        watchedAttributes: {
          parent: ['active'],
          anchor: ['active']
        },
        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode(),
            windowNode = anchorNode && anchorNode.getAncestor('Window'),
            windowController = windowNode && windowNode.getController(),
            windowWidget = windowController && windowController.getWidget();
          if (windowWidget && windowWidget.setClosable) {
            const activeValue = anchorNode.attribute('active');
            windowWidget.setClosable(activeValue);
          }
        },

        /**
         * @inheritDoc
         */
        _detach: function(controller) {
          const anchorNode = controller.getAnchorNode(),
            windowNode = anchorNode && anchorNode.getAncestor('Window'),
            windowController = windowNode && windowNode.getController(),
            windowWidget = windowController && windowController.getWidget();
          if (windowWidget && windowWidget.setClosable) {
            windowWidget.setClosable(false);
          }
        }
      };
    });
  });
;

"use strict";

modulum('WindowImageVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowImageVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowImageVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowImageVMBehavior.prototype */ {
        __name: "WindowImageVMBehavior",

        watchedAttributes: {
          anchor: ['image']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const windowNode = controller.getAnchorNode(),
            application = windowNode.getApplication(),
            image = windowNode && windowNode.attribute('image');
          windowNode.setIcon(application.wrapResourcePath(image));

          if (image.length > 0) {
            // Tell native part to update icon as well
            context.__wrapper.nativeCall(context.__wrapper.param({
              name: "applicationIcon",
              args: {
                "type": "window",
                "icon": image,
              }
            }, application));
          }
        }
      };
    });
  }
);
;

"use strict";

modulum('WindowParentVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * Behavior controlling the widget's Menu
     * @class WindowParentVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowParentVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowParentVMBehavior.prototype */ {
        __name: "WindowParentVMBehavior",

        watchedAttributes: {
          anchor: ['parent']
        },

        /**
         * @inheritDoc
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode(),
            app = anchorNode && anchorNode.getApplication(),
            appUI = app.getUI();
          anchorNode.setParentWindowId(anchorNode.attribute('parent'));
          appUI.syncCurrentWindow();
        },
      };
    });
  });
;

"use strict";

modulum('WindowTitleVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowTitleVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowTitleVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowTitleVMBehavior.prototype */ {
        __name: "WindowTitleVMBehavior",

        watchedAttributes: {
          anchor: ['name', 'text']
        },

        /**
         * Switches the current window
         */
        _apply: function(controller, data) {
          const anchorNode = controller.getAnchorNode();
          const text = anchorNode.attribute('text');
          const name = anchorNode.attribute('name');
          anchorNode.setTitle(text || name);
        }
      };
    });
  });
;

"use strict";

modulum('WindowTypeVMBehavior', ['BehaviorBase'],
  function(context, cls) {
    /**
     * @class WindowTypeVMBehavior
     * @memberOf classes
     * @extends classes.BehaviorBase
     */
    cls.WindowTypeVMBehavior = context.oo.Singleton(cls.BehaviorBase, function($super) {
      return /** @lends classes.WindowTypeVMBehavior.prototype */ {
        __name: "WindowTypeVMBehavior",

        usedStyleAttributes: ["windowType"],

        watchedAttributes: {
          anchor: ['style']
        },

        /**
         *
         */
        _apply: function(controller, data) {
          const windowNode = controller.getAnchorNode(),
            application = windowNode && windowNode.getApplication(),
            session = application && application.getSession();
          if ((!windowNode.isAttributeSetByVM("active") || windowNode.attribute("active") === 1) &&
            (!windowNode.isAttributeSetByVM("hidden") || windowNode.attribute("hidden") === 0)) {
            const widget = windowNode.getController().getWidget();
            if (widget?.setAsModal) {
              let windowTypeAttr = windowNode.attribute("style");
              if (!this._isMenuSpecial(widget, windowTypeAttr)) {
                windowTypeAttr = windowNode.getStyleAttribute("windowType");
              }
              if (this._isMenuSpecial(widget, windowTypeAttr)) {
                // in this case windowNode is the menuNode (fgl_winmsg case)
                widget.setAsModal(windowTypeAttr);
                const freeHandle = windowNode.getApplication().layout.afterLayout(function() {
                  widget._updateModalPosition();
                });
                widget.when(context.constants.widgetEvents.destroyed, function() {
                  freeHandle();
                });
              } else if (widget.isInstanceOf(cls.WindowWidget) && windowNode.isModal()) {
                const opt = {
                  storedSettingsKey: windowNode.getController().getStoredSettingKey()
                };
                const modalWidget = widget.setAsModal(opt); // pass options to modal

                if (modalWidget) {
                  const app = windowNode.getApplication();
                  modalWidget.when(context.constants.widgetEvents.modalResize, function() {
                    app.getUI().getWidget().getLayoutInformation().invalidateMeasure();
                    app.scheduler.layoutCommand({
                      resize: true
                    });
                  }.bind(this));
                }

                modalWidget.onClose(() => {
                  if (session) {
                    session.getNavigationManager().unfreezeApplication(application);
                  }
                });
                if (session) {
                  session.getNavigationManager().freezeApplication(application);
                }
              }
            }
          }
        },

        _isMenuSpecial: function(widget, styleAttr) {
          return (widget.isInstanceOf(cls.MenuWidget) && (styleAttr === "winmsg" || styleAttr === "dialog" || styleAttr === "popup"));
        }
      };
    });
  });
;

"use strict";

modulum('ChromeBarItemLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /** Use empty layout definition to enable measure mechanism
     * @class ChromeBarItemLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.ChromeBarItemLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.ChromeBarItemLayoutEngine.prototype */ {
        __name: "ChromeBarItemLayoutEngine",

      };
    });
  });
;

"use strict";

modulum('ChromeBarLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ChromeBarLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.ChromeBarLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.ChromeBarLayoutEngine.prototype */ {
        __name: "ChromeBarLayoutEngine",

        /**
         * @inheritDoc
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          this._getLayoutInfo().setDecorating(
            this._widget.getElement().clientWidth - this._widget.getContainerElement().clientWidth,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight
          );
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);
          // Refresh chromeBar to put overflown widgets in sidebar
          this._widget.refresh(); // true to force a refresh without conditions

        },

      };
    });
  });
;

"use strict";

modulum('DBoxLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * Base laxout engine clarr for HBoxLayoutEngine and VBoxLayoutEngine
     * @class DBoxLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.DBoxLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.DBoxLayoutEngine.prototype */ {
        __name: "DBoxLayoutEngine",
        /**
         * main measure size getter name
         * @type {?string}
         * @protected
         */
        _mainSizeGetter: null,
        /**
         * main measure size setter name
         * @type {?string}
         * @protected
         */
        _mainSizeSetter: null,
        /**
         * main has measure size getter name
         * @type {?string}
         * @protected
         */
        _mainHasSizeGetter: null,
        /**
         * main stretch info getter name
         * @type {?string}
         * @protected
         */
        _mainStretch: null,
        /**
         * opposite measure size getter name
         * @type {?string}
         * @protected
         */
        _oppositeSizeGetter: null,
        /**
         * opposite measure size setter name
         * @type {?string}
         * @protected
         */
        _oppositeSizeSetter: null,
        /**
         * opposite has measure size getter name
         * @type {?string}
         * @protected
         */
        _oppositeHasSizeGetter: null,
        /**
         * opposite stretch info getter name
         * @type {?string}
         * @protected
         */
        _oppositeStretch: null,
        /**
         * calculated split hints
         * @type {Array<number>}
         */
        _splitHints: null,
        /**
         * reference split hints
         * @type {Array<number>}
         * @protected
         */
        _referenceSplitHints: null,
        /**
         * currenty splitter index
         * @type {?number}
         * @protected
         */
        _currentlySplitting: -1,
        /**
         * Flag indicating whether it contains spacers or not
         * @type {boolean}
         * @protected
         */
        _hasSpacer: false,
        /**
         * registered children widgets
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _registeredWidgets: null,
        /**
         * stylesheet id
         * @protected
         */
        _styleSheetId: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "boxLayout_" + widget.getUniqueIdentifier();
          this._splitHints = [];
          this._registeredWidgets = [];
          this._referenceSplitHints = [];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          for (let i = this._registeredWidgets.length - 1; i > -1; i--) {
            const wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          this._splitHints = null;
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._setSplitHints(this._getReferenceSplitHints().slice());
        },

        /**
         * Initialize split Hints
         * @param {Array?} initial - if given, use this array as reference
         */
        initSplitHints: function(initial) {
          this._setReferenceSplitHints((initial || []).map(function(item) {
            return isNaN(item) ? 0 : item;
          }));
        },

        /**
         * Handle Splitting - start (on drag start)
         * @param {Number} splitterIndex - index of splitter to handle
         */
        startSplitting: function(splitterIndex) {
          this._currentlySplitting = splitterIndex;
          this._setReferenceSplitHints([]);
          for (let i = 0; i < this._registeredWidgets.length; i++) {
            const widget = this._registeredWidgets[i];
            if (!(widget instanceof cls.SplitterWidget)) {
              const idx = i / 2;
              this._setReferenceSplitHints(idx, Math.round(this._getAvailableSize(widget, true)));
            }
          }
          this._setSplitHints(this._getReferenceSplitHints().slice());
        },

        /**
         * Handle Splitting - stop (on drag end)
         */
        stopSplitting: function() {
          this._setReferenceSplitHints(this._getSplitHints());
          this._currentlySplitting = -1;
        },

        /**
         * Handler while moving splitter
         * @param {Number} delta - moving delta
         */
        splitting: function(delta) {
          const widget1 = this._registeredWidgets[this._currentlySplitting * 2],
            widget2 = this._registeredWidgets[(this._currentlySplitting + 1) * 2],
            min1 = this._getMinimalSize(widget1, true) || 1,
            min2 = this._getMinimalSize(widget2, true) || 1,
            splitIndex = this._currentlySplitting,
            splitNextIndex = this._currentlySplitting + 1;

          for (let i = 0; i < this._registeredWidgets.length; i++) {
            const widget = this._registeredWidgets[i];
            if (!(widget instanceof cls.SplitterWidget)) {
              const idx = i / 2;
              this._setSplitHints(idx, this._getReferenceSplitHints(idx));
            }
          }
          let extra = 0;
          const size1 = this._getSplitHints(splitIndex),
            size2 = this._getSplitHints(splitNextIndex);
          if ((size1 + delta) < min1) {
            extra = delta;
            delta = min1 - size1;
            extra -= delta;
          }
          if ((size2 - delta) < min2) {
            extra = delta;
            delta = size2 - min2;
            extra -= delta;
          }

          // Add delta to currentSplitting
          this._setSplitHints(splitIndex, this._getSplitHints(splitIndex) + delta);
          // Remove delta to next splitHint
          this._setSplitHints(splitNextIndex, this._getSplitHints(splitNextIndex) - delta);

          if (extra) {
            let currentIndex, currentMin, currentSize, canReduce;
            if (extra < 0) {
              currentIndex = splitIndex - 1;
              while (extra && (currentIndex >= 0)) {
                currentMin = this._getMinimalSize(this._registeredWidgets[currentIndex * 2], true) || 1;
                currentSize = this._getSplitHints(currentIndex);
                canReduce = currentSize - currentMin;
                if (canReduce > 0) {
                  if (-extra < canReduce) {
                    // Add extra to currentSplitting
                    this._setSplitHints(currentIndex, this._getSplitHints(currentIndex) + extra);
                    // Remove extra to next splitHint
                    this._setSplitHints(splitNextIndex, this._getSplitHints(splitNextIndex) - extra);
                    extra = 0;
                  } else {
                    extra += canReduce;
                    // Add canReduce to currentSplitting
                    this._setSplitHints(currentIndex, this._getSplitHints(currentIndex) - canReduce);
                    // Remove canReduce to next splitHint
                    this._setSplitHints(splitNextIndex, this._getSplitHints(splitNextIndex) + canReduce);
                  }
                }
                currentIndex--;
              }
            } else {
              currentIndex = splitIndex + 2;
              while (extra && (currentIndex < this._getSplitHints().length)) {
                currentMin = this._getMinimalSize(this._registeredWidgets[currentIndex * 2], true) || 1;
                currentSize = this._getSplitHints(currentIndex);
                canReduce = currentSize - currentMin;
                if (canReduce > 0) {
                  if (extra < canReduce) {
                    // Add extra to currentSplitting
                    this._setSplitHints(currentIndex, this._getSplitHints(currentIndex) - extra);
                    // Remove extra to next splitHint
                    this._setSplitHints(splitIndex, this._getSplitHints(splitIndex) + extra);
                    extra = 0;
                  } else {
                    extra -= canReduce;
                    // Add canReduce to currentSplitting
                    this._setSplitHints(currentIndex, this._getSplitHints(currentIndex) - canReduce);
                    // Remove canReduce to next splitHint
                    this._setSplitHints(splitIndex, this._getSplitHints(splitIndex) + canReduce);
                  }
                }
                currentIndex++;
              }
            }
          }
        },

        /**
         * @inheritDoc
         * @param {classes.WidgetBase} widget child widget
         * @param {number} position the wanted position
         */
        registerChild: function(widget, position) {
          if (this._registeredWidgets.indexOf(widget) < 0) {
            this._registeredWidgets.splice(position, 0, widget);
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareAdjustments: function() {
          const widgets = this._registeredWidgets;
          let lastSplitterVisible = null;
          for (let j = 0; j <= widgets.length - 1; j += 2) {
            const widget = widgets[j];
            const widget2 = widgets[j + 2];
            const isSpacer1 = widget instanceof cls.SpacerItemWidget;
            const isSpacer2 = !widget2 || widget2 instanceof cls.SpacerItemWidget;
            if (widget.isVisible()) {
              lastSplitterVisible = widgets[j + 1];
              if (lastSplitterVisible) {
                lastSplitterVisible.setHidden(isSpacer1 || isSpacer2);
              }
            } else {
              // if last widget no splitter to hide, but we may have to hide previous visible splitter
              if (j === widgets.length - 1) {
                if (lastSplitterVisible) {
                  lastSplitterVisible.setHidden(true);
                  lastSplitterVisible = null;
                }
              } else {
                widgets[j + 1].setHidden(true);
              }
            }
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const widgets = this._registeredWidgets;
          this._hasSpacer = false;
          this._getLayoutInfo().setPreferred(0, 0);
          const layoutInfo = this._getLayoutInfo();
          let position = 0,
            minimal = 0,
            minOppositeSize = 0,
            oppositeSize = 0,
            maxSize = 0,
            maxOppositeSize = 0;
          for (const element of widgets) {
            const widget = element;
            if (!widget.isVisible()) {
              continue;
            }
            const hasMaxSize = this._hasMaximalSize(widget),
              hasOppositeMaxSize = this._hasOppositeMaximalSize(widget),
              isSpacer = widget instanceof cls.SpacerItemWidget;
            if (isSpacer) {
              this._hasSpacer = true;
            }

            if (hasMaxSize || isSpacer) {
              maxSize += this._getMaximalSize(widget, true);
            } else {
              maxSize = cls.Size.maximal;
              this._setPreferredSize(this._widget,
                this._getPreferredSize(this._widget, true) +
                this._getPreferredSize(widget, true)
              );
            }
            if (hasOppositeMaxSize) {
              if (maxOppositeSize !== cls.Size.maximal) {
                maxOppositeSize = Math.max(maxOppositeSize, this._getOppositeMaximalSize(widget, true));
              }
            } else {
              maxOppositeSize = cls.Size.maximal;
            }
            const size = this._getMeasuredSize(widget, true),
              minimalSize = this._getMinimalSize(widget, true),
              opposite = this._getOppositeMeasuredSize(widget, true),
              minOpposite = this._getOppositeMinimalSize(widget, true);
            oppositeSize = Math.max(oppositeSize, opposite);
            minOppositeSize = Math.max(minOppositeSize, minOpposite);
            position += Math.max(minimalSize, size);
            minimal += minimalSize;
          }
          this._applyMeasure(position, oppositeSize);
          layoutInfo.getMinimal()[this._mainSizeSetter](minimal);
          layoutInfo.getMinimal()[this._oppositeSizeSetter](minOppositeSize);

          this._setMaximalSize(this._widget, maxSize);
          this._setOppositeMaximalSize(this._widget, maxOppositeSize);
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          const layoutInfo = this._getLayoutInfo();
          let oppositeStretch = 0;
          for (const element of this._registeredWidgets) {
            const widget = element,
              widgetInfo = widget.getLayoutInformation();
            if (!widget.isVisible()) {
              continue;
            }
            const hasOppositeMaxSize = this._hasOppositeMaximalSize(widget);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(widgetInfo);
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(widgetInfo);
            }

            if (!hasOppositeMaxSize) {
              if (oppositeStretch < this._getOppositePreferredSize(widget)) {
                oppositeStretch = this._getOppositePreferredSize(widget);
              }
            }
          }

          if (this._getOppositeMaximalSize() === cls.Size.maximal && oppositeStretch === 0) {
            oppositeStretch = 1;
          }
          if (oppositeStretch > 0) {
            this._setOppositePreferredSize(this._widget, oppositeStretch);
          }

        },

        _prepareApplyWhenSplitting: function(widgets) {
          for (const element of widgets) {
            const widget = element;
            if (widget.isVisible()) {
              if (!(widget instanceof cls.SplitterWidget)) {
                this._setAvailableSize(widget, this._getSplitHints(this._widget.getIndexOfChild(widget)));
              }
            }
          }
        },

        _prepareApplyWithStretch: function(widgets) {
          let availableSize = this._getAvailableSize(),
            initialFullRatio = 0,
            fullRatio = 0,
            initialStretched = 0,
            stretched = 0;
          const ratios = new Map();
          let i, widget, preferred, msize;

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
              msize = this._getMinimalSize(widget, true);
              preferred = this._getPreferredSize(widget, true);
              if (this._isStretched(widget) && !widget.isInstanceOf(cls.SplitterWidget)) {
                ratios.set(widget, {
                  widget: widget,
                  preferred: preferred,
                  minimal: msize
                });
                initialFullRatio += preferred;
                fullRatio += preferred;
                initialStretched++;
                stretched++;
              } else {
                // if not stretchable, apply minimal size
                this._setAvailableSize(widget, msize);
                availableSize -= msize;
              }
            }
          }
          let sizableCount = 0;
          const reducer = function(ratio, widget, map) {
            ratio.part = initialFullRatio ? (ratio.preferred || 0) / initialFullRatio : initialStretched ? (1 /
                initialStretched) :
              0;
            ratio.initialDistribution = availableSize * ratio.part;
            if (ratio.initialDistribution <= ratio.minimal) {
              this._setAvailableSize(widget, ratio.minimal);
              availableSize -= ratio.minimal;
              fullRatio -= ratio.preferred;
              stretched--;
              map.delete(widget);
            } else {
              sizableCount++;
            }
          }.bind(this);

          // seeking all stretchables that should strecch smaller than their minimal size
          while (ratios.size !== sizableCount) {
            sizableCount = 0;
            ratios.forEach(reducer);
            initialFullRatio = fullRatio;
            initialStretched = stretched;
          }

          ratios.forEach(function(ratio, widget, map) {
            const part = fullRatio ? (ratio.preferred || 0) / fullRatio : stretched ? (1 / stretched) : 0;
            this._setAvailableSize(widget, availableSize * part);
            map.delete(widget);
          }.bind(this));
        },

        _prepareApplyWithoutStretch: function(widgets) {
          let i;
          const items = [],
            distributedSize = {};
          let available = this._getAvailableSize(),
            accumulated = 0,
            currentLevel = 0,
            distibutableLevel = -1;
          let widgetMeasured = 0;

          // loop on each child of the hbox/vbox and add them in list if they aren't splitter and visible
          for (const w of widgets) {
            if (!w.isHidden()) {
              if ((this._hasSpacer && (w instanceof cls.SpacerItemWidget)) ||
                (!this._hasSpacer && !(w instanceof cls.SplitterWidget))) {
                if (this._widget
                  .isPacked()
                ) { // if packed, we only add the last child in the list, ignore other to not count them in the distribution model
                  if (widgets.last() === w) {
                    items.push(w);
                  } else {
                    // subtract widget size from remaining available size to distribute later on
                    widgetMeasured = this._getMeasuredSize(w, true);
                    available -= widgetMeasured;
                    // set widget measured size as available size to let splitter works properly on need
                    this._setAvailableSize(w, widgetMeasured);
                  }
                } else { // if not packed, add all child in distribution model
                  items.push(w);
                }
              } else { // subtract splitter size from remaining available size to distribute later on
                available -= this._getMeasuredSize(w, true);
              }
            }
          }

          const count = items.length;

          // sort child widget by minimal size (TODO explain why)
          items.sort(this._sortItems.bind(this));

          // while we have remaining available size to distribute
          while (distibutableLevel === -1 && currentLevel < count) {
            const minimalCurrent = this._getMinimalSize(items[currentLevel], true);
            if (available >= (accumulated + minimalCurrent * (count - currentLevel))) {
              distibutableLevel = currentLevel;
            } else {
              accumulated += minimalCurrent;
              distributedSize[items[currentLevel].getUniqueIdentifier()] = minimalCurrent;
              currentLevel++;
            }
          }
          if (distibutableLevel >= 0) {
            // divide remaining available size by number of child widgets and save this bonus size to allocate to the distributedSize list
            const distributablePart = (available - accumulated) / (count - distibutableLevel);
            for (i = distibutableLevel; i < count; i++) {
              distributedSize[items[i].getUniqueIdentifier()] = distributablePart;
            }
          }
          // loop on all child widgets (splitter included)
          for (i = 0; i < widgets.length; i++) {
            const widget = widgets[i];
            if (widget.isVisible()) {
              // set bonus available size to the widget
              if (distributedSize.hasOwnProperty(widget.getUniqueIdentifier())) {
                this._setAvailableSize(widget, distributedSize[widget.getUniqueIdentifier()]);
              }
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
            } else {
              this._setAvailableSize(widget, 0);
              this._setOppositeAvailableSize(widget, 0);
            }
          }
        },

        /**
         * Get hints
         * @param {Number?} idx - index of the split part to get
         * @return {*} either a specific splitHints if idx given, or all Array
         * @private
         */
        _getSplitHints(idx) {
          if (typeof idx === "undefined") {
            return this._splitHints;
          } else {
            return this._splitHints[idx];
          }
        },

        /**
         * Set hints
         * @param {Number?} idx - index of the split part to get
         * @param {*} value - either an array or a specific value
         * @private
         */
        _setSplitHints(idx, value) {
          if (typeof value === "undefined") {
            this._splitHints = idx;
          } else {
            this._splitHints[idx] = value;
          }
        },

        /**
         * Get reference hints
         * @param {Number?} idx - index of the split part to get
         * @return {*} either a specific refSplitHints if idx given, or all Array
         * @private
         */
        _getReferenceSplitHints(idx) {
          if (typeof idx === "undefined") {
            return this._referenceSplitHints;
          } else {
            return this._referenceSplitHints[idx];
          }
        },

        /**
         * Set reference hints
         * @param {Number?} idx - index of the split part to get
         * @param {*} value - either an array or a specific value
         * @private
         */
        _setReferenceSplitHints(idx, value) {
          if (typeof value === "undefined") {
            this._referenceSplitHints = idx;
          } else {
            this._referenceSplitHints[idx] = value;
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const widgets = this._registeredWidgets;
          let i, widget, wSize, oppositeWSize,
            position = 0,
            reallyAllocatedSpace = 0,
            stretchablesOnNeed = 0,
            extraSpace = 0;
          if (this._currentlySplitting >= 0) {
            // user is currently splitting
            this._prepareApplyWhenSplitting(widgets);
          } else if ( // box has been previously split, keep ratios
            this._getReferenceSplitHints().length &&
            (this._getReferenceSplitHints().length === ((widgets.length + 1) / 2))) {
            this._redistributeSplittedSpace(widgets);
          } else if (this._isStretched(this._widget)) {
            // some elements are stretchable
            this._prepareApplyWithStretch(widgets);
          } else {
            // no elements are stretchable
            // calculate remaining not allocated available space and add it evenly between each child (if 4ST packed = false)
            this._prepareApplyWithoutStretch(widgets);
          }

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              wSize = Math.max(this._getAvailableSize(widget, true), this._getMinimalSize(widget, true));
              reallyAllocatedSpace += wSize;
              if (!wSize) {
                stretchablesOnNeed++;
              }
            }
          }
          if (stretchablesOnNeed) {
            extraSpace =
              Math.max((Math.max(this._getAvailableSize(null, true), this._getMinimalSize(null, true)) - reallyAllocatedSpace) /
                stretchablesOnNeed, 0); // ignore negative values (may occur if available size < measured one)
          }
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              wSize = Math.max(this._getAvailableSize(widget, true), this._getMinimalSize(widget, true));
              if (!wSize) {
                wSize = extraSpace;
              }
              this._setAllocatedSize(widget, wSize);
              oppositeWSize = this._getOppositeAvailableSize();
              if (!this._getOppositeStretched() || this._getLayoutInfo().willOverflowContainerIfNeeded()) {
                oppositeWSize = Math.max(oppositeWSize, this._getOppositeMinimalSize());
              }
              this._setOppositeAllocatedSize(widget, oppositeWSize);
              this._setOppositeAvailableSize(widget, oppositeWSize);
              this._setItemClass(i, position, wSize);
              position += wSize;
            } else {
              this._setOppositeAllocatedSize(widget, 0);
              this._setOppositeAvailableSize(widget, 0);
              this._setItemClass(i, position, 0);
            }
          }

          const width = Math.max(this._getLayoutInfo().getAvailable().getWidth(true), this._getLayoutInfo().getMinimal().getWidth(
            true));
          const height = Math.max(this._getLayoutInfo().getAvailable().getHeight(true), this._getLayoutInfo().getMinimal().getHeight(
            true));
          this._getLayoutInfo().setAllocated(width, height);

          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setItemOppositeClass(i);
              this._setOppositeAllocatedSize(widget, this._getOppositeAllocatedSize());
            } else {
              this._setItemOppositeClass(i);
              this._setOppositeAllocatedSize(widget, 0);
            }
          }
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            width: this._getLayoutInfo().getAllocated().getWidth() + "px",
            height: this._getLayoutInfo().getAllocated().getHeight() + "px"
          };
        },

        _redistributeSplittedSpace: function(widgets) {
          let i, widget, total = this._getAvailableSize(),
            totalSplitters = 0;
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              if (widget instanceof cls.SplitterWidget) {
                const s = this._getMeasuredSize(widget);
                total -= s;
                totalSplitters += s;
              }
            }
          }
          if (this._getMinimalSize() < (total + totalSplitters)) {
            const sum = this._getReferenceSplitHints().reduce(function(acc, b, idx) {
              if (idx === 1 && !widgets[0].isVisible()) {
                acc = 0;
              }
              if (!widgets[idx * 2].isVisible()) {
                b = 0;
              }
              return acc + b;
            }.bind(this));
            let availableWeight = sum;
            const ratioed = this._getReferenceSplitHints().map(function(a, idx) {
              const relative = total * a / sum,
                min = this._getMinimalSize(widgets[idx * 2]),
                delta = relative - min;
              return {
                weight: a,
                min: min,
                size: min,
                relative: relative,
                delta: delta,
                index: idx
              };
            }, this).sort(function(a, b) {
              return a.delta < b.delta ? -1 : a.delta > b.delta ? 1 : 0;
            });
            let pos = 0,
              debt = 0;
            while (pos < ratioed.length) {
              if (ratioed[pos].delta < 0) {
                debt -= ratioed[pos].delta;
                availableWeight -= ratioed[pos].weight;
                pos++;
              } else {
                const weightDebt = debt * ratioed[pos].weight / availableWeight;
                if (weightDebt > ratioed[pos].delta) {
                  ratioed[pos].delta -= weightDebt;
                  debt -= weightDebt;
                } else {
                  debt -= weightDebt;
                  ratioed[pos].delta -= weightDebt;
                  ratioed[pos].size = ratioed[pos].min + ratioed[pos].delta;
                  availableWeight -= ratioed[pos].weight;
                  pos++;
                }
              }
            }
            for (i = 0; i < ratioed.length; i++) {
              widget = widgets[ratioed[i].index * 2];
              if (widget.isVisible()) {
                if (!(widget instanceof cls.SplitterWidget)) {
                  this._setAvailableSize(widget, ratioed[i].size);
                }
              }
            }
          } else {
            for (i = 0; i < widgets.length; i++) {
              widget = widgets[i];
              if (widget.isVisible()) {
                if (!(widget instanceof cls.SplitterWidget)) {
                  this._setAvailableSize(widget, this._getMinimalSize(widget));
                }
              }
            }
          }
          for (i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            if (widget.isVisible()) {
              this._setOppositeAvailableSize(widget, this._getOppositeAvailableSize());
            }
          }
        },
        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true,
            this.getLayoutSheetId());
        },

        /**
         * get main hint size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getPreferredSize: function(widget, useFallback) {
          const idx = this._widget.getIndexOfChild(widget);
          if (idx >= 0 && this._getSplitHints(idx)) {
            return this._getSplitHints(idx);
          }
          return this._getLayoutInfo(widget).getPreferred()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite hint size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositePreferredSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getPreferred()[this._oppositeSizeGetter](useFallback);
        },

        _setPreferredSize: function(widget, size) {
          return this._getLayoutInfo(widget).getPreferred()[this._mainSizeSetter](size);
        },

        _setOppositePreferredSize: function(widget, size) {
          return this._getLayoutInfo(widget).getPreferred()[this._oppositeSizeSetter](size);
        },

        /**
         * get main allocated size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getAllocatedSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getAllocated()[this._mainSizeGetter](useFallback);

        },

        /**
         * set main allocated size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setAllocatedSize: function(widget, size) {
          return this._getLayoutInfo(widget).getAllocated()[this._mainSizeSetter](size);
        },
        /**
         * set main maximal size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setMaximalSize: function(widget, size) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainSizeSetter](size);
        },
        /**
         * set opposite maximal size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeMaximalSize: function(widget, size) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeSizeSetter](size);
        },
        /**
         * get main measured size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMeasuredSize: function(widget, useFallback) {
          if (!(widget instanceof cls.SplitterWidget)) {
            const idx = this._widget.getIndexOfChild(widget);
            if (idx >= 0 && this._getSplitHints(idx)) {
              return this._getSplitHints(idx);
            }
          }
          return this._getLayoutInfo(widget).getMeasured()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite measured size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMeasuredSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMeasured()[this._oppositeSizeGetter](Boolean(useFallback));
        },
        /**
         * get main minimal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMinimalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMinimal()[this._mainSizeGetter](Boolean(useFallback));
        },
        /**
         * get opposite minimal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMinimalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMinimal()[this._oppositeSizeGetter](Boolean(useFallback));
        },
        /**
         * get main maximal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getMaximalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainSizeGetter](useFallback);
        },
        /**
         * get opposite maximal size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeMaximalSize: function(widget, useFallback) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeSizeGetter](useFallback);
        },
        /**
         * test if given widget or owner if none has main maximal size
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {number} the size
         * @protected
         */
        _hasMaximalSize: function(widget) {
          return this._getLayoutInfo(widget).getMaximal()[this._mainHasSizeGetter](true);
        },
        /**
         * test if given widget or owner if none has opposite maximal size
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {number} the size
         * @protected
         */
        _hasOppositeMaximalSize: function(widget) {
          return this._getLayoutInfo(widget).getMaximal()[this._oppositeHasSizeGetter](true);
        },
        /**
         * get main available size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getAvailableSize: function(widget, useFallback) {
          const availableSize = this._getLayoutInfo(widget).getAvailable();
          return availableSize[this._mainSizeGetter](useFallback);
        },
        /**
         * set main available size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setAvailableSize: function(widget, size) {
          const availableSize = this._getLayoutInfo(widget).getAvailable();
          availableSize[this._mainSizeSetter](size);
        },
        /**
         * get opposite available size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeAvailableSize: function(widget, useFallback) {
          const availableSize = this._getLayoutInfo(widget).getAvailable();
          return availableSize[this._oppositeSizeGetter](useFallback);
        },
        /**
         * set opposite available size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeAvailableSize: function(widget, size) {
          const availableSize = this._getLayoutInfo(widget).getAvailable();
          availableSize[this._oppositeSizeSetter](size);
        },
        /**
         * get opposite allocated size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @param {boolean} [useFallback] true to get fallback value if needed
         * @returns {number} the size
         * @protected
         */
        _getOppositeAllocatedSize: function(widget, useFallback) {
          const allocatedSize = this._getLayoutInfo(widget).getAllocated();
          return allocatedSize[this._oppositeSizeGetter](useFallback);
        },
        /**
         * set opposite allocated size of given widget or owner if none
         * @param {classes.WidgetBase} widget the widget
         * @param {number} size the size
         * @protected
         */
        _setOppositeAllocatedSize: function(widget, size) {
          const allocatedSize = this._getLayoutInfo(widget).getAllocated();
          allocatedSize[this._oppositeSizeSetter](size);
        },
        /**
         * set item css rules for main size
         * @param {number} position child widget position in children list
         * @param {number} start render start position
         * @param {number} size render size
         * @protected
         */
        _setItemClass: function(position, start, size) {

        },
        /**
         * set item css rules for opposite size
         * @param {number} position child widget position in children list
         * @protected
         */
        _setItemOppositeClass: function(position) {

        },
        /**
         * apply css rules
         * @param {number} mainSize owner main size
         * @param {number} oppositeSize owner opposite size
         * @protected
         */
        _applyMeasure: function(mainSize, oppositeSize) {

        },
        /**
         * get main stretchability from size of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretchability info
         * @protected
         */
        _isStretched: function(widget) {
          return false;
        },
        /**
         * get main stretch info of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretch info
         * @protected
         */
        _getMainStretched: function(widget) {
          const mainStretched = this._getLayoutInfo(widget).getStretched();
          return mainStretched["get" + this._mainStretch]();
        },
        /**
         * get opposite stretch info of given widget or owner if none
         * @param {classes.WidgetBase} [widget] the widget
         * @returns {boolean} the stretch info
         * @protected
         */
        _getOppositeStretched: function(widget) {
          const oppositeStretched = this._getLayoutInfo(widget).getStretched();
          return oppositeStretched["get" + this._oppositeStretch]();
        },
        /**
         * sort function for children widget by their main minimal size
         * @param {classes.WidgetBase} a the first widget
         * @param {classes.WidgetBase} b the second widget
         * @return {number} sort value
         * @private
         */
        _sortItems: function(a, b) {
          return this._getMinimalSize(b) - this._getMinimalSize(a);
        }
      };
    });
  });
;

"use strict";

modulum('HBoxLayoutEngine', ['DBoxLayoutEngine'],
  function(context, cls) {
    /**
     * @class HBoxLayoutEngine
     * @memberOf classes
     * @extends classes.DBoxLayoutEngine
     */
    cls.HBoxLayoutEngine = context.oo.Class(cls.DBoxLayoutEngine, function() {
      return /** @lends classes.HBoxLayoutEngine.prototype */ {
        __name: "HBoxLayoutEngine",
        _mainSizeGetter: "getWidth",
        _mainSizeSetter: "setWidth",
        _mainHasSizeGetter: "hasWidth",
        _mainStretch: "X",
        _oppositeSizeGetter: "getHeight",
        _oppositeSizeSetter: "setHeight",
        _oppositeHasSizeGetter: "hasHeight",
        _oppositeStretch: "Y",

        /**
         * @inheritDoc
         */
        _setItemClass: function(position, start, size) {
          const selector = ".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (position +
              1) + ")";
          const pos = cls.Size.cachedPxImportant(start);
          this._styleRules[selector] = {};
          this._styleRules[selector][this._widget.getStart()] = pos;
          this._styleRules[selector].width = cls.Size.cachedPxImportant(size);
        },

        /**
         * @inheritDoc
         */
        _setItemOppositeClass: function(position) {
          this._styleRules[".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"].height = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getHeight());
        },

        /**
         * @inheritDoc
         */
        _applyMeasure: function(mainSize, oppositeSize) {
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            width: mainSize + "px",
            height: oppositeSize + "px"
          };
          this._getLayoutInfo().setMeasured(mainSize, oppositeSize);
        },

        /**
         * @inheritDoc
         */
        _isStretched: function(widget) {
          return widget.getLayoutEngine().isXStretched();
        }
      };
    });
  });
;

"use strict";

modulum('HVBoxLayoutEngine', ['DBoxLayoutEngine'],
  function(context, cls) {
    /**
     * @class HVBoxLayoutEngine
     * @memberOf classes
     * @extends classes.DBoxLayoutEngine
     */
    cls.HVBoxLayoutEngine = context.oo.Class(cls.DBoxLayoutEngine, function($super) {
      return /** @lends classes.HVBoxLayoutEngine.prototype */ {
        __name: "HVBoxLayoutEngine",

        // Default accessors
        _orientation: "vertical",
        _mainSizeGetter: "getHeight",
        _mainSizeSetter: "setHeight",
        _mainHasSizeGetter: "hasHeight",
        _mainStretch: "Y",
        _oppositeSizeGetter: "getWidth",
        _oppositeSizeSetter: "setWidth",
        _oppositeHasSizeGetter: "hasWidth",
        _oppositeStretch: "X",
        _boxClassSelector: ".gbc_VBoxWidget",

        /**
         * @inheritDoc
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._splitHints = {
            "vertical": [],
            "horizontal": []
          };
          this._referenceSplitHints = {
            "vertical": [],
            "horizontal": []
          };
        },

        /**
         * Change layout orientation
         * @param {String} orientation - "horizontal" or "vertical"
         * @param {Boolean} force - force relayout
         */
        setOrientation: function(orientation, force) {
          //check if changed to avoid relayout
          if (!force && this._orientation === orientation) {
            return;
          }

          this._orientation = orientation;
          // Changing default accessors
          this._mainSizeGetter = this._isVertical() ? "getHeight" : "getWidth";
          this._mainSizeSetter = this._isVertical() ? "setHeight" : "setWidth";
          this._mainHasSizeGetter = this._isVertical() ? "hasHeight" : "hasWidth";
          this._mainStretch = this._isVertical() ? "Y" : "X";
          this._oppositeSizeGetter = this._isVertical() ? "getWidth" : "getHeight";
          this._oppositeSizeSetter = this._isVertical() ? "setWidth" : "setHeight";
          this._oppositeHasSizeGetter = this._isVertical() ? "hasWidth" : "hasHeight";
          this._oppositeStretch = this._isVertical() ? "X" : "Y";
          this._boxClassSelector = this._isVertical() ? ".gbc_VBoxWidget" : ".gbc_HBoxWidget";

          this._widget.removeClass(this._isVertical() ? "gbc_HBoxWidget" : "gbc_VBoxWidget");
          this._widget.removeClass(this._isVertical() ? "g_HBoxLayoutEngine" : "g_VBoxLayoutEngine");
          this._widget.addClass(this._isVertical() ? "g_VBoxLayoutEngine" : "g_HBoxLayoutEngine");
          this._widget.addClass(this._isVertical() ? "gbc_VBoxWidget" : "gbc_HBoxWidget");

          // Handle splitters
          this._setSplitHints(this._getReferenceSplitHints().slice());

          // Reset layout for child widgets and HBox/VBox
          this._registeredWidgets.forEach(w => w.getLayoutInformation().getAvailable().reset());
          this._getLayoutInfo().getAvailable().reset();
          this._getLayoutInfo().getAllocated().reset();
          this._getLayoutInfo().resetChildrenStretch();
          this.invalidateMeasure();
          this.invalidateAllocatedSpace();
        },

        /**
         * @inheritDoc
         */
        initSplitHints: function(initial) {
          initial = initial || {
            "horizontal": [],
            "vertical": []
          };
          const refHorizontal = (initial.horizontal || []).map(function(item) {
            return isNaN(item) ? 0 : item;
          });
          const refVertical = (initial.vertical || []).map(function(item) {
            return isNaN(item) ? 0 : item;
          });
          this._referenceSplitHints = {
            horizontal: refHorizontal,
            vertical: refVertical,
          };
        },

        /**
         * Check if orientation is vertical
         * @return {boolean} true if vertical, false otherwise
         * @private
         */
        _isVertical: function() {
          return this._orientation === "vertical";
        },

        /**
         * Get hints, orientation dependant
         * @param {Number?} idx - index of the split part to get
         * @return {*} either a specific splitHints if idx given, or all Array
         * @private
         */
        _getSplitHints(idx) {
          if (typeof idx === "undefined") {
            return this._splitHints[this._orientation];
          } else {
            return this._splitHints[this._orientation][idx];
          }
        },

        /**
         * Set hints, orientation dependant
         * @param {Number?} idx - index of the split part to get
         * @param {*} value - either an array or a specific value
         * @private
         */
        _setSplitHints(idx, value) {
          if (typeof value === "undefined") {
            this._splitHints[this._orientation] = idx;
          } else {
            this._splitHints[this._orientation][idx] = value;
          }
        },

        /**
         * Get reference hints, orientation dependant
         * @param {Number?} idx - index of the split part to get
         * @return {*} either a specific refSplitHints if idx given, or all Array
         * @private
         */
        _getReferenceSplitHints(idx) {
          if (typeof idx === "undefined") {
            return this._referenceSplitHints[this._orientation];
          } else {
            return this._referenceSplitHints[this._orientation][idx];
          }
        },

        /**
         * Set reference hints, orientation dependant
         * @param {Number?} idx - index of the split part to get
         * @param {*} value - either an array or a specific value
         * @private
         */
        _setReferenceSplitHints(idx, value) {
          if (typeof value === "undefined") {
            this._referenceSplitHints[this._orientation] = idx;
          } else {
            this._referenceSplitHints[this._orientation][idx] = value;
          }
        },

        /**
         * @inheritDoc
         */
        _setItemClass: function(position, start, size) {
          // Vbox rule
          if (this._isVertical()) {
            this._styleRules[".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
              ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
                position + 1) +
              ")"] = {
              top: cls.Size.cachedPxImportant(start),
              height: cls.Size.cachedPxImportant(size)
            };
          } else {
            //HBOX rule
            const selector = ".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
              ">div>.containerElement>.g_BoxElement:nth-of-type(" + (position +
                1) + ")";
            const pos = cls.Size.cachedPxImportant(start);
            this._styleRules[selector] = {};
            this._styleRules[selector][this._widget.getStart()] = pos;
            this._styleRules[selector].width = cls.Size.cachedPxImportant(size);
          }
        },

        /**
         * @inheritDoc
         */
        _setItemOppositeClass: function(position) {
          if (this._isVertical()) {
            // VBox rules
            const vBoxSelector = ".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
              ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
                position + 1) +
              ")";
            this._styleRules[vBoxSelector].width = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getWidth());
          } else {
            // HBox rules
            const hBoxSelector = ".g_measured .gbc_HBoxWidget" + this._widget._getCssSelector() +
              ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
                position + 1) +
              ")";
            this._styleRules[hBoxSelector].height = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getHeight());
          }

        },

        /**
         * @inheritDoc
         */
        _applyMeasure: function(mainSize, oppositeSize) {
          this._styleRules[`.g_measured #w_${this._widget.getUniqueIdentifier()}.g_measureable`] = {
            height: (this._isVertical() ? mainSize : oppositeSize) + "px",
            width: (this._isVertical() ? oppositeSize : mainSize) + "px"
          };
          if (this._isVertical()) {
            this._getLayoutInfo().setMeasured(oppositeSize, mainSize);
          } else {
            this._getLayoutInfo().setMeasured(mainSize, oppositeSize);
          }
        },

        /**
         * @inheritDoc
         */
        _isStretched: function(widget) {
          if (this._isVertical()) {
            return widget.getLayoutEngine().isYStretched();
          } else {
            return widget.getLayoutEngine().isXStretched();
          }
        },

        /**
         * @inheritDoc
         */
        _setOppositeMaximalSize: function(widget, size) {
          let isSelfWidgetChildrenStretched;

          if (this._isVertical()) {
            isSelfWidgetChildrenStretched = widget === this._widget && this._widget.getLayoutInformation().isChildrenXStretched();
          } else {
            isSelfWidgetChildrenStretched = widget === this._widget && this._widget.getLayoutInformation().isChildrenYStretched();
          }

          return $super._setOppositeMaximalSize.call(this, widget, isSelfWidgetChildrenStretched ? cls.Size.maximal : size);
        }

      };
    });
  });
;

"use strict";

modulum('SplitLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class SplitLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.SplitLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.SplitLayoutEngine.prototype */ {
        __name: "SplitLayoutEngine",
        /**
         * registered children widgets
         * @type {classes.WidgetBase[]}
         * @protected
         */
        _registeredWidgets: null,
        /**
         * stylesheet id
         * @protected
         */
        _styleSheetId: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "boxLayout_" + widget.getUniqueIdentifier();
          this._registeredWidgets = [];
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          for (let i = this._registeredWidgets.length - 1; i > -1; i--) {
            const wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * Refresh the child widgets layout
         */
        refreshLayout: function() {
          const session = context.SessionService.getCurrent();
          let app = session && session.getCurrentApplication();
          if (app && app.layout) {
            app.scheduler.layoutCommand({
              resize: true
            });
          }
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          if (!(widget instanceof cls.SplitterWidget)) {
            if (this._registeredWidgets.indexOf(widget) === -1) {
              this._registeredWidgets.push(widget);
            }
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget);
        },

        /**
         * Get list of all registered widget being a SplitView item
         * @returns {classes.WidgetBase[]}
         */
        getRegisteredWidgets: function() {
          return this._registeredWidgets;
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const layoutInfo = this._getLayoutInfo();
          const availWidth = layoutInfo.getAvailable().getWidth();
          const availHeight = layoutInfo.getAvailable().getHeight();
          const decoratingWidth = layoutInfo.getDecorating().getWidth();
          const decoratingHeight = layoutInfo.getDecorating().getHeight();
          const width = availWidth - decoratingWidth;
          const height = availHeight - decoratingHeight;

          for (const element of this._registeredWidgets) {
            const widgetInfo = this._getLayoutInfo(element);
            widgetInfo.setAvailable(width, height);
            widgetInfo.setAllocated(width, height);
          }
          layoutInfo.setAllocated(width, height);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const layoutInfo = this._getLayoutInfo();

          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable>.splitViewContent"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px",
            top: layoutInfo.getDecoratingOffset().getHeight() + "px",
            left: layoutInfo.getDecoratingOffset().getWidth() + "px"
          };
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() +
            ".g_measureable>.splitViewContent>.containerElement"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        },
      };
    });
  });
;

"use strict";

modulum('VBoxLayoutEngine', ['DBoxLayoutEngine'],
  function(context, cls) {
    /**
     * @class VBoxLayoutEngine
     * @memberOf classes
     * @extends classes.DBoxLayoutEngine
     */
    cls.VBoxLayoutEngine = context.oo.Class(cls.DBoxLayoutEngine, function($super) {
      return /** @lends classes.VBoxLayoutEngine.prototype */ {
        __name: "VBoxLayoutEngine",
        _mainSizeGetter: "getHeight",
        _mainSizeSetter: "setHeight",
        _mainHasSizeGetter: "hasHeight",
        _mainStretch: "Y",
        _oppositeSizeGetter: "getWidth",
        _oppositeSizeSetter: "setWidth",
        _oppositeHasSizeGetter: "hasWidth",
        _oppositeStretch: "X",

        /**
         * @inheritDoc
         */
        _setItemClass: function(position, start, size) {
          this._styleRules[".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"] = {
            top: cls.Size.cachedPxImportant(start),
            height: cls.Size.cachedPxImportant(size)
          };
        },
        /**
         * @inheritDoc
         */
        _setItemOppositeClass: function(position) {
          this._styleRules[".g_measured .gbc_VBoxWidget" + this._widget._getCssSelector() +
            ">div>.containerElement>.g_BoxElement:nth-of-type(" + (
              position + 1) +
            ")"].width = cls.Size.cachedPxImportant(this._getLayoutInfo().getAllocated().getWidth());
        },

        /**
         * @inheritDoc
         */
        _applyMeasure: function(mainSize, oppositeSize) {
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            height: mainSize + "px",
            width: oppositeSize + "px"
          };
          this._getLayoutInfo().setMeasured(oppositeSize, mainSize);
        },

        /**
         * @inheritDoc
         */
        _isStretched: function(widget) {
          return widget.getLayoutEngine().isYStretched();
        },

        /**
         * @inheritDoc
         */
        _setOppositeMaximalSize: function(widget, size) {
          const isSelfWidgetChildrenStretched = widget === this._widget &&
            this._widget.getLayoutInformation().isChildrenXStretched();
          return $super._setOppositeMaximalSize.call(this, widget, isSelfWidgetChildrenStretched ? cls.Size.maximal : size);
        }
      };
    });
  });
;

"use strict";

modulum('FlowItemLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * Layout engine for items in flowing container
     * This is empty, just to use measurement mechanism of items
     * @class FlowItemLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FlowItemLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FlowItemLayoutEngine.prototype */ {
        __name: "FlowItemLayoutEngine",

      };
    });
  });
;

"use strict";

modulum('FlowLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * Layout engine for container that will flow items in continuous dropdown
     * Note that it should be applied to WidgetGroupBase widgets only
     * @class FlowLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FlowLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FlowLayoutEngine.prototype */ {
        __name: "FlowLayoutEngine",

        /** @type {Number} */
        _childrenWidth: 0,

        /** @type {Number} */
        _containerWidth: 0,

        /** @type {classes.FlowDecoratorWidget} **/
        _flowDecoratorWidget: null,

        /**
         * Define the widget used for flowing (usually 3dots)
         * @param {classes.FlowDecoratorWidget} flowDecoratorWidget
         */
        setFlowDecoratorWidget: function(flowDecoratorWidget) {
          this._flowDecoratorWidget = flowDecoratorWidget;
        },

        /**
         * Get the widget used for flowing
         * @return {classes.FlowDecoratorWidget}
         */
        getFlowDecoratorWidget: function() {
          return this._flowDecoratorWidget;
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);

          this._registerAnimationFrame(function() {
            this._registerAnimationFrame(function() {
              if (this._needRefresh()) { // No need to refresh everytime
                if (this._throttle) {
                  window.clearTimeout(this._throttle);
                }
                this._throttle = this._registerTimeout(function() {
                  this._refresh();
                  this._throttle = null;
                }.bind(this), 30);
              }
            }.bind(this));
          }.bind(this));
        },

        /**
         * Refresh the flowing items
         * @private
         */
        _refresh: function() {
          const containerWidth = this.getContainerWidth();
          const childrenTotalWidth = this.getChildrenWidth() + this.getFlowingChildrenWidth();
          // If the children width is more than the container width, we need to flow some children
          this._flowItems(childrenTotalWidth > containerWidth);
        },

        /**
         * Flow or unflow items
         * @param {Boolean} flow - true to flow items if necessary, false to unflow them
         * @private
         */
        _flowItems: function(flow) {
          const widget = this._widget;
          const flowDecoratorWidget = this.getFlowDecoratorWidget();
          const childrenWidth = this.getChildrenWidth();
          const containerWidth = this.getContainerWidth();

          flowDecoratorWidget.enable(flow);
          // Flow items after size calculation: add to the dropdown
          let currentChildrenWidth = this.getChildrenWidth(),
            children = null,
            currentChildWidth = 0,
            i = 0;
          if (containerWidth > childrenWidth) {
            children = flowDecoratorWidget.getFlowingChildren();
            currentChildWidth = children.length && children[i].getLayoutInformation().getRawMeasure().getWidth();
            while (i < children.length && (currentChildrenWidth + currentChildWidth) < containerWidth) {
              flowDecoratorWidget.flowChild(children[i], false); // unflow this child
              currentChildrenWidth += currentChildWidth;
              i++;
              currentChildWidth = children[i] && children[i].getLayoutInformation().getRawMeasure().getWidth();
            }
          } else {
            children = widget.getChildren().slice(0);
            i = children.length - 1;
            while (i >= 0 && currentChildrenWidth > containerWidth) {
              flowDecoratorWidget.flowChild(children[i], true); // flow this child
              currentChildrenWidth -= children[i].getLayoutInformation().getRawMeasure().getWidth();
              i--;
            }
          }
        },

        /**
         * Check if refresh is necessary
         * @return {boolean} true if it needs a refresh, false otherwise
         * @private
         */
        _needRefresh: function() {
          const currentChildrenWidth = this.getChildrenWidth() + this.getFlowingChildrenWidth();
          const currentContainerWidth = this.getContainerWidth();

          // No need to refresh if either of container and/or children total width did not change
          if (this._childrenWidth !== currentChildrenWidth || this._containerWidth !== currentContainerWidth) {
            // If changed, update those values
            this._childrenWidth = currentChildrenWidth;
            this._containerWidth = currentContainerWidth;
            return true;
          } else {
            return false;
          }
        },

        /**
         * Calculate the total width of the children
         * @return {*}
         */
        getChildrenWidth: function() {
          return this._widget.getChildren().reduce(function(prev, child) {
            return prev + child.getLayoutInformation().getRawMeasure().getWidth();
          }, 0);
        },

        /**
         * Calculate the total width of the children
         * @return {*}
         */
        getFlowingChildrenWidth: function() {
          return this._widget.getFlowDecoratorWidget().getFlowingChildren().reduce(function(prev, child) {
            return prev + child.getLayoutInformation().getRawMeasure().getWidth();
          }, 0);
        },

        /**
         * Calculate the container Width, take the 3dots icon into account
         * @return {number}
         */
        getContainerWidth: function() {
          // Modal case: get the previously set toolbar width
          let containerWidth = 0;
          if (this._widget.getWindowWidget() && this._widget.getWindowWidget().isModal) {
            containerWidth = this._widget.getFormWidget().getLayoutInformation().getToolbarAllocatedWidth() - this._widget
              .getDecoratorWidth();
          } else if (this._widget.getWindowWidget() && this._widget.getWindowWidget().getMenuWidget() && this._widget.getWindowWidget()
            .getMenuWidget().getLayoutInformation()) {
            containerWidth = this._widget.getFormWidget().getLayoutInformation().getRawMeasure().getWidth() +
              this._widget.getWindowWidget().getMenuWidget().getLayoutInformation().getRawMeasure().getWidth() -
              this._widget.getDecoratorWidth();
          } else {
            containerWidth = this._widget.getFormWidget().getLayoutInformation().getRawMeasure().getWidth() - this._widget
              .getDecoratorWidth();
          }
          return Math.ceil(containerWidth);
        },

      };
    });
  });
;

"use strict";

modulum('AccordionFolderLayoutEngine', ['FolderLayoutEngine'],
  /**
   * @param {gbc} context
   * @param {classes} cls
   */
  function(context, cls) {
    /**
     * @class AccordionFolderLayoutEngine
     * @memberOf classes
     * @extends classes.FolderLayoutEngine
     */
    cls.AccordionFolderLayoutEngine = context.oo.Class(cls.FolderLayoutEngine, function($super) {
      return /** @lends classes.AccordionFolderLayoutEngine.prototype */ {
        __name: "AccordionFolderLayoutEngine",

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          let decorationHeight = 0;
          let decorationWidth = 0;
          let pageDecorationHeight = 0;
          let pageDecorationWidth = 0;
          const visiblePageCount = this._widget.getVisiblePageCount();
          if (visiblePageCount > 0) {
            const pageWithDecorationElement = this._widget.getElement().child("gbc_AccordionElement");
            const pageWithoutDecorationElement = pageWithDecorationElement.child("gbc_AccordionPage");

            const oneTitleHeight = pageWithDecorationElement.clientHeight - pageWithoutDecorationElement.clientHeight;
            decorationHeight = visiblePageCount * oneTitleHeight;
            decorationWidth = pageWithDecorationElement.clientWidth - pageWithoutDecorationElement.clientWidth;

            const pageMargin = parseInt(context.ThemeService.getValue("gbc-AccordionFolderWidget-page-margin"), 10);

            pageDecorationWidth = pageMargin * 2;
            pageDecorationHeight = pageMargin * 2;
          }

          this._getLayoutInfo().setDecorating(
            this._widget.getElement().clientWidth - this._widget.getContainerElement().clientWidth + decorationWidth +
            pageDecorationWidth,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight + decorationHeight +
            pageDecorationHeight
          );

          for (const element of this._widget._children) {
            element.getLayoutInformation().setDecorating(
              pageDecorationWidth,
              pageDecorationHeight
            );
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);

          const visiblePageCount = this._widget.getVisiblePageCount();
          let pageHeight = 0;

          if (visiblePageCount > 0) {
            // fix height of current page (this is necessary for css animation (transition on height))
            pageHeight = this._widget.getCurrentPage().getLayoutInformation().getAvailable().getHeight();
            pageHeight = pageHeight + this._widget.getCurrentPage().getLayoutInformation().getDecorating().getHeight();
          }

          this._widget.setStyle({
            selector: ".gbc_AccordionPage.currentPage",
            appliesOnRoot: false
          }, {
            "height": pageHeight + "px"
          });
        },
      };
    });
  });
;

"use strict";

modulum('FolderLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class FolderLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FolderLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FolderLayoutEngine.prototype */ {
        __name: "FolderLayoutEngine",
        /**
         * stylesheet id
         */
        _styleSheetId: null,
        /**
         * padding to add on folder viewport (px)
         * @type {Number}
         */
        _padding: 8,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "folderLayout_" + widget.getUniqueIdentifier();
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          if (this._widget) {
            this._widget.addPagesInDom();
          }
        },

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * Returns only already layouted + new current page when lateRendering to true, otherwise returns all children
         */
        getRenderableChildren: function() {
          let renderable = $super.getRenderableChildren.call(this);
          if (this._widget._isLateRendering) {
            const alreadyRendered = renderable.filter(function(page) {
              return page.getLayoutEngine().isLayouted();
            });
            if (!alreadyRendered.contains(this._widget.getCurrentPage())) {
              alreadyRendered.push(this._widget.getCurrentPage());
            }
            renderable = alreadyRendered;
          }
          return renderable;
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget.getTabsTitlesHostElement) {
            const info = this._getLayoutInfo(),
              container = this._widget.getTabsTitlesHostElement().getBoundingClientRect();
            info.setTitlesContainerDeltaWidth(info.getRawMeasure().getWidth() - container.width);
            info.setTitlesContainerDeltaHeight(info.getRawMeasure().getHeight() - container.height);
          }
        },
        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const containerMargin = parseFloat(context.ThemeService.getValue("mt-tab-items-container-margin")) * 2;
          // We can't do element - containerElement because the containerElement does not grow when there are too many tabs (GBC-4069)
          // We add the containerElement's margin to avoid some unwanted overflow (GBC-4363, GBC-4392)
          const decorateX = this._widget.getElement().getBoundingClientRect().width - this._widget.getScroller().getTabsHost()
            .getBoundingClientRect().width + containerMargin;

          this._getLayoutInfo().setDecorating(
            decorateX,
            this._widget.getElement().clientHeight - this._widget.getContainerElement().clientHeight
          );
          this._getLayoutInfo().setDecoratingOffset(
            this._widget.getContainerElement().offsetLeft - this._widget.getElement().offsetLeft,
            this._widget.getContainerElement().offsetTop - this._widget.getElement().offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const layoutInfo = this._getLayoutInfo();
          let measureX = 0,
            measureY = 0,
            minX = 0,
            minY = 0,
            maxX = 0,
            maxY = 0;
          const decorateX = layoutInfo.getDecorating().getWidth(),
            decorateY = layoutInfo.getDecorating().getHeight();
          let preferredX = 0,
            preferredY = 0;

          const children = this._widget.getChildren();
          for (const element of children) {
            if (!element.isHidden()) {
              const widgetInfo = this._getLayoutInfo(element);
              measureX = Math.max(measureX, widgetInfo.getMeasured().getWidth());
              measureY = Math.max(measureY, widgetInfo.getMeasured().getHeight());
              minX = Math.max(minX, widgetInfo.getMinimal().getWidth());
              minY = Math.max(minY, widgetInfo.getMinimal().getHeight());
              maxX = Math.max(maxX, widgetInfo.getMaximal().getWidth());
              maxY = Math.max(maxY, widgetInfo.getMaximal().getHeight());
              preferredX = Math.max(preferredX, widgetInfo.getPreferred().getWidth());
              preferredY = Math.max(preferredY, widgetInfo.getPreferred().getHeight());
            }
          }
          layoutInfo.setMeasured(measureX + decorateX, measureY + decorateY);
          layoutInfo.setPreferred(Math.max(preferredX, measureX + decorateX), Math.max(preferredY, measureY + decorateY));
          layoutInfo.setMinimal(minX + decorateX, minY + decorateY);
          layoutInfo.setMaximal(maxX + decorateX, cls.Size.maximal);
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          const layoutInfo = this._getLayoutInfo(),
            children = this._widget.getChildren();
          for (const element of children) {
            const widgetInfo = this._getLayoutInfo(element);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(widgetInfo);
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(widgetInfo);
            }
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const layoutInfo = this._getLayoutInfo(),
            decorateX = layoutInfo.getDecorating().getWidth() + this._padding,
            decorateY = layoutInfo.getDecorating().getHeight(),
            children = this._widget.getChildren(),
            minx = Math.max(layoutInfo.getAvailable().getWidth(), layoutInfo.getMinimal().getWidth()),
            miny = Math.max(layoutInfo.getAvailable().getHeight(), layoutInfo.getMinimal().getHeight());
          for (const element of children) {
            if (!element.isHidden()) {
              const widgetInfo = this._getLayoutInfo(element);
              widgetInfo.setAvailable(
                minx - decorateX,
                miny - decorateY
              );
              widgetInfo.setAllocated(minx - decorateX, miny - decorateY);
            }
          }
          layoutInfo.setAllocated(minx, miny);
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            height: layoutInfo.getAllocated().getHeight() + "px",
            width: layoutInfo.getAllocated().getWidth() + "px"
          };
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable>.containerElement"] = {
            height: (layoutInfo.getAllocated().getHeight() - decorateY) + "px",
            width: (layoutInfo.getAllocated().getWidth() - decorateX) + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;

"use strict";

modulum('PageLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class PageLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.PageLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.PageLayoutEngine.prototype */ {
        __name: "PageLayoutEngine",

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);
          this._getLayoutInfo().setPreferred(0, 0);
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget._title) {
            const info = this._getLayoutInfo(),
              title = this._widget._title.getElement().getBoundingClientRect();
            info.setTitleMeasureWidth(title.width);
            info.setTitleMeasureHeight(title.height);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            const widgetInfo = this._getLayoutInfo(child);
            layoutInfo.setMeasured(widgetInfo.getMeasured().getWidth(), widgetInfo.getMeasured().getHeight());
            layoutInfo.setMinimal(widgetInfo.getMinimal().getWidth(), widgetInfo.getMinimal().getHeight());
            layoutInfo.setMaximal(widgetInfo.getMaximal().getWidth(), widgetInfo.getMaximal().getHeight());
            layoutInfo.setPreferred(widgetInfo.getPreferred().getWidth(), widgetInfo.getPreferred().getHeight());
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          const layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            const widgetInfo = this._getLayoutInfo(child);
            if (widgetInfo.isXStretched() || widgetInfo.isChildrenXStretched()) {
              layoutInfo.addChildrenStretchX(this._widget.getLayoutInformation());
            }
            if (widgetInfo.isYStretched() || widgetInfo.isChildrenYStretched()) {
              layoutInfo.addChildrenStretchY(this._widget.getLayoutInformation());
            }
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const layoutInfo = this._getLayoutInfo(),
            child = this._widget.getChildren()[0];
          if (child) {
            const widgetInfo = this._getLayoutInfo(child);
            widgetInfo.setAvailable(
              layoutInfo.getAvailable().getWidth(),
              layoutInfo.getAvailable().getHeight()
            );
            widgetInfo.setAllocated(
              layoutInfo.getAvailable().getWidth(),
              layoutInfo.getAvailable().getHeight()
            );
          }
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);
          if (this._widget.isVisible() && !this._widget.hasClass("currentPage")) {
            this._widget.addClass("currentPage");
          }
        }

      };
    });
  });
;

"use strict";

modulum('TabbedContainerLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class TabbedContainerLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.TabbedContainerLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.TabbedContainerLayoutEngine.prototype */ {
        __name: "TabbedContainerLayoutEngine",

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          $super.DOMMeasure.call(this);
          if (this._widget.getTabsTitlesHostElement) {
            const info = this._getLayoutInfo(),
              container = this._widget.getTabsTitlesHostElement().getBoundingClientRect();
            info.setTitlesContainerDeltaWidth(info.getRawMeasure().getWidth() - container.width);
            info.setTitlesContainerDeltaHeight(info.getRawMeasure().getHeight() - container.height);
          }
        }
      };
    });
  });
;

"use strict";

modulum('FormLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class FormLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.FormLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.FormLayoutEngine.prototype */ {
        __name: "FormLayoutEngine",
        _initialRenderSize: null,
        /**
         * Auto overflow mode. Active when the form is taller than the browser viewport
         * @type {boolean}
         */
        _autoOverflowMode: false,
        /**
         * stylesheet id
         */
        _styleSheetId: null,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "formLayout_" + widget.getUniqueIdentifier();
        },
        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._initialRenderSize = null;
          this._autoOverflowMode = false;
          const modal = this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getModal();
          if (modal) {
            modal.resetLayout();
            modal._hasBeenSized = false;
          }
        },
        _getMinHintWidth: function() {
          const layoutInfo = this._getLayoutInfo();
          return cls.CharSize.translate(layoutInfo.getMinSizeHint().getWidth(), layoutInfo.getCharSize().getWidthM(),
            layoutInfo.getCharSize().getWidth0());
        },
        _getMinHintHeight: function() {
          const layoutInfo = this._getLayoutInfo();
          return cls.Size.translate(layoutInfo.getMinSizeHint().getHeight(), layoutInfo.getCharSize().getHeight());
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          const modal = this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getModal();
          if (modal) {
            const element = this._widget.getElement();
            if (!this._initialRenderSize) {
              this._initialRenderSize = {
                x: element.offsetWidth,
                y: element.offsetHeight
              };
            }
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const windowWidget = this._widget.getWindowWidget();
          if (windowWidget?.isModal) {
            // need a little extra space reserved as decoration for mobile (font size increase?) to avoid mini scrollbars appearing in Modal middle container
            const extraMargins = window.isMobile() ? context.ThemeService.getValue("gbc-ModalWidget-margin-ratio") * 30 : 0;
            const menuContainers = windowWidget.getMenuContainers();
            const menusXWidth = menuContainers.left.offsetWidth + menuContainers.right.offsetWidth,
              menusYHeight = menuContainers.top.offsetHeight + menuContainers.bottom.offsetHeight;
            const titleHeight = windowWidget.getModal().getHeader().offsetHeight,
              footerHeight = windowWidget.getModal().getFooter().offsetHeight;
            const decorateHeight = titleHeight + footerHeight + menusYHeight + extraMargins,
              decorateWidth = menusXWidth + extraMargins;
            this._getLayoutInfo().setDecorating(decorateWidth, decorateHeight);
          }
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          if (this._widget.getParentWidget().isModal) {
            this._measureModal();
          } else {
            this._measure();
          }
        },
        _measure: function() {
          const layoutInfo = this._getLayoutInfo();
          // set form dom size (offsetWidth/offsetHeight) as MEASURED
          layoutInfo.setMeasured(
            layoutInfo.getRawMeasure().getWidth(true),
            layoutInfo.getRawMeasure().getHeight(true)
          );
          // transfer form measured size to child group as available size (to be potentially used later on as allocated size for child group children)
          const childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
          if (childInfo) {
            const measured = layoutInfo.getMeasured();
            childInfo.wouldOverflowContainerIfNeeded(true);
            // will be overriden in adjustMeasure, is it needed here ?
            childInfo.setAvailable(measured.getWidth(), measured.getHeight());
          }
        },
        _measureModal: function() {
          const layoutInfo = this._getLayoutInfo(),
            width = this._getMinHintWidth(),
            height = this._getMinHintHeight();

          // set modal form min size as MINIMAL and MEASURED (is it needed ?)
          layoutInfo.setMinimal(width, height);
          layoutInfo.setMeasured(width, height);

          const availViewport = this._widget.getUserInterfaceWidget()?.getContainerElement()?.getBoundingClientRect();

          const measuredWidth = availViewport ? availViewport.width : 0;
          const measuredHeight = availViewport ? availViewport.height : 0;
          const decorationWidth = layoutInfo.getDecorating().getWidth(true);
          const decorationHeight = layoutInfo.getDecorating().getHeight(true);

          // set modal form available size with application measured size (modal viewport basically)
          // check to remove
          layoutInfo.setAvailable(
            measuredWidth - decorationWidth,
            measuredHeight - decorationHeight
          );
          const childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
          if (childInfo) {
            childInfo.setAvailable(
              measuredWidth - decorationWidth,
              measuredHeight - decorationHeight
            );
          }

        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function(lastInvalidated, layoutApplicationService) {
          const windowWidget = this._widget.getWindowWidget(),
            isInModal = windowWidget && windowWidget.isModal;
          if (isInModal) {
            this._adjustMeasureModal();
          } else {
            this._adjustMeasure();
          }
        },
        _adjustMeasure: function() {
          const windowWidget = this._widget.getWindowWidget();
          const parentLayoutInformation = windowWidget.getLayoutInformation();
          const childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);

          if (childInfo) {
            // flag child container as overflowable
            childInfo.wouldOverflowContainerIfNeeded(true);
            // if window is sizable, we take form measured size, otherwise we take child group measured size
            const measure = parentLayoutInformation.isSizable() ? this._getLayoutInfo().getMeasured() : childInfo.getMeasured();
            // if child group measured size is bigger than form measured size, set "willScroll" as true
            const willXScroll = childInfo.getMeasured().getWidth() > measure.getWidth();
            const willYScroll = childInfo.getMeasured().getHeight() > measure.getHeight();

            // set form measured size as available size on child group minus scrollbar size if child group will scroll
            childInfo.setAvailable(
              measure.getWidth() - (willYScroll ? window.scrollBarSize : 0),
              measure.getHeight() - (willXScroll ? window.scrollBarSize : 0)
            );

            // if window is sizable : if child group minimal height is bigger than form measured height, then flag form as autoOverflowMode
            if (parentLayoutInformation.isSizable()) {
              const minimal = childInfo.getMinimal();
              if (minimal.getHeight(true) > measure.getHeight(true)) {
                if (!this._statuses.adjusted) {
                  this._autoOverflowMode = true;
                }
              }
            }
          }
        },
        _adjustMeasureModal: function() {
          const childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
          if (childInfo) {
            const windowWidget = this._widget.getWindowWidget();
            const childMeasure = childInfo.getMeasured();
            childInfo.wouldOverflowContainerIfNeeded(true);
            const modal = windowWidget.getModal();
            const childPreferred = childInfo.getPreferred();
            let sizedX = 0,
              sizedY = 0;

            if (modal._hasBeenSized) {
              const childMinimal = childInfo.getMinimal(),
                sizingInfo = modal._sizingPositions;
              sizedX = sizingInfo.size.x - sizingInfo.decoration.x;
              sizedY = sizingInfo.size.y - sizingInfo.decoration.y;

              // set modal form measured size with : max between child group preferred size (.PER defined size), child group min size and manual size (why not always take manual size when it has been sized ?)
              const formMeasuredWidth = Math.max(childPreferred.getWidth(true), sizedX - window.scrollBarSize, childMinimal.getWidth(
                true));
              const formMeasuredHeight = Math.max(childPreferred.getHeight(true), sizedY - window.scrollBarSize, childMinimal
                .getHeight(
                  true));
              this._getLayoutInfo().setMeasured(formMeasuredWidth, formMeasuredHeight);
            }
            const measuredX = Math.max(childPreferred.getWidth(true), childMeasure.getWidth(true), this._getLayoutInfo().getMeasured()
              .getWidth(true));
            const measuredY = Math.max(childPreferred.getHeight(true), childMeasure.getHeight(true), this._getLayoutInfo().getMeasured()
              .getHeight(true));

            const formAvailable = this._getLayoutInfo().getAvailable();

            const willXScroll = measuredX > formAvailable.getWidth();
            const willYScroll = measuredY > formAvailable.getHeight();

            const availableX = (willXScroll ? formAvailable.getWidth() - window.scrollBarSize : measuredX);
            const availableY = (willYScroll ? formAvailable.getHeight() - window.scrollBarSize : measuredY);

            // set child available with max between form measured, child preferred, child measured if size doesn't exceed form available size, otherwise take form available size
            childInfo.setAvailable((sizedX || availableX), (sizedY || availableY));

            // if child height is going to overflow and generates vertical scrollbars in all case,
            // then flag autoOverflowMode to allow stretchable child to use their preferred size instead of their minimal size
            const minimal = childInfo.getMinimal();
            if (minimal.getHeight(true) > childInfo.getAvailable().getHeight(true)) {
              if (!this._statuses.adjusted) {
                this._autoOverflowMode = true;
              }
            }

          }
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          const parentWidget = this._widget.getParentWidget(),
            isInModal = parentWidget && parentWidget.isModal,
            modal = parentWidget && parentWidget.getModal();

          if (isInModal) {
            const childInfo = this._getLayoutInfo(this._widget.getChildren()[0]);
            if (modal) {
              modal._sizingPositions.contentMin = {
                x: Math.max(childInfo.getMinimal().getWidth(true), this._getMinHintWidth()),
                y: Math.max(childInfo.getMinimal().getHeight(true), this._getMinHintHeight())
              };
            }
          }
        },

        /**
         * @inheritDoc
         */
        notifyLayoutApplied: function() {
          $super.notifyLayoutApplied.call(this);
          this._onNotified();
        },

        _onNotified: function() {
          const widget = this._widget,
            windowWidget = widget && widget.getWindowWidget();
          if (windowWidget) {
            if (windowWidget.isModal) {
              this._notifyModal();
            } else {
              this._notify();
            }
          }
        },

        _notify: function() {
          const style = {};
          let overflownX = false,
            overflownY = false;
          const widget = this._widget,
            windowWidget = widget && widget.getWindowWidget(),
            element = widget.getElement();
          if (widget) {
            // need to check : if disabled: don't do that, but if visible behind modal, do that!
            if (windowWidget && !windowWidget._disabled) {
              const measured = widget.getLayoutInformation().getMeasured(),
                childWidget = widget.getChildren() && widget.getChildren()[0],
                childAllocated = childWidget && childWidget.getLayoutInformation().getAllocated(),
                childAllocatedWidth = childAllocated ? childAllocated.getWidth() : 0,
                childAllocatedHeight = childAllocated ? childAllocated.getHeight() : 0,
                dWidth = measured.getWidth() - childAllocatedWidth,
                dHeight = measured.getHeight() - childAllocatedHeight;
              style["#w_" + this._widget.getUniqueIdentifier() + ".g_measureable>.containerElement>.gbc_FormWidget_scrollkeeper"] = {
                height: (childAllocated && childAllocated.hasHeight(true)) ? cls.Size.cachedPxImportant(childAllocated.getHeight()) : null
              };
              context.styler.appendStyleSheet(style, this._styleSheetId, true, this.getLayoutSheetId());

              overflownX = dWidth < -0.9;
              overflownY = dHeight < -0.9;

              // Case where Webkit Scrollbars are used
              if (overflownY &&
                dWidth > 0 &&
                gbc.ThemeService.getValue("theme-webkit-scrollbars-global-enable") &&
                'WebkitAppearance' in document.documentElement.style) {
                overflownX = dWidth < window.scrollBarSize + 1;
              }

            }
            element
              .toggleClass("notOverflownX", !overflownX)
              .toggleClass("notOverflownY", !overflownY)
              .toggleClass("overflownX", overflownX)
              .toggleClass("overflownY", overflownY);
          }
        },
        _notifyModal: function() {
          const widget = this._widget,
            element = widget.getElement(),
            layoutInformation = widget.getLayoutInformation(),
            windowWidget = widget.getWindowWidget(),
            modal = windowWidget.getModal(),
            modalElement = modal.getElement(),
            modalpane = modalElement && modalElement.child("mt-dialog-pane"),
            modalcontent = modalpane && modalpane.child("mt-dialog-content");
          if (modalcontent) {
            const deltaWidth = modalpane.offsetWidth - modalElement.offsetWidth,
              deltaHeight = modalpane.offsetHeight - modalElement.offsetHeight,
              menuContainers = windowWidget.getMenuContainers();
            if (window.browserInfo.isSafari) {
              element.addClass("safariMeasure");
            }
            const measure = layoutInformation.getMeasured(),
              firstChild = widget.getChildren()[0],
              childInfo = firstChild && firstChild.getLayoutInformation(),
              childMeasure = childInfo && childInfo.getMeasured(),

              referenceWidth = modal._hasBeenSized ? 0 : childInfo.getPreferred().getWidth(true),
              referenceHeight = modal._hasBeenSized ? 0 : childInfo.getPreferred().getHeight(true);

            const width = Math.max(referenceWidth,
              childMeasure && childMeasure.getWidth() || (element.clientWidth - (deltaWidth > 0 ? deltaWidth : 0)),
              this._getMinHintWidth()
            );
            measure.setWidth(width);
            const height = Math.max(referenceHeight,
              childMeasure && childMeasure.getHeight() || (element.clientHeight - (deltaHeight > 0 ? deltaHeight : 0)),
              this._getMinHintHeight()
            );
            measure.setHeight(height);
            if (window.browserInfo.isSafari) {
              this._widget.getElement().removeClass("safariMeasure");
            }

            const menusXWidth = Math.max(0, menuContainers.left.offsetWidth + menuContainers.right.offsetWidth - 1),
              minWidth = this._getMinHintWidth(),
              minHeight = this._getMinHintHeight();
            const minStyle = {};
            minStyle[".g_measured .gbc_ModalWidget #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
              "min-width": cls.Size.cachedPxImportant(minWidth),
              "min-height": cls.Size.cachedPxImportant(minHeight)
            };
            context.styler.appendStyleSheet(minStyle, this._styleSheetId, true, this.getLayoutSheetId());

            const modalContentWidth = modalcontent.offsetWidth - menusXWidth;
            const contentMaxWidth = Math.max(measure.getWidth() + window.scrollBarSize + menusXWidth, this._getMinHintWidth());
            const calculatedWidth = (modal._hasBeenSized ? modalContentWidth : contentMaxWidth);
            this._widget.getLayoutInformation().setToolbarAllocatedWidth(calculatedWidth);

            if (windowWidget._toolBarWidget) {
              windowWidget._toolBarWidget.setStyle({
                "width": calculatedWidth + "px"
              });
            }
            if (modal) {
              modal.setMeasuredInfo(this._getLayoutInfo().getMeasured());
              modal.ensureInViewPort();
            }

            modalElement.removeClass('g_needLayout');
          }
        },

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          const invalidated = !invalidation || this._invalidatedMeasure < invalidation;
          $super.invalidateMeasure.call(this, invalidation);
          if (invalidated) {
            this.invalidateAllocatedSpace(this._invalidatedMeasure);
          }
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          const invalidated = !invalidation || this._invalidatedAllocatedSpace < invalidation;
          $super.invalidateAllocatedSpace.call(this, invalidation);
          if (invalidated) {
            this.invalidateMeasure(this._invalidatedAllocatedSpace);
          }
        },

        /**
         * @return {boolean} true when the form is taller than the browser viewport
         */
        isAutoOverflowActivated: function() {
          return this._autoOverflowMode;
        },

        /**
         * @inheritDoc
         */
        needMeasureSwitching: function() {
          return false;
        },

        /**
         * @inheritDoc
         */
        needMeasure: function() {
          return true;
        }
      };
    });
  });
;

"use strict";

modulum('FormLayoutInformation', ['LayoutInformation'],
  function(context, cls) {
    /**
     * @class FormLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     */
    cls.FormLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.FormLayoutInformation.prototype */ {
        __name: "FormLayoutInformation",
        /**
         * Min size hint (minWidth, minHeight)
         * @type {classes.Size}
         */
        _minSizeHint: null,

        /** @type {Number} */
        _toolbarAllocatedWidth: 0,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._minSizeHint = new cls.Size();
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._minSizeHint.reset();
        },

        /**
         *
         * @returns {classes.Size}
         */
        getMinSizeHint: function() {
          return this._minSizeHint;
        },

        /**
         *
         * @param {number} width
         * @param {number} height
         */
        setMinSizeHint: function(width, height) {
          this._minSizeHint.setWidth(width);
          this._minSizeHint.setHeight(height);
        },

        /**
         * Set width allocated for toolbar
         * @param {Number} width - width of the allocated space
         */
        setToolbarAllocatedWidth: function(width) {
          this._toolbarAllocatedWidth = width;
        },

        /**
         * Get width allocated for toolbar
         * @return {number}
         */
        getToolbarAllocatedWidth: function() {
          return this._toolbarAllocatedWidth;
        }
      };
    });
  });
;

"use strict";

modulum('GridDimensionManager',
  function(context, cls) {
    /**
     * Determine one dimension unit of a grid (e.g. column or line)
     * @class GridDimensionElement
     * @memberOf classes
     */
    cls.GridDimensionElement = context.oo.Class(function() {
      return /** @lends classes.GridDimensionElement.prototype */ {
        __name: "GridDimensionElement",
        /**
         * the position of this dimensionElement
         * @type {number}
         */
        position: 0,

        /**
         * Minimal mandatory size (without gaps) of this dimensionElement
         * @type {number}
         */
        intrinsicSize: 0,

        /**
         * Preferred size (without gaps) of this dimensionElement
         * @type {number}
         */
        hintSize: 0,

        /**
         * Maximal size (without gaps) of this dimensionElement
         * @type {number}
         */
        maxSize: 0,

        /**
         * Minimal size (without gaps) of this dimensionElement
         * @type {number}
         */
        minSize: 0,

        /**
         * Maximum bonus to apply to this dimensionElement when grid stretches
         * @type {number}
         */
        maxBonus: 0,

        /**
         * Maximum malus to apply to this dimensionElement when grid shrinks
         * @type {number}
         */
        maxMalus: 0,

        /**
         * Minimal size of gap before this dimensionElement
         * @type {number}
         */
        minimalBeforeGap: 0,
        /**
         * Minimal size of gap after this dimensionElement
         * @type {number}
         */
        minimalAfterGap: 0,
        /**
         * Size amount that is eventually added to the intrinsicSize when grid stretches/shrinks
         * @type {number}
         */
        bonusSize: 0,
        /**
         * Actual size of gap before this dimensionElement
         * @type {number}
         */
        beforeGap: 0,
        /**
         * Actual size of gap after this dimensionElement
         * @type {number}
         */
        afterGap: 0,
        /**
         * list of slots that starts on this dimensionElement
         * @type {classes.GridDimensionSlot[]}
         */
        slots: null,
        /**
         * Actual extra size of gap before this dimensionElement
         * @type {number}
         */
        extraBeforeGap: 0,
        /**
         * Actual extra size of gap after this dimensionElement
         * @type {number}
         */
        extraAfterGap: 0,
        /**
         * Incremental index to count number of unstretchable slots on this dimensionElement
         * @type {number}
         */
        unstretchable: 0,
        /**
         * Whether os not this dimensionElement is stretchable (i.e. one of its slots is)
         * @type {boolean}
         */
        stretchable: false,

        /**
         * @constructs
         * @param {number} position position of this dimensionElement
         */
        constructor: function(position) {
          this.position = position;
          this.slots = [];
        },

        /**
         * Returns a string representing the object
         * @returns {string}
         */
        toString: function() {
          let str = "position: " + this.position;
          str += "\nintrinsicSize: " + this.intrinsicSize;
          str += "\nhintSize: " + this.hintSize;
          str += "\nmaxSize: " + this.maxSize;
          str += "\nminSize: " + this.minSize;
          str += "\nmaxBonus: " + this.maxBonus;
          str += "\nmaxMalus: " + this.maxMalus;
          str += "\nminimalBeforeGap: " + this.minimalBeforeGap;
          str += "\nminimalAfterGap: " + this.minimalAfterGap;
          str += "\nbonusSize: " + this.bonusSize;
          str += "\nbeforeGap: " + this.beforeGap;
          str += "\nafterGap: " + this.afterGap;
          str += "\nextraBeforeGap: " + this.extraBeforeGap;
          str += "\nunstretchable: " + this.unstretchable;
          str += "\nstretchable: " + this.stretchable;
          str += "\n----------------";
          str += "\ngetSize(true, true): " + this.getSize(true, true);
          str += "\nslots.length: " + this.slots.length;

          return str;
        },

        /**
         * reset all information of this dimensionElement
         * @param {boolean} [swipeGaps] true to swipe gaps
         * @param {boolean} [resetIntrinsicSize] true to reset intrinsic size
         */
        resetSize: function(swipeGaps, resetIntrinsicSize) {
          this.unstretchable = 0;
          this.stretchable = false;
          this.bonusSize = 0;
          this.maxBonus = 0;
          this.maxMalus = 0;
          if (resetIntrinsicSize) {
            this.intrinsicSize = 0;
            this.hintSize = 0;
            this.maxSize = 0;
            this.minSize = 0;
          }
          if (swipeGaps) {
            this.resetGaps();
            this.updateGaps();
          }
        },
        /**
         * reset gaps
         */
        resetGaps: function() {
          this.beforeGap = 0;
          this.minimalBeforeGap = 0;
          this.afterGap = 0;
          this.minimalAfterGap = 0;
        },
        /**
         * Determine whether the grid would render or not
         * @return {boolean} true if it will render
         * @private
         */
        _shouldRender: function() {
          let i = 0;
          const len = this.slots.length;
          for (; i < len; i++) {
            if (this.slots[i].displayed) {
              return true;
            }
          }
          return false;
        },

        /**
         * Get the total gap before this dimensionElement
         * @return {number} the total gap before this dimensionElement
         */
        getBeforeGap: function() {
          return this._shouldRender() ? this.beforeGap + this.extraBeforeGap : 0;
        },

        /**
         * Get the total gap after this dimensionElement
         * @return {number} the total gap after this dimensionElement
         */
        getAfterGap: function() {
          return this._shouldRender() ? this.afterGap + this.extraAfterGap : 0;
        },
        /**
         * Get the computed total size of this dimensionElement
         * @param {boolean} [withBeforeGap] add total before gap
         * @param {boolean} [withAfterGap] add total after gap
         * @return {number} the computed total size of this dimensionElement
         */
        getSize: function(withBeforeGap, withAfterGap) {
          return this.intrinsicSize + this.bonusSize + (withBeforeGap ? this.beforeGap + this.extraBeforeGap : 0) + (
            withAfterGap ? this.afterGap + this.extraAfterGap : 0);
        },

        /**
         * attach a slot to this dimensionElement
         * @param {classes.GridDimensionSlot} slot slot to attach
         */
        attach: function(slot) {
          let insertIndex = 0;
          const size = this.slots.length,
            slotSize = slot.getSize();
          for (; insertIndex < size && this.slots[insertIndex].getSize() < slotSize;) {
            insertIndex++;
          }
          this.slots.add(slot, insertIndex);
          this.updateGaps();
        },

        /**
         * detach a slot from this dimensionElement
         * @param {classes.GridDimensionSlot} slot slot to detach
         */
        detach: function(slot) {
          const index = this.slots.indexOf(slot);
          if (index >= 0) {
            this.slots.splice(index, 1);
          }
          this.updateGaps();
        },

        /**
         * update the gaps depending on attached slots
         */
        updateGaps: function() {
          this.resetGaps();
          this.extraBeforeGap = 0;
          this.extraAfterGap = 0;
          let i = 0;
          const len = this.slots.length;
          for (; i < len; i++) {
            const slot = this.slots[i];
            if (slot.displayed && slot.getPosition() === this.position) {
              this.extraBeforeGap = Math.max(this.extraBeforeGap, slot.extraBeforeGap);
              this.beforeGap = this.minimalBeforeGap = Math.max(this.minimalBeforeGap, slot.minimalBeforeGap);
            }
            if (slot.displayed && slot.getLastPosition() === this.position) {
              this.extraAfterGap = Math.max(this.extraAfterGap, slot.extraAfterGap);
              this.afterGap = this.minimalAfterGap = Math.max(this.minimalAfterGap, slot.minimalAfterGap);
            }
          }
        },

        /**
         * adjust the intrinsic size given a new size
         * @param size new size to manage
         */
        adjustIntrinsicSize: function(size) {
          this.intrinsicSize = Math.max(this.intrinsicSize, size);
        },

        /**
         * adjust the preferred size given a new size
         * @param size new size to manage
         */
        adjustHintSize: function(size) {
          this.hintSize = Math.max(this.hintSize, size);
        },

        /**
         * adjust the maximal size given a new size
         * @param size new size to manage
         */
        adjustMaxSize: function(size) {
          if (this.maxSize !== cls.Size.maximal) {
            this.maxSize = size === cls.Size.maximal || this.maxSize === 0 ? size : Math.min(this.maxSize, size);
          }
        },

        /**
         * adjust the minimal size given a new size
         * @param size new size to manage
         */
        adjustMinSize: function(size) {
          this.minSize = Math.max(this.minSize, size);
        },

        /**
         * destroy all slots
         */
        destroy: function() {
          while (this.slots.length) {
            this.slots.pop().destroy();
          }
        }
      };
    });
  });
;

"use strict";

modulum('GridDimensionManager',
  function(context, cls) {
    /**
     *
     * slots:             [       ]   [           ]
     * elements (unit): |_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
     * @class GridDimensionManager
     * @memberOf classes
     */
    cls.GridDimensionManager = context.oo.Class(function() {
      return /** @lends classes.GridDimensionManager.prototype */ {
        __name: "GridDimensionManager",

        /**
         * handle registration for theme change
         * @type {HandleRegistration}
         */
        _themeWatcher: null,

        /**
         * dimension elements
         * @type {classes.GridDimensionElement[]}
         */
        dimensionElements: null,

        /**
         * gutter size (minimal space between elements)
         * @type {number}
         */
        _gutterSize: 0,

        /**
         * empty element size
         * @type {number}
         */
        _emptyElementSize: 0,

        /**
         * will force uniform distribution while stretching
         * true for X dimension (columns) false for Y dimension (rows)
         * @type {boolean}
         */
        _uniformDistribution: false,

        /**
         * slots
         * @type {classes.GridDimensionSlot[]}
         */
        slots: null,

        /**
         * dimension size
         * @type {number}
         */
        _size: 0,

        /**
         * is dimension meant to stretch
         * @type {boolean}
         */
        stretchable: false,

        /**
         * Managed dimension ('X' or 'Y')
         * @type {string}
         */
        _dimension: 'X',

        /**
         * @constructs
         * @param {?boolean} [uniformDistribution] will force uniform distribution while stretching
         * @param {string} dimension Specify the X or Y dimension managed
         */
        constructor: function(uniformDistribution, dimension = 'X') {
          this._dimension = dimension;
          this._uniformDistribution = Boolean(uniformDistribution);
          this._gutterSize = this._dimension === 'X' ?
            context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
          this._themeWatcher = context.ThemeService.whenThemeChanged(function() {
            this._gutterSize = this._dimension === 'X' ?
              context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
          }.bind(this));
          this.slots = [];
          this.dimensionElements = [];
        },

        /**
         * get the dimension size
         * @return {number} the dimension size
         */
        getSize: function() {
          return this._size;
        },

        /**
         * Get the computed preferred size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed preferred size
         */
        getHintSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          let total = 0;
          let totalGaps = 0;
          for (let i = from; i <= to; i++) {
            total += this.dimensionElements[i].hintSize;
            totalGaps +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (!total) {
            if (this.getMaxSize() === cls.Size.maximal) {
              total = totalGaps;
            }
          } else {
            total += totalGaps;
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * Get the computed maximum size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed maximum size
         */
        getMaxSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          let total = 0;
          for (let i = from; i <= to; i++) {
            total += this.dimensionElements[i].maxSize +
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * Get the computed minimum size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed minimum size
         */
        getMinSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          let total = 0;
          for (let i = from; i <= to; i++) {
            total += this.dimensionElements[i].minSize +
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return Number.isNaN(total) ? 0 : total;
        },
        /**
         * Get the computed size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed size
         */
        getCalculatedSize: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          from = Object.isNumber(from) ? from : 0;
          to = Object.isNumber(to) ? to : this._size - 1;
          includeFirstBeforeGap = includeFirstBeforeGap !== false;
          includeLastAfterGap = includeLastAfterGap !== false;

          let total = 0;
          for (let i = from; i <= to; i++) {
            total +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((this.dimensionElements[i].intrinsicSize + this.dimensionElements[i].bonusSize) || this._emptyElementSize) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          if (includeLastAfterGap && from === 0 && to === (this._size - 1) && total > this._gutterSize) {
            total -= this._gutterSize;
          }
          return total;
        },

        /**
         * set a new dimension size
         * @param {number} newSize the new size
         * @param {boolean} [destroyDimensionElements] destroy current dimension elements
         */
        setSize: function(newSize, destroyDimensionElements) {
          const size = this._size;
          if (newSize > size) {
            for (let addingIndex = this.dimensionElements.length; addingIndex < newSize; addingIndex++) {
              this.dimensionElements[addingIndex] = new cls.GridDimensionElement(addingIndex);
            }
          }
          if (destroyDimensionElements) {
            for (let i = newSize; i < this.dimensionElements.length; i++) {
              this.dimensionElements[i].destroy();
            }
            this.dimensionElements.length = newSize;
          }
          this._size = newSize;
        },

        /**
         * Ensure given size
         * @param {number} size the size to ensure
         */
        ensureSize: function(size) {
          if (this.getSize() < size) {
            this.setSize(size);
          }
        },

        /**
         * Set the dimension as stretchable
         * @param stretchable the stretchable state
         */
        setStretchable: function(stretchable) {
          this.stretchable = stretchable;
        },

        /**
         * reset elements
         * @param {boolean} [swipeGaps] true to swipe gaps
         * @param {boolean} [resetIntrinsicSizes] true to reset intrinsic sizes
         */
        resetDimensionSizes: function(swipeGaps, resetIntrinsicSizes) {
          const size = this.getSize();
          for (let i = 0; i < size; i++) {
            this.dimensionElements[i].resetSize(swipeGaps, resetIntrinsicSizes);
          }
        },

        /**
         * update MaxSize of all elements
         */
        updateMaxSizes: function() {
          let size = this.getSize();
          for (let i = 0; i < size; i++) {
            this.dimensionElements[i].maxSize = 0;
          }
          size = this.slots.length;
          for (let i = 0; i < size; i++) {
            const slot = this.slots[i];
            const slotSize = slot.getSize();
            const pos = slot.getPosition();
            const lastPos = slot.getLastPosition();
            if (slot.displayed) {
              const elementMaxSize = slot.maxSize / slotSize;
              for (let position = pos; position <= lastPos; position++) {
                const dimensionElement = this.dimensionElements[position];
                dimensionElement.adjustMaxSize(elementMaxSize);
              }
            }
          }
        },

        /**
         * Add slot usage on the dimension
         * @param {classes.GridDimensionSlot} slot
         */
        addSlot: function(slot) {
          this.ensureSize(slot.getLastPosition() + 1);
          let insertIndex = 0;
          const size = this.slots.length;
          for (; insertIndex < size && this.slots[insertIndex].getPosition() < slot.getPosition();) {
            insertIndex++;
          }
          for (; insertIndex < size && this.slots[insertIndex].getSize() < slot.getSize();) {
            insertIndex++;
          }
          this.slots.add(slot, insertIndex);
          slot.attach(this);
          for (let i = slot.getPosition(); i <= slot.getLastPosition(); i++) {
            this.dimensionElements[i].attach(slot);
          }
        },
        /**
         * Remove slot usage on the dimension
         * @param {classes.GridDimensionSlot} slot
         */
        removeSlot: function(slot) {
          for (let i = slot.getPosition(); i <= slot.getLastPosition(); i++) {
            this.dimensionElements[i].detach(slot);
          }
          slot.detach();
          const index = this.slots.indexOf(slot);
          if (index >= 0) {
            this.slots.splice(index, 1);
          }
          return slot;
        },

        /**
         * update gaps of all elements
         */
        updateGaps: function() {
          const size = this.getSize();
          for (let i = 0; i < size; i++) {
            this.dimensionElements[i].updateGaps();
          }
        },
        /**
         * compute intrinsic sizes (natural measured sizes)
         */
        updateIntrinsicSizes: function() {
          this.resetDimensionSizes(true, true);

          const size = this.slots.length;
          for (let i = 0; i < size; i++) {
            const slot = this.slots[i];
            const slotSize = slot.getSize();
            const pos = slot.getPosition();
            const lastPos = slot.getLastPosition();
            if (slot.displayed) {
              const totalGapSizes = this.getGapSizing(pos, lastPos);
              const elementMaxSize = slot.maxSize / slotSize;
              const elementMinSize = slot.minSize / slotSize;

              const lambdaUnitSize = Math.max((slot.desiredMinimalSize - totalGapSizes) / slotSize, elementMinSize);

              for (let position = pos; position <= lastPos; position++) {
                const dimensionElement = this.dimensionElements[position];
                dimensionElement.adjustMinSize(elementMinSize);
                dimensionElement.adjustMaxSize(elementMaxSize);
                dimensionElement.adjustIntrinsicSize(lambdaUnitSize);
              }
            }
          }
        },
        /**
         * adjust elements stretchability and preferred sizes
         */
        updateStretchability: function() {
          const size = this.slots.length;
          for (let i = 0; i < size; i++) {
            const slot = this.slots[i];
            const slotSize = slot.getSize();
            const pos = slot.getPosition();
            const lastPos = slot.getLastPosition();

            if (slot.displayed) {
              const totalGapSizes = this.getGapSizing(pos, lastPos);
              const slotHint = (slot.hintSize - totalGapSizes) / slotSize;
              for (let position = pos; position <= lastPos; position++) {
                const dimensionElement = this.dimensionElements[position];
                if (slot.stretchable) {
                  dimensionElement.adjustHintSize(slotHint);
                  dimensionElement.stretchable = true;
                } else {
                  if (!slot.opportunisticStretchable) {
                    dimensionElement.unstretchable++;
                  }
                }
              }
            }
          }
        },

        /**
         * Not uniform distribution used for Y dimension (rows)
         * TODO Explain what is the meaning of "not uniform distribution"
         * @param {number} sizeToDistribute - the total difference to add
         * @param {number} totalWeights - total weight that determines how to distribute space
         * @returns {boolean}
         * @private
         */
        _updateBonusSizeNotUniformDistribution: function(sizeToDistribute, totalWeights) {
          let result = false;
          const unstretchable = this._searchMinUnstretchableInAllElements();
          const stretchableElements = [];

          // - get all stretchable elements
          // - compute maxBonus size for each element
          for (let i = 0; i < this._size; i++) {
            const dimensionElement = this.dimensionElements[i];
            if (dimensionElement.stretchable && (dimensionElement.unstretchable ===
                unstretchable)) {
              stretchableElements.push(dimensionElement);
              dimensionElement.maxBonus = dimensionElement.maxSize - dimensionElement.intrinsicSize;
            }
          }

          // Compute bonusSize for each element
          const len = stretchableElements.length;
          for (let i = 0; i < len; i++) {
            const dimensionElement = stretchableElements[i];
            const weight = dimensionElement.intrinsicSize / totalWeights;
            dimensionElement.bonusSize = weight * sizeToDistribute;
            result = true;
          }

          return result;
        },

        /**
         * Distribute space to add to elements (when grid needs to stretch)
         * Space is first distribute only on minimum size elements which new size that can not be greater than other elements.
         * If there is still some space to distribute we redo again the distribution on the minimum size elements
         * and again until there is no space to distribute.
         * @param {number} sizeToDistribute the total difference to add
         * @return {boolean}
         */
        _updateBonusSizeUniformDistribution: function(sizeToDistribute) {
          let result = false;
          const stretchableElements = [];
          let localSizeToDistribute = sizeToDistribute;

          // loop until there will be no more space to distribute
          // if there is 1 pixel or less no need to distribute
          while (localSizeToDistribute > 1) {

            // check if we have already computed the array of stretchable elements
            const stretchableElementAlreadyComputed = stretchableElements.length > 0;
            const elements = stretchableElementAlreadyComputed ? stretchableElements : this.dimensionElements;

            // minimum size of stretchable elements
            let minElementsSize = Number.POSITIVE_INFINITY;
            // number of elements with a minimum size
            let nbMinElementSize = 0;
            // minimum size 2 is the minimum immediately greater than minElementsSize
            let min2ElementsSize = Number.POSITIVE_INFINITY;

            // go through all stretchable elements
            const elementsSize = elements.length;
            for (let i = 0; i < elementsSize; i++) {
              const dimensionElement = elements[i];
              if (dimensionElement.stretchable) {
                const elementRealSize = dimensionElement.intrinsicSize + dimensionElement.bonusSize;
                if (elementRealSize === minElementsSize) {
                  nbMinElementSize++;
                } else if (elementRealSize < minElementsSize) {
                  min2ElementsSize = minElementsSize;
                  minElementsSize = elementRealSize;
                  nbMinElementSize = 1;

                } else if (elementRealSize < min2ElementsSize) {
                  min2ElementsSize = elementRealSize;
                }
                if (!stretchableElementAlreadyComputed) {
                  stretchableElements.push(dimensionElement);

                  // TODO what is the purpose of maxBonus variable
                  dimensionElement.maxBonus = dimensionElement.maxSize - dimensionElement.intrinsicSize;
                }
              }
            }

            // maximum size that we can add to min elements to reach the size of min elements 2
            const maxBonusForMinElements = min2ElementsSize === minElementsSize ? Number.POSITIVE_INFINITY : (min2ElementsSize -
              minElementsSize);

            // bonusSize will be the space that will be distributed on all min elements
            const bonusSize = Math.min(localSizeToDistribute / nbMinElementSize, maxBonusForMinElements);

            // Update bonusSize for each min element
            const len = stretchableElements.length;
            for (let i = 0; i < len; i++) {
              const dimensionElement = stretchableElements[i];
              const elementRealSize = dimensionElement.intrinsicSize + dimensionElement.bonusSize;
              if (elementRealSize === minElementsSize) { // if it's a min elements, add bonusSize
                dimensionElement.bonusSize += bonusSize;
                // update sizeToDistribute
                localSizeToDistribute -= bonusSize;
                result = true;
              }
            }
          }

          return result;
        },

        /**
         * Distribute space to add to elements (when grid needs to stretch)
         * @param {number} sizeToDistribute the total difference to add
         * @return {boolean}
         */
        updateBonusSize: function(sizeToDistribute) {
          let result = false;
          const totalWeights = this._getTotalWeights();
          if (totalWeights > 0) {

            if (this._uniformDistribution) {
              // uniform distribution used for X dimension (columns)
              result = this._updateBonusSizeUniformDistribution(sizeToDistribute);
            } else {
              // not uniform distribution used for Y dimension (rows)
              result = this._updateBonusSizeNotUniformDistribution(sizeToDistribute, totalWeights);
            }

          } else {
            // TODO explain this case
            if (this.stretchable && this._size > 0) {
              for (let i = 0; i < this._size; i++) {
                const dimensionElement = this.dimensionElements[i];
                dimensionElement.bonusSize = sizeToDistribute / this._size;
                result = true;
              }
            }
          }
          return result;
        },

        /**
         * Distribute space to remove to elements (when grid needs to shrink)
         * Distribution is proportional to intrinsicSize of each element
         * It means an element with a bigger intrinsicSize get more malusSize than a smaller element
         * @param sizeToDistribute the total difference to remove
         * @return {boolean}
         */
        updateMalusSize: function(sizeToDistribute) {
          let result = false;
          const totalWeights = this._getTotalWeights();
          if (totalWeights > 0) {
            const unstretchable = this._uniformDistribution ? Number.POSITIVE_INFINITY : this._searchMinUnstretchableInAllElements();

            // - get all stretchable elements
            // - compute maxMalus size for each element
            // - compute totalLocalWeights
            let totalLocalWeights = 0;
            const stretchableElements = [];
            let i;
            for (i = 0; i < this._size; i++) {
              const dimensionElement = this.dimensionElements[i];
              if (dimensionElement.stretchable && (this._uniformDistribution || (dimensionElement.unstretchable ===
                  unstretchable))) {
                stretchableElements.push(dimensionElement);
                totalLocalWeights += dimensionElement.intrinsicSize;
                dimensionElement.maxMalus = dimensionElement.intrinsicSize - dimensionElement.minSize;
              }
            }
            stretchableElements.sort(function(a, b) {
              return a.maxMalus < b.maxMalus ? -1 : (a.maxMalus > b.maxMalus ? 1 : 0);
            });

            // Compute malusSize for each element
            const len = stretchableElements.length;
            for (i = 0; i < len; i++) {
              const dimensionElement = stretchableElements[i];
              const delta = -sizeToDistribute * (dimensionElement.intrinsicSize / totalLocalWeights);
              if (dimensionElement.maxMalus > delta) {
                dimensionElement.bonusSize = -delta;
                sizeToDistribute += delta;
                totalLocalWeights -= dimensionElement.intrinsicSize;
              } else {
                dimensionElement.bonusSize = -dimensionElement.maxMalus;
                sizeToDistribute += dimensionElement.maxMalus;
                totalLocalWeights -= dimensionElement.intrinsicSize;
              }
              result = true;
            }
          } else {
            let maxMalus;
            if (this.stretchable && this._size > 0) {
              for (let e = 0; e < this._size; e++) {
                const dimensionElement = this.dimensionElements[e];
                dimensionElement.bonusSize = sizeToDistribute / this._size;
                maxMalus = dimensionElement.intrinsicSize - dimensionElement.minSize;
                if ((-dimensionElement.bonusSize) > maxMalus) {
                  dimensionElement.bonusSize = -maxMalus;
                }
                result = true;
              }
            }
          }
          return result;
        },

        /**
         * compute all slots positions and sizes to apply to css
         * @return {{regularPositions: Array, regular: {}}}
         */
        render: function() {
          const result = {
            regularPositions: [],
            regular: {}
          };
          for (const slot of this.slots) {
            if (!result.regular[slot.getPosition()]) {
              result.regularPositions.push(slot.getPosition());
              result.regular[slot.getPosition()] = {
                position: this.getCalculatedSize(0, slot.getPosition() - 1, true, true),
                beforeGap: this.dimensionElements[slot.getPosition()].beforeGap,
                regularLengths: [],
                lengths: {},
                lengthsWithGaps: {}
              };
            }
            if (!Object.isNumber(result.regular[slot.getPosition()].lengths[slot.getSize()])) {
              result.regular[slot.getPosition()].regularLengths.push(slot.getSize());
              result.regular[slot.getPosition()].lengths[slot.getSize()] = this.getCalculatedSize(slot.getPosition(), slot
                .getLastPosition(),
                false, false);
              result.regular[slot.getPosition()].lengthsWithGaps[slot.getSize()] = this.getCalculatedSize(slot.getPosition(),
                slot.getLastPosition(),
                true, true);
            }
          }
          return result;
        },

        /**
         * get the total weight that determines how to distribute space
         * @return {number} the total weight in the dimension
         * @private
         */
        _getTotalWeights: function() {
          let result = 0;
          const unstretchable = this._uniformDistribution ? Number.POSITIVE_INFINITY : this._searchMinUnstretchableInAllElements();

          for (let i = 0; i < this._size; i++) {
            const dimensionElement = this.dimensionElements[i];
            if (dimensionElement.stretchable && (this._uniformDistribution || (dimensionElement.unstretchable === unstretchable))) {
              result += dimensionElement.intrinsicSize;
            }
          }
          return result;
        },

        /**
         * Search the min unstretchable value for all elements
         * @returns {number} min unstretchable
         * @private
         */
        _searchMinUnstretchableInAllElements: function() {
          let unstretchable = Number.POSITIVE_INFINITY;
          for (let i = 0; i < this._size; i++) {
            const dimensionElement = this.dimensionElements[i];
            if (dimensionElement.stretchable) {
              unstretchable = Math.min(unstretchable, dimensionElement.unstretchable);
            }
          }
          return unstretchable;
        },

        /**
         * Get the computed total gap size
         * @param {number} [from] from position (or start)
         * @param {number} [to] to position (or end)
         * @param {boolean} [includeFirstBeforeGap] true to include first before gap
         * @param {boolean} [includeLastAfterGap] true to include last after gap
         * @return {number} the computed total gap size
         */
        getGapSizing: function(from, to, includeFirstBeforeGap, includeLastAfterGap) {
          let total = 0;
          for (let i = from; i <= to; i++) {
            total +=
              ((i !== from || includeFirstBeforeGap) ? this.dimensionElements[i].getBeforeGap() : 0) +
              ((i !== to || includeLastAfterGap) ? this.dimensionElements[i].getAfterGap() : 0);
          }
          return total;
        },

        /**
         * destroy
         */
        destroy: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.setSize(0, true);
        }
      };
    });
  });
;

"use strict";

modulum('GridDimensionSlot',
  function(context, cls) {
    /**
     *
     * @class GridDimensionSlot
     * @memberOf classes
     */
    cls.GridDimensionSlot = context.oo.Class(function() {
      return /** @lends classes.GridDimensionSlot.prototype */ {
        __name: "GridDimensionSlot",

        /**
         * handle registration for theme change
         * @type {HandleRegistration}
         */
        _themeWatcher: null,

        /**
         * default minimal gap to apply before this slot
         * @type {number}
         */
        defaultMinimalBeforeGap: 0,

        /**
         * default minimal gap to apply after this slot
         * @type {number}
         */
        defaultMinimalAfterGap: 0,

        /**
         * starting position of the slot
         * @type {number}
         */
        position: 0,

        /**
         * slot size
         * @type {number}
         */
        size: 0,

        /**
         * Desired slot size (calculated in pixels from raw width/height hint)
         * @type {number}
         */
        desiredMinimalSize: 0,

        /**
         * Minimal slot size
         * @type {number}
         */
        minSize: 0,

        /**
         * Maximal slot size
         * @type {number}
         */
        maxSize: 0,

        /**
         * Preferred slot size
         * @type {number}
         */
        hintSize: 0,

        /**
         * Owner
         * @type {classes.GridDimensionManager}
         */
        dimensionManager: null,

        /**
         * minimal gap to apply before this slot
         * @type {number}
         */
        minimalBeforeGap: 0,

        /**
         * minimal gap to apply after this slot
         * @type {number}
         */
        minimalAfterGap: 0,

        /**
         * extra gap to apply before this slot
         * @type {number}
         */
        extraBeforeGap: 0,

        /**
         * extra gap to apply after this slot
         * @type {number}
         */
        extraAfterGap: 0,

        /**
         * is this slot stretchable?
         * @type {boolean}
         */
        stretchable: false,

        /**
         * is this slot opportunistic stretchable?
         * (e.g. will only stretch if some other slot sharing dimension elements stretches)
         * @type {boolean}
         */
        opportunisticStretchable: false,

        /**
         * is this slot displayed?
         * @type {boolean}
         */
        displayed: true,

        /**
         * Managed dimension ('X' or 'Y')
         * @type {string}
         */
        _dimension: null,

        /**
         * @constructs
         * @param {number} position the position
         * @param {number} size the size
         * @param {string} dimension Specify the X or Y dimension managed
         */
        constructor: function(position, size, dimension) {
          this._dimension = dimension || 'X';
          this.position = position;
          this.size = size;
          this.defaultMinimalAfterGap = this._dimension === 'X' ?
            context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
          this.minimalAfterGap = this._dimension === 'X' ?
            context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
        },

        /**
         * Returns a string representing the object
         * @returns {string}
         */
        toString: function() {
          let str = "defaultMinimalBeforeGap: " + this.defaultMinimalBeforeGap;
          str += "\ndefaultMinimalAfterGap: " + this.defaultMinimalAfterGap;
          str += "\nposition: " + this.position;
          str += "\nsize: " + this.size;
          str += "\ndesiredMinimalSize: " + this.desiredMinimalSize;
          str += "\nminSize: " + this.minSize;
          str += "\nmaxSize: " + this.maxSize;
          str += "\nhintSize: " + this.hintSize;
          str += "\nminimalBeforeGap: " + this.minimalBeforeGap;
          str += "\nminimalAfterGap: " + this.minimalAfterGap;
          str += "\nextraBeforeGap: " + this.extraBeforeGap;
          str += "\nextraAfterGap: " + this.extraAfterGap;
          str += "\nextraBeforeGap: " + this.extraBeforeGap;
          str += "\nstretchable: " + this.stretchable;
          str += "\nopportunisticStretchable: " + this.opportunisticStretchable;
          str += "\ndisplayed: " + this.displayed;
          str += "\n_dimension: " + this._dimension;

          return str;
        },

        /**
         * reset the slot
         * @param {number} position the new position
         * @param {number} size the new size
         * @return {classes.GridDimensionSlot} this
         */
        reset: function(position, size) {
          this.position = position;
          this.size = size;
          return this;
        },

        /**
         * get the first position of the slot
         * @return {number} the first position of the slot
         */
        getPosition: function() {
          return this.position;
        },
        /**
         * get the last position of the slot
         * @return {number} the last position of the slot
         */
        getLastPosition: function() {
          return this.position + this.size - 1;
        },

        /**
         * get the size of the slot
         * @return {number} the size of the slot
         */
        getSize: function() {
          return this.size;
        },

        /**
         * set the desired minimal size
         * @param {number} desiredMinimalSize calculated in pixels from raw width/height hint
         */
        setDesiredMinimalSize: function(desiredMinimalSize) {
          this.desiredMinimalSize = desiredMinimalSize || 0;
        },

        /**
         * Set the slot as stretchable
         * @param stretchable stretchable value
         */
        setStretchable: function(stretchable) {
          this.stretchable = stretchable;
        },

        /**
         * Set the slot as opportunistic stretchable
         * @param stretchable stretchable value
         */
        setOpportunisticStretchable: function(stretchable) {
          this.opportunisticStretchable = stretchable;
        },

        /**
         * Set maximal size
         * @param maxSize maximal size
         */
        setMaxSize: function(maxSize) {
          this.maxSize = maxSize;
        },

        /**
         * Set minimal size
         * @param minSize minimal size
         */
        setMinSize: function(minSize) {
          this.minSize = minSize;
        },

        /**
         * Set preferred size
         * @param hintSize preferred size
         */
        setHintSize: function(hintSize) {
          this.hintSize = hintSize;
        },

        /**
         * Set displayed state
         * @param displayed displayed state
         */
        setDisplayed: function(displayed) {
          this.displayed = displayed;
        },

        /**
         * set minimum gap before the slot
         * @param {number} value the minimum gap before the slot
         */
        setMinimumBeforeGap: function(value) {
          if (Object.isNumber(value)) {
            this.minimalBeforeGap = value;
          } else {
            this.minimalBeforeGap = this.defaultMinimalBeforeGap;
          }
        },

        /**
         * set minimum gap after the slot
         * @param {number} value the minimum gap after the slot
         */
        setMinimumAfterGap: function(value) {
          if (Object.isNumber(value)) {
            this.minimalAfterGap = value;
          } else {
            this.minimalAfterGap = this.defaultMinimalAfterGap;
          }
        },
        /**
         * attach to dimension manager
         * @param {classes.GridDimensionManager} dimensionManager dimension manager
         */
        attach: function(dimensionManager) {
          this.dimensionManager = dimensionManager;
          if (this._themeWatcher) {
            this._themeWatcher();
          }
          this._themeWatcher = context.ThemeService.whenThemeChanged(function() {
            this.defaultMinimalAfterGap = this._dimension === 'X' ?
              context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
            this.minimalAfterGap = this._dimension === 'X' ?
              context.ThemeService.getGutterX() : context.ThemeService.getGutterY();
          }.bind(this));
        },

        /**
         * detach from dimension manager
         */
        detach: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.dimensionManager = null;
        },

        /**
         * destroy
         */
        destroy: function() {
          if (this._themeWatcher) {
            this._themeWatcher();
            this._themeWatcher = null;
          }
          this.dimensionManager = null;
        }
      };
    });
  });
;

"use strict";

modulum('GridLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class GridLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.GridLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.GridLayoutEngine.prototype */ {
        __name: "GridLayoutEngine",
        /**
         * list of registered children widgets
         * @type {classes.WidgetBase[]}
         */
        _registeredWidgets: null,
        /**
         * map of registered grid dimension slots
         * @type {object<string, ?classes.XYDimensionSlot>}
         */
        _registeredSlots: null,
        /**
         * map of widgets handle registration
         * @type {object<Number, HandleRegistration>}
         */
        _registeredWidgetWatchers: null,
        /**
         * X dimension sub engine
         * @type {classes.GridLayoutEngineX}
         */
        _xspace: null,
        /**
         * Y dimension sub engine
         * @type {classes.GridLayoutEngineY}
         */
        _yspace: null,

        /**
         * stylesheet id
         */
        _styleSheetId: null,
        /**
         * set to false to avoid to render children
         * @type {boolean}
         */
        _willRenderContent: true,
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._styleSheetId = "gridLayout_" + widget.getUniqueIdentifier();
          this._registeredWidgets = [];
          this._registeredSlots = {};
          this._registeredWidgetWatchers = {};
          this._xspace = new cls.GridLayoutEngineX(widget);
          this._yspace = new cls.GridLayoutEngineY(widget);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          for (let w in this._registeredWidgetWatchers) {
            const watch = this._registeredWidgetWatchers[w];
            if (watch) {
              watch();
            }
          }
          for (let i = this._registeredWidgets.length - 1; i > -1; i--) {
            const wi = this._registeredWidgets[i];
            wi.destroy();
            this.unregisterChild(wi);
          }
          for (let s in this._registeredSlots) {
            const slot = this._registeredSlots[s];
            if (slot) {
              slot.x.destroy();
              slot.y.destroy();
            }
          }
          this._xspace.destroy();
          this._yspace.destroy();
          this._xspace = null;
          this._yspace = null;
          this._registeredSlots = null;
          this._registeredWidgetWatchers = null;
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * Specifies whether to render content or not
         * @return {boolean}  true if content has to be rendered
         */
        willRenderContent: function() {
          const parentEngine = this._widget && this._widget.getParentWidget() &&
            this._widget.getParentWidget().isInstanceOf(cls.GroupWidget) &&
            this._widget.getParentWidget().getLayoutEngine(),
            hasWillRenderContent = parentEngine && parentEngine.willRenderContent;
          return this._willRenderContent && (!hasWillRenderContent || parentEngine.willRenderContent());
        },
        /**
         * set hint size
         * @param {number|string} widthHint the width
         * @param {number|string} heightHint the height
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 1 : widthHint,
            ((typeof(heightHint) === "undefined") || heightHint === null || heightHint === "") ? 1 : heightHint
          );
        },

        /**
         *
         * @param {classes.LayoutInformation} widgetLayoutInformation
         * @param {?{x:classes.GridDimensionSlot, y:classes.GridDimensionSlot}} slotRecycle
         * @return {classes.GridDimensionSlot}
         */
        getSlotX: function(widgetLayoutInformation, slotRecycle) {
          const gridX = widgetLayoutInformation.getGridX(),
            gridWidth = widgetLayoutInformation.getGridWidth();
          let result = null;
          if (slotRecycle && slotRecycle.x) {
            result = slotRecycle.x.reset(gridX, gridWidth);
          } else {
            result = new cls.GridDimensionSlot(gridX, gridWidth, 'X');
          }
          return result;
        },

        /**
         *
         * @param {classes.LayoutInformation} widgetLayoutInformation
         * @param {?{x:classes.GridDimensionSlot, y:classes.GridDimensionSlot}} slotRecycle
         * @return {classes.GridDimensionSlot}
         */
        getSlotY: function(widgetLayoutInformation, slotRecycle) {
          const gridY = widgetLayoutInformation.getGridY(),
            gridHeight = widgetLayoutInformation.getGridHeight();
          let result = null;
          if (slotRecycle && slotRecycle.y) {
            result = slotRecycle.y.reset(gridY, gridHeight);
          } else {
            result = new cls.GridDimensionSlot(gridY, gridHeight, 'Y');
          }
          return result;
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          let slotRecycle = null;
          if (this._registeredWidgets.indexOf(widget) >= 0) {
            slotRecycle = this.unregisterChild(widget);
          }
          const widgetLayoutInformation = widget.getLayoutInformation(),
            id = widget.getUniqueIdentifier();
          if (!this._registeredSlots[id]) {
            this._registeredWidgets.push(widget);
            const slotX = this.getSlotX(widgetLayoutInformation, slotRecycle);
            const slotY = this.getSlotY(widgetLayoutInformation, slotRecycle);
            this._registeredSlots[id] = {
              x: this._xspace.registerSlot(slotX),
              y: this._yspace.registerSlot(slotY)
            };
            this._registeredWidgetWatchers[id] = widgetLayoutInformation.onGridInfoChanged(this.registerChild.bind(this, widget));
          }
        },

        hasChangesInSlot: function(widget) {
          const id = widget.getUniqueIdentifier(),
            widgetLayoutInformation = widget.getLayoutInformation();
          if (this._registeredSlots[id]) {
            const slotX = this._registeredSlots[id].x;
            const slotY = this._registeredSlots[id].y;
            return slotX.getPosition() !== widgetLayoutInformation.getGridX() ||
              slotX.getSize() !== widgetLayoutInformation.getGridWidth() ||
              slotY.getPosition() !== widgetLayoutInformation.getGridY() ||
              slotY.getSize() !== widgetLayoutInformation.getGridHeight();
          } else {
            return true;
          }
        },
        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          const id = widget.getUniqueIdentifier();
          if (this._registeredSlots[id]) {
            const slotRecycle = {};
            this._registeredWidgetWatchers[id]();
            this._registeredWidgetWatchers[id] = null;
            const index = this._registeredWidgets.indexOf(widget);
            if (index >= 0) {
              this._registeredWidgets.splice(index, 1);
            }
            slotRecycle.x = this._xspace.unregisterSlot(this._registeredSlots[id].x);
            slotRecycle.y = this._yspace.unregisterSlot(this._registeredSlots[id].y);
            this._registeredSlots[id] = null;
            return slotRecycle;
          }
          return null;
        },

        /**
         * @inheritDoc
         */
        beforeLayout: function() {
          const layoutInformation = this._getLayoutInfo();
          let i = 0,
            currentVirtualY = 0,
            widget = null,
            widgetLayoutInformation = null,
            list = null;
          const hasChanges = false;
          if (this._registeredWidgets.length) {
            for (; i < this._registeredWidgets.length; i++) {
              widget = this._registeredWidgets[i];
              widgetLayoutInformation = widget && widget.getLayoutInformation();
              if (widgetLayoutInformation) {
                widgetLayoutInformation.setChildOfGridAutomaticStack(layoutInformation.isStacked(), true);
              }
            }
            if (layoutInformation.isStacked()) {
              list = this._registeredWidgets.slice().sort(function(a, b) {
                const ax = a.getLayoutInformation().getRawInformation().getPosX(),
                  ay = a.getLayoutInformation().getRawInformation().getPosY(),
                  bx = b.getLayoutInformation().getRawInformation().getPosX(),
                  by = b.getLayoutInformation().getRawInformation().getPosY();
                return Number.compare(ay, by) || Number.compare(ax, bx);
              });
              for (i = 0; i < list.length; i++) {
                widget = list[i];
                widgetLayoutInformation = widget && widget.getLayoutInformation();
                if (widgetLayoutInformation) {
                  widgetLayoutInformation.setVirtualGridY(currentVirtualY, true);
                  currentVirtualY += widgetLayoutInformation.getGridHeight();
                }
              }
            }

            list = this._registeredWidgets.slice();
            for (i = 0; i < list.length; i++) {
              widget = list[i];
              /*   hasChanges = hasChanges || this.hasChangesInSlot(widget);
               }
               if(hasChanges) {
                 for (i = 0; i < list.length; i++) {
                   widget = list[i];*/
              this.registerChild(widget);
              //  }
            }
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const layoutInformation = this._getLayoutInfo();
          const element = this._widget.getElement(),
            container = this._widget.getContainerElement();
          layoutInformation.setDecorating(
            element.clientWidth - container.clientWidth,
            element.clientHeight - container.clientHeight
          );
          layoutInformation.setDecoratingOffset(
            container.offsetLeft - element.offsetLeft,
            container.offsetTop - element.offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const layoutInformation = this._getLayoutInfo();
          if (this._registeredWidgets.length) {
            for (const widget of this._registeredWidgets) {
              const widgetLayoutInformation = widget.getLayoutInformation(),
                owningGrid = widgetLayoutInformation.getOwningGrid(),
                isOwningGridDisplayed = !owningGrid || owningGrid.isVisible(),
                isOwningGridNoContentRender = !owningGrid || owningGrid.getLayoutEngine().willRenderContent(),
                isDisplayed = widget.isVisible() && isOwningGridDisplayed,
                widgetSlot = this._registeredSlots[widget.getUniqueIdentifier()];

              if (isDisplayed && isOwningGridNoContentRender && this.willRenderContent()) {
                widgetSlot.x.setDisplayed(true);
                widgetSlot.y.setDisplayed(true);
                widgetSlot.x.setMinimumBeforeGap();
                widgetSlot.x.setMinimumAfterGap();
                widgetSlot.y.setMinimumBeforeGap();
                widgetSlot.y.setMinimumAfterGap();
                const measured = widgetLayoutInformation.getMeasured(),
                  maxSize = widgetLayoutInformation.getMaximal(),
                  minSize = widgetLayoutInformation.getMinimal();

                widgetSlot.x.setMinSize(minSize.getWidth());
                widgetSlot.y.setMinSize(minSize.getHeight());
                widgetSlot.x.setMaxSize(maxSize.getWidth());
                widgetSlot.y.setMaxSize(maxSize.getHeight());

                widgetSlot.x.setDesiredMinimalSize(measured.getWidth() || widgetLayoutInformation.forcedMinimalWidth);
                widgetSlot.y.setDesiredMinimalSize(measured.getHeight() || widgetLayoutInformation.forcedMinimalHeight);

                if (widget.isGridChildrenInParent && widget.isGridChildrenInParent()) {
                  widgetSlot.x.setMinimumBeforeGap(widgetLayoutInformation.getDecoratingOffset().getWidth());
                  widgetSlot.x.setMinimumAfterGap(widgetLayoutInformation.getDecorating().getWidth() - widgetLayoutInformation
                    .getDecoratingOffset()
                    .getWidth());
                  widgetSlot.y.setMinimumBeforeGap(widgetLayoutInformation.getDecoratingOffset().getHeight());
                  widgetSlot.y.setMinimumAfterGap(widgetLayoutInformation.getDecorating().getHeight() - widgetLayoutInformation
                    .getDecoratingOffset()
                    .getHeight());
                } else {
                  widgetSlot.x.setMinimumBeforeGap(null);
                  widgetSlot.x.setMinimumAfterGap(null);
                  widgetSlot.y.setMinimumBeforeGap(null);
                  widgetSlot.y.setMinimumAfterGap(null);
                }

                const extra = widgetLayoutInformation._extraGap;
                if (extra) {
                  widgetSlot.x.extraBeforeGap = Math.max(widgetSlot.x.extraBeforeGap, extra.beforeX || 0);
                  widgetSlot.x.extraAfterGap = Math.max(widgetSlot.x.extraAfterGap, extra.afterX || 0);
                  widgetSlot.y.extraBeforeGap = Math.max(widgetSlot.y.extraBeforeGap, extra.beforeY || 0);
                  widgetSlot.y.extraAfterGap = Math.max(widgetSlot.y.extraAfterGap, extra.afterY || 0);
                }
              } else {
                widgetSlot.x.setDisplayed(false);
                widgetSlot.y.setDisplayed(false);
              }
            }
            layoutInformation.setMeasured(this._xspace.adjustMeasure() + layoutInformation.getDecorating().getWidth(true),
              this._yspace.adjustMeasure() + layoutInformation.getDecorating().getHeight(true));
            layoutInformation.setMinimal(
              this._xspace.getMinSize() + layoutInformation.getDecorating().getWidth(true),
              this._yspace.getMinSize() + layoutInformation.getDecorating().getHeight(true));
            layoutInformation.setMaximal(this._xspace.getMaxSize(), this._yspace.getMaxSize());
          } else {
            layoutInformation.setMeasured(
              layoutInformation.getDecorating().getWidth(true),
              layoutInformation.getDecorating().getHeight(true)
            );
            layoutInformation.setMinimal(layoutInformation.getMeasured().getWidth(), layoutInformation.getMeasured().getHeight());
            layoutInformation.setMaximal(layoutInformation.getMeasured().getWidth(), layoutInformation.getMeasured().getHeight());
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          const layoutInformation = this._getLayoutInfo();
          if (this._registeredWidgets.length) {
            layoutInformation.resetChildrenStretch();
            for (const widget of this._registeredWidgets) {
              const widgetLayoutEngine = widget.getLayoutEngine(),
                widgetLayoutInformation = widget.getLayoutInformation(),
                owningGrid = widgetLayoutInformation.getOwningGrid(),
                isOwningGridDisplayed = !owningGrid || owningGrid.isVisible(),
                isOwningGridNoContentRender = !owningGrid || owningGrid.getLayoutEngine().willRenderContent(),
                isDisplayed = widget.isVisible() && isOwningGridDisplayed,
                widgetSlot = this._registeredSlots[widget.getUniqueIdentifier()];

              if (isDisplayed && isOwningGridNoContentRender && this.willRenderContent()) {
                const maxSize = widgetLayoutInformation.getMaximal();
                widgetSlot.x.setMaxSize(maxSize.getWidth());
                widgetSlot.y.setMaxSize(maxSize.getHeight());
              }
              widgetSlot.y.setStretchable(false);
              widgetSlot.x.setStretchable(false);
              widgetSlot.x.setHintSize(0);
              widgetSlot.y.setHintSize(0);

              if (isDisplayed && isOwningGridNoContentRender && this.willRenderContent()) {

                const hintSize = widgetLayoutInformation.getPreferred();
                widgetSlot.x.setHintSize(hintSize.getWidth());
                widgetSlot.y.setHintSize(hintSize.getHeight());

                if (widgetLayoutEngine.isXStretched()) {
                  widgetSlot.x.setStretchable(true);
                  layoutInformation.addChildrenStretchX(widgetLayoutInformation);
                }
                if (widgetLayoutEngine.isYStretched()) {
                  widgetSlot.y.setStretchable(true);
                  layoutInformation.addChildrenStretchY(widgetLayoutInformation);
                }
                widgetSlot.x.setOpportunisticStretchable(widgetLayoutInformation.getStretched().getOpportunisticX());
                widgetSlot.y.setOpportunisticStretchable(widgetLayoutInformation.getStretched().getOpportunisticY());
              }
            }
            this._xspace.adjustStretchability();
            this._yspace.adjustStretchability();
            layoutInformation.setMaximal(this._xspace.getMaxSize(), this._yspace.getMaxSize());
          } else {
            layoutInformation.setMaximal(layoutInformation.getMeasured().getWidth(), layoutInformation.getMeasured().getHeight());
          }
          layoutInformation.setPreferred(this._xspace.getHintSize(), this._yspace.getHintSize());
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const size = layoutInfo.getMeasured();
          const availableSize = layoutInfo.getAvailable().clone(true);
          const minimalSize = layoutInfo.getMinimal();
          if (minimalSize.getWidth() > availableSize.getWidth()) {
            availableSize.setWidth(minimalSize.getWidth());
          }
          if (minimalSize.getHeight() > availableSize.getHeight()) {
            availableSize.setHeight(minimalSize.getHeight());
          }
          const diffSize = availableSize.minus(size);
          if (diffSize.getWidth() >= 0) {
            const children = this._widget.getChildren() && this._widget.getChildren().filter(function(item) {
              return item && item.isHidden && !item.isHidden();
            });
            this._xspace.setStretchable(true);
            if (layoutInfo.getPreferred().hasWidth() || (children.length === 1 && (children[0] instanceof cls.VBoxWidget))) {
              this._xspace.doStretch(diffSize.getWidth());
            }
          } else {
            if (layoutInfo.getPreferred().hasWidth()) {
              this._xspace.doShrink(diffSize.getWidth());
            }
          }
          if (diffSize.getHeight() >= 0) {
            this._yspace.setStretchable(true);
            if (layoutInfo.getPreferred().hasHeight()) {
              this._yspace.doStretch(diffSize.getHeight());
            }
          } else {
            if (layoutInfo.getPreferred().hasHeight()) {
              this._yspace.doShrink(diffSize.getHeight());
            }
          }

          const hasGridChildrenInParentChildren = this._widget.getChildren() && this._widget.getChildren().filter(function(item) {
            return item && item.isHidden && !item.isHidden() && item.isGridChildrenInParent && item.isGridChildrenInParent();
          }).length;
          for (const widget of this._registeredWidgets) {
            const slot = this._registeredSlots[widget.getUniqueIdentifier()];
            const widgetLayoutInformation = this._getLayoutInfo(widget);
            widgetLayoutInformation.setAvailable(
              this._xspace.adjustAvailableMeasure(slot.x),
              this._yspace.adjustAvailableMeasure(slot.y)
            );
            widgetLayoutInformation.setAllocated(widgetLayoutInformation.getAvailable().getWidth(), widgetLayoutInformation
              .getAvailable()
              .getHeight());
            const isChildOfGridWithGridChildrenInParent = !(!widget.isGridChildrenInParent || widget.isGridChildrenInParent()) &&
              Boolean(hasGridChildrenInParentChildren);
            widgetLayoutInformation.getHostElement()
              .toggleClass("gl_gridElementHidden", !slot.x.displayed)
              .toggleClass("g_gridChildrenInParent", Boolean(widget.isGridChildrenInParent && widget.isGridChildrenInParent()))
              .toggleClass("g_gridChildrenInParentChild", Boolean(widgetLayoutInformation.getOwningGrid()))
              .toggleClass("g_decoratingElement", Boolean(widgetLayoutInformation._extraGap))
              .toggleClass("g_childOfGridWithGridChildrenInParent", isChildOfGridWithGridChildrenInParent);
          }
          if (!this._widget._isGridChildrenInParent) {
            layoutInfo.setAllocated(
              this._xspace.getCalculatedSize() + layoutInfo.getDecorating().getWidth(true),
              this._yspace.getCalculatedSize() + layoutInfo.getDecorating().getHeight(true)
            );
          }
          this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
            "min-height": layoutInfo.getAllocated().getHeight() + "px",
            "min-width": layoutInfo.getAllocated().getWidth() + "px"
          };
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          const prefix = ".gl_" + this._widget.getUniqueIdentifier() + "_";
          this._xspace.applyStyles(this._styleRules, prefix);
          this._yspace.applyStyles(this._styleRules, prefix);
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;

"use strict";

modulum('GridLayoutEngineX',
  function(context, cls) {
    /**
     * Manage X dimension (columns)
     * @class GridLayoutEngineX
     * @memberOf classes
     */
    cls.GridLayoutEngineX = context.oo.Class(
      /** @lends classes.GridLayoutEngineX.prototype */
      {
        __name: "GridLayoutEngineX",
        /**
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type classes.GridDimensionManager
         */
        dimensionManager: null,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._widget = widget;
          this.dimensionManager = new cls.GridDimensionManager(true, 'X');
        },
        destroy: function() {
          this.dimensionManager.destroy();
          this.dimensionManager = null;
          this._widget = null;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         * @returns {classes.GridDimensionSlot} the same slot
         */
        registerSlot: function(slot) {
          this.dimensionManager.addSlot(slot);
          return slot;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        unregisterSlot: function(slot) {
          return this.dimensionManager.removeSlot(slot);
        },

        setStretchable: function(stretchable) {
          this.dimensionManager.setStretchable(stretchable);
        },

        /**
         *
         * @param {number} widthToDistribute
         * @returns {boolean}
         */
        doStretch: function(widthToDistribute) {
          return this.dimensionManager.updateBonusSize(widthToDistribute);
        },

        /**
         *
         * @param {number} widthToRemove
         * @returns {boolean}
         */
        doShrink: function(widthToRemove) {
          return this.dimensionManager.updateMalusSize(widthToRemove);
        },

        /**
         *
         * @returns {number} the calculated size
         */
        adjustMeasure: function() {
          this.dimensionManager.updateGaps();
          this.dimensionManager.updateIntrinsicSizes();
          return this.dimensionManager.getCalculatedSize();
        },

        adjustStretchability: function() {
          this.dimensionManager.updateMaxSizes();
          this.dimensionManager.updateStretchability();
        },

        getHintSize: function() {
          return this.dimensionManager.getHintSize(null, null, true, true);
        },

        getMaxSize: function() {
          return this.dimensionManager.getMaxSize(null, null, true, true);
        },
        getMinSize: function() {
          return this.dimensionManager.getMinSize(null, null, true, true);
        },

        getCalculatedSize: function() {
          return this.dimensionManager.getCalculatedSize();
        },
        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        adjustAvailableMeasure: function(slot) {
          return this.dimensionManager.getCalculatedSize(slot.getPosition(), slot.getLastPosition(), false, false);
        },

        applyStyles: function(styleRules, prefix) {
          const rendering = this.dimensionManager.render();
          this.applyRegularStyles(rendering, styleRules, prefix);
        },

        applyRegularStyles: function(rendering, styleRules, prefix) {
          for (const position of rendering.regularPositions) {
            const positionInfo = rendering.regular[position];

            const pxPos = cls.Size.cachedPxImportant(positionInfo.position);
            const pxPosWithGap = cls.Size.cachedPxImportant(positionInfo.position + positionInfo.beforeGap);

            const selector = prefix + "x_" + position;
            const selectorGrid = prefix + "x_" + position + ".g_gridChildrenInParent";
            const selectorGridChildOf = prefix + "x_" + position + ".g_childOfGridWithGridChildrenInParent";
            const selectorElem = prefix + "x_" + position + ".g_decoratingElement";
            const selectorGridChild = prefix + "x_" + position + ".g_gridChildrenInParentChild";

            styleRules[selector] = {};
            styleRules[selectorGrid] = {};
            styleRules[selectorElem] = {};
            styleRules[selectorGridChild] = {};
            styleRules[selectorGridChildOf] = {};
            styleRules[selector][this._widget.getStart()] = pxPos;
            styleRules[selectorGrid][this._widget.getStart()] = pxPos;
            styleRules[selectorElem][this._widget.getStart()] = pxPosWithGap;
            styleRules[selectorGridChild][this._widget.getStart()] = pxPosWithGap;
            styleRules[selectorGridChildOf][this._widget.getStart()] = pxPos;

            for (const length of positionInfo.regularLengths) {
              const size = positionInfo.lengths[length];
              styleRules[prefix + "w_" + position + "_" + length] = {
                width: cls.Size.cachedPxImportant(size)
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_gridChildrenInParent"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_childOfGridWithGridChildrenInParent"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_decoratingElement"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "w_" + position + "_" + length + ".g_gridChildrenInParentChild"] = {
                width: cls.Size.cachedPxImportant(positionInfo.lengths[length])
              };
            }
          }
        }
      });
  });
;

"use strict";

modulum('GridLayoutEngineY',
  function(context, cls) {
    /**
     * Manage Y dimension (Rows)
     * @class GridLayoutEngineY
     * @memberOf classes
     */
    cls.GridLayoutEngineY = context.oo.Class(
      /** @lends classes.GridLayoutEngineY.prototype */
      {
        __name: "GridLayoutEngineY",
        /**
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type classes.GridDimensionManager
         */
        dimensionManager: null,

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        constructor: function(widget) {
          this._widget = widget;
          this.dimensionManager = new cls.GridDimensionManager(false, 'Y');
        },
        destroy: function() {
          this.dimensionManager.destroy();
          this.dimensionManager = null;
          this._widget = null;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         * @returns {classes.GridDimensionSlot} the same slot
         */
        registerSlot: function(slot) {
          this.dimensionManager.addSlot(slot);
          return slot;
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        unregisterSlot: function(slot) {
          return this.dimensionManager.removeSlot(slot);
        },

        setStretchable: function(stretchable) {
          this.dimensionManager.setStretchable(stretchable);
        },

        /**
         *
         * @param {number} heightToDistribute
         * @returns {boolean}
         */
        doStretch: function(heightToDistribute) {
          return this.dimensionManager.updateBonusSize(heightToDistribute);
        },

        /**
         *
         * @param {number} heightToRemove
         * @returns {boolean}
         */
        doShrink: function(heightToRemove) {
          return this.dimensionManager.updateMalusSize(heightToRemove);
        },

        /**
         *
         * @returns {number} the calculated size
         */
        adjustMeasure: function() {
          this.dimensionManager.updateGaps();
          this.dimensionManager.updateIntrinsicSizes();
          return this.dimensionManager.getCalculatedSize();
        },

        adjustStretchability: function() {
          this.dimensionManager.updateMaxSizes();
          this.dimensionManager.updateStretchability();
        },

        getHintSize: function() {
          return this.dimensionManager.getHintSize(null, null, true, true);
        },

        getMaxSize: function() {
          return this.dimensionManager.getMaxSize(null, null, true, true);
        },
        getMinSize: function() {
          return this.dimensionManager.getMinSize(null, null, true, true);
        },

        getCalculatedSize: function() {
          return this.dimensionManager.getCalculatedSize();
        },

        /**
         *
         * @param {classes.GridDimensionSlot} slot
         */
        adjustAvailableMeasure: function(slot) {
          return this.dimensionManager.getCalculatedSize(slot.getPosition(), slot.getLastPosition(), false, false);
        },

        applyStyles: function(styleRules, prefix) {
          const rendering = this.dimensionManager.render();
          this.applyRegularStyles(rendering, styleRules, prefix);
        },

        applyRegularStyles: function(rendering, styleRules, prefix) {
          for (const position of rendering.regularPositions) {
            const positionInfo = rendering.regular[position];
            styleRules[prefix + "y_" + position] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_gridChildrenInParent"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_childOfGridWithGridChildrenInParent"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_decoratingElement"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position)
            };
            styleRules[prefix + "y_" + position + ".g_gridChildrenInParentChild"] = {
              top: cls.Size.cachedPxImportant(positionInfo.position + positionInfo.beforeGap)
            };
            for (const length of positionInfo.regularLengths) {
              const size = positionInfo.lengths[length];
              styleRules[prefix + "h_" + position + "_" + length] = {
                height: cls.Size.cachedPxImportant(size)
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_gridChildrenInParent"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_childOfGridWithGridChildrenInParent"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_decoratingElement"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengthsWithGaps[length])
              };
              styleRules[prefix + "h_" + position + "_" + length + ".g_gridChildrenInParentChild"] = {
                height: cls.Size.cachedPxImportant(positionInfo.lengths[length])
              };
            }
          }
        }
      });
  });
;

"use strict";

modulum('GroupLayoutEngine', ['GridLayoutEngine'],
  function(context, cls) {
    /**
     * @class GroupLayoutEngine
     * @memberOf classes
     * @extends classes.GridLayoutEngine
     */
    cls.GroupLayoutEngine = context.oo.Class(cls.GridLayoutEngine, function($super) {
      return /** @lends classes.GroupLayoutEngine.prototype */ {
        __name: "GroupLayoutEngine",

        _titleWidth: 0,

        /**
         * @inheritDoc
         */
        measure: function(invalidation) {
          $super.measure.call(this);
          if (this._widget._title.getLayoutEngine().isInvalidatedMeasure(invalidation)) {
            this._titleWidth = this._widget._title.getElement().clientWidth + this._getLayoutInfo().getDecorating().getWidth(true);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          if (!this.willRenderContent()) {
            this._getLayoutInfo().setMaximal(
              this._getLayoutInfo().getMeasured().getWidth(true),
              this._getLayoutInfo().getMeasured().getHeight(true)
            );
          }
          const layoutInfo = this._getLayoutInfo();
          const minimal = layoutInfo.getMinimal().getWidth(true);
          layoutInfo.getMinimal().setWidth(Math.max(this._titleWidth, minimal));
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          $super.adjustStretchability.call(this);

          if (this._widget && this._widget.getParentWidget() &&
            !this._widget.getParentWidget().isInstanceOf(cls.BoxWidget) &&
            this._widget.getParentWidget().getChildren().length === 1) {
            this._getLayoutInfo().setMaximal(null, null);
          }

          const layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.getStretched().setOpportunisticX(true);
          layoutInfo.getStretched().setOpportunisticY(true);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const allocatedW = layoutInfo.getAllocated().getWidth(true);
          const allocatedH = layoutInfo.getAllocated().getHeight(true);
          $super.prepareApplyLayout.call(this);

          if (this.willRenderContent()) {
            const visibleChildren = this.getRenderableChildren().filter(function(item) {
              return item && item.isHidden && !item.isHidden();
            });
            if (visibleChildren.length === 1 && (visibleChildren[0] instanceof cls.VBoxWidget)) {
              visibleChildren[0].getLayoutInformation().getAvailable().setWidth(
                layoutInfo.getAvailable().getWidth() - layoutInfo.getDecorating().getWidth(true));
            }
          }

          if (!this._widget._isGridChildrenInParent) {
            layoutInfo.setAllocated(
              Math.max(
                Math.min(
                  Math.max(this._xspace.getCalculatedSize() + layoutInfo.getDecorating().getWidth(true), allocatedW),
                  layoutInfo.getAvailable().getWidth(true)
                ),
                layoutInfo.getMinimal().getWidth(true)
              ),
              this.willRenderContent() ?
              Math.max(
                Math.min(
                  Math.max(this._yspace.getCalculatedSize() + layoutInfo.getDecorating().getHeight(true), allocatedH),
                  layoutInfo.getAvailable().getHeight(true)
                ),
                layoutInfo.getMinimal().getHeight(true)
              ) :
              layoutInfo.getMinimal().getHeight(true)
            );
          }

          if (this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().isInstanceOf(cls.FormWidget)) {
            layoutInfo.setAllocated(
              Math.max(
                layoutInfo.getAvailable().getWidth(true),
                layoutInfo.getMinimal().getWidth(true)
              ),
              this.willRenderContent() ?
              Math.max(
                layoutInfo.getAvailable().getHeight(true),
                layoutInfo.getMinimal().getHeight(true)
              ) :
              layoutInfo.getMinimal().getHeight(true)
            );
            this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"] = {
              "height": layoutInfo.getAllocated().getHeight() + "px !important",
              "width": layoutInfo.getAllocated().getWidth() + "px !important"
            };
          }
        },

        /**
         * @inheritDoc
         */
        updateInvalidated: function(invalidation) {
          $super.updateInvalidated.call(this, invalidation);
          this._widget._title.getLayoutEngine().updateInvalidated(invalidation);
        }
      };
    });
  });
;

"use strict";

modulum('ScrollGridLayoutEngine', ['GridLayoutEngine'],
  function(context, cls) {
    /**
     * @class ScrollGridLayoutEngine
     * @memberOf classes
     * @extends classes.GridLayoutEngine
     */
    cls.ScrollGridLayoutEngine = context.oo.Class(cls.GridLayoutEngine, function($super) {
      return /** @lends classes.ScrollGridLayoutEngine.prototype */ {
        __name: "ScrollGridLayoutEngine",
        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          const layoutInfo = this._getLayoutInfo();
          if (!layoutInfo.lineHeight) {
            layoutInfo.lineHeight = layoutInfo.getMeasured().getHeight();
          }
          layoutInfo.getMinimal().setHeight(layoutInfo.lineHeight + layoutInfo.getDecorating()
            .getHeight(true));
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          const decorating = this._getLayoutInfo().getDecorating();
          decorating.setWidth(decorating.getWidth() + window.scrollBarSize);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);
          const layoutInfo = this._widget.getLayoutInformation();
          const rules = this._styleRules[".g_measured #w_" + this._widget.getUniqueIdentifier() + ".g_measureable"];
          rules.height = layoutInfo.getAllocated().getHeight() + "px";
          rules.width = layoutInfo.getAllocated().getWidth() + "px";
        }
      };
    });
  });
;

"use strict";

modulum('FolderLayoutInformation', ['EventListener', 'LayoutInformation'],
  function(context, cls) {
    /**
     * Folder layout information
     * This is an advanced class, be careful while using it
     * @class FolderLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     * @publicdoc Base
     */
    cls.FolderLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.FolderLayoutInformation.prototype */ {
        __name: "FolderLayoutInformation",

        /** @type {number} */
        _titlesContainerDeltaWidth: 0,
        /** @type {number} */
        _titlesContainerDeltaHeight: 0,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },
        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._titlesContainerDeltaWidth = 0;
          this._titlesContainerDeltaHeight = 0;
        },

        /**
         * get the difference between folder width and titles container width
         * @returns {number}
         */
        getTitlesContainerDeltaWidth: function() {
          return this._titlesContainerDeltaWidth;
        },
        /**
         * set the difference between folder width and titles container width
         * @param {number} titlesContainerDeltaWidth the width
         */
        setTitlesContainerDeltaWidth: function(titlesContainerDeltaWidth) {
          this._titlesContainerDeltaWidth = titlesContainerDeltaWidth;
        },

        /**
         * get the difference between folder height and titles container height
         * @returns {number}
         */
        getTitlesContainerDeltaHeight: function() {
          return this._titlesContainerDeltaHeight;
        },
        /**
         * get the difference between folder height and titles container height
         * @param {number} titlesContainerDeltaHeight the height
         */
        setTitlesContainerDeltaHeight: function(titlesContainerDeltaHeight) {
          this._titlesContainerDeltaHeight = titlesContainerDeltaHeight;
        }
      };
    });
  });
;

"use strict";

modulum('GridLayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Grid layout information
     * This is an advanced class, be careful while using it
     * @class GridLayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.GridLayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.GridLayoutInformation.prototype */ {
        __name: "GridLayoutInformation",

        _useVirtual: false,

        _gridX: null,
        _gridY: null,
        _gridWidth: null,
        _gridHeight: null,

        _virtualGridX: null,
        _virtualGridY: null,
        _virtualGridWidth: null,
        _virtualGridHeight: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          $super.constructor.call(this);
          this.reset();
        },
        /**
         * reset the values for object reuse purpose
         */
        reset: function() {
          this._gridX = 0;
          this._gridY = 0;
          this._gridWidth = 1;
          this._gridHeight = 1;

          this._virtualGridX = 0;
          this._virtualGridY = 0;
          this._virtualGridWidth = 1;
          this._virtualGridHeight = 1;
        },

        isUsingVirtualCoordinates: function() {
          return Boolean(this._useVirtual);
        },
        useVirtualCoordinates: function(useVirtual) {
          useVirtual = Boolean(useVirtual);
          if (this._useVirtual !== useVirtual) {
            this._useVirtual = useVirtual;
            this.invalidateInfos();
          }
        },

        getX: function() {
          return this._useVirtual ? this._virtualGridX : this._gridX;
        },
        getY: function() {
          return this._useVirtual ? this._virtualGridY : this._gridY;
        },
        getWidth: function() {
          return this._useVirtual ? this._virtualGridWidth : this._gridWidth;
        },
        getHeight: function() {
          return this._useVirtual ? this._virtualGridHeight : this._gridHeight;
        },

        getGridX: function() {
          return this._gridX;
        },
        setGridX: function(gridX) {
          if (this._gridX !== gridX) {
            this._gridX = gridX;
            this.invalidateInfos();
          }
        },

        getGridY: function() {
          return this._gridY;
        },
        setGridY: function(gridY) {
          if (this._gridY !== gridY) {
            this._gridY = gridY;
            this.invalidateInfos();
          }
        },

        getGridWidth: function() {
          return this._gridWidth;
        },
        setGridWidth: function(gridWidth) {
          if (this._gridWidth !== gridWidth) {
            this._gridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getGridHeight: function() {
          return this._gridHeight;
        },
        setGridHeight: function(gridHeight) {
          if (this._gridHeight !== gridHeight) {
            this._gridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        getVirtualGridX: function() {
          return this._virtualGridX;
        },
        setVirtualGridX: function(gridX) {
          if (this._virtualGridX !== gridX) {
            this._virtualGridX = gridX;
            this.invalidateInfos();
          }
        },

        getVirtualGridY: function() {
          return this._virtualGridY;
        },
        setVirtualGridY: function(gridY) {
          if (this._virtualGridY !== gridY) {
            this._virtualGridY = gridY;
            this.invalidateInfos();
          }
        },

        getVirtualGridWidth: function() {
          return this._virtualGridWidth;
        },
        setVirtualGridWidth: function(gridWidth) {
          if (this._virtualGridWidth !== gridWidth) {
            this._virtualGridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getVirtualGridHeight: function() {
          return this._virtualGridHeight;
        },
        setVirtualGridHeight: function(gridHeight) {
          if (this._virtualGridHeight !== gridHeight) {
            this._virtualGridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @return {HandleRegistration} the handle registration
         */
        onGridLayoutInformationChanged: function(hook) {
          return this.when(context.constants.widgetEvents.layoutInformationChanged, hook);
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.layoutInformationChanged);
        }
      };
    });
  });
;

"use strict";

modulum('LayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Layout information
     * This is an advanced class, be careful while using it
     * @class LayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.LayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.LayoutInformation.prototype */ {
        __name: "LayoutInformation",
        /**
         * the widget
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * @type {classes.RawLayoutInformation}
         */
        _rawInformation: null,

        /**
         * @type {classes.GridLayoutInformation}
         */
        _gridInformation: null,

        _isAutomaticStack: false,
        _isChildOfAutomaticStack: false,

        /**
         * Has a grid width set in the AUI
         * @type {boolean}
         */
        _hasRawGridWidth: false,
        /**
         * Initial size preferred by design
         * @type {classes.Size}
         */
        _preferred: null,
        /**
         * is the element sizable
         * @type boolean
         */
        _sizable: true,
        /**
         * Size hint //TODO this value should never be change by any LayoutEngine as it comes from VM
         * @type {classes.Size}
         */
        _sizeHint: null,
        /**
         * measured char size
         * @type {classes.CharSize}
         */
        _charSize: null,
        /**
         * Measure in current state
         * @type {classes.Size}
         */
        _measured: null,
        /**
         * Raw element measure
         * @type {classes.Size}
         */
        _rawMeasure: null,
        /**
         * Till which size I can shrink
         * @type {classes.Size}
         */
        _minimal: null,
        /**
         * Till which size I can grow
         * @type {classes.Size}
         */
        _maximal: null,
        /**
         * The space I will effectively take
         * @type {classes.Size}
         */
        _allocated: null,
        /**
         * The space my host reserved for me
         * @type {classes.Size}
         */
        _available: null,

        /**
         * widget overflow behavior when container is not big enough
         * @type {boolean}
         */
        _willOverflowContainerIfNeeded: false,

        /**
         * In case of a container, the space reserved for decoration(borders, title, ...)
         * @type {classes.Size}
         */
        _decorating: null,
        /**
         * In case of a container, the offset of the containerElement
         * @type {classes.Size}
         */
        _decoratingOffset: null,
        /**
         * x and y stretchability
         * @type {classes.Stretch}
         */
        _stretched: null,
        /**
         * list of children info that stretches x
         * @type {Array<classes.LayoutInformation>}
         */
        _childrenStretchX: null,
        /**
         * list of children info that stretches y
         * @type {Array<classes.LayoutInformation>}
         */
        _childrenStretchY: null,
        /**
         * classes applied to the host element
         * @type {?{x:?string, y:?string, width:?string, height:?string}}
         */
        _classes: null,
        /**
         * the host element
         * @type {HTMLElement}
         */
        _hostElement: null,
        /**
         * the size policy config
         * @type {classes.SizePolicyConfig}
         */
        _sizePolicyConfig: null,
        _needMeasure: true,
        _needValuedMeasure: false,
        _initialMeasure: false,
        /**
         * owning grid if any
         * @type {classes.WidgetGridLayoutBase}
         */
        _owningGrid: null,

        hasBeenFixed: false,

        forcedMinimalWidth: 1,
        forcedMinimalHeight: 1,

        /**
         * If widget content contains only a single line
         * @type {boolean}
         */
        _singleLineContentOnly: false,

        /** Number of cols reserved for decoration (done by VM)
         * @type {number}
         */
        _reservedDecorationSpace: 0,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.WidgetBase} widget Owner
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._rawInformation = new cls.RawLayoutInformation();
          this._gridInformation = new cls.GridLayoutInformation();
          this._widget = widget;
          this._childrenStretchX = [];
          this._childrenStretchY = [];
          this._sizeHint = new cls.Size();
          this._charSize = new cls.CharSize();
          this._preferred = new cls.Size();
          this._measured = new cls.Size();
          this._rawMeasure = new cls.Size();
          this._minimal = new cls.Size();
          this._maximal = new cls.Size({
            undefinedValue: cls.Size.maximal
          });
          this._allocated = new cls.Size();
          this._available = new cls.Size();
          this._decorating = new cls.Size();
          this._decoratingOffset = new cls.Size();
          this._stretched = new cls.Stretch();
          this._sizePolicyConfig = new cls.SizePolicyConfig();
          this._classes = {
            x: null,
            y: null,
            width: null,
            height: null
          };
          this.reset();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          this._widget = null;
          if (this._rawInformation) {
            this._rawInformation.destroy();
            this._rawInformation = null;
          }
          if (this._gridInformation) {
            this._gridInformation.destroy();
            this._gridInformation = null;
          }
          $super.destroy.call(this);
        },
        /**
         * reset the values for object reuse purpose
         * @param {boolean} [soft] true to keep information given by the VM
         */
        reset: function(soft) {
          if (!soft) {
            this._rawInformation.reset();
            this._gridInformation.reset();

            this._classes.x = null;
            this._classes.y = null;
            this._classes.width = null;
            this._classes.height = null;

            this._stretched.reset();
            this._sizePolicyConfig.reset();

            this.resetChildrenStretch();

            this._sizeHint.reset();
          }

          this._initialMeasure = false;
          this.hasBeenFixed = false;

          this._charSize.reset();
          this._preferred.reset();
          this._measured.reset();
          this._rawMeasure.reset();
          this._minimal.reset();
          this._maximal.reset();
          this._allocated.reset();
          this._available.reset();
          this._decorating.reset();
          this._decoratingOffset.reset();
        },

        /**
         *
         * @return {classes.RawLayoutInformation}
         */
        getRawInformation: function() {
          return this._rawInformation;
        },
        /**
         * returns true if the layout engine must measure element
         * @return {boolean} true if it needs measure
         */
        needMeasure: function() {
          if (this._needMeasure || this._needValuedMeasure) {
            this._needMeasure = false;
            this._needValuedMeasure = false;
            return true;
          }
          return !this._measured.hasWidth() && !this._measured.hasHeight();
        },
        /**
         * get the owning grid
         * @return {classes.WidgetGridLayoutBase} the owning grid
         */
        getOwningGrid: function() {
          return this._owningGrid;
        },
        /**
         * set the owning grid
         * @param {classes.WidgetGridLayoutBase} grid the grid
         */
        setOwningGrid: function(grid) {
          this._owningGrid = grid;
        },
        /**
         * force measure invalidation
         */
        invalidateMeasure: function() {
          this._needMeasure = true;
        },
        /**
         * force initial measure invalidation (for size policy initial purpose)
         * @param {boolean} hadValue true if had value once
         * @param {boolean} hasValue true if it has currently a value
         */
        invalidateInitialMeasure: function(hadValue, hasValue) {
          if (this.getSizePolicyConfig().isDynamic()) {
            this._needValuedMeasure = true;
            this._initialMeasure = true;
          } else if (this.getSizePolicyConfig().isFixed()) {
            this._needValuedMeasure = false;
          } else if (!this._initialMeasure) {
            this._needValuedMeasure = true;
            if (!hadValue && hasValue) {
              this._initialMeasure = true;
            }
          }
        },
        /**
         * Get the raw element measure
         * @returns {classes.Size} the raw element measure
         */
        getRawMeasure: function() {
          return this._rawMeasure;
        },
        /**
         * Set the raw element measure
         * @param {number} width the width
         * @param {number} height the height
         */
        setRawMeasure: function(width, height) {
          this._rawMeasure.setWidth(width);
          this._rawMeasure.setHeight(height);
        },
        /**
         * Get the measured size
         * @returns {classes.Size} the measured size
         */
        getMeasured: function() {
          return this._measured;
        },
        /**
         * Set the measured size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMeasured: function(width, height) {
          this._measured.setWidth(width);
          this._measured.setHeight(height);
        },
        /**
         * Get the minimal size
         * @returns {classes.Size} the minimal size
         */
        getMinimal: function(containerOnly) {
          if (containerOnly) {
            return this._minimal.minus(this._decorating);
          } else {
            return this._minimal;
          }
        },
        /**
         * Set the minimal size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMinimal: function(width, height) {
          this._minimal.setWidth(width);
          this._minimal.setHeight(height);
        },
        /**
         * Get the maximal size
         * @returns {classes.Size} the maximal size
         */
        getMaximal: function() {
          return this._maximal;
        },
        /**
         * Set the maximal size
         * @param {number} width the width
         * @param {number} height the height
         */
        setMaximal: function(width, height) {
          this._maximal.setWidth(width);
          this._maximal.setHeight(height);
        },
        /**
         * Get the allocated size
         * @returns {classes.Size} the allocated size
         */
        getAllocated: function() {
          return this._allocated;
        },
        /**
         * Set the allocated size
         * @param {number} width the width
         * @param {number} height the height
         */
        setAllocated: function(width, height) {
          this._allocated.setWidth(width);
          this._allocated.setHeight(height);
        },
        /**
         * Get the decorating size
         * @returns {classes.Size} the decorating size
         */
        getDecorating: function() {
          return this._decorating;
        },
        /**
         * Set the decorating size
         * @param {number} width the width
         * @param {number} height the height
         */
        setDecorating: function(width, height) {
          this._decorating.setWidth(width);
          this._decorating.setHeight(height);
        },
        /**
         * Get the decorating offset
         * @returns {classes.Size} the decorating offset
         */
        getDecoratingOffset: function() {
          return this._decoratingOffset;
        },
        /**
         * Set the decorating offset
         * @param {number} width the width
         * @param {number} height the height
         */
        setDecoratingOffset: function(width, height) {
          this._decoratingOffset.setWidth(width);
          this._decoratingOffset.setHeight(height);
        },
        /**
         * Get the available size
         * @returns {classes.Size} the available size
         */
        getAvailable: function(containerOnly) {
          if (containerOnly) {
            return this._available.minus(this._decorating);
          } else {
            return this._available;
          }
        },
        /**
         * Set the available size
         * @param {number} width the width
         * @param {number} height the height
         */
        setAvailable: function(width, height) {
          this._available.setWidth(width);
          this._available.setHeight(height);
        },

        /**
         * get whether or not the widget would overflow its container if this one is not big enough
         * @return {boolean} true if the widget would overflow its container if this one is not big enough
         */
        willOverflowContainerIfNeeded: function() {
          /* // sample test of using context.DebugService.count
             // todo : see if feature is interesting
          if (this._willOverflowContainerIfNeeded) {
            context.DebugService.count("willOverflowContainerIfNeeded");
          }
          */
          return this._willOverflowContainerIfNeeded;
        },

        /**
         * set whether or not the widget would overflow its container if this one is not big enough
         * @param {boolean} willOverflowContainerIfNeeded - true to let the widget overflow its container if this one is not big enough
         */
        wouldOverflowContainerIfNeeded: function(willOverflowContainerIfNeeded) {
          this._willOverflowContainerIfNeeded = willOverflowContainerIfNeeded;
        },
        /**
         * Get the preferred size
         * @returns {classes.Size} the prefered size
         */
        getPreferred: function() {
          return this._preferred;
        },
        /**
         * Set the prefered size
         * @param {number} width the width
         * @param {number} height the height
         */
        setPreferred: function(width, height) {
          this._preferred.setWidth(width);
          this._preferred.setHeight(height);
        },

        /**
         * is the element sizable
         * @returns {boolean} true if it is sizable
         */
        isSizable: function() {
          return this._sizable;
        },

        /**
         * Set if the element is sizable
         * @param {boolean} sizable true if it is sizable
         */
        setSizable: function(sizable) {
          this._sizable = sizable;
        },

        /**
         * get the char size
         * @returns {classes.CharSize} the char size
         */
        getCharSize: function() {
          return this._charSize;
        },

        /**
         * Set the char size
         * @param {number} widthM witth of M
         * @param {number} width0 width of 0
         * @param {number} height height of M
         */
        setCharSize: function(widthM, width0, height) {
          this._charSize.setWidthM(widthM);
          this._charSize.setWidth0(width0);
          this._charSize.setHeight(height);
          this.updatePreferred();
        },

        /**
         * get the size hint
         * @returns {classes.Size} the size hint
         */
        getSizeHint: function() {
          return this._sizeHint;
        },

        /**
         * Set the size hint
         * @param {number} width the width
         * @param {number} height the height
         */
        setSizeHint: function(width, height) {
          this._sizeHint.setWidth(width);
          this._sizeHint.setHeight(height);
          this.updatePreferred();
        },

        /**
         * update prefered from size hint and char size
         */
        updatePreferred: function() {
          this._preferred.setWidth(cls.CharSize.translate(this._sizeHint.getWidth(true), this._charSize.getWidthM(), this._charSize
            .getWidth0()));
          this._preferred.setHeight(cls.Size.translate(this._sizeHint.getHeight(true), this._charSize.getHeight()));
        },

        /**
         * get the size policy config
         * @returns {classes.SizePolicyConfig} the size policy config
         */
        getSizePolicyConfig: function() {
          return this._sizePolicyConfig;
        },
        /**
         * get the current size policy
         * @returns {classes.SizePolicy} the current size policy
         */
        getCurrentSizePolicy: function() {
          return this._sizePolicyConfig.getMode();
        },
        /**
         * set the size policy mode
         * @param {string} policy the size policy mode
         */
        setSizePolicyMode: function(policy) {
          this._sizePolicyConfig.setMode(policy);
        },
        /**
         * get the x position in grid
         * @returns {number} the x position in grid
         */
        getGridX: function() {
          let delta = 0;
          if (this._owningGrid && !this.isInAutomaticStack()) {
            delta = this._owningGrid.getLayoutInformation().getGridX() || 0;
          }
          return this._gridInformation.getX() + delta;
        },

        /**
         * set the x position in grid
         * @param {number} x the x position in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridX: function(x, noEvent) {
          if (x !== this._gridInformation.getGridX()) {
            this._gridInformation.setGridX(x || 0);
            this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
            this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },
        /**
         * get the y position in grid
         * @returns {number} the y position in grid
         */
        getGridY: function() {
          let delta = 0;
          if (this._owningGrid && !this.isInAutomaticStack()) {
            delta = this._owningGrid.getLayoutInformation().getGridY() || 0;
          }
          return this._gridInformation.getY() + delta;
        },
        /**
         * set the y position in grid
         * @param {number} y the y position in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridY: function(y, noEvent) {
          if (y !== this._gridInformation.getGridY()) {
            this._gridInformation.setGridY(y || 0);
            this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
            this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },

        setVirtualGridY: function(y, no) {
          this._gridInformation.setVirtualGridY(y);
          this._gridInformation.setVirtualGridHeight(this._gridInformation.getGridHeight());
          this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
          this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
          this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
          this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
          if (!no) {
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
          return true;
        },
        /**
         * get the width in grid
         * @returns {number} the width in grid
         */
        getGridWidth: function() {
          return this._gridInformation.getWidth();
        },

        /**
         * set the width in grid
         * @param {number} width the width in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridWidth: function(width, noEvent) {
          this._hasRawGridWidth = Boolean(width);
          if (width !== this._gridInformation.getGridWidth()) {
            this._gridInformation.setGridWidth(width || (width === 0 ? 0 : 1));
            this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },

        /**
         * Returns if layout has a grid width in the AUI (generally it should mean thant widget is in a grid)
         * @returns {boolean} true is has a grid width in the AUI
         */
        hasRawGridWidth: function() {
          return this._hasRawGridWidth;
        },

        /**
         * get the height in grid
         * @returns {number} the height in grid
         */
        getGridHeight: function() {
          return this._gridInformation.getHeight();
        },
        /**
         * set the height in grid
         * @param {number} height the height in grid
         * @param {?boolean} [noEvent] true to avoid sending {context.constants.widgetEvents.gridInfoChanged}
         * @return {?boolean} true if the value has been changed
         */
        setGridHeight: function(height, noEvent) {
          if (height !== this._gridInformation.getGridHeight()) {
            this._gridInformation.setGridHeight(height || (height === 0 ? 0 : 1));
            this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
            if (!noEvent) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
            return true;
          }
        },
        /**
         * get the host element
         * @returns {HTMLElement} the host element
         */
        getHostElement: function() {
          return this._hostElement;
        },
        /**
         * set the host element
         * @param {HTMLElement} hostElement the host element
         */
        setHostElement: function(hostElement) {
          this._hostElement = hostElement;
          this.setGridXClass(this.getPositionClassName("x", this.getGridX()));
          this.setGridYClass(this.getPositionClassName("y", this.getGridY()));
          this.setGridWidthClass(this.getLengthClassName("w", this.getGridX(), this.getGridWidth()));
          this.setGridHeightClass(this.getLengthClassName("h", this.getGridY(), this.getGridHeight()));
        },
        /**
         * set the grid x class on host element
         * @param {string} className the classname
         */
        setGridXClass: function(className) {
          if (this._classes.x) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.x);
            }
          }
          this._classes.x = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.x);
            }
          }
        },
        /**
         * set the grid y class on host element
         * @param {string} className the classname
         */
        setGridYClass: function(className) {
          if (this._classes.y) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.y);
            }
          }
          this._classes.y = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.y);
            }
          }
        },
        /**
         * set the grid width class on host element
         * @param {string} className the classname
         */
        setGridWidthClass: function(className) {
          if (this._classes.width) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.width);
            }
          }
          this._classes.width = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.width);
            }
          }
        },
        /**
         * set the grid height class on host element
         * @param {string} className the classname
         */
        setGridHeightClass: function(className) {
          if (this._classes.height) {
            if (this._hostElement) {
              this._hostElement.removeClass(this._classes.height);
            }
          }
          this._classes.height = className;
          if (this.isGridItem()) {
            if (this._hostElement) {
              this._hostElement.addClass(this._classes.height);
            }
          }
        },
        /**
         * test if item is in a grid layout
         * @todo check the test
         * @return {boolean} true if is a grid item
         */
        isGridItem: function() {
          return Boolean(this._widget.getParentWidget()) &&
            (
              this._widget.getParentWidget().getLayoutEngine() instanceof cls.GridLayoutEngine ||
              this._widget.getParentWidget().getLayoutEngine() instanceof cls.ScrollGridLayoutEngine
            );
        },

        /**
         * get the position classname
         * @param {string} way the wày (x/y)
         * @param {number} pos the position
         * @return {?string} the classname
         */
        getPositionClassName: function(way, pos) {
          if (this._widget.getParentWidget()) {
            const uuid = this._widget.getParentWidget().getUniqueIdentifier();
            return ["gl_", uuid, "_", way, "_", pos].join("");
          } else {
            return null;
          }
        },
        /**
         * get the position classname
         * @param {string} way the wày (width/height)
         * @param {number} pos the position
         * @param {number} len the length
         * @return {?string} the classname
         */
        getLengthClassName: function(way, pos, len) {
          if (this._widget.getParentWidget()) {
            const uuid = this._widget.getParentWidget().getUniqueIdentifier();
            return ["gl_", uuid, "_", way, "_", pos, "_", len].join("");
          } else {
            return null;
          }
        },

        /**
         * Set if widget content contains only a single line
         * @param {boolean} b true if widget content contains only a single line
         */
        setSingleLineContentOnly: function(b) {
          this._singleLineContentOnly = b;
        },

        /**
         * Returns if widget content contains only a single line
         * @returns {boolean} true if widget content contains only a single line
         */
        hasSingleLineContentOnly: function() {
          return this._singleLineContentOnly;
        },

        /**
         * Sets number of cols reserved for decoration by VM
         * @param {number} n number of cols reserved for decoration by VM
         */
        setReservedDecorationSpace: function(n) {
          this._reservedDecorationSpace = n;
        },

        /**
         * Returns number of cols reserved for decoration by VM
         * @returns {number} number of cols reserved for decoration by VM
         */
        getReservedDecorationSpace: function() {
          return this._reservedDecorationSpace;
        },

        /**
         * Get stretchability info
         * @returns {classes.Stretch} stretchability info
         */
        getStretched: function() {
          return this._stretched;
        },
        /**
         * get whether or not is x stretched
         * @returns {boolean} true if is x stretched
         */
        isXStretched: function() {
          return this.isInAutomaticStack() || this._stretched.getX(true);
        },
        /**
         * Set if is x stretched
         * @param {boolean} stretch true if is x stretched
         */
        setXStretched: function(stretch) {
          if (this._stretched.getX() !== stretch) {
            this._stretched.setX(stretch);
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
        },
        /**
         * get whether or not is y stretched
         * @returns {boolean} true if is y stretched
         */
        isYStretched: function() {
          return this._stretched.getY(true);
        },
        /**
         * get whether or not at least one child is x stretchable
         * @returns {boolean} true if at least one child is x stretchable
         */
        isChildrenXStretched: function() {
          return Boolean(this._childrenStretchX.length);
        },
        /**
         * get whether or not at least one child is y stretchable
         * @returns {boolean} true if at least one child is y stretchable
         */
        isChildrenYStretched: function() {
          return Boolean(this._childrenStretchY.length);
        },
        /**
         * Set if is y stretched
         * @param {boolean} stretch true if is y stretched
         */
        setYStretched: function(stretch) {
          if (this._stretched.getY() !== stretch) {
            this._stretched.setY(stretch);
            this.emit(context.constants.widgetEvents.gridInfoChanged);
          }
        },
        /**
         * reset x and y stretchable list
         */
        resetChildrenStretch: function() {
          this._childrenStretchX.length = 0;
          this._childrenStretchY.length = 0;
        },
        /**
         * add child info to x stretchables
         * @param {classes.LayoutInformation} val the child info
         */
        addChildrenStretchX: function(val) {
          this._childrenStretchX.push(val);
        },
        /**
         * add child info to y stretchables
         * @param {classes.LayoutInformation} val the child info
         */
        addChildrenStretchY: function(val) {
          this._childrenStretchY.push(val);
        },
        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @return {HandleRegistration} the handle registration
         */
        onGridInfoChanged: function(hook) {
          return this.when(context.constants.widgetEvents.gridInfoChanged, hook);
        },

        setGridAutomaticStack: function(automaticStack, no) {
          if (this._isAutomaticStack !== automaticStack) {
            this._isAutomaticStack = automaticStack;
            if (this._hostElement) {
              this._hostElement.setAttribute("grid-renderer", this._isAutomaticStack ? "stack" : "grid");
            }
            if (!no) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
          }
        },

        setChildOfGridAutomaticStack: function(automaticStack, no) {
          if (this._isChildOfAutomaticStack !== automaticStack) {
            this._isChildOfAutomaticStack = automaticStack;
            this._gridInformation.useVirtualCoordinates(automaticStack);
            if (this._hostElement) {
              this._hostElement.setAttribute("grid-parent-renderer", this._isChildOfAutomaticStack ? "stack" : "grid");
            }
            if (!no) {
              this.emit(context.constants.widgetEvents.gridInfoChanged);
            }
          }
        },

        isStacked: function() {
          return this._isAutomaticStack;
        },

        isInAutomaticStack: function() {
          return this._isChildOfAutomaticStack;
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.gridInfoChanged);
        },

        /**
         * Get a JSON representation of this layout information
         * @return {Object}
         */
        serialize: function() {
          return {
            layoutEngineName: this._widget._layoutEngine.__name,
            grid: {
              posX: this.getGridX(),
              poxY: this.getGridY(),
              gridWidth: this.getGridWidth(),
              gridHeight: this.getGridHeight(),
            },
            measured: {
              measuredHasSize: this.getMeasured().hasSize(),
              measureWidth: this.getMeasured().getWidth(),
              measuredHeight: this.getMeasured().getHeight(),
            },
            minimal: {
              minimalHasSize: this.getMinimal().hasSize(),
              minimalWidth: this.getMinimal().getWidth(),
              minimalHeight: this.getMinimal().getHeight(),
            },
            maximal: {
              maximalHasSize: this.getMaximal().hasSize(),
              maximalWidth: this.getMaximal().getWidth(),
              maximalHeight: this.getMaximal().getHeight(),
            },
            available: {
              availableHasSize: this.getAvailable().hasSize(),
              availableWidth: this.getAvailable().getWidth(),
              availableHeight: this.getAvailable().getHeight()
            },
            allocated: {
              allocatedHasSize: this.getAllocated().hasSize(),
              allocatedWidth: this.getAllocated().getWidth(),
              allocatedHeight: this.getAllocated().getHeight()
            },
            preferred: {
              preferredHasSize: this.getPreferred().hasSize(),
              preferredWidth: this.getPreferred().getWidth(),
              preferredHeight: this.getPreferred().getHeight(),
            },
            decorating: {
              decoratingHasSize: this.getDecorating().hasSize(),
              decoratingWidth: this.getDecorating().getWidth(),
              decoratingHeight: this.getDecorating().getHeight(),
              decoratingOffsetHasSize: this.getDecoratingOffset().hasSize(),
              decoratingOffsetWidth: this.getDecoratingOffset().getWidth(),
              decoratingOffsetHeight: this.getDecoratingOffset().getHeight()
            },
            stretch: {
              stretchX: this.getStretched().getX(true),
              stretchY: this.getStretched().getY(true),
              childrenStretchX: this.isChildrenXStretched(),
              childrenStretchY: this.isChildrenYStretched(),
            },
            invalidated: {
              invalidatedMeasure: this._widget._layoutEngine._invalidatedMeasure,
              invalidatedAllocatedSpace: this._widget._layoutEngine._invalidatedAllocatedSpace
            }
          };
        }

      };
    });
  });
;

"use strict";

modulum('PageLayoutInformation', ['EventListener', 'LayoutInformation'],
  function(context, cls) {
    /**
     * Page layout information
     * This is an advanced class, be careful while using it
     * @class PageLayoutInformation
     * @memberOf classes
     * @extends classes.LayoutInformation
     * @publicdoc Base
     */
    cls.PageLayoutInformation = context.oo.Class(cls.LayoutInformation, function($super) {
      return /** @lends classes.PageLayoutInformation.prototype */ {
        __name: "PageLayoutInformation",

        /** @type {number} */
        _titleMeasureWidth: 0,
        /** @type {number} */
        _titleMeasureHeight: 0,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
        },
        /**
         * @inheritDoc
         */
        reset: function(soft) {
          $super.reset.call(this, soft);
          this._titleMeasureWidth = 0;
          this._titleMeasureHeight = 0;
        },

        /**
         * get the page title width
         * @returns {number}
         */
        getTitleMeasureWidth: function() {
          return this._titleMeasureWidth;
        },

        /**
         * set the page title width
         * @param titleMeasureWidth
         */
        setTitleMeasureWidth: function(titleMeasureWidth) {
          this._titleMeasureWidth = titleMeasureWidth;
        },

        /**
         * get the page title height
         * @returns {number}
         */
        getTitleMeasureHeight: function() {
          return this._titleMeasureHeight;
        },

        /**
         * set the page title height
         * @param titleMeasureHeight
         */
        setTitleMeasureHeight: function(titleMeasureHeight) {
          this._titleMeasureHeight = titleMeasureHeight;
        }
      };
    });
  });
;

"use strict";

modulum('RawLayoutInformation', ['EventListener'],
  function(context, cls) {
    /**
     * Raw layout information
     * This is an advanced class, be careful while using it
     * @class RawLayoutInformation
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.RawLayoutInformation = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.RawLayoutInformation.prototype */ {
        __name: "RawLayoutInformation",

        /**
         * is autoscale
         * @type {?number}
         */
        _autoScale: null,
        /**
         * The visible width of an object in character cells. For some objects like windows, tables and images, it can be followed by an optional unit (co,ln,pt,px). Default unit is character cells.
         * @type {?string}
         */
        _width: null,
        _height: null,
        _gridWidth: null,
        _gridHeight: null,
        _posX: null,
        _posY: null,
        _minWidth: null,
        _minHeight: null,
        _stepX: null,
        _stepY: null,
        _columnCount: null,
        _stretch: null,
        /** @type ?number */
        _stretchMin: null,
        /** @type ?number */
        _stretchMax: null,
        _wantFixedPageSize: null,
        _gridChildrenInParent: null,
        _childOfGridChildrenInParent: null,
        /**
         * the size policy config
         * @type {?string}
         */
        _sizePolicy: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function() {
          $super.constructor.call(this);
          this.reset();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
        },
        /**
         * reset the values for object reuse purpose
         */
        reset: function() {
          this._stretch = undefined;
        },

        /**
         *
         * @return {?string}
         */
        getSizePolicy: function() {
          return this._sizePolicy;
        },
        /**
         *
         * @param {?string} sizePolicy
         */
        setSizePolicy: function(sizePolicy) {
          if (this._sizePolicy !== sizePolicy) {
            this._sizePolicy = sizePolicy;
            this.invalidateInfos();
          }
        },

        getAutoScale: function() {
          return this._autoScale;
        },
        setAutoScale: function(autoScale) {
          if (this._autoScale !== autoScale) {
            this._autoScale = autoScale;
            this.invalidateInfos();
          }
        },

        getWidth: function() {
          return this._width;
        },
        setWidth: function(width) {
          //Width seems to be "" sometimes, that cannot be parsed with parseInt
          if (typeof(width) !== "boolean" && !isNaN(width) && width.length > 0) {
            width = parseInt(width, 10);
          }
          if (this._width !== width) {
            this._width = width;
            this.invalidateInfos();
          }
        },

        getHeight: function() {
          return this._height;
        },
        setHeight: function(height) {
          // Height seems to be "" sometimes, that cannot be parsed with parseInt
          if (typeof(height) !== "boolean" && !isNaN(height) && height.length > 0) {
            height = parseInt(height, 10);
          }
          if (this._height !== height) {
            this._height = height;
            this.invalidateInfos();
          }
        },

        getGridWidth: function() {
          return this._gridWidth;
        },
        setGridWidth: function(gridWidth) {
          if (this._gridWidth !== gridWidth) {
            this._gridWidth = gridWidth;
            this.invalidateInfos();
          }
        },

        getGridHeight: function() {
          return this._gridHeight;
        },
        setGridHeight: function(gridHeight) {
          if (this._gridHeight !== gridHeight) {
            this._gridHeight = gridHeight;
            this.invalidateInfos();
          }
        },

        getPosX: function() {
          return this._posX;
        },
        setPosX: function(posX) {
          if (this._posX !== posX) {
            this._posX = posX;
            this.invalidateInfos();
          }
        },

        getPosY: function() {
          return this._posY;
        },
        setPosY: function(posY) {
          if (this._posY !== posY) {
            this._posY = posY;
            this.invalidateInfos();
          }
        },

        getMinWidth: function() {
          return this._minWidth;
        },
        setMinWidth: function(minWidth) {
          if (this._minWidth !== minWidth) {
            this._minWidth = minWidth;
            this.invalidateInfos();
          }
        },

        getMinHeight: function() {
          return this._minHeight;
        },
        setMinHeight: function(minHeight) {
          if (this._minHeight !== minHeight) {
            this._minHeight = minHeight;
            this.invalidateInfos();
          }
        },

        getStepX: function() {
          return this._stepX;
        },
        setStepX: function(stepX) {
          if (this._stepX !== stepX) {
            this._stepX = stepX;
            this.invalidateInfos();
          }
        },

        getStepY: function() {
          return this._stepY;
        },
        setStepY: function(stepY) {
          if (this._stepY !== stepY) {
            this._stepY = stepY;
            this.invalidateInfos();
          }
        },

        getColumnCount: function() {
          return this._columnCount;
        },
        setColumnCount: function(columnCount) {
          if (this._columnCount !== columnCount) {
            this._columnCount = columnCount;
            this.invalidateInfos();
          }
        },

        getStretch: function() {
          return this._stretch;
        },
        setStretch: function(stretch) {
          if (this._stretch !== stretch) {
            this._stretch = stretch;
            this.invalidateInfos();
          }
        },

        /**
         * Return stretch min value
         * @return {?number} stretchMin
         */
        getStretchMin: function() {
          return this._stretchMin;
        },

        /**
         * Sets stretch min value
         * @param {?number} stretchMin - stretch min value
         */
        setStretchMin: function(stretchMin) {
          if (this._stretchMin !== stretchMin) {
            this._stretchMin = stretchMin;
            this.invalidateInfos();
          }
        },

        /**
         * Return stretch max value
         * @return {?number} stretchMax
         */
        getStretchMax: function() {
          return this._stretchMax;
        },

        /**
         * Sets stretch max value
         * @param {?number} stretchMax - stretch max value
         */
        setStretchMax: function(stretchMax) {
          if (this._stretchMax !== stretchMax) {
            this._stretchMax = stretchMax;
            this.invalidateInfos();
          }
        },

        getWantFixedPageSize: function() {
          return this._wantFixedPageSize;
        },
        setWantFixedPageSize: function(wantFixedPageSize) {
          if (this._wantFixedPageSize !== wantFixedPageSize) {
            this._wantFixedPageSize = wantFixedPageSize;
            this.invalidateInfos();
          }
        },

        getGridChildrenInParent: function() {
          return this._gridChildrenInParent;
        },
        setGridChildrenInParent: function(gridChildrenInParent) {
          if (this._gridChildrenInParent !== gridChildrenInParent) {
            this._gridChildrenInParent = gridChildrenInParent;
            this.invalidateInfos();
          }
        },

        getChildOfGridChildrenInParent: function() {
          return this._childOfGridChildrenInParent;
        },
        setChildOfGridChildrenInParent: function(childOfGridChildrenInParent) {
          if (this._childOfGridChildrenInParent !== childOfGridChildrenInParent) {
            this._childOfGridChildrenInParent = childOfGridChildrenInParent;
            this.invalidateInfos();
          }
        },

        /**
         * fired when grid information changed
         * @param {Hook} hook the hook
         * @param {boolean} [once] fires only once
         * @return {HandleRegistration} the handle registration
         */
        onRawLayoutInformationChanged: function(hook, once) {
          return this.when(context.constants.widgetEvents.layoutInformationChanged, hook, Boolean(once));
        },
        /**
         * invalidate information
         */
        invalidateInfos: function() {
          this.emit(context.constants.widgetEvents.layoutInformationChanged);
        }
      };
    });
  });
;

"use strict";

modulum('LayoutEngineBase', ['EventListener', 'LayoutInvalidationService'],
  function(context, cls) {
    /**
     * Definition of Layout Engine
     * This is an advanced class, be careful while using it
     * @class LayoutEngineBase
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.LayoutEngineBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.LayoutEngineBase.prototype */ {
        __name: "LayoutEngineBase",

        /**
         * owner widget
         * @protected
         * @type {classes.WidgetBase}
         */
        _widget: null,

        /**
         * flag to know if widget's char size has been measured
         * @type {boolean}
         */
        _charMeasured: false,

        /**
         * buffered css rules
         * @type {Object}
         * @protected
         */
        _styleRules: null,

        /**
         * layout statuses
         * @type {?classes.LayoutStatus}
         * @protected
         */
        _statuses: null,

        /**
         * the current measure invalidation timestamp
         * @type {number}
         */
        _invalidatedMeasure: context.LayoutInvalidationService.getInitialInvalidation(),

        /**
         * the current allocated space invalidation timestamp
         * @type {number}
         */
        _invalidatedAllocatedSpace: context.LayoutInvalidationService.getInitialInvalidation(),

        /**
         * flag to know if this layout has to force parent layout measure invalidation
         * @type {boolean}
         */
        _forceParentInvalidateMeasure: false,

        /**
         * flag to know if this layout needs measure
         * @type {boolean}
         */
        _needMeasure: true,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.WidgetBase} widget Owner widget
         */
        constructor: function(widget) {
          $super.constructor.call(this);
          this._widget = widget;
          this._styleRules = {};
          this._statuses = {
            measured: false,
            adjusted: false,
            layouted: false
          };
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._destroyStyle();
          this._widget = null;
          this._styleRules = null;
          this._statuses = null;
          $super.destroy.call(this);
        },

        /**
         * returns true if widget has already been layouted
         * @returns {boolean}
         */
        isLayouted: function() {
          return this._statuses.layouted;
        },

        /**
         * Destroy style sheet related to widget layout engine
         * @private
         */
        _destroyStyle: function() {
          if (this._styleSheetId) {
            const stylingContext = this._widget.getStylingContext();
            if (stylingContext === "widget") {
              context.styler.removeStyleSheet(this._styleSheetId);
            } else { // "window" or "global" styling context
              const sheetId = this._widget.getStyleSheetId();
              context.styler.appendStyleSheet({}, this._styleSheetId, true, sheetId);
            }
          }
        },

        /**
         * Resets all precalculated layout data
         * @param {boolean} recursive is the reset need to be applied to children recursively
         */
        reset: function(recursive) {
          this._statuses.layouted = false;
          this._statuses.measured = false;
          this._statuses.adjusted = false;

          this._invalidatedMeasure = context.LayoutInvalidationService.getInitialInvalidation();
          this._invalidatedAllocatedSpace = context.LayoutInvalidationService.getInitialInvalidation();
          this._forceParentInvalidateMeasure = false;
          this._needMeasure = true;
          this._charMeasured = false;
          this._getLayoutInfo().reset(true);
          if (recursive) {
            const children = this._widget && this._widget.getChildren && this._widget.getChildren();
            let i = 0;
            const len = children && children.length || 0;
            for (; i < len; i++) {
              const engine = children[i].getLayoutEngine();
              if (engine) {
                engine.reset(recursive);
              }
            }
          }
        },

        /**
         * Get layout information of the given widget, or owner widget if not given
         * @param {classes.WidgetBase=} widget the widget
         * @returns {classes.LayoutInformation} thi information
         */
        _getLayoutInfo: function(widget) {
          const w = widget || this._widget;
          if (!w) {
            return null;
          }
          return w.getLayoutInformation();
        },

        /**
         * The layout engine cannot have a child
         * @param {classes.WidgetBase} widget child widget
         */
        registerChild: function(widget) {},

        /**
         * The layout engine cannot have a child
         * @param {classes.WidgetBase} widget child widget
         */
        unregisterChild: function(widget) {},

        /**
         * reset
         */
        resetSizes: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.getMinimal().reset();
          layoutInfo.getMaximal().reset();
          layoutInfo.getMeasured().reset();
          layoutInfo.getAllocated().reset();
          layoutInfo.getAvailable().reset();
        },

        /**
         * action entry point to deal with layout information, children widget layout information/placement before any layout computing is done
         */
        beforeLayout: function() {},

        /**
         * prepare measure self widget
         */
        prepareMeasure: function() {},

        /**
         * measure char size in widget
         */
        measureChar: function() {
          if (!this._ignoreLayout && !this._charMeasured) {
            const MMMlen = this._widget.__charMeasurer1.getBoundingClientRect(),
              _000len = this._widget.__charMeasurer2.getBoundingClientRect();
            this._getLayoutInfo().setCharSize(MMMlen.width / 10, _000len.width / 10, MMMlen.height / 10);
            if (_000len.width > 0 && MMMlen.height > 0) {
              this._charMeasured = true;
            }
          }
        },
        /**
         * raw measure widget DOM element
         */
        DOMMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation(),
            element = this._widget.getElement(),
            elemRects = element.getBoundingClientRect();

          layoutInfo.setRawMeasure(elemRects.width, elemRects.height);
        },

        /**
         * measure self widget
         */
        measure: function() {},

        /**
         * measure widget decoration
         */
        measureDecoration: function() {

        },

        /**
         * called after measure.
         * Should not be overridden
         */
        afterMeasure: function() {
          this._statuses.measured = true;
        },

        /**
         * update information from children to parent
         */
        prepareAdjustments: function() {},

        /**
         * determine measured ('natural size') from children
         */
        adjustMeasure: function() {},

        /**
         * called after adjust.
         * Should not be overridden
         */
        afterAdjustMeasure: function() {
          this._statuses.adjusted = true;
        },

        /**
         * determine children stretchability
         */
        adjustStretchability: function() {},

        /**
         * determine stretched allocated size for children
         * @param {classes.LayoutApplicationService} [layoutApplicationService] layoutApplicationService
         */
        prepareApplyLayout: function(layoutApplicationService) {},

        /**
         * apply final sizes
         */
        applyLayout: function() {},

        /**
         * Notify layout was applied
         */
        notifyLayoutApplied: function() {
          this.emit(context.constants.widgetEvents.layoutApplied);
        },

        /**
         * Everytime layout is applied, launch a callback
         * @param {Hook} hook - callback to appy
         * @return {HandleRegistration}  a registration handle (for unbind purpose)
         */
        onLayoutApplied: function(hook) {
          return this.when(context.constants.widgetEvents.layoutApplied, hook);
        },

        /**
         * does the widget need measure
         * @return {boolean} true if the widget need measure
         */
        needMeasure: function() {
          return this._needMeasure;
        },

        /**
         * method that would return true if the engine does not want to force a measuring
         * @return {boolean} true if the engine does not want to force a measuring
         */
        ignoreMeasureInvalidation: function() {
          return false;
        },

        /**
         * force measure need
         */
        forceMeasurement: function() {
          this._needMeasure = true;
        },
        /**
         * invalidates measure of the linked widget against an invalidation increment
         * @param {number} [invalidation] the invalidation timestamp
         */
        invalidateMeasure: function(invalidation) {
          this._invalidateMeasure(invalidation);
        },

        /**
         * invalidates measure of the linked widget against an invalidation increment
         * @param {number} [invalidation] the invalidation timestamp
         */
        _invalidateMeasure: function(invalidation) {
          if (this._widget && this._widget.getElement() && !this._widget.getElement().isInDOM()) {
            this._invalidatedMeasure = context.LayoutInvalidationService.getInitialInvalidation();
          }
          this._invalidatedMeasure = this._prepareInvalidation(invalidation, this._invalidatedMeasure);
          if (this._widget && (this._forceParentInvalidateMeasure || !this._widget.isHidden())) {
            const parentWidget = this._widget && this._widget.getParentWidget(),
              parentEngine = parentWidget && parentWidget.getLayoutEngine();
            if (parentEngine) {
              parentEngine.invalidateMeasure(this._invalidatedMeasure, this);
            }
            this._forceParentInvalidateMeasure = false;
          }
        },

        /**
         * invalidates allocated space of the linked widget against an invalidation increment
         * @param {number} [invalidation] the invalidation timestamp
         */
        invalidateAllocatedSpace: function(invalidation) {
          this._invalidatedAllocatedSpace = this._prepareInvalidation(invalidation, this._invalidatedAllocatedSpace);
          if (this._widget && !this._widget.isHidden()) {
            const children = this.getRenderableChildren();
            for (const element of children) {
              if (element) {
                const layoutEngine = element.getLayoutEngine();
                if (layoutEngine) {
                  layoutEngine.invalidateAllocatedSpace(this._invalidatedAllocatedSpace);
                }
              }
            }
          }
        },

        _prepareInvalidation: function(invalidation, current) {
          if (current !== context.LayoutInvalidationService.getInitialInvalidation() && (!invalidation || current < invalidation)) {
            return invalidation || context.LayoutInvalidationService.nextInvalidation();
          }
          return current;
        },
        /**
         * test if layout must switch to measure mode
         * @return {boolean} true if measure mode is neede
         */
        needMeasureSwitching: function() {
          return true;
        },
        /**
         * test measure invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if measure is invalidated
         */
        isInvalidatedMeasure: function(timestamp) {
          return this.needMeasure() && Boolean(this._widget) &&
            !this._widget.isHidden() && (this._invalidatedMeasure >= timestamp);
        },
        /**
         * test allocated space invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if allocated space is invalidated
         */
        isInvalidatedAllocatedSpace: function(timestamp) {
          return Boolean(this._widget) && !this._widget.isHidden() &&
            (this._invalidatedAllocatedSpace >= timestamp);
        },
        /**
         * test invalidation against a timestamp
         * @param {number} timestamp the timestamp
         * @return {boolean} true if layout engine is invalidated
         */
        isInvalidated: function(timestamp) {
          const result = this.isInvalidatedMeasure(timestamp) || this.isInvalidatedAllocatedSpace(timestamp),
            windowWidget = this._widget && this._widget.getWindowWidget();

          return result && (!windowWidget || !windowWidget._disabled || windowWidget._forceVisible);
        },

        isXStretched: function() {
          const info = this._getLayoutInfo();
          return info && info.isXStretched() || info.isChildrenXStretched();
        },

        isYStretched: function() {
          const info = this._getLayoutInfo();
          return info && info.isYStretched() || info.isChildrenYStretched();
        },

        /**
         * get list of renderable children
         * @return {classes.WidgetBase[]} list of renderable children
         */
        getRenderableChildren: function() {
          return this._widget && this._widget.getChildren && this._widget.getChildren() || [];
        },
        /**
         * update invalidation information
         * @param {number} invalidation the invalidation timestamp
         */
        updateInvalidated: function(invalidation) {
          if (this._widget && this._widget.isLayoutMeasureable(true)) {
            this._invalidatedMeasure = this._getUpdatedInvalidation(invalidation, this._invalidatedMeasure);
            this._invalidatedAllocatedSpace = this._getUpdatedInvalidation(invalidation, this._invalidatedAllocatedSpace);
            if (this._getLayoutInfo().getSizePolicyConfig().isInitial()) {
              this._needMeasure = false;
            }
            this._statuses.layouted = true;
          }
        },

        _getUpdatedInvalidation: function(invalidation, current) {
          return Math.max(invalidation, current === context.LayoutInvalidationService.getInitialInvalidation() ? 1 : current);
        },

        /**
         * Inform the layout that visibility has changed
         */
        changeHidden: function() {
          this._forceParentInvalidateMeasure = true;
          if (this._widget && this._widget.getParentWidget() && this._widget.getParentWidget().getLayoutEngine()) {
            this._widget.getParentWidget().getLayoutEngine().invalidateMeasure();
            this._widget.getParentWidget().getLayoutEngine().invalidateAllocatedSpace();
          }
          this.invalidateMeasure();
        },

        /**
         * get a generated css sheet id
         * @return {string}
         */
        getLayoutSheetId: function() {
          return this._widget && this._widget.getStyleSheetId() || "_";
        },

        /**
         * @return The widget owning the layoutEngine
         * @protected
         */
        _getWidget() {
          if (!this._widget) {
            throw new Error(`The widget owning the layoutEngine is invalid : this._widget = ${this._widget}`);
          }
          return this._widget;
        }
      };
    });
  });
;

"use strict";

modulum("LayoutTriggerAttributes",
  function(context, cls) {

    /**
     * Nodes which imply a relayout. Used in 'add' and 'remove' command type
     * @type {Object}
     */
    const nodesWhichRelayout = {
      "Button": true,
      "HLine": true,
      "Label": true,
      "Image": true,
      "Message": true,
      "Folder": true,
      "Form": true,
      "Group": true,
      "Grid": true,
      "HBox": true,
      "Screen": true,
      "Stack": true,
      "VBox": true,
      "Window": true,
      "ScrollArea": true,
      "ScrollGrid": true,
      "UserInterface": true,
      "Action": true,
      "Dialog": true,
      "Menu": true,
      "MenuAction": true,
      "Table": true,
      "FormField": true,
      "Matrix": true,
      "Item": true
    };

    /**
     * Nodes which imply a relayout. Used in 'add' and 'remove' command type
     * @type {Object}
     */
    const attributesWhichRelayout = {
      height: true,
      hidden: true,
      minHeight: true,
      minWidth: true,
      pageSize: true, // relayout should be done only for ScrollGrid
      sample: true,
      sizePolicy: true,
      splitter: true,
      width: true,
      windowStyle: true,
      size: true // relayout should be done only for Table
    };

    /**
     * Enum of all VM attributes which imply relayout
     * @namespace classes.LayoutTriggerAttributes
     */
    cls.LayoutTriggerAttributes = {
      "add": nodesWhichRelayout,
      "a": nodesWhichRelayout,
      "remove": nodesWhichRelayout,
      "r": nodesWhichRelayout,
      "update": attributesWhichRelayout,
      "u": attributesWhichRelayout
    };
    Object.freeze(cls.LayoutTriggerAttributes);
  });
;

"use strict";

modulum('ButtonLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ButtonLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ButtonLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ButtonLayoutEngine.prototype */ {
        __name: "ButtonLayoutEngine",

        /**
         * sets measure as fixed measure
         * @private
         */
        _setFixedMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const rawMeasure = layoutInfo.getRawMeasure();
          //the height never depend on the size policy
          layoutInfo.setMeasured(
            layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true),
            this._naturalHeight || rawMeasure.getHeight(true)
          );
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          $super.measureDecoration.call(this);

          const layoutInfo = this._widget.getLayoutInformation(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          if (this._widget.isLayoutMeasureable(true) && currentSizePolicy.isFixed()) {
            if (this._widget._image && !this._widget.getText()) {
              const containerRect = this._widget._image._element.getBoundingClientRect();
              const decorating = this._getLayoutInfo().getDecorating();
              this._getLayoutInfo().setDecorating(
                layoutInfo.getRawMeasure().getWidth(true) - containerRect.width + (
                  decorating.hasWidth() ? decorating.getWidth() : 0),
                layoutInfo.getRawMeasure().getHeight(true) - containerRect.height + (
                  decorating.hasHeight() ? decorating.getHeight() : 0)
              );
            }
          }
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);

          const layoutInfo = this._widget.getLayoutInformation();
          const preferedWidth = layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true);
          const minSize = layoutInfo.getMinimal();
          const maxSize = layoutInfo.getMaximal();
          const measuredSize = layoutInfo.getMeasured();

          if (this._widget._buttonType !== 'link' && !layoutInfo.getCurrentSizePolicy().isFixed()) {
            const sizePolicy = layoutInfo.getSizePolicyConfig().mode;
            if (sizePolicy === "initial") {
              const width = preferedWidth > measuredSize.getWidth(true) ? preferedWidth : measuredSize.getWidth(true);
              if (!this.canOverrideMinWidth()) {
                minSize.setWidth(width);
              }
              measuredSize.setWidth(width);
              maxSize.setWidth(width);
            }
          }
        }
      };
    });
  });
;

"use strict";

modulum('CanvasLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class CanvasLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.CanvasLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.CanvasLayoutEngine.prototype */ {
        __name: "CanvasLayoutEngine",

        /**
         * Calculate and set measured size
         * @protected
         */
        _setMinMax: function() {
          $super._setMinMax.call(this);
          const layoutInfo = this._widget.getLayoutInformation();
          const minSize = layoutInfo.getMinimal();
          // Set measured height as minimal height
          minSize.setHeight(Math.max(layoutInfo.getRawMeasure().getHeight(true), minSize.getHeight(true)));
        }
      };
    });
  });
;

"use strict";

modulum('ComboBoxLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ComboBoxLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ComboBoxLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ComboBoxLayoutEngine.prototype */ {
        __name: "ComboBoxLayoutEngine",
        /**
         * The number of strings that are in the dom
         * @type number
         */
        _dataMeasureStringCount: 0,
        /**
         * The number of strings we keep for dom measurement
         * @type number
         */
        _dataMeasureStringCountLimit: 10,

        /**
         * @type string
         */
        _oneText: '',

        /**
         * @inheritDoc
         */
        prepareDynamicMeasure: function() {
          this._dataMeasureStringCount = 0;
          if (this._dataContentMeasure) {
            if (!this._widget.getLayoutInformation().getCurrentSizePolicy().isFixed()) {
              this._oneText = this._dataContentMeasure.innerText;

              const children = this._widget.getItems().map(function(item) {
                return item.text;
              });
              if (this._textSample.length > 0) {
                children.push(this._textSample);
              }

              children.sort(function(e1, e2) {
                return e2.length - e1.length;
              });
              let html = '';

              //We keep the <_dataMeasureStringCountLimit> longest values
              for (let i = 0; i < children.length && this._dataMeasureStringCount <= this._dataMeasureStringCountLimit; i++) {
                const value = children[i];
                if (value) {
                  html += value + "<br>";
                  this._dataMeasureStringCount++;
                  this._oneText = value;
                }
              }
              this._dataContentMeasure.innerHTML = html;
            }
          }
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation(),
            element = this._widget.getElement();
          let elemRects = element.getBoundingClientRect();
          const dataCount = this._dataMeasureStringCount === 0 ? 1 : this._dataMeasureStringCount;
          // Measure the checkbox icon in Construct
          const isConstruct = this._widget.getDialogType() === 'Construct';
          const checkBoxElem = element.querySelector(".zmdi"),
            checkBoxWidth = checkBoxElem && isConstruct ? checkBoxElem.clientWidth : 0;

          let width = elemRects.width + checkBoxWidth; // add box icon to the measure in construct
          let height = elemRects.height;

          //when we have dataCount > 1 the widget height is not elemRects.height/dataCount (maybe some marge, padding, etc...)
          if (dataCount > 1) {
            this._dataContentMeasure.innerHTML = this._oneText;
            elemRects = element.getBoundingClientRect();
            height = elemRects.height;
          }

          layoutInfo.setRawMeasure(width, height);
        },
      };
    });
  });
;

"use strict";

modulum('EditLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class EditLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.EditLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.EditLayoutEngine.prototype */ {
        __name: "EditLayoutEngine",

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          // always invalidate for EDIT
          const layoutInfo = this._getLayoutInfo();
          this._invalidateMeasure(invalidation);
          this._getLayoutInfo().invalidateMeasure();
          layoutInfo.hasBeenFixed = false;
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {},

        /**
         * @inheritDoc
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          const rawMeasure = layoutInfo.getRawMeasure();

          if (currentSizePolicy.isDynamic() || (layoutInfo._widget.isVisible() && layoutInfo.needMeasure())) {
            if (!currentSizePolicy.isFixed() || !layoutInfo.hasBeenFixed) {
              layoutInfo.setMeasured(rawMeasure.getWidth(true), rawMeasure.getHeight(true));
              layoutInfo.hasBeenFixed = currentSizePolicy.isFixed();
            }
          }
        }

      };
    });
  });
;

"use strict";

modulum('ImageLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class ImageLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.ImageLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.ImageLayoutEngine.prototype */ {
        __name: "ImageLayoutEngine",

        /**
         * set natural size
         * @param {number} width the width
         * @param {number} height the height
         */
        setNaturalSize: function(width, height) {
          $super.setNaturalSize.call(this, width, height);
          const layoutInfo = this._widget.getLayoutInformation(),
            rawMeasure = layoutInfo.getRawMeasure(),
            measure = layoutInfo.getMeasured();
          if (!rawMeasure.hasWidth()) {
            rawMeasure.setWidth(width);
          }
          if (!rawMeasure.hasHeight()) {
            rawMeasure.setHeight(height);
          }
          if (!measure.hasWidth()) {
            measure.setWidth(width);
          }
          if (!measure.hasHeight()) {
            measure.setHeight(height);
          }
          const parentWidget = this._widget && this._widget.getParentWidget(),
            parentLayoutEngine = parentWidget && parentWidget.getLayoutEngine();
          if (parentLayoutEngine) {
            parentLayoutEngine.invalidateAllocatedSpace();
          }
        },

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          const layoutInfo = this._getLayoutInfo(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          if (!this._statuses.layouted || (!this._widget.isFontImage() && !currentSizePolicy.isFixed())) {
            this._invalidateMeasure(invalidation);
            this._getLayoutInfo().invalidateMeasure();
          }
          layoutInfo.hasBeenFixed = false;
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const layoutInfo = this._widget.getLayoutInformation(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();

          if (this._widget.isFontImage() || currentSizePolicy.isFixed()) {
            this._measureDecoration();
          }
        },

        /**
         * @inheritDoc
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          if (this._widget.isFontImage()) {
            if (!layoutInfo.hasBeenFixed) {
              this._setFixedMeasure();
              layoutInfo.hasBeenFixed = true;
            }
          } else {
            $super._measure.call(this);
          }
        }
      };
    });
  });
;

"use strict";

modulum('LeafDynamicHeightLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class LeafDynamicHeightLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.LeafDynamicHeightLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.LeafDynamicHeightLayoutEngine.prototype */ {
        __name: "LeafDynamicHeightLayoutEngine",

        /**
         * prepare widget for dynamic measure
         */
        prepareDynamicMeasure: function() {
          if (this._widget.isInTable() && this._dataContentPlaceholder) {
            //Need to simulate dynamic sizepolicy to be compliant with the 1.00.57 layout
            this._dataContentPlaceholder.toggleClass("gbc_staticMeasure", false);
            this._dataContentPlaceholder.toggleClass("gbc_dynamicMeasure", true);
          } else {
            $super.prepareDynamicMeasure.call(this);
          }
        },

        /**
         * sets measure as fixed measure
         * @private
         */
        _setFixedMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const rawMeasure = layoutInfo.getRawMeasure();
          //the height never depends on the size policy
          layoutInfo.setMeasured(
            layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true),
            this._naturalHeight || rawMeasure.getHeight(true)
          );
        }
      };
    });
  });
;

"use strict";

modulum('LeafLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * @class LeafLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.LeafLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.LeafLayoutEngine.prototype */ {
        __name: "LeafLayoutEngine",
        /**
         * data content placeholder is the DOM element that contains what is defined as widget's value
         * @type HTMLElement
         */
        _dataContentPlaceholder: null,
        /**
         * data content measure element is the DOM element that contains widget's value as text for measuring purpose
         * @type HTMLElement
         */
        _dataContentMeasure: null,
        /**
         * text sample, used in measure
         * @type {?string}
         */
        _textSample: null,
        /**
         * text sample width (in characters)
         * @type {number}
         */
        _sampleWidth: 0,
        /**
         * text sample height (in characters)
         * @type {number}
         */
        _sampleHeight: 0,
        /**
         * value content natural width (to deal with images for example)
         * @type {number}
         */
        _naturalWidth: 0,
        /**
         * value content natural height (to deal with images for example)
         * @type {number}
         */
        _naturalHeight: 0,

        /**
         * minimum content width if stretchmin attribute is used
         * @type {number}
         */
        _stretchMinWidth: 0,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this.invalidateDataContentSelector(widget);
        },

        /**
         * set natural size
         * @param {number} width the width
         * @param {number} height the height
         */
        setNaturalSize: function(width, height) {
          this._naturalWidth = width;
          this._naturalHeight = height;
        },

        /**
         * test if this layout has a natural size
         * @return {boolean} true if this layout has a natural size
         */
        hasNaturalSize: function() {
          return Boolean(this._naturalWidth) && Boolean(this._naturalHeight);
        },
        /**
         * set hint size
         * @param {number} widthHint the width
         * @param {number} heightHint the height
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 1 : widthHint,
            ((typeof(heightHint) === "undefined") || heightHint === null || heightHint === "") ? 1 : heightHint
          );
        },

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._widget.resetLayout();
        },

        /**
         * @inheritDoc
         */
        resetSizes: function() {
          $super.resetSizes.call(this);

          const layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.hasBeenFixed = false;
        },

        /**
         * invalidate data content selector, creates it if needed
         * @param {classes.WidgetBase} widget this widget
         */
        invalidateDataContentSelector: function(widget) {
          if (widget.__dataContentPlaceholderSelector) {
            const element = this._widget.getElement();
            this._dataContentPlaceholder = widget.__dataContentPlaceholderSelector === cls.WidgetBase.selfDataContent ? element :
              element.getElementsByClassName(widget.__dataContentPlaceholderSelector.replace(".", ""))[0];
            if (this._dataContentPlaceholder) {
              this._dataContentPlaceholder.addClass("gbc_staticMeasure");
              this._dataContentPlaceholder.removeClass("gbc_dynamicMeasure");

              this._dataContentMeasure = this._dataContentPlaceholder.getElementsByClassName("gbc_dataContentMeasure")[0];
              if (!this._dataContentMeasure && !widget.ignoreLayout()) {
                this._dataContentMeasure = context.TemplateService.renderDOM("LeafLayoutMeasureElement");
                this._dataContentPlaceholder.appendChild(this._dataContentMeasure);
              }
            }
          }
        },

        /**
         * Returns Element containing the data to be measured
         * @returns {HTMLElement} element containing the data to be measured
         */
        getDataContentMeasureElement: function() {
          return this._dataContentMeasure;
        },

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          const layoutInfo = this._getLayoutInfo(),
            currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          if (!this._statuses.layouted || !currentSizePolicy.isFixed()) {
            $super.invalidateMeasure.call(this, invalidation);
            this._getLayoutInfo().invalidateMeasure();
          }
          layoutInfo.hasBeenFixed = false;
        },

        /**
         * sets measure as fixed measure
         * @private
         */
        _setFixedMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation();

          layoutInfo.setMeasured(
            layoutInfo.getPreferred().getWidth() + layoutInfo.getDecorating().getWidth(true),
            layoutInfo.getPreferred().getHeight() + layoutInfo.getDecorating().getHeight(true));
        },

        /**
         * @inheritDoc
         */
        beforeLayout: function() {
          $super.beforeLayout.call(this);
          // widgets contained in tables should not have a max height defined
          if (this._widget.isInTable()) {
            this._shouldFillHeight = true;
          }
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          if (this._dataContentMeasure) {
            const layoutInfo = this._widget.getLayoutInformation();
            const sizeHintWidth = layoutInfo.getSizeHint().getWidth();
            let width = (!layoutInfo.hasRawGridWidth() && cls.Size.isCols(sizeHintWidth)) ? parseInt(sizeHintWidth, 10) :
              layoutInfo.getGridWidth();

            // if a grid is present gridWidth send by VM add the reservedDecorationSpace automatically
            // so, we need to remove it to correctly measure the widget
            if (layoutInfo.hasRawGridWidth() && width > layoutInfo.getReservedDecorationSpace()) {
              width -= layoutInfo.getReservedDecorationSpace();
            }
            if (width !== this._sampleWidth || layoutInfo.getGridHeight() !== this._sampleHeight) {

              if (layoutInfo.isXStretched()) {
                //Measure min stretch size
                let minWidth = layoutInfo.getRawInformation().getStretchMin();
                if (minWidth > 0) {
                  this._dataContentMeasure.textContent = cls.Measurement.getTextSample(minWidth, layoutInfo.hasSingleLineContentOnly() ? 1 :
                    layoutInfo
                    .getGridHeight());
                  this._stretchMinWidth = this._widget.getElement().getBoundingClientRect().width;
                }
              }

              const sample = cls.Measurement.getTextSample(width, layoutInfo.hasSingleLineContentOnly() ? 1 : layoutInfo
                .getGridHeight());
              this._sampleWidth = width;
              this._sampleHeight = layoutInfo.getGridHeight();
              this._textSample = sample;
              this._dataContentMeasure.textContent = sample;
            }
          }
          this.prepareDynamicMeasure();
        },

        /**
         * prepare widget for dynamic measure
         */
        prepareDynamicMeasure: function() {
          if (this._dataContentPlaceholder) {
            const layoutInfo = this._widget.getLayoutInformation();
            let isDynamic = layoutInfo._needValuedMeasure || layoutInfo.getCurrentSizePolicy().isDynamic();

            this._dataContentPlaceholder.toggleClass("gbc_staticMeasure", !isDynamic);
            this._dataContentPlaceholder.toggleClass("gbc_dynamicMeasure", isDynamic);
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();

          if (currentSizePolicy.isFixed()) {
            this._measureDecoration();
          }
        },

        /**
         * Measure decoration
         * @protected
         */
        _measureDecoration: function() {
          if (this._widget.isLayoutMeasureable(true) && this._dataContentPlaceholder) {
            const layoutInfo = this._widget.getLayoutInformation();
            const element = this._widget.getElement();
            const container = this._dataContentPlaceholder.hasClass("gbc_dynamicMeasure") ?
              this._widget.getElement().querySelector(".gbc-label-text-container") || this._dataContentMeasure :
              this._dataContentMeasure;

            const containerRects = container.getBoundingClientRect();
            this._getLayoutInfo().setDecorating(
              layoutInfo.getRawMeasure().getWidth(true) - containerRects.width,
              layoutInfo.getRawMeasure().getHeight(true) - containerRects.height
            );
            this._getLayoutInfo().setDecoratingOffset(
              container.offsetLeft - element.offsetLeft,
              container.offsetTop - element.offsetTop
            );
          }
        },

        /**
         * If we can override the min width
         * @return {boolean}
         */
        canOverrideMinWidth: function() {
          let layoutInfo = this._widget.getLayoutInformation(),
            minWidth = layoutInfo.getRawInformation().getStretchMin();

          return minWidth > 0 && layoutInfo.isXStretched();
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();

          if (this._widget.isLayoutMeasureable(true)) {
            // 1. Set Measured
            this._measure();
            // 2. Set Min/Max
            this._setMinMax();
          } else {
            layoutInfo.setMeasured(0, 0);
            layoutInfo.setMinimal(0, 0);
            layoutInfo.setMaximal(0, 0);
          }
        },

        /**
         * Calculate and set measured size
         * @protected
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          const rawMeasure = layoutInfo.getRawMeasure();

          if (currentSizePolicy.isFixed()) {
            if (!layoutInfo.hasBeenFixed) {
              this._setFixedMeasure();
              layoutInfo.hasBeenFixed = true;
            }
          } else if (currentSizePolicy.isDynamic() || (layoutInfo._widget.isVisible() && layoutInfo.needMeasure())) {
            const width = this._naturalWidth || rawMeasure.getWidth(true); // NATURAL FOR IMAGE
            const height = this._naturalHeight || rawMeasure.getHeight(true);
            layoutInfo.setMeasured(width, height);
          }
        },

        /**
         * Define Min and Max sizes
         * @protected
         */
        _setMinMax: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          const minSize = layoutInfo.getMinimal();
          const maxSize = layoutInfo.getMaximal();
          const measured = layoutInfo.getMeasured();
          if (layoutInfo.getCurrentSizePolicy().isDynamic()) {
            layoutInfo.setMinimal(measured.getWidth(), measured.getHeight());
          } else {
            // min size is identified with capacity of the widget to stretch and its basic natural width (natural width can be preferred width if sizepolicy fixed, or natural content width if sizepolicy dynamic)
            // so if the widget can shrink and has a sizepolicy mode allowing it to shrink (initial or dynamic), then set min size to very small value.
            // Otherwise, if it can't shrink and can't stretch, its measured size if its min size (widget size isn't supposed to change. ex: stretch=none + sizepolicy=fixed)
            if (layoutInfo.isXStretched() && currentSizePolicy.canShrink()) {
              minSize.setWidth(layoutInfo.forcedMinimalWidth);
            } else {
              minSize.setWidth(measured.getWidth());
            }
            if (layoutInfo.isYStretched() && currentSizePolicy.canShrink()) {
              minSize.setHeight(layoutInfo.forcedMinimalHeight);
            } else {
              minSize.setHeight(measured.getHeight());
            }
          }
          if (layoutInfo.isXStretched()) {
            maxSize.setWidth(cls.Size.maximal);
            let minWidth = layoutInfo.getRawInformation().getStretchMin();
            if (minWidth > 0) {
              if (this._dataContentMeasure) {
                // Use the sample text to measure the min size via DOM
                // Set in prepareMeasure
                minSize.setWidth(this._stretchMinWidth);
              } else {
                // Manually calculate the min size (no added html space like padding and border)
                // i.e. Radiogroup doesn't use any data placeholder
                let charSize = layoutInfo.getCharSize();
                minSize.setWidth(cls.CharSize.translate(minWidth, charSize.getWidthM(), charSize.getWidth0()));
              }
            }
          } else {
            maxSize.setWidth(measured.getWidth());
          }
          if (layoutInfo.isYStretched()) {
            maxSize.setHeight(cls.Size.maximal);
          } else {
            maxSize.setHeight(measured.getHeight());
          }
        },

        /**
         * @inheritDoc
         */
        adjustStretchability: function() {
          const formWidget = this._widget.getFormWidget();
          const layoutInfo = this._widget.getLayoutInformation(),
            maxSize = layoutInfo.getMaximal(),
            measured = layoutInfo.getMeasured();

          if (layoutInfo.isXStretched()) {
            maxSize.setWidth(cls.Size.maximal);
          } else {
            maxSize.setWidth(measured.getWidth());
          }
          if (layoutInfo.isYStretched()) {
            maxSize.setHeight(cls.Size.maximal);
          } else {
            maxSize.setHeight(measured.getHeight());
          }
          if (formWidget && formWidget.getLayoutEngine().isAutoOverflowActivated()) {
            if (layoutInfo.isYStretched()) {
              layoutInfo.getMinimal().setHeight(Math.max(layoutInfo.getPreferred().getHeight(true), layoutInfo.getMeasured()
                .getHeight(
                  true)));
            }
          }
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          if (this._getLayoutInfo().isXStretched()) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              width: this._getLayoutInfo().getAvailable().getWidth() + "px"
            });
          } else {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              width: "inherit"
            });
          }
          if (this._getLayoutInfo().isYStretched()) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              height: this._getLayoutInfo().getAvailable().getHeight() + "px"
            });
          } else if (this._getLayoutInfo().getMaximal().getHeight(true) && !this._shouldFillHeight) {
            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              "max-height": this._getLayoutInfo().getMaximal().getHeight(true) + "px"
            });
          }
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return [];
        }
      };
    });
  });
;

"use strict";

modulum('ListViewLayoutEngine', ['TableLayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ListViewLayoutEngine
     * @memberOf classes
     * @extends classes.TableLayoutEngineBase
     */
    cls.ListViewLayoutEngine = context.oo.Class(cls.TableLayoutEngineBase, function($super) {
      return /** @lends classes.ListViewLayoutEngine.prototype */ {
        __name: "ListViewLayoutEngine",

        /** @type boolean */
        _firstWidgetMeasured: false,

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._firstWidgetMeasured = false;
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          const layoutInfo = this._widget.getLayoutInformation();

          let computePreferredWidth = 0;
          if (!this._firstWidgetMeasured && layoutInfo._charSize.hasSize()) {
            // measure first widget of first row to initialize row height of listview
            const rowWidget = this._widget.getChildren()[0];
            if (rowWidget) {
              const widget = rowWidget.getChildren()[0];
              if (widget) {
                widget._layoutInformation._charSize = layoutInfo._charSize;
                widget._layoutInformation.getSizePolicyConfig().mode = "fixed";
                widget._layoutInformation.updatePreferred();
                widget._layoutEngine.DOMMeasure();
                widget._layoutEngine.measureDecoration();
                widget._layoutEngine.measure();
                widget._layoutEngine.afterMeasure();

                let height = widget._layoutInformation.getMeasured().getHeight();
                if (rowWidget.getLineCount() === 1) {
                  height = height * cls.ListViewWidget.defaultOneLineHeightRatio;
                } else if (rowWidget.getLineCount() === 2) {
                  height = height * cls.ListViewWidget.defaultTwoLinesHeightRatio;
                }
                computePreferredWidth = widget._layoutInformation.getMeasured().getWidth();

                this._widget.setRowHeight(Math.round(height));

                this._firstWidgetMeasured = true;
              }
            }
          }

          // Compute preferred size
          if (!this._initialPreferredSize) {
            this._initialPreferredSize = true;
            const rowHeight = this._widget.getRowHeight();
            const sizeHint = layoutInfo.getSizeHint();
            layoutInfo.getPreferred().setWidth(Math.round(computePreferredWidth));
            if (sizeHint.getHeight()) {
              // translate height into number of rows
              this._widget._firstPageSize = Math.max(this._convertHeightToRowCount(sizeHint.getHeight(), layoutInfo.getCharSize().getHeight(),
                rowHeight), 1);
            }
            const h = this._widget._firstPageSize ? this._widget._firstPageSize * rowHeight : 1;
            layoutInfo.getPreferred().setHeight(Math.round(h + layoutInfo.getDecorating().getHeight()));
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const scrollAreaElementHeight = this._widget.getScrollableArea().offsetHeight;
          const decorateHeight = this._widget.getElement().offsetHeight - scrollAreaElementHeight;
          const scrollAreaElementWidth = this._widget.getScrollableArea().offsetWidth;
          const decorateWidth = this._widget.getElement().offsetWidth - scrollAreaElementWidth;

          this._getLayoutInfo().setDecorating(decorateWidth + window.scrollBarSize, decorateHeight);
        }

      };
    });
  });
;

"use strict";

modulum('RTableLayoutEngine', ['TableLayoutEngineBase'],
  function(context, cls) {
    /**
     * @class RTableLayoutEngine
     * @memberOf classes
     * @extends classes.TableLayoutEngineBase
     */
    cls.RTableLayoutEngine = context.oo.Class(cls.TableLayoutEngineBase, function($super) {
      return /** @lends classes.TableLayoutEngine.prototype */ {
        __name: "RTableLayoutEngine",

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);

          this._visibleColumnsWidth = null;
          this._visibleItemsInRowHeight = null;
          this._totalColumnsWidth = 0;
          this._totalDetachedWidth = 0;
          this._computedMinWidth = 0;
          this._computedMaxWidth = 0;

          // Reset column first item width layout
          if (!this._widget) {
            return;
          }

          let rows = this._widget.getRows();
          if (rows.length === 0) {
            return;
          }

          let firstRowTableItemWidgets = rows[0].getChildren();
          for (const tableItemWidget of firstRowTableItemWidgets) {
            let widget = tableItemWidget.getChildren()[0];
            if (widget) {
              widget._layoutInformation.reset(true);
              widget._layoutEngine.reset(true);
            }
          }
        },

        //#region Measures

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          $super.prepareMeasure.call(this);

          if (this.isLayoutDone()) {
            return;
          }

          // Add all visible columns in DOM before layout
          // TODO GBC-4154 : adapt code here to only add columns on first row
          let columns = this._getWidget().getColumns();
          for (const col of columns) {
            if (!col.isHidden() && col.isDetachedFromDom()) {
              col.attachItemsToDom();
            }
          }

          // Set size policy mode as fixed on first row item widgets
          let rows = this._widget.getRows();
          if (rows.length === 0) {
            return;
          }
          let firstRowTableItemWidgets = rows[0].getChildren();

          for (const tableItemWidget of firstRowTableItemWidgets) {
            let itemWidget = tableItemWidget.getChildren()[0];
            if (itemWidget) {
              if (!(itemWidget instanceof cls.RadioGroupWidget || itemWidget instanceof cls.ComboBoxWidget)) {
                itemWidget.getLayoutInformation().setSizePolicyMode("fixed");
              }
              let charSize = this._widget.getLayoutInformation().getCharSize();
              itemWidget.getLayoutInformation().setCharSize(charSize.getWidthM(), charSize.getWidth0(), charSize.getHeight());
            }
          }
        },

        /**
         * @inheritDoc
         */
        measure: function() {

          $super.measure.call(this);

          if (this.isLayoutDone()) {
            return;
          }
          // Set some layout information on column widget
          const rows = this._widget.getRows();
          if (rows.length === 0) {
            return;
          }

          let sumColumnsWidth = 0,
            columnsWidth = [];
          const firstRowTableItemWidgets = rows[0].getChildren();
          const layoutInfo = this._widget.getLayoutInformation();

          for (const tableItemWidget of firstRowTableItemWidgets) {
            const widget = tableItemWidget.getChildren()[0];
            if (!widget) {
              return;
            }
            let column = tableItemWidget.getColumnWidget(),
              widgetLayoutInfo = widget.getLayoutInformation(),
              colLayoutInfo = column.getLayoutInformation();

            let widgetCharSize = this._widget.getLayoutInformation().getCharSize();
            colLayoutInfo.setCharSize(widgetCharSize.getWidthM(), widgetCharSize.getWidth0(), widgetCharSize.getHeight());

            // Get DOM measure of column first item widget and set it as measure on column layout
            const measuredWidth = widgetLayoutInfo.getMeasured().getWidth(),
              preferredWidth = widgetLayoutInfo.getPreferred().getWidth(),
              stretchMinWidth = this._pixelToCharWidth(widgetLayoutInfo.getRawInformation().getStretchMin(), layoutInfo.getCharSize()),
              measuredHeight = widgetLayoutInfo.getMeasured().getHeight(),
              preferredHeight = widgetLayoutInfo.getPreferred().getHeight(),
              // take biggest value between measured width and .PER width (preferred or stretchmin width)
              width = Math.max(measuredWidth, preferredWidth, stretchMinWidth);

            colLayoutInfo.setPreferred(width, preferredHeight);
            colLayoutInfo.setMeasured(width, measuredHeight);

            // get STRETCH values of first item widget and set it to column layout
            colLayoutInfo.setXStretched(widgetLayoutInfo.isXStretched());
            colLayoutInfo.getRawInformation().setStretchMin(widgetLayoutInfo.getRawInformation().getStretchMin());
            colLayoutInfo.getRawInformation().setStretchMax(widgetLayoutInfo.getRawInformation().getStretchMax());

            if (!column.isHidden()) {
              columnsWidth.push(width);
              sumColumnsWidth += width;
            }
          }

          // only compute rows during layout because columns will be measured after layout
          this._layoutDone = this.computeRowsColsCss(true, false, true);

          if (!this.isLayoutDone()) {
            return;
          }

          // Compute preferred size
          const rowHeight = this._widget.getRowHeight(),
            sizeHint = layoutInfo.getSizeHint();

          if (!sizeHint.getWidth()) {
            layoutInfo.getPreferred().setWidth(sumColumnsWidth);
          } else if (cls.Size.isCols(sizeHint.getWidth())) {
            let count = parseInt(sizeHint.getWidth(), 10),
              colsLen = columnsWidth.slice(0, count).reduce(function(pv, cv) {
                return pv + cv;
              }, 0);
            layoutInfo.getPreferred().setWidth(Math.round(colsLen));
          }

          if (sizeHint.getHeight()) {
            // translate height into number of rows
            this._widget._firstPageSize = Math.max(this._convertHeightToRowCount(sizeHint.getHeight(), layoutInfo.getCharSize().getHeight(),
              rowHeight), 1);
          }

          let h = (this._widget._firstPageSize ? this._widget._firstPageSize : 1) * rowHeight;
          layoutInfo.getPreferred().setHeight(Math.round(h + layoutInfo.getDecorating().getHeight()));
        },

        /**
         * Compute CSS rules (grid template) for rows height and col widths
         * @param {boolean} measureRows - compute rows height
         * @param {boolean} measureCols - compute cols width
         * @param {boolean} force - force measure
         * @return {boolean} true if layout has been correctly computed
         */
        computeRowsColsCss: function(measureRows, measureCols, force = false) {

          if ((!this.isLayoutDone() && !force) || (!measureCols && !measureRows)) {
            return false;
          }

          // If the table is flipped, we need to compute both as it's used in the CSS template
          if (this._getWidget().isFlipped()) {
            measureRows = true;
            measureCols = true;
          }

          let measureDone = false;
          this._visibleColumnsWidth = [];
          this._visibleItemsInRowHeight = [];
          let minWidth = 99999;

          // go through all columns
          this._totalColumnsWidth = 0;
          this._totalDetachedWidth = 0;
          let foundScrollableColumn = false;

          let maxCharSize = 0;
          for (const columnWidget of this._widget.getOrderedColumns()) {
            if (columnWidget.isHidden()) {
              continue;
            }
            const layoutInfo = columnWidget.getLayoutInformation();

            // width
            if (measureCols) {
              let width = columnWidget.getUserWidth();
              if (width === null) {
                width = layoutInfo.getMeasured().getWidth();
                if (layoutInfo.isXStretched()) {
                  const rawStretchMin = layoutInfo.getRawInformation().getStretchMin();
                  if (rawStretchMin !== 0) {
                    const stretchMin = this._pixelToCharWidth(rawStretchMin, layoutInfo.getCharSize());
                    width = stretchMin > width ? stretchMin : width;
                  }
                }
              }
              minWidth = Math.min(minWidth, width);

              // generate grid template for each visible column on current screen viewport
              if (!columnWidget.isDetachedFromDom()) {
                if (!columnWidget.isFrozen()) { // detected our first column which can be scrolled
                  foundScrollableColumn = true;
                }
                let columnWidthData = {
                  width: width,
                  stretchX: layoutInfo.isXStretched(),
                  stretchMin: layoutInfo.getRawInformation().getStretchMin(),
                  stretchMax: layoutInfo.getRawInformation().getStretchMax(),
                  charSize: layoutInfo.getCharSize()
                };
                maxCharSize = Math.max(maxCharSize, layoutInfo.getCharSize());
                this._visibleColumnsWidth.push(columnWidthData);
              } else if (!foundScrollableColumn) {
                // build our scroll left value which will be consumed by our spacer "margin" css grid column
                this._totalDetachedWidth += width;
              }
              this._totalColumnsWidth += width;
            }

            // height
            if (measureRows && !columnWidget.isHidden()) {
              let height = layoutInfo.getMeasured().getHeight();
              this._visibleItemsInRowHeight.push(height);
            }

            measureDone = true;
          }

          // If table fills empty space, set last column to fill it
          if (this._widget.isResizeFillsEmptySpace() && this._visibleColumnsWidth.last()) {
            this._visibleColumnsWidth.last().fillEmptySpace = true;
          }

          const rowboundColumnWidthData = {
            width: this._getRowBoundWidth(),
            stretchX: false,
            stretchMin: 0,
            stretchMax: this._getRowBoundWidth(),
            charSize: maxCharSize
          };
          this._visibleColumnsWidth.push(rowboundColumnWidthData);
          this._totalColumnsWidth += rowboundColumnWidthData.width;

          this._applyCss(measureRows, measureCols);

          return measureDone;
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          let layoutInfo = this._widget.getLayoutInformation();
          let scrollAreaElementWidth = this._widget.getScrollableArea().offsetWidth;
          let scrollAreaElementHeight = this._widget.getScrollableArea().offsetHeight;
          let decorateWidth = this._widget.getElement().offsetWidth - scrollAreaElementWidth;
          let decorateHeight = this._widget.getElement().offsetHeight - scrollAreaElementHeight;

          decorateWidth += window.scrollBarSize;
          if (!this._widget.isFlipped()) {
            decorateHeight += window.scrollBarSize;
          }
          layoutInfo.setDecorating(decorateWidth, decorateHeight);
        },

        //#endregion

        //#region CSS

        /**
         * Filter which CSS to build and apply depending on the table configuration
         * @param {boolean} measureRows Should we build and apply the CSS for rows
         * @param {boolean} measureCols Should we build and apply the CSS for columns
         * @private
         */
        _applyCss: function(measureRows, measureCols) {
          // Else apply the CSS
          this._widget.setStyle({
            "--visibleColumnCount": this._visibleColumnsWidth.length
          });

          if (this._widget.getViewType() === "listview") {
            let rowHeight = this._visibleItemsInRowHeight[0];
            if (this._visibleItemsInRowHeight.length > 1) {
              rowHeight += this._visibleItemsInRowHeight[1];
            }
            if (this._visibleItemsInRowHeight.length > 2) {
              rowHeight = Math.max(rowHeight, this._visibleItemsInRowHeight[2]);
            }
            this._widget.setRowHeight(rowHeight);
          } else if (this._getWidget().isFlipped()) {
            this._applyFlippedTableCss();
          } else {
            this._applyClassicTableCss(measureRows, measureCols);
          }
        },

        /**
         * Build the css template for classic table
         * @param {boolean} measureRows Should we build and apply the CSS for rows
         * @param {boolean} measureCols Should we build and apply the CSS for columns
         * @private
         */
        _applyClassicTableCss: function(measureRows, measureCols) {
          // set grid-template-columns (columns width)
          if (measureCols) {
            let strTemplateColumns = "";

            let isAnyColumnStretchX = false;
            for (let i = 0; i < this._visibleColumnsWidth.length; i++) {
              let colWidth;
              const widthObj = this._visibleColumnsWidth[i];
              const widthCss = `${widthObj.width}px`;

              // add scroll left spacer grid template after visible left frozen columns to avoid glitch with frozen columns during scrolling
              const totalLeftFrozenCols = this._widget.getTotalVisibleLeftFrozenColumns();
              if (totalLeftFrozenCols !== this._visibleColumnsWidth.length && i === totalLeftFrozenCols) {
                strTemplateColumns += ` ${this._totalDetachedWidth}px`;
              }

              if (widthObj.stretchX) {
                isAnyColumnStretchX = true;
                // if stretchMin === 0 min is the form width
                // if stretchMax === 0 max is infinity
                // (minWidth || 1) to avoid division by 0 which returns NaN
                const stretchMin = widthObj.stretchMin === 0 ? widthCss :
                  `${this._pixelToCharWidth(widthObj.stretchMin, widthObj.charSize)}px`;
                const stretchMax = widthObj.stretchMax === 0 ? `${widthObj.width / (this._computedMinWidth || 1)}fr` : `${this._pixelToCharWidth(widthObj
                  .stretchMax,
                  widthObj.charSize)}px`;
                colWidth = ` minmax(${stretchMin}, ${stretchMax})`;
              } else if (widthObj.fillEmptySpace && !isAnyColumnStretchX) {
                colWidth = " auto"; // auto in CSS grid will take the available space
              } else {
                colWidth = ` ${widthCss}`;
              }
              strTemplateColumns += colWidth;
            }

            // if we have frozen columns only, add 0 for the left spacer located after the frozen columns
            // this is needed to respect the grid css template order
            if (this._widget.getTotalVisibleLeftFrozenColumns() === this._visibleColumnsWidth.length) {
              strTemplateColumns += " 0";
            }

            // set 1px horizontal div total width to create the scroll as if all columns went in DOM
            this._widget.getElement().style.setProperty("--scrollWidth", `${this._totalColumnsWidth}px`);

            // set/update css grid template computed on each visible columns (based on columns orders).
            this._widget.getElement().style.setProperty("--gridTemplateColumns", strTemplateColumns);
          }

          if (measureRows) {
            this._visibleItemsInRowHeight.push(context.ThemeService.getTableMinimalRowHeight());
            const rowHeight = Math.max(...this._visibleItemsInRowHeight);
            this._widget.setRowHeight(rowHeight);
          }
        },

        //#endregion

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          let children = [];
          if (this._widget && !this.isLayoutDone()) {
            let rows = this._widget.getRows();
            if (rows.length > 0) {
              let firstRowTableItemWidgets = rows[0].getChildren();
              for (const tableItemWidget of firstRowTableItemWidgets) {
                const widget = tableItemWidget.getChildren()[0];
                if (widget) {
                  children.push(widget);
                }
              }
            }
          }
          return children;
        },

        /**
         * Build the CSS template for flipped tables
         * @private
         */
        _applyFlippedTableCss: function() {
          let rowHeight = this._visibleItemsInRowHeight.reduce((accumulator, height) => accumulator + height, 0);
          rowHeight = Math.ceil(rowHeight);
          this._getWidget().setRowHeight(rowHeight);
          this._getWidget().setStyle({
            "--rowBoundWidth": `${this._getRowBoundWidth()}px`
          });
        },

        /**
         * helper function to compute width in pixels according to a number of char
         * @returns The width in pixels
         * @private
         */
        _pixelToCharWidth: function(nbChar, charSize) {
          return cls.CharSize.translate(nbChar, charSize.getWidthM(), charSize.getWidth0());
        }
      };
    });
  });
;

"use strict";

modulum('ScrollLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class ScrollLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    // TODO why it is a layoutEngienBase or why it is in leaf directory ?
    cls.ScrollLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function() {
      return /** @lends classes.ScrollLayoutEngine.prototype */ {
        __name: "ScrollLayoutEngine",

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const parentWidget = this._widget.getParentWidget();
          const parentLayoutInfo = this._getLayoutInfo(parentWidget);
          // widget => scroll Widget

          // Calculate needed values
          const widgetHeight = parentLayoutInfo.getAllocated()._height;
          let lineHeight = parentWidget.getRowHeight ? parentWidget.getRowHeight() : (parseFloat(widgetHeight) / this._widget._pageSize) ||
            0;

          if (lineHeight === 0 && parentWidget._isGridChildrenInParent && this._widget._pageSize > 0) {
            lineHeight = parentLayoutInfo.getAllocated().getHeight() / this._widget._pageSize;
            const allocatedSize = parentLayoutInfo.getAllocated();
            parentLayoutInfo.setMeasured(allocatedSize.getWidth(), allocatedSize.getHeight());
          }

          this._widget.setLineHeight(lineHeight);
          this._widget.setTotalHeight(lineHeight * this._widget._size);

          this._widget.setVisibleHeight(widgetHeight);
          if (this._widget.refreshScroll) {
            this._widget.refreshScroll();
          }
        }
      };
    });
  });
;

"use strict";

modulum('SliderLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class SliderLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.SliderLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.SliderLayoutEngine.prototype */ {
        __name: "SliderLayoutEngine",

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);
          const layoutInfo = this._widget.getLayoutInformation();
          if (this._widget._orientation === "vertical") {
            layoutInfo.getMeasured().rotate();
            layoutInfo.getPreferred().rotate();
            layoutInfo.getMinimal().rotate();
            layoutInfo.getMaximal().rotate();
          }
        },

        /**
         * @inheritDoc
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const rawMeasure = layoutInfo.getRawMeasure();

          const width = layoutInfo.getPreferred().getWidth(true);
          const height = rawMeasure.getHeight(true);
          layoutInfo.setMeasured(width, height);
        }

      };
    });
  });
;

"use strict";

modulum('StretchableScrollLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class StretchableScrollLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.StretchableScrollLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.StretchableScrollLayoutEngine.prototype */ {
        __name: "StretchableScrollLayoutEngine",

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          $super.measureDecoration.call(this);
          const paginationWidget = this._widget.getPaginationWidget ? this._widget.getPaginationWidget() : null;
          const paginationHeight = paginationWidget ? paginationWidget.getElement().getBoundingClientRect().height : 0;
          const layoutInfo = this._widget.getLayoutInformation();
          layoutInfo.setDecorating(window.scrollBarSize, paginationHeight + window.scrollBarSize);
        },

        /**
         * @inheritDoc
         */
        DOMMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation(),
            element = this._widget.getContainerElement(),
            elemRects = element.getBoundingClientRect();

          layoutInfo.setRawMeasure(elemRects.width, elemRects.height);
        },

        /**
         * @inheritDoc
         */
        measure: function() {
          $super.measure.call(this);

          if (!this._widget._firstPageSize) {
            this._widget._firstPageSize = this._widget._pageSize;
          }
        },

        invalidateMeasure: function(invalidation) {
          $super.measure.call(this, invalidation);
          this._widget.resetRowHeight();
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          let layoutInfo = this._widget.getLayoutInformation();
          let children = this.getRenderableChildren();
          let decorationHeight = layoutInfo.getDecorating().getHeight(true);

          if (children.length > 0) {
            let childMinimal = children[0].getLayoutInformation().getMinimal(); // take row margin into consideration
            let rowMargin = parseFloat(context.ThemeService.getValue("gbc-ScrollGridWidget-margin-ratio"), 10);
            let rowHeight = childMinimal.getHeight() + rowMargin;

            let preferredPageSize = this._widget._firstPageSize ?
              Math.max(this._widget._firstPageSize, 1) : 1;

            // we calculate preferred height based on row height and current page size
            let preferredHeight = preferredPageSize * rowHeight;
            layoutInfo.getMinimal().setHeight(rowHeight);
            layoutInfo.getPreferred().setHeight(preferredHeight);

            layoutInfo.getMinimal().setWidth(
              Math.max(
                layoutInfo.getMinimal().getWidth(true),
                childMinimal.getWidth(true) + layoutInfo.getDecorating().getWidth()
              )
            );

          } else {
            layoutInfo.setMinimal(0, decorationHeight);
          }

          let sizeX = layoutInfo.isXStretched() ?
            layoutInfo.getAvailable().getWidth() - layoutInfo.getDecorating().getWidth() :
            layoutInfo.getMinimal().getWidth(true);

          // biggest value between preferred and minimal is our measured height
          let sizeY = Math.max(layoutInfo.getMinimal().getHeight(true), layoutInfo.getPreferred().getHeight(true));

          layoutInfo.setMeasured(sizeX, sizeY);
          layoutInfo.setPreferred(sizeX, sizeY);
          layoutInfo.setAllocated(sizeX, sizeY);

          if (!(this._widget instanceof cls.PagedScrollGridWidget)) {
            children.forEach((w) => {
              w.getLayoutInformation().getAvailable().setWidth(sizeX);
              w.getLayoutInformation().getAllocated().setWidth(sizeX);
            });
          }
        }

      };
    });
  });
;

"use strict";

modulum('TableLayoutEngineBase', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * Base code for RTable, FLIPPED RTable and FLIPPED RTable displayed as list
     * @class TableLayoutEngineBase
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.TableLayoutEngineBase = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.TableLayoutEngineBase.prototype */ {
        __name: "TableLayoutEngineBase",

        /** @type {boolean} */
        _layoutDone: false,

        /** @type {number} */
        _minPageSize: 1,
        /** @type {number} */
        _minWidth: 60,
        /** @type {boolean} */
        _initialPreferredSize: false,

        _visibleColumnsWidth: null,
        _visibleItemsInRowHeight: null,
        _totalColumnsWidth: 0,
        _totalDetachedWidth: 0,
        _computedMinWidth: 0,
        _computedMaxWidth: 0,

        /**
         * @inheritDoc
         */
        reset: function(recursive) {
          $super.reset.call(this, recursive);
          this._initialPreferredSize = false;
        },

        /**
         * Returns if layout has been done at least one time
         * @return {boolean} layout done ?
         */
        isLayoutDone: function() {
          return this._layoutDone;
        },

        /**
         * @inheritDoc
         */
        resetLayout: function() {
          this._layoutDone = false;
          this._widget.getElement().style.setProperty("--gridTemplateColumns", null);
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          this._invalidatedAllocatedSpace = invalidation || context.LayoutInvalidationService.nextInvalidation();
        },

        // TODO check if this override is necessary
        /**
         * @inheritDoc
         */
        setHint: function(widthHint, heightHint) {
          this._widget.getLayoutInformation().setSizeHint(
            ((typeof(widthHint) === "undefined") || widthHint === null || widthHint === "") ? 0 : widthHint,
            ((typeof(heightHint) === "undefined") || heightHint === null || heightHint === "") ? 0 : heightHint
          );
        },

        /**
         * @inheritDoc
         */
        needMeasureSwitching: function() {
          return this._widget.isVisibleRecursively();
        },

        /**
         * Translate table height into number of rows
         * @param {number} height - table height (ex: 10, 10 row, 10 em, ...)
         * @param {number} charHeight - height of a char (pixels)
         * @param {number} rowHeight - height of table rows (pixels)
         * @return {number} number of rows
         */
        _convertHeightToRowCount: function(height, charHeight, rowHeight) {
          if (!height) {
            return 0;
          }
          if (Object.isNumber(height)) {
            return height;
          }

          const result = cls.Size.valueRE.exec(height);
          if (!result) {
            return 0;
          }

          let rowResult = 0;
          const numeric = +result[1];
          const unit = result[2];
          switch (unit) {
            case "ln":
            case "row":
              rowResult = numeric;
              break;
            case "ch":
            case "em": {
              const fontSizeRatio = parseFloat(context.ThemeService.getValue("theme-font-size-ratio"));
              charHeight = +charHeight || (16 * fontSizeRatio);
              rowResult = Object.isNumber(rowHeight) && rowHeight ? Math.ceil((numeric * charHeight) / rowHeight) : 0;
              break;
            }
            case "px":
              rowResult = Object.isNumber(rowHeight) && rowHeight ? Math.ceil(numeric / rowHeight) : 0;
              break;
            default:
              rowResult = numeric;
              break;
          }

          return rowResult;
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {},

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          const layoutInfo = this._widget.getLayoutInformation();
          const rowHeight = this._widget.getRowHeight();
          const formWidget = this._widget.getFormWidget();

          // default minimum height
          let minHeight = this.getMinPageSize() * rowHeight + layoutInfo.getDecorating().getHeight();

          // we don't want to override the min height if we are in auto overflow mode
          // because this min height has been computed in the first adjustMeasure pass.
          if (!(formWidget && formWidget.getLayoutEngine().isAutoOverflowActivated())) {
            layoutInfo.getMinimal().setHeight(minHeight);
          }
          // default minimum width
          const minWidth = this.getMinWidth() + layoutInfo.getDecorating().getWidth();
          layoutInfo.getMinimal().setWidth(minWidth);

          // if fixedPageSize or window sizable=false --> height of table must be fixed
          if (this._widget.isFixedPageSize()) {
            const preferredPageSize = this._widget._firstPageSize ? Math.max(this._widget._firstPageSize, 1) : 1;
            minHeight = preferredPageSize * rowHeight + layoutInfo.getDecorating().getHeight();
            layoutInfo.getMinimal().setHeight(minHeight);
            layoutInfo.getMeasured().setHeight(minHeight);
            layoutInfo.getMaximal().setHeight(minHeight);
          } else {
            layoutInfo.getMeasured().setHeight(Math.max(layoutInfo.getMinimal().getHeight(true), layoutInfo.getPreferred().getHeight(
              true)));
          }

          // Set measured width
          layoutInfo.getMeasured().setWidth(Math.max(layoutInfo.getMinimal().getWidth(true), layoutInfo.getPreferred().getWidth(
            true)) + layoutInfo.getDecorating().getWidth());
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          $super.prepareApplyLayout.call(this);
          // need to fix allocated height as late as possible to avoid current row not being visible (GBC-1606)
          if (this._widget.isFixedPageSize()) {
            // Fix height when page size is fixed
            const layoutInfo = this._widget.getLayoutInformation();
            layoutInfo.getAllocated().setHeight(layoutInfo.getMinimal().getHeight());

            this._widget.setStyle({
              preSelector: ".g_measured ",
              selector: ".g_measureable",
              appliesOnRoot: true
            }, {
              height: this._getLayoutInfo().getAllocated().getHeight() + "px"
            });
          }
        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          // set correct width of the table when measuring to avoid reset of horizontal scrollbar
          $super.applyLayout.call(this);
          this._widget.setStyle({
            preSelector: ".g_measuring ",
            selector: ".g_measureable",
            appliesOnRoot: true
          }, {
            width: `${this._getLayoutInfo().getAllocated().getWidth()}px !important`,
          });
        },

        /**
         * Returns minimum page size
         * @return {number} min page size
         */
        getMinPageSize: function() {
          return this._minPageSize;
        },

        /**
         * Sets minimum page size
         * @param {number} minPageSize - min page size
         */
        setMinPageSize: function(minPageSize) {
          this._minPageSize = minPageSize;
        },

        /**
         * Returns minimum width (pixels)
         * @return {number} min width
         */
        getMinWidth: function() {
          return this._minWidth;
        },

        /**
         * Sets minimum width (pixels)
         * @param {number} minWidth - min width
         */
        setMinWidth: function(minWidth) {
          this._minWidth = minWidth;
        },

        /**
         * Compute the rowbound width depending on the parent widget rowbound actions
         * @returns The Rowbound Width in pixel
         */
        _getRowBoundWidth: function() {
          return this._widget.haveRowBoundActions() ? 32 : 0;
        }
      };
    });
  });
;

"use strict";

modulum('TextEditLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class TextEditLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.TextEditLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.TextEditLayoutEngine.prototype */ {
        __name: "TextEditLayoutEngine",

        /**
         * @inheritDoc
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          const rawMeasure = layoutInfo.getRawMeasure();

          if (currentSizePolicy.isFixed()) {
            if (!layoutInfo.hasBeenFixed) {
              this._setFixedMeasure();
              layoutInfo.hasBeenFixed = true;
            }
          } else if (layoutInfo._widget.isVisible() && layoutInfo.needMeasure()) {
            const width = Math.max(layoutInfo.getPreferred().getWidth(true), rawMeasure.getWidth(true));
            const height = Math.max(layoutInfo.getPreferred().getHeight(true), rawMeasure.getHeight(true));
            layoutInfo.setMeasured(width, height);
          }
        }

      };
    });
  });
;

"use strict";

modulum('WebComponentLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {

    /**
     * @class WebComponentLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.WebComponentLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.WebComponentLayoutEngine.prototype */ {
        __name: "WebComponentLayoutEngine",

        /**
         * @inheritDoc
         */
        _measure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const currentSizePolicy = layoutInfo.getCurrentSizePolicy();
          const rawMeasure = layoutInfo.getRawMeasure();

          if (currentSizePolicy.isFixed()) {
            if (!layoutInfo.hasBeenFixed) {
              this._setFixedMeasure();
              layoutInfo.hasBeenFixed = true;
            }
          } else if (layoutInfo._widget.isVisible() && layoutInfo.needMeasure()) {
            const width = Math.max(layoutInfo.getPreferred().getWidth(true), rawMeasure.getWidth(true));
            const height = Math.max(layoutInfo.getPreferred().getHeight(true), rawMeasure.getHeight(true));
            layoutInfo.setMeasured(width, height);
          }
        }

      };
    });
  });
;

"use strict";

modulum('MenuLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class MenuLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.MenuLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.MenuLayoutEngine.prototype */ {
        __name: "MenuLayoutEngine",

        /**
         * @inheritDoc
         */
        needMeasureSwitching: function() {
          return !this._widget || !this._widget.isPopup || !this._widget.isPopup();
        },

        /**
         * @inheritDoc
         */
        ignoreMeasureInvalidation: function() {
          return this._widget && this._widget.isPopup && this._widget.isPopup();
        }
      };
    });
  });
;

"use strict";

modulum('NoLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class NoLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.NoLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.NoLayoutEngine.prototype */ {
        __name: "NoLayoutEngine"
      };
    });
  });
;

"use strict";

modulum('StackGroupLayoutEngine', ['StackLayoutEngine'],
  function(context, cls) {
    /**
     * @class StackGroupLayoutEngine
     * @memberOf classes
     * @extends classes.StackLayoutEngine
     */
    cls.StackGroupLayoutEngine = context.oo.Class(cls.StackLayoutEngine, function($super) {
      return /** @lends classes.StackGroupLayoutEngine.prototype */ {
        __name: "StackGroupLayoutEngine",

        _titleWidth: 0,

        /**
         * @inheritDoc
         */
        measure: function(invalidation) {
          $super.measure.call(this);
          if (this._widget._title.getLayoutEngine().isInvalidatedMeasure(invalidation)) {
            this._titleWidth = this._widget._title.getElement().clientWidth + this._getLayoutInfo().getDecorating().getHeight(true);
          }
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          $super.adjustMeasure.call(this);
          const layoutInfo = this._getLayoutInfo();
          const minimal = layoutInfo.getMinimal().getWidth(true);
          layoutInfo.getMinimal().setWidth(Math.max(this._titleWidth, minimal));
        }
      };
    });
  });
;

"use strict";

modulum('StackLayoutEngine', ['LeafLayoutEngine'],
  function(context, cls) {
    /**
     * @class StackLayoutEngine
     * @memberOf classes
     * @extends classes.LeafLayoutEngine
     */
    cls.StackLayoutEngine = context.oo.Class(cls.LeafLayoutEngine, function($super) {
      return /** @lends classes.StackLayoutEngine.prototype */ {
        __name: "StackLayoutEngine",
        /**
         * @type {classes.WidgetBase[]}
         */
        _registeredWidgets: null,
        /**
         * set to false to avoid render children
         * @type {boolean}
         */
        _willRenderContent: true,
        /**
         * stylesheet id
         */
        _styleSheetId: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._registeredWidgets = [];
          this._styleSheetId = "stackLayout_" + this._widget.getUniqueIdentifier();
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          for (let i = this._registeredWidgets.length - 1; i > -1; i--) {
            const wi = this._registeredWidgets[i];
            this.unregisterChild(wi);
          }
          this._registeredWidgets.length = 0;
          $super.destroy.call(this);
        },

        /**
         * whether to render content or not
         * @return {boolean}  true if content has to be rendered
         */
        willRenderContent: function() {
          const parentEngine = this._widget && this._widget.getParentWidget() &&
            this._widget.getParentWidget().isInstanceOf(cls.GroupWidget) &&
            this._widget.getParentWidget().getLayoutEngine(),
            hasWillRenderContent = parentEngine && parentEngine.willRenderContent;
          return this._willRenderContent && (!hasWillRenderContent || parentEngine.willRenderContent());
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return this.willRenderContent() && this._registeredWidgets || [];
        },

        /**
         * @inheritDoc
         * @param {classes.WidgetBase} widget child widget
         * @param {number} position the wanted position
         */
        registerChild: function(widget, position) {
          if (this._registeredWidgets.indexOf(widget) < 0) {
            this._registeredWidgets.splice(position * 2, 0, widget.getLayoutInformation()._stackLabel, widget);
          }
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._registeredWidgets.remove(widget.getLayoutInformation()._stackLabel);
          this._registeredWidgets.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareMeasure: function() {
          let parent = this._widget.getParentWidget(),
            foundStack = false;
          while (!foundStack && parent) {
            foundStack = Boolean(parent.getLayoutEngine()) && parent.getLayoutEngine().isInstanceOf(cls.StackLayoutEngine);
            parent = parent.getParentWidget();
          }
          this._isTopStack = !foundStack;
        },

        /**
         * @inheritDoc
         */
        prepareAdjustments: function() {
          const children = this.getRenderableChildren();
          for (let i = 1; i < children.length; i += 2) {
            children[i - 1].setHidden(children[i].isHidden());
          }
        },

        /**
         * @inheritDoc
         */
        measureDecoration: function() {
          const element = this._widget.getElement(),
            container = this._widget.getContainerElement();
          this._getLayoutInfo().setDecorating(
            element.clientWidth - container.clientWidth,
            element.clientHeight - container.clientHeight
          );
          this._getLayoutInfo().setDecoratingOffset(
            container.offsetLeft - element.offsetLeft,
            container.offsetTop - element.offsetTop
          );
        },

        /**
         * @inheritDoc
         */
        adjustMeasure: function() {
          const layoutInfo = this._widget.getLayoutInformation();
          const children = this.getRenderableChildren();
          let minX = 0,
            minY = 0,
            preferredX = 0,
            preferredY = 0;

          this._visibleChildren = 0;
          for (const element of children) {
            if (element.isVisible() && this.willRenderContent()) {
              if (!element.isInstanceOf(cls.StackLabelWidget)) {
                this._visibleChildren++;
              }
              const childInfo = element.getLayoutInformation();
              const childHeight = Math.max(childInfo.getMinimal().getHeight(true), childInfo.getPreferred().getHeight(true));
              minX = Math.max(minX, childInfo.getMinimal().getWidth(true));
              minY += childHeight;
              preferredX = Math.max(preferredX, childInfo.getPreferred().getWidth(true));
              preferredY += childHeight;
            }
          }
          minX += layoutInfo.getDecorating().getWidth(true);
          minY += layoutInfo.getDecorating().getHeight(true);
          preferredX += layoutInfo.getDecorating().getWidth(true);
          preferredY += layoutInfo.getDecorating().getHeight(true);
          layoutInfo.setMinimal(minX, minY);
          layoutInfo.setMeasured(minX, minY);

          layoutInfo.setPreferred(preferredX, preferredY);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function(layoutApplicationService) {
          const children = this.getRenderableChildren();
          const layoutInfo = this._widget.getLayoutInformation();
          let childInfo, i;
          let childrenWidth = layoutInfo.getAvailable().getWidth(true) - layoutInfo.getDecorating().getWidth(true);
          let minChildrenWidth = 0,
            columns = 1,
            maxHeight = 0,
            currentItemHeight = 0,
            currentLineHeight = 0;
          if (this._isTopStack) {
            minChildrenWidth = layoutInfo.getMinimal().getWidth(true);
            columns = Math.min(Math.floor(this._visibleChildren), Math.floor(childrenWidth / minChildrenWidth));
            if (columns > 1) {
              childrenWidth = childrenWidth / columns;
            }
            if (children.length === 2) {
              this._shouldStretch = true;
            }
          }
          for (i = 0; i < children.length; i++) {
            childInfo = children[i].getLayoutInformation();
            childInfo.getMaximal().setWidth(layoutInfo.getAvailable().getWidth(true));
            let childHeight = Math.max(childInfo.getMinimal().getHeight(true), childInfo.getPreferred().getHeight(true));
            if (layoutApplicationService && childInfo._keepRatio) {
              layoutApplicationService.activateBackLayout();
              childHeight = childInfo.getMaximal().getWidth() * childInfo._sizeRatio;
              childInfo.getMinimal().setHeight(childHeight);
              childInfo.getMeasured().setHeight(childHeight);
              childInfo.getMaximal().setHeight(childHeight);
            }
            if (i % (columns * 2) === 0) {
              maxHeight += currentLineHeight;
              currentLineHeight = 0;
            }
            currentItemHeight += childHeight;
            if (i % 2 === 1) {
              if (this._shouldStretch && childInfo.shouldFillStack) {
                const labelHeight = currentItemHeight - childHeight;
                childHeight = layoutInfo.getAvailable().getHeight(true) - labelHeight;
              }
              currentLineHeight = Math.max(currentLineHeight, currentItemHeight);
              currentItemHeight = 0;
            }
            childInfo.setAvailable(childrenWidth, childHeight);
            childInfo.setAllocated(childrenWidth, childHeight);

            this._styleRules[".g_measured #w_" + children[i].getUniqueIdentifier() + ".g_measureable"] = {
              "height": childHeight + "px",
              "width": childrenWidth + "px"
            };
          }
          maxHeight += currentLineHeight;
          layoutInfo.setAllocated(layoutInfo.getAvailable().getWidth(true), maxHeight);

        },

        /**
         * @inheritDoc
         */
        applyLayout: function() {
          context.styler.appendStyleSheet(this._styleRules, this._styleSheetId, true, this.getLayoutSheetId());
        }
      };
    });
  });
;

"use strict";

modulum('TraditionalLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {

    /**
     * @class TraditionalLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.TraditionalLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.TraditionalLayoutEngine.prototype */ {
        __name: "TraditionalLayoutEngine",

        _children: null,

        /**
         * @inheritDoc
         * @constructs
         */
        constructor: function(widget) {
          $super.constructor.call(this, widget);
          this._children = [];
        },

        /**
         * @inheritDoc
         */
        registerChild: function(widget) {
          this._children.push(widget);
          const li = widget.getLayoutInformation();
          li.className = 'tgl_' + widget.getUniqueIdentifier();
          li.styleRules = {};
          li.styleRulesContent = {};
          li.styleRules['.' + li.className] = li.styleRulesContent;
        },

        /**
         * @inheritDoc
         */
        unregisterChild: function(widget) {
          this._children.remove(widget);
        },

        /**
         * @inheritDoc
         */
        prepareApplyLayout: function() {
          const heightpadding = parseFloat(context.ThemeService.getValue("theme-field-height-ratio"));
          const fieldheight = parseFloat(context.ThemeService.getValue("theme-field-default-height"));
          const letterSpacing = context.ThemeService.getValue("theme-traditional-mode-letter-spacing");

          for (const child of this._children) {
            child.traditionalDisplay(letterSpacing, fieldheight, heightpadding);
          }
        },

        /**
         * @inheritDoc
         */
        getRenderableChildren: function() {
          return [];
        }
      };
    });
  });
;

"use strict";

/**
 * Size values' type. Should be a {number}
 * @typedef {?number} classes.SizeValue
 */

/**
 * Two dimension grid slot
 * @typedef {Object} classes.XYDimensionSlot
 * @property {classes.GridDimensionSlot} x X-dimension slot
 * @property {classes.GridDimensionSlot} y Y-dimension slot
 */

/**
 * Grid info
 * @typedef {Object} classes.GridInfo
 * @property {?number} x x coordinate
 * @property {?number} y y coordinate
 * @property {?number} width width in grid
 * @property {?number} height height in grid
 */

/**
 * Layout Statuses
 * @typedef {Object} classes.LayoutStatus
 * @property {boolean} measured has been measured
 * @property {boolean} adjusted has been adjusted
 * @property {boolean} layouted has been layouted
 */
;

"use strict";

modulum('UserInterfaceLayoutEngine', ['LayoutEngineBase'],
  function(context, cls) {
    /**
     * @class UserInterfaceLayoutEngine
     * @memberOf classes
     * @extends classes.LayoutEngineBase
     */
    cls.UserInterfaceLayoutEngine = context.oo.Class(cls.LayoutEngineBase, function($super) {
      return /** @lends classes.UserInterfaceLayoutEngine.prototype */ {
        __name: "UserInterfaceLayoutEngine",

        /**
         * @inheritDoc
         */
        invalidateMeasure: function(invalidation) {
          const invalidated = !invalidation || this._invalidatedMeasure < invalidation;
          $super.invalidateMeasure.call(this, invalidation);
          if (invalidated) {
            this.invalidateAllocatedSpace(this._invalidatedMeasure);
          }
        },

        /**
         * @inheritDoc
         */
        invalidateAllocatedSpace: function(invalidation) {
          const invalidated = !invalidation || this._invalidatedAllocatedSpace < invalidation;
          $super.invalidateAllocatedSpace.call(this, invalidation);
          if (invalidated) {
            this.invalidateMeasure(this._invalidatedAllocatedSpace);
          }
        },

      };
    });
  });
;

"use strict";

modulum("CharSize",
  function(context, cls) {
    /**
     * Data class to store sizes af character in terms of Genero layout.
     * Will store width of a "M", width of a "0", and height of a "M"
     * @class CharSize
     * @memberOf classes
     */
    cls.CharSize = context.oo.Class(function() {
      return /** @lends classes.CharSize.prototype */ {
        $static: /** @lends classes.CharSize */ {
          translate: function(size, widthM, width0) {
            return cls.Size.translate(size, function(s) {
              let result = Math.min(6, s) * widthM;
              if (s > 6) {
                result += (s - 6) * width0;
              }
              return result;
            });
          },
        },
        __name: "CharSize",
        /**
         * @type {classes.SizeValue}
         */
        _widthM: null,
        /**
         * @type {classes.SizeValue}
         */
        _width0: null,
        /**
         * @type {classes.SizeValue}
         */
        _height: null,
        /**
         * @type {number}
         */
        _defaultWidthM: 0,
        /**
         * @type {number}
         */
        _defaultWidth0: 0,
        /**
         * @type {number}
         */
        _defaultHeight: 0,
        /**
         *
         * @param {{widthM:number, width0:number, height:number}} [rawOptions]
         */
        constructor: function(rawOptions) {
          const opts = rawOptions || {};
          this._widthM = Object.isNumber(opts.widthM) ? opts.widthM : 0;
          this._width0 = Object.isNumber(opts.width0) ? opts.width0 : 0;
          this._height = Object.isNumber(opts.height) ? opts.height : 0;
        },

        /**
         * reset values to 0
         */
        reset: function() {
          this._widthM = 0;
          this._width0 = 0;
          this._height = 0;
        },

        /**
         * Return whether the width of the letter 'M' is set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width of a "M" is set
         */
        hasWidthM: function(considerZero) {
          return considerZero && !this._widthM || this._widthM > 0;
        },

        /**
         * Return whether the width of the '0' is set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width of a "0" is set
         */
        hasWidth0: function(considerZero) {
          return considerZero && !this._width0 || this._width0 > 0;
        },

        /**
         * Return whether the height of the letter 'M' is set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if height of a "M" is set
         */
        hasHeight: function(considerZero) {
          return considerZero && !this._height || this._height > 0;
        },

        /**
         * Return whether the widths or height are set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if either widths or height is set
         */
        hasSize: function(considerZero) {
          return (this.hasWidth0(considerZero) && this.hasWidthM(considerZero)) || this.hasHeight(considerZero);
        },

        /**
         * Get the width of a "M"
         * @param {boolean} [useFallback] true to return default "M" width value if not set
         * @return {?number} width of a "M"
         */
        getWidthM: function(useFallback) {
          if (useFallback && !this.hasWidthM(true)) {
            return this._defaultWidthM;
          }
          return this._widthM;
        },

        /**
         * Get the width of a "0"
         * @param {boolean} [useFallback] true to return default "0" width value if not set
         * @return {?number} width of a "0"
         */
        getWidth0: function(useFallback) {
          if (useFallback && !this.hasWidth0(true)) {
            return this._defaultWidth0;
          }
          return this._width0;
        },

        /**
         * Get the height of a "M"
         * @param {boolean} [useFallback] true to return default "M" height value if not set
         * @return {?number} height of a "M"
         */
        getHeight: function(useFallback) {
          if (useFallback && !this.hasHeight(true)) {
            return this._defaultHeight;
          }
          return this._height;
        },

        /**
         * Set the width of a "M"
         * @param {number} widthM the value
         */
        setWidthM: function(widthM) {
          this._widthM = widthM;
        },

        /**
         * Set the width of a "0"
         * @param {number} width0 the value
         */
        setWidth0: function(width0) {
          this._width0 = width0;
        },

        /**
         * Set the height of a "M"
         * @param {number} height the value
         */
        setHeight: function(height) {
          this._height = height;
        }
      };
    });
  });
;

"use strict";

(
  function(context, cls) {
    const _cache = {};

    const getCacheFor = function(fontFamily, fontSize) {
      _cache[fontFamily] = _cache[fontFamily] || {};
      return (_cache[fontFamily][fontSize] = _cache[fontFamily][fontSize] || {
        width: [],
        height: null
      });
    };

    const measureElement = document.createElement("div");
    measureElement.classList.add("measureTool");
    document.body.appendChild(measureElement);

    const measurementHost = document.createElement("div");
    measurementHost.classList.add("measurementHost");
    document.body.appendChild(measurementHost);

    const measureWidth = function(fontFamily, fontSize, size) {
      const cache = getCacheFor(fontFamily, fontSize);
      if (Object.isNumber(cache.width[size])) {
        return cache.width[size];
      } else {
        measureElement.style.fontFamily = fontFamily;
        measureElement.style.fontSize = fontSize;
        measureElement.textContent = cls.Measurement.getTextSample(size, 1);
        // TODO : look further for this add
        // add 7 pixels: to match the width needed for an input with just a 'W' character
        return (cache.width[size] = (measureElement.getBoundingClientRect().width + 7));
      }
    };

    const measureHeight = function(fontFamily, fontSize, size) {
      const cache = getCacheFor(fontFamily, fontSize);
      if (Object.isNumber(cache.height)) {
        return cache.height;
      } else {
        measureElement.style.fontFamily = fontFamily;
        measureElement.style.fontSize = fontSize;
        measureElement.textContent = "X";
        // TODO : look further for this add
        // add 4 pixels: to match the height needed for an input with borders and paddings
        return (cache.height = (Math.max(20, measureElement.getBoundingClientRect().height * size + 4)));
      }
    };

    /**
     * Tool for rendered size measurement
     * Caches measurements for perfs.
     * @namespace classes.Measurement
     */
    cls.Measurement = context.oo.StaticClass(function() {
      return /** @lends classes.Measurement */ {
        __name: "Measurement",
        _samples: {},
        /**
         *
         * @param element
         */
        fontInfo: function(element) {
          const style = window.getComputedStyle(element);
          const fontFamilly = style.fontFamily === null || style.fontFamily === undefined ? style.fontFamily :
            style.fontFamily.escapeFontFamily();

          return {
            "font-family": fontFamilly,
            "font-size": style.fontSize,
            "font-weight": style.fontWeight
          };
        },
        measuredWidth: function(fontFamily, fontSize, size) {
          return measureWidth(fontFamily, fontSize, size);
        },
        measuredHeight: function(fontFamily, fontSize, size) {
          return measureHeight(fontFamily, fontSize, size);
        },

        getTextSample: function(width, height) {
          let result = this._samples["" + width + "x" + height];
          if (result) {
            return result;
          }
          let i;
          const M = Math.min(6, width),
            O = Math.max(0, (width - 6)),
            H = Math.max(height - 1, 0);
          result = [];
          for (i = 0; i < M; i++) {
            result.push("M");
          }
          for (i = 0; i < O; i++) {
            result.push("0");
          }
          for (i = 0; i < H; i++) {
            result.push("\nM");
          }
          result = this._samples["" + width + "x" + height] = result.join("");
          return result;
        }
      };
    });
  })(gbc, gbc.classes);
;

"use strict";

modulum("Size",
  function(context, cls) {
    /**
     * size (width, height)
     * @class Size
     * @memberOf classes
     */
    cls.Size = context.oo.Class(function() {
      return /** @lends classes.Size.prototype */ {
        $static: /** @lends classes.Size */ {
          /**
           * common size value regular expression
           * @type {RegExp}
           */
          valueRE: /([0-9]+)(px|em|ch|ln|col|row)/,

          /**
           * column based size value regular expression
           * @type {RegExp}
           */
          colsRE: /^([0-9]+)(ch|col|co)?$/,

          /**
           * maximal value constant
           * @type {number}
           */
          maximal: Number.POSITIVE_INFINITY,
          /**
           * Test if given value is intented to be a value representing a number of columns
           * @param {string} value - the value to test
           * @return {boolean} true if given value is intented to be a value representing a number of columns
           */
          isCols: function(value) {
            return cls.Size.colsRE.test(value);
          },

          _defaultTranslate: function(size) {
            let ratio = parseFloat(context.ThemeService.getValue("theme-font-size-ratio"));
            if (Number.isNaN(ratio)) {
              ratio = 1;
            }
            return size * 16 * ratio;
          },

          /**
           * translates a raw size in pixels
           * @param {*} size raw size
           * @param {Function|number} baseSize a function that takes size in parameter, or size of a unit
           * @return {number} the pixel size
           */
          translate: function(size, baseSize) {
            let trans = cls.Size._defaultTranslate;
            if (baseSize) {
              if (baseSize instanceof Function) {
                trans = baseSize;
              } else if (!Number.isNaN(+baseSize) && (+baseSize > 0)) {
                trans = function(size) {
                  return size * (+baseSize);
                };
              }
            }
            let pxResult = 0;
            if (size) {
              if (Object.isNumber(size)) {
                pxResult = trans(size);
              } else {
                const result = cls.Size.valueRE.exec(size);
                if (result) {
                  const numeric = +result[1],
                    unit = result[2];
                  switch (unit) {
                    case "ln":
                      pxResult = trans(numeric);
                      break;
                    case "col":
                      // TODO : read col widths
                      pxResult = trans(numeric * 2);
                      break;
                    case "row":
                      pxResult = numeric * context.ThemeService.getTableMinimalRowHeight();
                      break;
                    case "ch":
                    case "em":
                      pxResult = trans(numeric);
                      break;
                    default:
                      pxResult = numeric;
                      break;
                  }
                }
              }
            }
            return pxResult;
          },
          __cachedPxImportant: {},
          /**
           * get a cached string corresponding to the size en px
           * @param {number} val
           * @return {string}
           */
          cachedPxImportant: function(val) {
            if (!this.__cachedPxImportant[val]) {
              this.__cachedPxImportant[val] = [val, "px !important"].join("");
            }
            return this.__cachedPxImportant[val];
          }
        },
        __name: "Size",

        /**
         * the undefined value
         * @type {*}
         */
        _undefinedValue: null,
        /**
         * the width value
         * @type {classes.SizeValue}
         */
        _width: null,

        /**
         * the height value
         * @type {classes.SizeValue}
         */
        _height: null,

        /**
         * @type {number}
         */
        _defaultWidth: 0,
        /**
         * @type {number}
         */
        _defaultHeight: 0,
        /**
         *
         * @param {Object} [rawOptions] initialization options
         * @param {*} [rawOptions.undefinedValue] value when undefined
         * @param {number} [rawOptions.width] width to initialize
         * @param {number} [rawOptions.height] height to initialize
         * @constructs classes.Size
         */
        constructor: function(rawOptions) {
          const opts = rawOptions || {};
          this._undefinedValue = opts.undefinedValue || 0;
          this._width = Object.isNumber(opts.width) ? opts.width : this._undefinedValue;
          this._height = Object.isNumber(opts.height) ? opts.height : this._undefinedValue;
        },

        /**
         * reset values to undefined value
         */
        reset: function() {
          this._width = this._undefinedValue;
          this._height = this._undefinedValue;
        },

        /**
         * Return whether width is set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if width is set
         */
        hasWidth: function(considerZero) {
          return this._width !== this._undefinedValue && (Boolean(considerZero) || this._width > 0);
        },

        /**
         * Return whether height is set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if height is set
         */
        hasHeight: function(considerZero) {
          return this._height !== this._undefinedValue && (Boolean(considerZero) || this._height > 0);
        },

        /**
         * Return whether width or height are set or not
         * @param {boolean} [considerZero] true to consider 0 as a value
         * @return {boolean} true if either width or height is set
         */
        hasSize: function(considerZero) {
          return this.hasWidth(considerZero) || this.hasHeight(considerZero);
        },

        /**
         * Get the width.
         * @param {boolean} [useFallback] return undefined value if width value is not defined
         * @return {number} the width
         */
        getWidth: function(useFallback) {
          if (useFallback && !this.hasWidth(true)) {
            return this._defaultWidth;
          }
          return this._width;
        },

        /**
         * Get the height.
         * @param {boolean} [useFallback] return undefined value if height value is not defined
         * @return {number} the height
         */
        getHeight: function(useFallback) {
          if (useFallback && !this.hasHeight(true)) {
            return this._defaultHeight;
          }
          return this._height;
        },

        /**
         * Set the width
         * @param {number} width the width. If width is null, sets the undefined value
         */
        setWidth: function(width) {
          if (width === null) {
            this._width = this._undefinedValue;
          } else {
            this._width = width;
          }
        },

        /**
         * Set the height
         * @param {number} height the height. If height is null, sets the undefined value
         */
        setHeight: function(height) {
          if (height === null) {
            this._height = this._undefinedValue;
          } else {
            this._height = height;
          }
        },

        /**
         * Returns a new Size object with values from a substraction of each member
         * @param {classes.Size} size the other size to substract
         * @return {classes.Size} a new instance with the values resulting of a substraction
         */
        minus: function(size) {
          const result = new cls.Size({
            width: this.getWidth(true) - size.getWidth(true),
            height: this.getHeight(true) - size.getHeight(true)
          });
          result._defaultWidth = this._defaultWidth;
          result._defaultHeight = this._defaultHeight;
          return result;
        },

        /**
         * Returns a new Size object with the same values and default values
         * @param {boolean} [useFallback] use default value if value is not defined
         * @return {classes.Size} a new instance with the same values
         */
        clone: function(useFallback) {
          const result = new cls.Size({
            width: this.getWidth(useFallback),
            height: this.getHeight(useFallback)
          });
          result._defaultWidth = this._defaultWidth;
          result._defaultHeight = this._defaultHeight;
          return result;
        },

        /**
         * flip width and height values.
         */
        rotate: function() {
          const width = this.getHeight(true),
            height = this.getWidth(true);
          this._width = width;
          this._height = height;
        }
      };
    });
  });
;

"use strict";

modulum("SizePolicy",
  function(context, cls) {
    /**
     * Size Policy
     * @class SizePolicy
     * @memberOf classes
     */
    cls.SizePolicy = context.oo.Class(function() {
      return /** @lends classes.SizePolicy.prototype */ {
        __name: "SizePolicy",
        $static: /** @lends classes.SizePolicy */ {
          /**
           * @returns {classes.SizePolicy}
           */
          Fixed: function() {
            const result = new cls.SizePolicy();
            result._fixed = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          Initial: function() {
            const result = new cls.SizePolicy();
            result._growable = true;
            result._shrinkable = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          InitialGrow: function() {
            const result = new cls.SizePolicy();
            result._growable = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          InitialShrink: function() {
            const result = new cls.SizePolicy();
            result._shrinkable = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          Dynamic: function() {
            const result = new cls.SizePolicy();
            result._growable = true;
            result._shrinkable = true;
            result._dynamic = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          DynamicGrow: function() {
            const result = new cls.SizePolicy();
            result._growable = true;
            result._dynamic = true;
            return result;
          },
          /**
           * @returns {classes.SizePolicy}
           */
          DynamicShrink: function() {
            const result = new cls.SizePolicy();
            result._shrinkable = true;
            result._dynamic = true;
            return result;
          }
        },
        /**
         * @type {boolean}
         */
        _growable: false,
        /**
         * @type {boolean}
         */
        _dynamic: false,
        /**
         * @type {boolean}
         */
        _shrinkable: false,
        /**
         * @type {boolean}
         */
        _fixed: false,

        /**
         *
         * @returns {boolean}
         */
        canGrow: function() {
          return this._growable;
        },
        /**
         *
         * @returns {boolean}
         */
        canShrink: function() {
          return this._shrinkable;
        },
        setShrinkable: function(canShrink) {
          this._shrinkable = canShrink;
        },
        setGrowable: function(canGrow) {
          this._growable = canGrow;
        },
        isFixed: function() {
          return this._fixed;
        },
        isDynamic: function() {
          return this._dynamic;
        }
      };
    });
  });
;

"use strict";

modulum("SizePolicyConfig", ["SizePolicy"],
  function(context, cls) {
    /**
     * Size Policy Config
     * @class SizePolicyConfig
     * @memberOf classes
     */
    cls.SizePolicyConfig = context.oo.Class(function() {
      return /** @lends classes.SizePolicyConfig.prototype */ {
        __name: "SizePolicyConfig",

        /**
         * @type {classes.SizePolicy}
         */
        fixed: null,
        /**
         * @type {classes.SizePolicy}
         */
        initial: null,
        /**
         * @type {classes.SizePolicy}
         */
        dynamic: null,
        /**
         * @type {string}
         */
        mode: "initial",
        _defaultMode: "initial",
        /**
         * @type {boolean}
         */
        measured: false,
        /**
         *
         */
        constructor: function() {
          this.reset();
        },
        reset: function() {
          this.fixed = cls.SizePolicy.Fixed();
          this.initial = cls.SizePolicy.Initial();
          this.dynamic = cls.SizePolicy.Dynamic();
        },
        setAllShrinkable: function(canShrink) {
          this.fixed?.setShrinkable(canShrink);
          this.initial?.setShrinkable(canShrink);
          this.dynamic?.setShrinkable(canShrink);
        },
        setAllGrowable: function(canGrow) {
          this.fixed?.setGrowable(canGrow);
          this.initial?.setGrowable(canGrow);
          this.dynamic?.setGrowable(canGrow);
        },
        setMeasured: function() {
          this.measured = true;
        },
        /**
         * @returns {classes.SizePolicy}
         */
        getMode: function() {
          return this[this.mode] || this.initial;
        },
        /**
         *
         * @param {string} mode
         */
        setMode: function(mode) {
          this.mode = mode || this._defaultMode;
        },

        isInitial: function() {
          return this.mode === "initial";
        },

        isDynamic: function() {
          return this.mode === "dynamic";
        },

        isFixed: function() {
          return this.mode === "fixed";
        }
      };
    });
  });
;

"use strict";

modulum("Stretch",
  function(context, cls) {
    /**
     * Stretch (x, y)
     * @class Stretch
     * @memberOf classes
     */
    cls.Stretch = context.oo.Class(function() {
      return /** @lends classes.Stretch.prototype */ {
        $static: /** @lends classes.Stretch */ {
          undef: {}
        },
        __name: "Stretch",
        /**
         * x-stretch value
         * @type {boolean|object}
         */
        _x: null,
        /**
         * y-stretch value
         * @type {boolean|object}
         */
        _y: null,
        /**
         * x-stretch opportunistic value
         * @type {boolean}
         */
        _opportunisticX: false,
        /**
         * y-stretch opportunistic value
         * @type {boolean}
         */
        _opportunisticY: false,
        /**
         * x-stretch default value
         * @type {boolean}
         */
        _defaultX: false,
        /**
         * y-stretch default value
         * @type {boolean}
         */
        _defaultY: false,
        /**
         * @constructs
         * @param {Object} [rawOptions] initialization options
         * @param {number} [rawOptions.x] x-stretch to initialize
         * @param {number} [rawOptions.y] y-stretch to initialize
         */
        constructor: function(rawOptions) {
          const opts = rawOptions || {};
          this._x = opts.x || cls.Stretch.undef;
          this._y = opts.y || cls.Stretch.undef;
        },

        /**
         * reset values
         */
        reset: function() {
          this._x = cls.Stretch.undef;
          this._y = cls.Stretch.undef;
          this._opportunisticX = false;
          this._opportunisticY = false;
        },

        /**
         * Returns whether if it has an x-stretch value or not
         * @return {boolean} true if it has an x-stretch value
         */
        isXDefined: function() {
          return this._x !== cls.Stretch.undef;
        },

        /**
         * Returns whether it has a y-stretch value or not
         * @return {boolean} true if it has a y-stretch value
         */
        isYDefined: function() {
          return this._y !== cls.Stretch.undef;
        },

        /**
         * Get x-stretch value
         * @param {boolean} [useFallback] return default value if no value
         * @return {*} x-stretch value
         */
        getX: function(useFallback) {
          if (useFallback && !this.isXDefined()) {
            return this._defaultX;
          }
          return this._x;
        },

        /**
         * Get y-stretch value
         * @param {boolean} [useFallback] return default value if no value
         * @return {*} y-stretch value
         */
        getY: function(useFallback) {
          if (useFallback && !this.isYDefined()) {
            return this._defaultY;
          }
          return this._y;
        },

        /**
         * Set x-stretch value
         * @param {boolean} x value
         */
        setX: function(x) {
          if (x === null) {
            this._x = cls.Stretch.undef;
          } else {
            this._x = x;
          }
        },
        /**
         * Set y-stretch value
         * @param {boolean} y value
         */
        setY: function(y) {
          if (y === null) {
            this._y = cls.Stretch.undef;
          } else {
            this._y = y;
          }
        },

        /**
         * Get x opportunistic stretch value (e.g. would only stretch if other elements sharing stretching dimentsion stretches)
         * @return {boolean} x opportunistic stretch value
         */
        getOpportunisticX: function() {
          return this._opportunisticX;
        },

        /**
         * Get y opportunistic stretch value (e.g. would only stretch if other elements sharing stretching dimentsion stretches)
         * @return {boolean} y opportunistic stretch value
         */
        getOpportunisticY: function() {
          return this._opportunisticY;
        },

        /**
         * Set x opportunistic stretch value
         * @param {boolean} x opportunistic stretch value
         */
        setOpportunisticX: function(x) {
          this._opportunisticX = x;
        },

        /**
         * Set y opportunistic stretch value
         * @param {boolean} y opportunistic stretch value
         */
        setOpportunisticY: function(y) {
          this._opportunisticY = y;
        },

        /**
         * Set x-stretch default value
         * @param {boolean} x default value
         */
        setDefaultX: function(x) {
          this._defaultX = x;
        },

        /**
         * Set y-stretch default value
         * @param {boolean} y default value
         */
        setDefaultY: function(y) {
          this._defaultY = y;
        },

        /**
         * Get x-stretch default value
         * @return {boolean} x default value
         */
        getDefaultX: function(x) {
          return this._defaultX;
        },

        /**
         * Get y-stretch default value
         * @return {boolean} y default value
         */
        getDefaultY: function(y) {
          return this._defaultY;
        }
      };
    });
  });
;

"use strict";
modulum('ApplicationEnding',
  function(context, cls) {
    /**
     * application ending
     * @class ApplicationEnding
     * @memberOf classes
     */
    cls.ApplicationEnding = context.oo.Class(
      /** @lends classes.ApplicationEnding.prototype */
      {
        __name: "ApplicationEnding",
        normal: false,
        flag: null,
        message: null,
        constructor: function(isNormal, flag) {
          this.normal = isNormal;
          this.flag = flag;
        }
      });
    cls.ApplicationEnding.ok = new cls.ApplicationEnding(true);
    cls.ApplicationEnding.notok = function(message) {
      const result = new cls.ApplicationEnding(false, "notok");
      result.message = message.escapeHTML();
      gbc.LogService.networkProtocol.error(message);
      return result;
    };
    cls.ApplicationEnding.notFound = new cls.ApplicationEnding(false, "notFound");
    cls.ApplicationEnding.forbidden = new cls.ApplicationEnding(false, "forbidden");
    cls.ApplicationEnding.uaProxy = function(message) {
      const result = new cls.ApplicationEnding(false, "uaProxy");
      result.message = message;
      return result;
    };
    cls.ApplicationEnding.autoLogout = function(message) {
      const result = new cls.ApplicationEnding(false, "autoLogout");
      result.message = message;
      return result;
    };
    cls.ApplicationEnding.logPlayer = new cls.ApplicationEnding(true, "hidden");

  });
;

"use strict";

modulum('ActionApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class ActionApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.ActionApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      /** @lends classes.ActionApplicationService.prototype */
      return {
        __name: "ActionApplicationService",
        $static: /** @lends classes.ActionApplicationService */ {
          /**
           * list of local actions with corresponding key accelerator
           * @type {Object}
           */
          _localActions: {
            'nextfield': 'tab',
            'prevfield': 'shift-tab',
            'nextrow': 'down',
            'prevrow': 'up',
            'firstrow': 'home',
            'lastrow': 'end',
            'nextpage': 'next',
            'prevpage': 'prior',
            'nexttab': 'control-tab',
            'prevtab': 'control-shift-tab',
            'guisnapshot': 'alt-f12'
          },

          /**
           * Returns local action names
           *  @returns {String[]}
           */
          getLocalActionNames: function() {
            return Object.keys(this._localActions);
          },

          /**
           * Returns local action accelerators
           *  @returns {String[]}
           */
          getLocalActionAccelerators: function() {
            return Object.values(this._localActions);
          },

          /**
           * Returns default keyboard accelerator for a local action
           * @param {string} actionName
           * @returns {?string} accelerator
           */
          getLocalActionAccelerator: function(actionName) {
            return this._localActions[actionName];
          },

          /** Returns local action name for an accelerator
           * @param {string} acc
           * @returns {?string} actionName
           */
          getLocalActionName: function(acc) {
            const accelerators = this.getLocalActionAccelerators();
            const names = this.getLocalActionNames();
            for (let i = 0; i < accelerators.length; ++i) {
              if (acc === accelerators[i]) {
                return names[i];
              }
            }
            return null;
          },

          /**
           * Browser native actions
           * @type {String[]}
           */
          browserNativeActions: ["editcopy", "editcut", "editpaste"],

          /**
           * static list of special actions
           * @type {Map<string, Object>}
           */
          _specialActions: new Map(),

          /**
           * Add special action in the list
           * @param {string} name - action name
           * @param {Object} ctor - action class typeref
           */
          registerSpecialAction: function(name, ctor) {
            this._specialActions.set(name, ctor);
          },
          /**
           * Remove special action in the list
           * @param {string} name - action name
           */
          unregisterSpecialAction: function(name) {
            this._specialActions.delete(name);
          }
        },
        /**
         * list of special actions
         * @type {Map<string, Object>}
         */
        _specialActions: null,

        /**
         * list of actions
         * @type {Map<string, classes.ActionNode>}
         */
        _actions: null,

        /**
         * list of actions defaults
         * @type {Map<string, classes.ActionDefaultNode>}
         */
        _actionDefaults: null,

        /**
         * List of bound actions filtered by browser key
         * @type {Map<string, Array>}
         */
        _boundActions: null,

        /**
         * List of interrupt widgets
         * @type {Array}
         */
        _interruptWidgets: null,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._interruptWidgets = [];
          this._actionDefaults = new Map();
          this._boundActions = new Map();
          this._actions = new Map();
          this._specialActions = new Map();
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._specialActions.clear();
          this._actions.clear();
          this._actionDefaults.clear();
          this._boundActions.clear();

          this._interruptWidgets = null;
          this._specialActions = null;
          this._actions = null;
          this._actionDefaults = null;
          this._boundActions = null;

          $super.destroy.call(this);
        },
        /**
         * Add a new action to this App Service
         * @param {classes.ActionNode} action node
         */
        registerAction: function(action) {
          let actionName = action.attribute("name");
          this._actions.set(actionName, action);

          this._bindAccelerators(action);
          if (cls.ActionApplicationService._specialActions.has(actionName)) {
            let actionConstructor = cls.ActionApplicationService._specialActions.get(actionName);
            this._specialActions.set(actionName, new actionConstructor(this));
          }
          if (actionName === "interrupt") {
            for (const element of this._interruptWidgets) {
              element.setInterruptable(false);
            }
          }

          let applicationWidget = this._application.getUI().getWidget();

          // Do not add to contextMenu/rowbound if not action (e.g. MenuAction)
          if (applicationWidget && action.getTag() === "Action") {

            // Add action to application contextMenu
            if (applicationWidget.getContextMenu()) {
              let actionOrder = action.getIndex();
              let contextMenuWidget = applicationWidget.getContextMenu();
              let contextMenu = action.attribute('contextMenu');
              let addInCtxMenu = contextMenu === 'yes' || contextMenu === 'auto';
              /*
              // GBC-1824 regression : need to handle this case
              let defaultView = action.attribute('defaultView');
              if(defaultView === 'no' && isActionInForm()){ // Need implementation of this isActionInForm method
                addInCtxMenu = false;
              }
              */
              if (addInCtxMenu) {
                let actionText = action.attribute("text").replace(/&(.)/g, "$1"); // Filter ampersand
                contextMenuWidget.addAction(actionName,
                  actionText,
                  this._application.wrapResourcePath(action.attribute("image")),
                  action.attribute("acceleratorName").toString(), {
                    clickCallback: function() {
                      contextMenuWidget.hide();
                      action.getWidget().emit(gbc.constants.widgetEvents.click);
                    },
                    hidden: action.attribute("hidden"),
                    order: actionOrder
                  });
              }
            }

            // Add action to application rowBound
            if (applicationWidget.getRowBoundMenu()) {
              let actionOrder = action.getIndex();
              let rowBoundWidget = applicationWidget.getRowBoundMenu();
              let context = action.attribute('context');
              let addInRowBound = context === 'row';

              if (addInRowBound) {
                let actionText = action.attribute("text").replace(/&(.)/g, "$1"); // Filter ampersand
                rowBoundWidget.addAction(actionName,
                  actionText === "" ? actionName : actionText,
                  action.attribute("image"),
                  action.attribute("acceleratorName").toString(), {
                    clickCallback: function() {
                      rowBoundWidget.hide();
                      action.execute();
                    },
                    hidden: action.attribute("hidden"),
                    order: actionOrder
                  });
              }
            }
          }
        },

        /**
         * Add a new actionDefault to this App Service
         * @param {classes.NodeBase} action node
         */
        registerActionDefault: function(action) {
          this._actionDefaults.set(action.attribute("name"), action);

          this._bindAccelerators(action);
        },

        /**
         * Bind an action to VM accelerators
         * @param {classes.NodeBase} action node
         */
        _bindAccelerators: function(action) {
          // TODO : why do we need to convert VMKey when storing accelerators since we are retrieving them in scheduler doing the opposite ? old implementation ?
          const key1 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName"));
          const key2 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName2"));
          const key3 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName3"));
          const key4 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName4"));

          if (key1) {
            this._bindAccelerator(key1, action);
          }
          // we make sure to not bind same action two times :
          // for example, Enter and Return VM accelerators are both considered as Enter key from browser
          // so we only have to bind one action to this key even if there are two accelerators defined on it
          if (key2 && key2 !== key1) {
            this._bindAccelerator(key2, action);
          }
          if (key3 && key3 !== key1 && key3 !== key2) {
            this._bindAccelerator(key3, action);
          }
          if (key4 && key4 !== key1 && key4 !== key2 && key4 !== key3) {
            this._bindAccelerator(key4, action);
          }
        },

        /**
         * Bind action to browser key
         * @param {string} key - DOM key combination
         * @param {classes.NodeBase} action node
         */
        _bindAccelerator: function(key, action) {
          //erase previous action to keep the last one
          this._boundActions.set(key, []);
          const actions = this._boundActions.get(key);
          if (!actions.contains(action._id)) {
            // push new action in the list
            actions.push(action._id);
          }
        },

        /**
         * Unbind an action from VM accelerators
         * @param {classes.NodeBase} action node
         */
        _unbindAccelerators: function(action) {
          // Remove all accelerator bound for this action...
          const key1 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName"));
          const key2 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName2"));
          const key3 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName3"));
          const key4 = cls.KeyboardHelper.convertVMKeyToBrowserKey(action.attribute("acceleratorName4"));

          if (key1) {
            this._unbindAccelerator(key1, action);
          }
          // we make sure to not unbind same action two times :
          // for example, Enter and Return VM accelerators are both considered as Enter key from browser
          // so we only have to unbind one action from this key even if there are two accelerators defined on it
          if (key2 && key2 !== key1) {
            this._unbindAccelerator(key2, action);
          }
          if (key3 && key3 !== key1 && key3 !== key2) {
            this._unbindAccelerator(key3, action);
          }
          if (key4 && key4 !== key1 && key4 !== key2 && key4 !== key3) {
            this._unbindAccelerator(key4, action);
          }
        },

        /**
         * Unbind action from browser key
         * @param {string} key browser key
         * @param {classes.NodeBase} action node
         */
        _unbindAccelerator: function(key, action) {
          const keyActionIdArray = this._boundActions.get(key);
          if (keyActionIdArray) {
            // remove action id from our active actions list
            keyActionIdArray.remove(action._id);
            if (keyActionIdArray.length === 0) {
              this._boundActions.delete(key);
            }
          }
        },

        /**
         * Get the action by its name
         * @param {?string} name of the action
         * @returns {classes.NodeBase} action node
         */
        getAction: function(name) {
          return this._actions.get(name);
        },

        /**
         * Test if the action is registered
         * @param {string} name of the action
         * @returns {boolean} action node
         */
        hasAction: function(name) {
          return this._actions.has(name);
        },

        /**
         * Remove the action and unbind accelerators
         * @param {classes.NodeBase} action
         */
        destroyAction: function(action) {
          this._unbindAccelerators(action);

          let name = action.attribute("name");
          this._actions.delete(name);
          if (this._specialActions.has(name)) {
            this._specialActions.get(name).destroy();
            this._specialActions.delete(name);
          }

          let applicationWidget = this._application.getUI().getWidget();

          // Remove action from app contextMenu
          if (applicationWidget && applicationWidget.getContextMenu()) {
            let contextMenu = applicationWidget.getContextMenu();
            contextMenu.removeAndDestroyAction(name, false);
          }

          // Remove action from rowbound
          if (applicationWidget && applicationWidget.getRowBoundMenu()) {
            let rowBoundWidget = applicationWidget.getRowBoundMenu();
            rowBoundWidget.removeAndDestroyAction(name, false);
          }

        },

        /**
         * Remove the actionDefault and unbind accelerators
         * @param {classes.NodeBase} action
         */
        destroyActionDefault: function(action) {
          this._unbindAccelerators(action);

          const acceleratorName = action.attribute("name");
          this._actionDefaults.delete(acceleratorName);
        },

        /**
         * Execute an action with its ID
         * @param {number} idRef - id of the action
         * @param {classes.NodeBase=} node - node which requires cursors/value sending
         * @param {object=} value - node value to send to vm
         * @returns {classes.CommandBase} the created command to execute the action
         */
        executeById: function(idRef, node, value) {
          const actionNode = this._application.getNode(idRef);
          if (!actionNode) {
            return null;
          }

          const group = this._application.scheduler.startGroupCommand();

          if (node) {
            const ctrl = node.getController();
            if (ctrl) {
              ctrl.sendWidgetCursors();
              ctrl.sendWidgetValue(value);
            }
          }
          this._application.scheduler.actionVMCommand(actionNode);
          this._application.scheduler.finishGroupCommand();
          return group;
        },

        /**
         * Execute an action by knowing its name
         * @param {string} name of the action
         * @param {classes.NodeBase=} additionalValueNode an additional value node which value should be sent to the VM too. (CheckBox special case)
         * @param {object=} options
         * @returns {classes.CommandBase} the created command to execute the action
         */
        executeByName: function(name, additionalValueNode, options) {
          const action = this.getAction(name);
          if (!action) {
            return this.executeActionDefaultByName(name);
          }
          return this._execute(action, additionalValueNode, options);
        },

        /**
         * Execute an action by knowing its name
         * @param {?string} name of the action
         * @param {object=} options
         * @returns {classes.CommandBase} the created command to execute the action
         */
        executeActionDefaultByName: function(name, options) {
          options = options || {};
          let actionEvent = null;

          // TODO: GBC-1760: for me this code seems to be wrong
          // TODO GBC-1760 why we don't do this in ActionVMCommand
          // why for all local actions we don't execute same code ?
          if (cls.ActionApplicationService.getLocalActionNames().contains(name)) {
            switch (name) {
              case "nextfield":
                // what if local action AND action have the same name?
                actionEvent = new cls.VMKeyEvent("Tab");
                break;
              case "prevfield":
                actionEvent = new cls.VMKeyEvent("Shift-Tab");
                break;
              case "nextrow":
                actionEvent = new cls.VMKeyEvent("Down");
                break;
              case "prevrow":
                actionEvent = new cls.VMKeyEvent("Up");
                break;
              default:
                const action = this._actionDefaults.get(name);
                const accelerator = action && action.attribute("acceleratorName");
                if (accelerator && accelerator.toString().length > 0) {
                  actionEvent = new cls.VMKeyEvent(accelerator);
                }
                break;
            }
          }
          if (actionEvent) {
            actionEvent.noUserActivity = Boolean(options.noUserActivity);

            const focusedNode = this._application.getFocusedVMNode();
            const ctrl = focusedNode.getController();
            if (ctrl) {
              ctrl.sendWidgetCursors();
              ctrl.sendWidgetValue();
            }

            return this._application.scheduler.eventVMCommand(actionEvent);
          }
          return null;
        },

        /**
         * Execute an action with its ID if none found with its name
         * @param {number} idRef of the action
         * @param {classes.NodeBase=} additionalValueNode an additional value node which value should be sent to the VM too. (CheckBox special case)
         * @param {object=} options
         * @returns {classes.CommandBase} the created command to execute the action
         */
        execute: function(idRef, additionalValueNode, options) {
          const actionNode = this._application.getNode(idRef);
          const actionName = actionNode ? actionNode.attribute("name") : null;

          if (!this.getAction(actionName) && cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
            return this.executeActionDefaultByName(actionName, options);
          }

          return this._execute(actionNode, additionalValueNode, options);
        },

        /**
         * 
         * @param {classes.NodeBase} actionNode 
         * @param {classes.NodeBase=} additionalValueNode an additional value node which value should be sent to the VM too. (CheckBox special case)
         * @param {Object} options 
         * @returns {classes.CommandBase} the created command to execute the action
         * @private 

         */
        _execute: function(actionNode, additionalValueNode, options) {
          options = options || {};

          if (cls.ActionApplicationService.browserNativeActions.contains(actionNode.name)) {
            return null;
          }

          const group = this._application.scheduler.startGroupCommand();

          const focusedNode = this._application.getFocusedVMNodeAndValue(true);
          if (focusedNode && options.sendValue) {
            const ctrl = focusedNode.getController();
            if (ctrl && !ctrl.hasActiveDropDown()) {
              if (ctrl.sendWidgetCursors) {
                ctrl.sendWidgetCursors();
              }
              if (ctrl.sendWidgetValue) {
                ctrl.sendWidgetValue();
              }
              // if there is an additionalValueNode must send its value
              if (additionalValueNode && focusedNode !== additionalValueNode && additionalValueNode.getController() && additionalValueNode
                .getController().sendWidgetValue) {
                additionalValueNode.getController().sendWidgetValue();
              }
            }
          }
          this._application.scheduler.actionVMCommand(actionNode, {
            noUserActivity: Boolean(options.noUserActivity)
          });
          this._application.scheduler.finishGroupCommand();
          return group;
        },

        registerInterruptWidget: function(widget) {
          this._interruptWidgets.push(widget);
          widget.setInterruptableActive(this._application.isProcessing());
        },
        unregisterInterruptWidget: function(widget) {
          widget.setInterruptableActive(false);
          this._interruptWidgets.remove(widget);
        },
        setInterruptablesActive: function(isActive) {
          for (const element of this._interruptWidgets) {
            element.setInterruptableActive(isActive);
          }
        },
        /** Return the action node of active dialog for a given action name
         *
         * @param actionName the name of the action
         * @returns {?classes.NodeBase} an action node
         */
        getActiveDialogAction: function(actionName) {
          const uiNode = this._application.uiNode();
          if (uiNode) {
            const window = this._application.getVMWindow();
            if (window) { // search the action in the current dialog
              const dialog = window.getActiveDialog();
              if (dialog) {
                const actions = dialog.getChildren();
                for (const element of actions) {
                  const action = element;
                  const isActive = action.attribute("active") !== 0;
                  if (isActive) {
                    if (action.attribute("name") === actionName) {
                      return action;
                    }
                  }
                }
              }
            }
          }
          return null;
        },
      };
    });
    cls.ApplicationServiceFactory.register("Action", cls.ActionApplicationService);
  });
;

"use strict";

modulum('ApplicationServiceBase', ['EventListener'],
  function(context, cls) {
    /**
     * Base class of application scoped services
     * @class ApplicationServiceBase
     * @memberOf classes
     * @extends classes.EventListener
     */
    cls.ApplicationServiceBase = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.ApplicationServiceBase.prototype */ {
        __name: "ApplicationServiceBase",
        /**
         * owner
         * @protected
         * @type classes.VMApplication
         */
        _application: null,
        /**
         *
         * @param {classes.VMApplication} app owner
         */
        constructor: function(app) {
          $super.constructor.call(this);
          this._application = app;
        },
        /**
         * frees memory hooks of this service (typically when application is destroyed)
         */
        destroy: function() {
          this._application = null;
          $super.destroy.call(this);
        },
        /**
         * Get owning application
         * @publicdoc
         * @return {classes.VMApplication} the owning application
         */
        getApplication: function() {
          return this._application;
        }
      };
    });
  });
;

"use strict";

modulum('ApplicationServiceFactory', ['Factory'],

  function(context, cls) {
    /**
     * @namespace classes.ApplicationServiceFactory
     */
    cls.ApplicationServiceFactory = context.oo.StaticClass(function() {
      const factory = new cls.Factory("Application Service");
      return /** @lends classes.ApplicationServiceFactory */ {
        /**
         *
         * @param {string} type
         * @param {Function} constructor
         */
        register: function(type, constructor) {
          factory.register(type, constructor);
        },
        /**
         *
         * @param {string} type
         */
        unregister: function(type) {
          factory.unregister(type);
        },
        /**
         *
         * @param {string} type
         * @param {...args} args
         * @returns {classes.ApplicationServiceBase}
         */
        create: function(type, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
          return factory.create(type, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
      };
    });
  });
;

"use strict";

modulum('AuiApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * AUI tree model store
     * @class AuiApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.AuiApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.AuiApplicationService.prototype */ {
        __name: "AuiApplicationService",
        nodeHash: null,
        // logs
        contents: null,
        file: null,

        /**
         * @param {classes.VMApplication} app the owner application
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this.nodeHash = [];
          this.contents = ["LOGVERSION=2"];
        },

        /**
         * Clears the model
         */
        stop: function() {
          this.nodeHash.length = 0;
        },

        /**
         * Destroys the service
         */
        destroy: function() {
          this.nodeHash.length = 0;
          this.contents.length = 0;
          $super.destroy.call(this);
        },

        /**
         * Get a node object
         * @param {number|String} id - id of the Node to get
         * @returns {classes.NodeBase} Node Object
         */
        getNode: function(id) {
          if (Object.isNumber(id)) {
            return this.nodeHash[id];
          }
          if (Object.isString(id)) {
            return this.nodeHash[parseInt(id, 10)];
          }
          return null;
        },

        getNodesFrom: function(id, currentBag) {
          const result = currentBag || [];
          const localRoot = Object.isNumber(id) ? this.getNode(id || 0) : id;
          if (localRoot) {
            result.push(localRoot);
            for (const element of localRoot.children) {
              this.getNodesFrom(element, result);
            }
          }
          if (!currentBag) {
            return result;
          } else {
            return null;
          }
        },

        /**
         * Add a node to the model
         * @param {number} id node idRef
         * @param {classes.NodeBase} node AUI tree node
         */
        addNode: function(id, node) {
          this.nodeHash[id] = node;
        },

        /**
         * Searches the nodes with the corresponding attribute and value
         * @param {string} attr attribute name
         * @param {string} value attribute value
         * @return {classes.NodeBase[]} the found node or null
         */
        getNodeByAttribute: function(attr, value) {
          return this.nodeHash.find(function(node) {
            return node ? node.attribute(attr) === value : false;
          });
        },

        /**
         * Searches the nodes with the corresponding tag
         * @param {string} tag node tag
         * @return {classes.NodeBase} the found nodes
         */
        getNodesByTag: function(tag) {
          return this.nodeHash.filter(function(node) {
            return node ? node.getTag() === tag : false;
          });
        },

        /**
         * Removes the node from the store
         * @param {number} id node idRef
         */
        removeNode: function(id) {
          this.nodeHash[id] = null;
        },

        /**
         * Creates and adds a node subtree to the store
         * @param {*} omCommand parsed VM command
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {classes.NodeBase} root of the created subtree
         */
        commandAdd: function(omCommand, treeModificationTrack) {
          const parentNode = (omCommand.node.id === 0) ? null : this.getNode(omCommand.parent);
          let partRootNode = null;
          if (this._application) {
            partRootNode = gbc.classes.NodeFactory.createRecursive(parentNode, omCommand.node, this._application,
              treeModificationTrack);
          }
          return partRootNode;
        },

        /**
         * Update nodes attributes
         * @param {*} omCommand parsed VM command
         * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
         * @return {boolean} true if a relayout is required, false otherwise
         */
        commandUpdate: function(omCommand, treeModificationTrack) {
          let needRelayout = false;
          const node = this.getNode(omCommand.id),
            attrsKeys = Object.keys(omCommand.attributes);
          if (omCommand.attributes && attrsKeys.length) {
            if (!treeModificationTrack.isNodeCreated(omCommand.id)) {
              let i = 0;
              const len = attrsKeys.length;
              for (; i < len; i++) {
                const attr = attrsKeys[i];
                needRelayout = needRelayout || Boolean(cls.LayoutTriggerAttributes[omCommand.type][attr]);
                treeModificationTrack.attributeChanged(omCommand.id, attr);
              }
            }
          }
          node.updateAttributes(omCommand.attributes);
          return needRelayout;
        },

        /**
         * Handles VM node removal order
         * @param {number} omNode node idRef
         */
        remove: function(omNode) {
          const nodeToRemove = omNode || this._application && this._application.uiNode();
          if (nodeToRemove) {
            nodeToRemove.destroy();
          }
        },

        logFireEvent: function(eventContents) {

          // NOTE used to generate VM log (disabled temporally)

          const logItem = "" + this._application.applicationHash + ":FE:0:" + eventContents;

          /* if (context.$app._dvmLogger !== this) {
           context.$app._dvmLogger.contents.push(logItem);
           } else {
           this.contents.push(logItem);
           }*/
        },

        logDvm: function(dvmContents) {

          // NOTE used to generate VM log (disabled temporally)

          const logItem = "" + this._application.applicationHash + ":DVM:0:" + dvmContents;
          /* if (context.$app._dvmLogger !== this) {
           context.$app._dvmLogger.contents.push(logItem);
           } else {
           this.contents.push(logItem);
           }*/
        },

        linkDownload: function() {
          const data = new Blob([this.contents.join("\n")], {
            type: "text/plain"
          });

          if (this.file !== null) {
            window.URL.revokeObjectURL(this.file);
          }
          this.file = window.URL.createObjectURL(data);
          this._application.getSession().getWidget().getEndWidget().setAuiLogUrl(this._application.info().session, this.file);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Model", cls.AuiApplicationService);
  });
;

"use strict";

modulum('DVMApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * Application Service to manage DVM interactions for an application
     *
     * @class DVMApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.DVMApplicationService = context.oo.Class(cls.ApplicationServiceBase,
      function($super) {
        return /** @lends classes.DVMApplicationService.prototype */ {

          __name: "DVMApplicationService",
          $static: /** @lends classes.DVMApplicationService */ {
            nodesIgnoringStyleCompute: ["FunctionCall", "FunctionCallParameter"]
          },
          /** Indicator to know if DVM is idle (interactive) or not */
          idle: true,
          _managingOrders: false,
          processed: false,
          /** @type {Boolean} **/
          /*- tell if json protocol is used */
          jsonAuiProtocol: false,
          /**
           * @constructs
           * @param app
           */
          constructor: function(app) {
            $super.constructor.call(this, app);
            this.jsonAuiProtocol = window.isURLParameterEnabled("json") || context.ThemeService.getValue("aui-json-protocol");
            context.LogService.networkProtocol.info("DVM order PARSER :", this.jsonAuiProtocol ? "JSON" : "TCL");
          },

          destroy: function() {
            $super.destroy.call(this);
          },

          updateProcessingStatus: function() {
            const menu = this._getMenu("runtimeStatus");
            if (menu) {
              let uiWidget = this._application.getUI().getWidget();
              if (this.idle) {
                menu.setIdle();
                uiWidget.domAttributesMutator(() => uiWidget.removeClass("processing"));
              } else {
                menu.setProcessing();
                uiWidget.domAttributesMutator(() => uiWidget.addClass("processing"));
              }
            }
          },

          setIdle: function(isIdle) {
            this.idle = isIdle;
            if (!this.processed && this.idle) {
              this.processed = true;
            }
            this.updateProcessingStatus();
            this.emit(context.constants.baseEvents.idleChanged);
          },

          onOrdersManaged: function(hook, once) {
            return this.when(context.constants.baseEvents.ordersManaged, hook, once);
          },

          onIdleChanged: function(hook) {
            return this.when(context.constants.baseEvents.idleChanged, hook);
          },

          manageAuiOrders: function(data, callback) {
            this._managingOrders = true;

            const treeModificationTrack = new cls.TreeModificationTracker(),
              nodesWithDom = [];

            // Consider default data to be correctly encoded
            let vmMessages = data;

            // In case of not parsed yet
            if (typeof data === "string") {
              if (this.jsonAuiProtocol && data.slice(0, 2) !== "om") { // if first 2 chars are "om", it's not json
                vmMessages = data

                  .split("\n")
                  .filter(om => om.length > 0)
                  .map(om => JSON.parse(om));
              } else {
                // Use old way to decode messages
                vmMessages = cls.AuiProtocolReader.translate(data);
              }
            }
            context.styler.bufferize();
            this._application.getUI().getWidget().bufferizeDom(true);
            let needLayout = false;
            let hasAddedRemovedNodes = false;
            let hasAddedRemovedStylableNodes = false;
            let containsRipWidget = false;
            const initialOrder = vmMessages.length && vmMessages[0] && vmMessages[0].id === 0 && vmMessages[0];
            // 1. readOrder : create nodes
            let order = {};

            while (vmMessages.length) {
              if (this._application) {
                const om = vmMessages.shift();

                if (this.jsonAuiProtocol && Array.isArray(om)) {
                  if (om.length === 3 && om[0] === "om") {
                    order.type = om[0];
                    order.id = om[1];
                    order.operations = om[2];
                  } else {
                    throw new Error("Received auiTree bad format : " + order);
                  }
                } else {
                  order = om;
                }

                if (order.type !== "om") {
                  throw new Error("Received auiTree bad format : " + order);
                }

                const result = this.manageAuiOrder(order, treeModificationTrack, nodesWithDom);
                containsRipWidget = containsRipWidget || result.containRipWidget;
                needLayout = needLayout || result.needLayout;
                hasAddedRemovedNodes = hasAddedRemovedNodes || result.hasAddedRemovedNodes;
                hasAddedRemovedStylableNodes = hasAddedRemovedStylableNodes || result.hasAddedRemovedStylableNodes;
                if (vmMessages.length !== 0 && treeModificationTrack.isNodeAttributeChanged(0, 'runtimeStatus')) {
                  // We don't apply behaviors before reading all VM orders
                  // except for runtimeStatus which must be managed immediately
                  // to handle the transitive 'childstart' status
                  const runtimeStatusTracker = new cls.TreeModificationTracker();
                  runtimeStatusTracker.attributeChanged(0, 'runtimeStatus');
                  this._application.getNode(0).applyBehaviors(runtimeStatusTracker);
                }
              }
            }

            let callbackDone = false;
            const rootNode = this._application && this._application.getNode(0);

            if (rootNode) {
              if (containsRipWidget) {
                this._application.fail(i18next.t('gwc.app.ripWidgetFound'));
                this._application.scheduler.emptyCommandsQueue(); // cancel all command and send only the destroyEvent
                const event = new cls.VMDestroyEvent(-3, i18next.t('gwc.app.ripWidgetFound')); // -3 = bad AUI (see spec in VM DestroyEvent.js)
                this._application.scheduler.eventVMCommand(event);
              }

              treeModificationTrack.attributeChanged(0, "runtimeStatus");

              const runtimeStatus = rootNode.attribute('runtimeStatus');
              if (runtimeStatus === "childstart" || runtimeStatus === "processing") {
                callbackDone = true;
                if (callback) {
                  callback();
                }
              }

              if (initialOrder) {
                treeModificationTrack.attributeChanged(0, "focus");
              }

              const nodes = this._application.model.nodeHash;
              for (const node of nodes) {
                if (node && cls.DVMApplicationService.nodesIgnoringStyleCompute.indexOf(node.getTag()) < 0) {
                  if (treeModificationTrack.isNodeCreated(node._id) || treeModificationTrack.isNodeAttributeChanged(node._id, "style")) {
                    node.getApplication().styleAttributesChanged.push(node);
                  }

                  node.resetActivePseudoSelectors();
                }
              }

              // 2. update styles
              if (this._application.styleListsChanged || this._application.styleAttributesChanged.length || hasAddedRemovedStylableNodes) {
                rootNode.updateApplicableStyles(true, this._application.styleListsChanged,
                  this._application.styleAttributesChanged, treeModificationTrack);
                this._application.usedStyleAttributes = {};
                const styleLists = rootNode.getChildren('StyleList');
                for (const styleList of styleLists) {
                  const styles = styleList.getChildren();
                  for (const style of styles) {
                    const styleAttributes = style.getChildren();
                    for (const attr of styleAttributes) {
                      this._application.usedStyleAttributes[attr.attribute('name')] = true;
                    }
                  }
                }
                for (const node of nodes) {
                  if (node) {
                    node.resetPseudoSelectorsUsedInSubTree();
                  }
                }
                for (const node of nodes) {
                  if (node) {
                    node.updatePseudoSelectorsUsedInSubTree();
                  }
                }
                treeModificationTrack.forEach(function(mods, idRef) {
                  if (mods.created && !mods.removed) {
                    const node = this._application.getNode(idRef);
                    if (node) {
                      node.setInitialStyleAttributes();
                    }
                  }
                }.bind(this));
              }

              // 3. create controllers + widgets
              this._createControllers(treeModificationTrack);
              this._notifyUpdatedAttributes(treeModificationTrack);

              if (this._application.styleListsChanged || this._application.styleAttributesChanged.length || hasAddedRemovedStylableNodes) {
                for (const node of nodes) {
                  if (node) {
                    const controller = node.getController();
                    if (controller) {
                      controller.setStyleBasedBehaviorsDirty(true, true);
                    }
                  }
                }
              }

              this._application.styleListsChanged = false;
              this._application.styleAttributesChanged = [];

              let stillDirty = true;
              // 4. Apply behaviors
              while (stillDirty) {
                stillDirty = rootNode.applyBehaviors(treeModificationTrack, true);
              }

              // 5. Add root widget to DOM
              for (const domNode of nodesWithDom) {
                if (!domNode.getParentNode()) {
                  if (domNode.getController()) {
                    this._application.attachRootWidget(domNode.getController().getWidget());
                  }
                }
              }
            }
            this._application.getUI().getWidget().bufferizeDom(false); // calls context.styler.flush() in requestAnimationFrame
            context.styler.flush(); // removing this generates a regression on GBC-1637
            if (!callbackDone) {
              if (callback) {
                callback();
              }
            }
            if (this._application) {
              this._application.scheduler.validateLastCommand();
            }

            this._managingOrders = false;
            this.emit(context.constants.baseEvents.ordersManaged, data);
          },

          manageAuiOrder: function(order, treeModificationTrack, nodesWithDom) {
            const result = {
              needLayout: false,
              hasAddedRemovedNodes: false,
              hasAddedRemovedStylableNodes: false,
              containRipWidget: false
            };
            let node;
            let i;
            for (const operation of order.operations) {
              const isJsonOperation = Array.isArray(operation);

              // cmd is operation if not json protocol
              let cmd = this.jsonAuiProtocol && isJsonOperation ? {
                type: operation[0]
              } : operation;
              switch (cmd.type) {
                case "update":
                case "u":
                  if (this.jsonAuiProtocol && isJsonOperation) {
                    cmd.id = operation[1];
                    cmd.attributes = operation[2];
                  }
                  result.needLayout = this._application.model.commandUpdate(cmd, treeModificationTrack) || result.needLayout;
                  this._application.getNode(0).auiSerial = order.id;
                  break;
                case "add":
                case "a":
                  if (this.jsonAuiProtocol && isJsonOperation) {
                    cmd.parent = operation[1];
                    cmd.node = {
                      id: operation[3],
                      type: operation[2], // same as tag
                      attributes: operation[4],
                      children: operation[5]
                    };
                  }
                  node = this._application.model.commandAdd(cmd, treeModificationTrack);
                  result.containRipWidget = gbc.classes.NodeFactory.ripWidgetCreated();
                  if (node) {
                    nodesWithDom.push(node);
                    result.needLayout = result.needLayout || Boolean(cls.LayoutTriggerAttributes[cmd.type][node._tag]);
                    result.hasAddedRemovedNodes = true;
                    if (cls.DVMApplicationService.nodesIgnoringStyleCompute.indexOf(node.getTag()) < 0) {
                      result.hasAddedRemovedStylableNodes = true;
                    }
                  }
                  if (this._application) {
                    this._application.getNode(0).auiSerial = order.id;
                  }
                  break;
                case "remove":
                case "r":
                  if (this.jsonAuiProtocol && isJsonOperation) {
                    cmd.id = operation[1];
                  }
                  node = null;
                  for (i = 0; i < nodesWithDom.length; ++i) {
                    if (nodesWithDom[i].getId() === cmd.id) {
                      nodesWithDom.splice(i, 1);
                      break;
                    }
                  }
                  const toDestroy = this._application.getNode(cmd.id);
                  treeModificationTrack.nodeRemoved(cmd.id, toDestroy ? toDestroy._tag : null);
                  if (toDestroy) {
                    if (cls.DVMApplicationService.nodesIgnoringStyleCompute.indexOf(toDestroy.getTag()) < 0) {
                      result.hasAddedRemovedStylableNodes = true;
                    }
                    // detach from DOM first and then destroy recursively
                    if (toDestroy.getController()) {
                      const widget = toDestroy.getController().getWidget();
                      if (widget) {
                        widget.detach();
                      }
                    }

                    treeModificationTrack.clean(toDestroy);
                    toDestroy.destroy();
                  }
                  if (cmd.id === 0) {
                    this._application.setEnding();
                    this.emit(context.constants.baseEvents.gotRN0);
                  } else {
                    this._application.getNode(0).auiSerial = order.id;
                  }
                  result.needLayout = result.needLayout || Boolean(cls.LayoutTriggerAttributes[cmd.type][toDestroy._tag]);
                  result.hasAddedRemovedNodes = true;
                  break;
                default:
                  node = null;
                  context.LogService.error("dvm.manageAuiOrder: Invalid command (" + cmd.type + ")");
              }
            }

            return result;
          },

          /**
           * Call update attributes callback for modified attributes
           * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
           * @private
           */
          _notifyUpdatedAttributes: function(treeModificationTrack) {
            treeModificationTrack.forEach(function(mods, nodeId) {
              const node = this._application.getNode(nodeId);
              if (node) {
                const attrs = Object.keys(mods.updatedAttributes);
                for (const attr of attrs) {
                  const eventName = cls.NodeBase.attributeChangedEventName(attr);
                  if (node.hasEventListeners(eventName)) {
                    const oldValue = node.previousAttribute(attr);
                    const newValue = node.attribute(attr);
                    node.emit(eventName, {
                      node: node,
                      attr: attr,
                      old: oldValue,
                      new: newValue,
                      changed: newValue !== oldValue
                    });
                  }
                }
              }
            }.bind(this));
          },

          /**
           * Create controllers for created nodes
           * @param {classes.TreeModificationTracker} treeModificationTrack tree modifications log
           * @private
           */
          _createControllers: function(treeModificationTrack) {
            treeModificationTrack.forEach(function(mods, nodeId) {
              if (mods.createdSubTreeRoot) {
                const node = this._application.getNode(nodeId);
                if (node && !node._destroyed) {
                  node.createController();
                  node.attachUI();
                }
              }
            }.bind(this));
          },

          /**
           * Get a menu item by name
           * @param {String} name of the action to get
           * @return {boolean|*}
           * @private
           */
          _getMenu: function(name) {
            let menu = null;
            const uiWidget = this._application.getUI().getWidget().getUserInterfaceWidget();
            if (uiWidget) {
              menu = uiWidget.getChromeBarWidget();
              return menu ? menu.getGbcMenuItem(name) : false;
            } else {
              return false;
            }
          }
        };
      });
    cls.ApplicationServiceFactory.register("Dvm", cls.DVMApplicationService);
  });
;

"use strict";

modulum('FileTransferApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * Base class of application scoped services
     * @class FileTransferApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.FileTransferApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.FileTransferApplicationService.prototype */ {
        __name: "FileTransferApplicationService",
        /**
         * @type {Object<string, Array<FilePickerWidget>>}
         */
        _fileChoosers: null,
        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._fileChoosers = {};
        },
        /**
         * Handler raised on file pick
         * @param callback
         * @param errorCallback
         * @param event
         * @param src
         * @param data
         * @private
         */
        _whenFileSelectionChanged: function(callback, errorCallback, event, src, data) {
          let hasData = false;
          let normalizedFileName = "";
          if (data) {
            if (Array.isArray(data)) {
              if (data.length) {
                hasData = true;
                for (const fileName of data) {
                  // normalize() converts 2 combined diacritical marks into 1 (ex: é encoded as e')
                  // For exemple under Safari a file with name 'Qualité.pdf' has a length of 12 while under
                  // chrome length will be 11 because of the special accent char : é
                  // for this reason we need to normalize our file name.
                  // ! IE11 doesn't support normalize.
                  normalizedFileName = fileName.normalize ? fileName.normalize() : fileName;
                  this._fileChoosers[normalizedFileName] = this._fileChoosers[normalizedFileName] || [];
                  this._fileChoosers[normalizedFileName].push(src);
                  src._processing = true;
                }
              } else {
                src.destroy();
              }
            } else {
              hasData = true;
              // cf previous comment of normalize()
              normalizedFileName = data.normalize ? data.normalize() : data;
              this._fileChoosers[normalizedFileName] = this._fileChoosers[normalizedFileName] || [];
              this._fileChoosers[normalizedFileName].push(src);
              src._processing = true;
            }
            if (hasData) {
              src.when(context.constants.widgetEvents.destroyed, this._onFilePickerDestroyed.bind(this, src), true);
            }
            callback(data);
          } else {
            src.destroy();
            callback("");
          }
        },
        /**
         * manage openFile frontcall
         * @param options
         * @param callback
         * @param errorCallback
         * @return {classes.FilePickerWidget} the new FilePicketWidget
         */
        openFile: function(options, callback, errorCallback) {
          const filePicker = cls.WidgetFactory.createWidget("FilePicker", {
            appHash: this._application.applicationHash
          });
          this._application.layout.afterLayout(function() {
            filePicker.resizeHandler();
          });
          this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
          filePicker.setExtension(this._extractExtensions(options && options.wildcards || ""));
          filePicker.setCaption(options && options.caption || "");
          filePicker.show();
          filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, callback, errorCallback));

          return filePicker;
        },
        /**
         * manage openFiles frontcall
         * @param options
         * @param callback
         * @param errorCallback
         * @return {classes.FilePickerWidget} return the new FilePicker widget
         */
        openFiles: function(options, callback, errorCallback) {
          const filePicker = cls.WidgetFactory.createWidget("FilePicker", {
            appHash: this._application.applicationHash
          });
          this._application.layout.afterLayout(function() {
            filePicker.resizeHandler();
          });
          this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
          filePicker.setExtension(this._extractExtensions(options && options.wildcards || ""));
          filePicker.setCaption(options && options.caption || "");
          filePicker.allowMultipleFiles(true);
          filePicker.show();
          filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, callback, errorCallback));

          return filePicker;
        },
        /**
         * getFile method executed on getfile frontcall call
         * @param options
         * @param callback
         * @param errorCallback
         * @return {classes.FilePickerWidget} return the new FilePicker widget
         */
        getFile: function(options, callback, errorCallback) {
          let filePicker;
          // cf previous comment of normalize() in _whenFileSelectionChanged function definition
          const normalizedFileName = options.filename.normalize ? options.filename.normalize() : options.filename;
          const onSuccess = function() {
              if (filePicker._processing) {
                if (this._application.getMenu("uploadStatus")) {
                  this._application.getMenu("uploadStatus").setIdle();
                }
              }
              callback();
              filePicker.freeFile(normalizedFileName, true);
              if (this._fileChoosers[normalizedFileName]) {
                this._fileChoosers[normalizedFileName].remove(filePicker);
              }
            }.bind(this),
            onError = function() {
              if (filePicker._processing) {
                if (this._application.getMenu("uploadStatus")) {
                  this._application.getMenu("uploadStatus").setIdle();
                }
              }
              errorCallback();
              filePicker.freeFile(normalizedFileName, true);
              if (this._fileChoosers[normalizedFileName]) {
                this._fileChoosers[normalizedFileName].remove(filePicker);
              }
            }.bind(this),
            onProgress = function(progressEvent) {
              this._application.getMenu("uploadStatus").setProgress({
                loaded: progressEvent.loaded,
                total: progressEvent.total
              });
            }.bind(this),
            onFile = function(file) {
              if (!file) {
                onError();
              } else {
                if (this._application.getMenu("uploadStatus")) {
                  this._application.getMenu("uploadStatus").setProcessing();
                }
                const url = options.fileTransferUrl;
                filePicker.send(file, url, onSuccess, onError, onProgress);
              }
            }.bind(this);
          if (this._fileChoosers[normalizedFileName] && this._fileChoosers[normalizedFileName].length) {
            filePicker = this._fileChoosers[normalizedFileName].shift();
            onFile(normalizedFileName);
          } else {
            filePicker = cls.WidgetFactory.createWidget("FilePicker", {
              appHash: this._application.applicationHash
            });
            this._application.layout.afterLayout(function() {
              filePicker.resizeHandler();
            });
            this._application.getUI().getWidget().getElement().appendChild(filePicker.getElement());
            filePicker.setExtension("." + normalizedFileName.split('.').pop());
            filePicker.show();
            filePicker.whenFileSelectionChanged(this._whenFileSelectionChanged.bind(this, onFile, onError));
          }
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          const destroyable = [],
            keys = Object.keys(this._fileChoosers);
          let len = keys.length,
            k = 0,
            i = 0;
          for (; k < len; k++) {
            while (this._fileChoosers[keys[k]] && this._fileChoosers[keys[k]][i]) {
              if (!destroyable.contains(this._fileChoosers[keys[k]][i])) {
                destroyable.push(this._fileChoosers[keys[k]][i]);
              }
              i++;
            }
          }
          len = destroyable.length;
          for (k = 0; k < len; k++) {
            destroyable[k].destroy();
          }
          $super.destroy.call(this);
        },

        /**
         * free resources when a file picker is destroyed
         * @param {classes.FilePickerWidget} picker
         * @private
         */
        _onFilePickerDestroyed: function(picker) {
          const files = picker && picker.getAvailableFiles();
          if (files) {
            for (const element of files) {
              if (this._fileChoosers[element]) {
                this._fileChoosers[element].remove(picker);
              }
            }
          }
        },

        /**
         * format extensions
         * @param {string} raw
         * @return {string}
         * @private
         */
        _extractExtensions: function(raw) {
          const regex = /[^\s.]+\.[^\s.]+/g;
          let m;
          const res = [];
          while ((m = regex.exec(raw)) !== null) {
            const ext = m[1];
            if (ext === ".*") {
              res.length = 0;
              break;
            }
            res.push(ext);
          }
          return res.join(",") || "";
        }
      };
    });
    cls.ApplicationServiceFactory.register("FileTransfer", cls.FileTransferApplicationService);
  });
;

"use strict";

modulum('FocusApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class FocusApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.FocusApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.FocusApplicationService.prototype */ {
        __name: "FocusApplicationService",

        /**
         * true if we are currently restoring the VM focus, false otherwise
         * @type {boolean}
         */
        _restoringVMFocus: false,

        /**
         * Active DropDown widget
         * @type {classes.WidgetGroupBase}
         */
        _activeDropDownWidget: null,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          $super.destroy.call(this);
          this._activeDropDownWidget = null;
        },

        /**
         * Restores the focus according to the VM focus
         * @param {boolean=} [restoreDOMFocus] ensure to restore the DOM focus
         */
        restoreVMFocus: function(restoreDOMFocus) {
          const node = this._application.getFocusedVMNodeAndValue(true);
          if (node) {
            // set current focused node
            context.LogService.focus.log("restoreVMFocus for node : ", node);

            const ctrl = node.getController();
            if (ctrl) {
              // ensure visible for folder pages
              const parentForm = node.getAncestor("Form");
              let visibleId = null;
              if (parentForm) {
                visibleId = parentForm.attribute("visibleId");
              }
              let uiWidget = null;
              const appWidget = this._application.getUI().getWidget();
              if (appWidget) {
                uiWidget = appWidget._uiWidget;
              }
              const focusedWidget = ctrl.getWidget() || ctrl.getCurrentInternalWidget();
              if (focusedWidget) {
                if (!uiWidget) {
                  uiWidget = focusedWidget.getUserInterfaceWidget();
                }
                if (uiWidget) { // set ui current focused widget
                  uiWidget.setFocusedWidget(focusedWidget);
                }
              } else if (ctrl instanceof cls.MatrixController) {
                //When the current cell of a Matrix is not visible refresh the layout
                restoreDOMFocus = true;
              }

              this._restoringVMFocus = true;
              if (uiWidget && (restoreDOMFocus || uiWidget.hasFocusedWidgetChanged())) {
                // if no visibleId is set we make sure to display potential current page
                if (!visibleId || visibleId === -1) {
                  if (ctrl.ensureVisible()) {
                    this._application.scheduler.layoutCommand();
                  }
                }

                if (node.isInTable()) {
                  //We need to set the focus on the Table to be able to show the rowbound
                  let tableNode = node.getAncestor('Table');
                  let tableController = tableNode.getController();

                  tableController.setFocus();
                }

                ctrl.setFocus(); // set ui focus on widget element

                // hide previously displayed dropdowns
                if (cls.DropDownWidget.hasAnyVisible() && !cls.DropDownWidget.isChildOrParentOfDropDown(focusedWidget
                    .getElement())) {
                  cls.DropDownWidget.hideAll();
                }

              }
              this.emit(context.constants.widgetEvents.focusRestored);
              this._restoringVMFocus = false;
            }
          }
        },

        /**
         * @returns {boolean} true if we are currently restoring the VM focus, false otherwise
         */
        isRestoringVMFocus: function() {
          return this._restoringVMFocus;
        },

        /**
         * Set the widget which has an active DropDown
         * @param {classes.WidgetGroupBase} activeDDWidget - active DropDown widget
         */
        setActiveDropDownWidget: function(activeDDWidget) {
          this._activeDropDownWidget = activeDDWidget;
        },

        /**
         * Get the widget which has an active DropDown
         * @return {classes.WidgetGroupBase} the active DropDown widget
         */
        getActiveDropDownWidget: function() {
          return this._activeDropDownWidget;
        }
      };
    });
    cls.ApplicationServiceFactory.register("Focus", cls.FocusApplicationService);
  });
;

"use strict";

modulum('InputApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class InputApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.InputApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.InputApplicationService.prototype */ {
        __name: "InputApplicationService",

        /** @type {*} */
        _lastBeforeInputEvent: null,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._application.dvm.onOrdersManaged(this._bindEvents.bind(this), true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._unbindEvents();
          this._lastBeforeInputEvent = null;
          $super.destroy.call(this);
        },

        /**
         * Bind input events on the ui
         * @private
         */
        _bindEvents: function() {
          const uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            const uiElement = uiWidget.getElement();
            uiElement.on('input.UserInterfaceWidget', this._onInput.bind(this));
            uiElement.on('beforeinput.UserInterfaceWidget', this._onBeforeInput.bind(this));
          }
        },

        /**
         * Unbind input events of the ui
         * @private
         */
        _unbindEvents: function() {
          const uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            const uiElement = uiWidget.getElement();
            uiElement.off('input.UserInterfaceWidget');
            uiElement.off('beforeinput.UserInterfaceWidget');
          }
        },

        /**
         * Input event handler.
         * @param {*} event
         * @private
         */
        _onInput: function(event) {
          context.LogService.input.log("_onInput event : ", event);

          const targetElement = event.target;

          // search widget from dom event
          const widget = gbc.WidgetService.getWidgetFromElement(targetElement);
          if (!widget) {
            return;
          }

          let dataString = event.data;
          if (dataString === null) { // if data is not available in input event, try to find it in beforeinput event
            dataString = this._lastBeforeInputEvent ? this._lastBeforeInputEvent.data : "";
          }
          widget.manageInput(dataString, event);
        },

        /**
         * BeforeInput event handler.
         * @param {*} event
         * @private
         */
        _onBeforeInput: function(event) {
          context.LogService.input.log("_onBeforeInput event : ", event);

          const targetElement = event.target;
          this._lastBeforeInputEvent = event;

          // search widget from dom event
          const widget = gbc.WidgetService.getWidgetFromElement(targetElement);
          if (!widget) {
            return;
          }

          let preventDefault = false;

          if (!this._application.hasVMFocus(widget)) {
            // if widget has not the focus:
            // 1. prevent input
            // 2. request focus on this widget
            // 3. add a paste command to insert the input after the focus
            preventDefault = true;
            widget.emit(context.constants.widgetEvents.requestFocus);
            this._application.scheduler.clipboardPasteCommand(event.data, widget);
          } else {
            // execute manageBeforeInput from current widget
            const widgetBeforeInputAccepted = widget.manageBeforeInput(event.data, event);

            // check if scheduler is processing
            const schedulerProcessing = this._application.scheduler.hasProcessingCommands();
            if (schedulerProcessing) {
              // flash app, no input admit during processing
              this._application.getUI().getWidget().flash(100);
            }

            // prevent input when
            // 1. widget manageBeforeInput return false (widget explicit ask to prevent input)
            // 2. scheduler is processing (it means no input accepted when waiting for VM response)
            // 3. inputType is deleteByDrag (it means drag and drop doesn't delete text from drag source)
            preventDefault = !widgetBeforeInputAccepted || schedulerProcessing || event.inputType === 'deleteByDrag';
          }

          // TODO event.inputType === 'insertFromDrop'
          // TODO event.inputType === 'deleteByDrag'

          if (preventDefault) {
            event.stopPropagation();
            event.preventCancelableDefault();
          }
        },
      };
    });
    cls.ApplicationServiceFactory.register("Input", cls.InputApplicationService);
  });
;

"use strict";

modulum('KeyboardApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class KeyboardApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.KeyboardApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.KeyboardApplicationService.prototype */ {
        __name: "KeyboardApplicationService",
        $static: /** @lends classes.KeyboardApplicationService */ {
          keymap: {
            8: 'backspace',
            9: 'tab',
            13: 'enter',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            19: 'pause',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'ins',
            46: 'del',
            91: 'meta',
            92: 'meta',
            93: 'contextmenu',
            112: 'f1',
            113: 'f2',
            114: 'f3',
            115: 'f4',
            116: 'f5',
            117: 'f6',
            118: 'f7',
            119: 'f8',
            120: 'f9',
            121: 'f10',
            122: 'f11',
            123: 'f12',
            144: 'numlock',
            145: 'scrolllock',
            224: 'meta',
          },

          navigationKeys: [
            'up',
            'down',
            'left',
            'right'
          ],

          /**
           * For composed keys (shift+key) and (ctrl+alt+key) where key.length = 1
           * transform keyString into the keyEvent.key char
           * Ex (shift+a --> 'A' or 'ctrl+alt+e' --> €)
           * @param {String} keyString - key string ex "shift+a"
           * @param {Object} keyEvent - dom key event
           * @returns {String} char for composed keys or unchanged keyString
           */
          getCharIfComposedKey: function(keyString, keyEvent) {
            if (keyEvent.key.length === 1 && (keyEvent.shiftKey || (keyEvent.ctrlKey && keyEvent.altKey))) {
              return keyEvent.key;
            }
            return keyString;
          }
        },

        /** @type {String} */
        _bufferedKeys: null,
        /** @type {Boolean} */
        _keyDownProcessed: false,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._application.dvm.onOrdersManaged(this._bindKeyboardEvents.bind(this), true);
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._bufferedKeys = null;
          this._unbindKeyboardEvents();
          $super.destroy.call(this);
        },

        /**
         * Bind keydown & keyup events on the ui and listen to them to catch all keys
         * @private
         */
        _bindKeyboardEvents: function() {
          const uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            const uiElement = uiWidget.getElement();
            uiElement.on("keydown.UserInterfaceWidget", this._onKeyDown.bind(this));
            uiElement.on("keyup.UserInterfaceWidget", this._onKeyUp.bind(this));
          }
        },

        /**
         * Unbind keydown & keyup events of the ui
         * @private
         */
        _unbindKeyboardEvents: function() {
          const uiWidget = this._application.getUI().getWidget();
          if (uiWidget) {
            const uiElement = uiWidget.getElement();
            uiElement.off("keydown.UserInterfaceWidget");
            uiElement.off("keyup.UserInterfaceWidget");
          }
        },

        /**
         * Used the DBFormat definition to replace the keypad '.' by the good one
         * @param event
         * @returns {boolean} true if the translation is done
         * @private
         */
        _translateKeyAccordingDBFormat: function(event) {
          const userInterfaceNode = this._application.getNode(0);

          if (!userInterfaceNode.isAttributeSetByVM("decimalSeparator")) {
            return false;
          }

          const decimalSeparator = userInterfaceNode.attribute("decimalSeparator");

          if (event.key === "." && decimalSeparator !== event.key && event.code === "NumpadDecimal") {
            event.stopPropagation();
            event.preventCancelableDefault();

            const newEvent = new cls.DelayedKeyCommand(this._application, decimalSeparator, event);
            this._keyDownProcessed = this.processKey(decimalSeparator, event, false);

            if (!this._keyDownProcessed) {
              const focusedNode = this._application.getFocusedVMNodeAndValue(true);
              const widget = focusedNode && focusedNode.getWidget();

              if (widget) {
                newEvent.simulateBrowserBehaviorOnWidget(widget);
              }
            }

            this.executeKeyUp(decimalSeparator, event);

            return true;
          }

          return false;
        },

        /**
         * Keydown handler bound on UserInterface widget. Catch all keydown events and propagate it to the corresponding widget.
         * We detect the key combination and execute all actions bound to it. Otherwise, we let widget manage the key
         * @param event
         * @private
         */
        _onKeyDown: function(event) {
          if (!this._canProcessEvent()) {
            return;
          }

          event.gbcKey = this.getNormalizedKey(event);

          if (this._translateKeyAccordingDBFormat(event)) {
            return;
          }

          let combi = this.translateKeys(event, event.gbcKey);

          if (gbc.androidEmulationDebug === true) {
            // Try to emulate android behavior

            if (combi === "tab") {
              // try to emulate "next field" virtual keyboard key
              event.preventCancelableDefault();
              event.stopPropagation();
              this._emulateAndroidNextFieldVirtualKey();

            } // keyDown keyCode are not raised correctly on android, so set key as "unidentified"
            combi = "unidentified";
          }

          // if user keep pressing same key without releasing it and typeahead is flagged as frozen, we don't push event
          this._keyDownProcessed = false;

          const repeatKey = this._bufferedKeys === combi;

          if (combi && !combi.includes("unidentified")) {
            this._bufferedKeys = combi;
            context.LogService.keyboard.log("KEY USED onKeyDown saved as bufferedKeys : ", this._bufferedKeys, event.key);

            const focusedNode = this._application.getFocusedVMNodeAndValue(true);
            // Add delayed keys when (vm is processing or when there are already pending commands) and no webcomponent is inside the current focused node.
            // They may be background process such as current focused node being destroyed when checking on webcomponent
            if (!this._application.scheduler.hasNoCommandToProcess() && (!focusedNode || focusedNode.getFirstChild(
                'WebComponent') === null)) {
              event.stopPropagation();
              event.preventCancelableDefault();

              if (!repeatKey) { // don't delay repeated key, simply ignore it
                context.LogService.keyboard.log("Delayed key captured : ", this._bufferedKeys);
                this._application.scheduler.delayedKeyCommand(this._bufferedKeys, event);
              }
            } else {
              this._keyDownProcessed = this.processKey(this._bufferedKeys, event, repeatKey);
              if (this._keyDownProcessed) {
                context.LogService.keyboard.log("onKeyDown processed event.key : ", event.key);
              }
            }
          }
        },

        /**
         * Try to emulate "Next field" virtual keyboard behavior
         * @private
         */
        _emulateAndroidNextFieldVirtualKey: function() {
          const focusedNode = this._application.getFocusedVMNodeAndValue(true);
          const focusedWidget = focusedNode.getWidget();

          let found = false;
          if (focusedWidget.getInputElement()) {
            // go through all element of the FORM
            for (const field of focusedWidget.getInputElement().form) {
              // if field is after the current one, and is not readonly focus it
              if (found && !field.hasAttribute("readonly")) {
                field.focus();
                break;
              }
              // search current field
              if (field === focusedWidget.getInputElement()) {
                found = true;
              }
            }
          }
        },

        /**
         * Keyup handler bound on UserInterface widget. Catch all keyup events and propagate it to the corresponding widget.
         * Key combination previously detected in Keydown is passed as parameter
         * @param event
         * @private
         */
        _onKeyUp: function(event) {
          if (!this._canProcessEvent()) {
            return;
          }

          const key = this.getNormalizedKey(event);
          if (!key.toLowerCase().includes("unidentified")) {
            // if scheduler isn't finished, don't manage key up it will be done by DelayedKey command
            if (!this._application.scheduler.hasNoCommandToProcess()) {
              event.stopPropagation();
              event.preventCancelableDefault();
            } else {
              event.gbcKey = key;
              this.executeKeyUp(this._bufferedKeys, event);
            }
          }
          this._bufferedKeys = null;
        },

        /**
         * @param {String} keyString string corresponding to the key
         * @param {Object} keyEvent keyDown js event
         */
        executeKeyUp: function(keyString, keyEvent) {
          const focusedNode = this._application.getFocusedVMNodeAndValue(true);
          const widget = focusedNode && focusedNode.getWidget();
          if (widget) {
            // we pass bufferedKeys as parameter in order to be able to be sure to manage previously typed combination.
            widget.manageKeyUp(keyString, keyEvent);
          }
        },

        /**
         * Check if key is a basic modifier (ctrl, shift, alt)
         * @param {string} key
         * @returns {boolean} returns true if key is a basic modifier
         */
        isBasicModifier: function(key) {
          const k = key.toLowerCase();
          return k === 'shift' || k === 'ctrl' || k === 'alt' || k === 'meta' || k === 'dead';
        },

        /**
         * Normalize DOM event key using VM modifier common names
         * @param event
         * @returns {*|string} returns normalized key
         */
        getNormalizedKey: function(event) {
          let key = cls.KeyboardApplicationService.keymap[event.which] || "";

          // Difference between Numpad keys and "normal" keys
          if (key === "enter" && event.code !== "NumpadEnter") {
            key = "return";
          } else if (key === "del" && event.code !== "NumpadDecimal") {
            key = "delete";
          } else if (key === "ins" && event.code !== "Numpad0") {
            key = "insert";
          }

          if (!key) {
            key = event.key;
          }
          if (window.browserInfo.isEdge || window.browserInfo.isIE) {
            key = key.replace("Divide", "/").replace("Multiply", "*").replace("Subtract", "-").replace("Add", "+").replace(
              "Decimal", ".");
          }

          if (!key) {
            key = String.fromCharCode(event.which || event.code);
          }

          return key;
        },

        /**
         * Get the combination of keys (modifiers included) being typed
         * @param event
         * @param {string} normalizedKey
         * @returns {string} returns normalized keys combination
         */
        translateKeys: function(event, normalizedKey) {
          const ctrlKey = event.ctrlKey;
          const altKey = event.altKey;
          const shiftKey = event.shiftKey;
          const metaKey = event.metaKey;

          let keys = "";
          if (!this.isBasicModifier(normalizedKey)) {
            if (metaKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "meta";
            }
            // use that order : ctrl+shift+alt
            if (ctrlKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "ctrl";
            }
            if (altKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "alt";
            }
            if (shiftKey) {
              if (keys.length !== 0) {
                keys += '+';
              }
              keys += "shift";
            }
            if (keys.length !== 0) {
              keys += '+';
            }
            keys += normalizedKey;
          }
          return keys.length === 1 ? keys : keys.toLowerCase();
        },

        /**
         *
         * @param {String} keyString - string of the key (including combination, ctrl+, shift+, ...)
         * @param {Object} event - dom key event
         * @param {boolean} repeat - true if key is being pressed
         * @returns {boolean} true if the key has been processed, false otherwise
         */
        processKey: function(keyString, event, repeat) {
          let processed = false;

          const app = this._application;
          const focusedNode = app.getFocusedVMNodeAndValue(true);
          const activeDropDownWidget = app.focus.getActiveDropDownWidget();

          // Search widget
          let widget = focusedNode && focusedNode.getWidget();
          if (!widget) {
            // If focused node is in a matrix look for scrollgrid widget
            // because there is no Matrix widget
            if (focusedNode.getTag() === "Matrix") {
              let scrollGridNode = focusedNode.getAncestor("ScrollGrid");
              if (scrollGridNode) {
                widget = scrollGridNode.getWidget();
              }
            }
          }

          // TODO gbc-3832 : this special case, initially created for tables, is maybe not needed anymore
          // 1. Special case CTRL+C, if there is a text selection and the current VM focus has not DOM focus
          if (keyString === "ctrl+c" || keyString === "meta+c") {
            const selectionText = gbc.ClipboardService.getSelection(); // window.getSelection().toString() don't work on firefox
            const domFocus = widget.hasDOMFocus();
            if (!domFocus && selectionText && selectionText !== "") {
              // return false, to let the browser manage CTRL+C
              return false;
            }
          }

          // 2. Priority key managed by the widget before any action
          if (!processed && activeDropDownWidget) { // first widget with an active DropDown catches the keys
            processed = activeDropDownWidget.managePriorityKeyDown(keyString, event, repeat);
          }
          if (!processed && widget && !widget.isHidden()) {
            processed = widget.managePriorityKeyDown(keyString, event, repeat);
          }

          // 3. Try to process action for combination key
          if (!processed) {
            processed = this._processAction(keyString);
          }
          // 4. If there is no accelerator defined on combination when shift key is pressed,
          // we try to process action on shifted key directly but only for key which can be displayed.
          // Example : we need this to manage ? accelerator
          if (!processed && event.shiftKey === true && event.key && event.key.length === 1) {
            processed = this._processAction(event.key);
          }

          // 5. if key not processed, ask widget to manage it
          if (!processed && activeDropDownWidget) { // first widget with an active DropDown catches the keys
            processed = activeDropDownWidget.manageKeyDown(keyString, event, repeat);
          }
          if (!processed && widget && !widget.isHidden()) {
            processed = widget.manageKeyDown(keyString, event, repeat);
          }

          // 6. Check if key must be sent to VM (for specific nodes and specific keys we always send to VM)
          if (!processed) {
            let vmKey = cls.KeyboardHelper.convertBrowserKeyToVMKey(keyString);
            let createKeyEvent = false;

            if (widget && !widget.isHidden()) {
              if (widget.isInstanceOf(cls.FieldWidgetBase)) {
                if (keyString === "tab" || keyString === "shift+tab") {
                  createKeyEvent = true;
                }
              } else if (widget.isInstanceOf(cls.TableWidgetBase) || widget.isInArray()) {
                if (keyString === "up" || keyString === "down" || keyString === "tab" || keyString === "shift+tab") {
                  createKeyEvent = true;
                } else {
                  // transform "shift+a" vmKey into "A" to send the correct key at VM
                  // TODO we should probably do this more globally
                  vmKey = cls.KeyboardApplicationService.getCharIfComposedKey(vmKey, event);

                  // letter should be sent to VM for "search" feature
                  createKeyEvent = (focusedNode.attribute("dialogType") === "DisplayArray" && vmKey.length === 1 && (cls
                    .KeyboardHelper
                    .isLetter(vmKey) || cls.KeyboardHelper.isNumeric(vmKey)));
                }
              }
            }
            if (focusedNode.getTag() === "MenuAction") {
              // first letter of actions and nav keys should be sent to VM to navigate in the menu
              createKeyEvent = (this._isMenuActionShortcutKey(focusedNode.getParentNode(), vmKey) ||
                cls.KeyboardApplicationService.navigationKeys.indexOf(keyString) >= 0);
            }

            if (createKeyEvent) {
              let vmEvent = new cls.VMKeyEvent(vmKey);
              context.LogService.keyboard.log("processKey send KeyEvent for key : ", vmKey);

              if (focusedNode) {
                const ctrl = focusedNode.getController();
                if (ctrl) {
                  ctrl.sendWidgetCursors();
                  ctrl.sendWidgetValue();
                }
              }
              app.scheduler.eventVMCommand(vmEvent);
              processed = true;
            }
          }

          // 7. Manage dom event, stopPropagation preventDefault if key has been processed
          if (event) {
            if (processed) {
              event.stopPropagation();
              if (event.gbcDontPreventDefault !== true) {
                event.preventCancelableDefault();
              }
            } else {
              // check if existing modal menu
              const uiNode = app.uiNode();
              const currentWindow = uiNode && app.getNode(uiNode.attribute('currentWindow'));
              const modalMenu = currentWindow && currentWindow.getFirstChildWithAttribute('Menu', 'active', 1);
              if (modalMenu) {
                const modalType = modalMenu.attribute("style");
                if (modalType === "winmsg" || modalType === "dialog") {
                  // dialog detected, we need to prevent default to avoid focus being moved to another application
                  event.stopPropagation();
                  event.preventCancelableDefault();
                }
              }
            }
          }

          return processed;
        },

        /**
         * Check if key is a menu action shortcut
         * @param {classes.NodeBase} menuNode
         * @param {string} key
         * @returns {boolean} returns true if key is a shortcut of the passed menu node
         * @private
         */
        _isMenuActionShortcutKey: function(menuNode, key) {
          const menuActions = menuNode.getChildren('MenuAction');
          for (let i = 0; i < menuActions.length; ++i) {
            const menuAction = menuActions[i];
            if (menuAction.attribute('active')) {
              let text = menuAction.isAttributeSetByVM('text') ? menuAction.attribute('text') : menuAction.attribute('name');
              text = text.toString().toLocaleLowerCase();
              if (text && text.length !== 0 && text[0] === key) {
                return true;
              }
            }
          }
          return false;
        },

        /**
         * Find and execute VM action corresponding to key
         * @param {string} keyString - string of the key (including combination, ctrl+, shift+, ...)
         * @returns {boolean} true if the key has been processed, false otherwise
         */
        _processAction: function(keyString) {
          let processed = false;
          let actionName = "";
          let actionNode = null;
          let shouldSendAction = false;

          const vmKey = cls.KeyboardHelper.convertBrowserKeyToVMKey(keyString);
          const app = this._application;
          const focusedNode = app.getFocusedVMNodeAndValue(true);

          // 1. Try to find corresponding action in active dialog actions list
          if (!processed) {
            actionNode = this._application.getActiveDialogAction(vmKey);
            if (actionNode) {
              shouldSendAction = true;
              processed = true;
            }
          }

          const activeForm = focusedNode && focusedNode.getAncestor("Form");
          // 2. Try to find corresponding action in current form action defaults list
          if (!processed) {
            if (activeForm) {
              actionNode = this._application.getDefaultAction(vmKey, activeForm);
              if (actionNode) {
                actionName = actionNode.attribute('name');
                if (cls.ActionApplicationService.browserNativeActions.contains(actionName)) {
                  context.LogService.keyboard.log("processKey found copy/cut/paste Action");
                } else if (cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
                  shouldSendAction = true;
                  processed = true;
                }
              }
            }
          }

          // 3. Try to find corresponding action in application global action defaults list
          if (!processed) {
            actionNode = this._application.getDefaultAction(vmKey);
            if (actionNode) {
              actionName = actionNode.attribute('name');
              if (cls.ActionApplicationService.browserNativeActions.contains(actionName)) {
                context.LogService.keyboard.log("processKey found copy/cut/paste Action");
                // TODO : this check seems useless. Why are we trying to look at action defined on active form again ? (we did it in previous step)
              } else if (activeForm && this._application.getDefaultActionForName(actionName, activeForm)) {
                context.LogService.keyboard.log("detected a global ActionDefault for this VM key but is override in a sub form : do nothing",
                  vmKey);
                processed = true;
              } else if (cls.ActionApplicationService.getLocalActionNames().contains(actionName)) {
                shouldSendAction = true;
                processed = true;
              }
            }
          }

          // 4. Check that the action must be sent, some actions can be ignored depending on the AUI node
          if (shouldSendAction) {
            const sendAction = !focusedNode || !focusedNode.ignoreAction(actionName);
            if (sendAction) {
              this._sendAction(actionNode);
            }
            processed = sendAction;
          }
          return processed;
        },

        /**
         * Send an action
         * @param {classes.ActionNode} actionNode - action node to be processed
         * @private
         */
        _sendAction: function(actionNode) {

          // action: guisnapshot only in debugMode
          if (actionNode.attribute('name') === "guisnapshot") {
            if (gbc.DebugService.isActive() || gbc.LogService.isRecordingEnabled()) {
              this._sendLogEvent("snapshot");
              return;
            }
          }

          const app = this._application;
          const scheduler = app.scheduler;
          const focusedNode = app.getFocusedVMNodeAndValue(true);
          const focusedNodeController = focusedNode && focusedNode.getController();
          const focusedNodeIsMatrix = (focusedNode && focusedNode.getTag() === "Matrix");
          const focusedNodeIsTable = (focusedNode && focusedNode.getTag() === "Table");

          const focusedNodeIsInInputMode = focusedNode ? (['Input', 'InputArray', 'Construct'].indexOf(focusedNode.attribute(
              'dialogType')) !==
            -1) : null;

          // if Table or Matrix in DISPLAY mode, no need to send value/cursors
          if ((focusedNodeIsTable || focusedNodeIsMatrix) && !focusedNodeIsInInputMode) {
            scheduler.actionVMCommand(actionNode);
          } else {
            scheduler.startGroupCommand();
            if (focusedNodeController) {
              focusedNodeController.sendWidgetCursors();
              focusedNodeController.sendWidgetValue();
            }
            scheduler.actionVMCommand(actionNode);
            scheduler.finishGroupCommand();
          }
        },

        /**
         * Sends a log event command
         * @param {string} text you want to add to your log
         * @private
         */
        _sendLogEvent: function(text) {
          // Flash app and display message
          this._application.getUI().getWidget().flash(300);
          const messageService = this._application.message;
          const userInterfaceNode = this._application.getNode(0);
          const userInterfaceWidget = userInterfaceNode.getController().getWidget();
          const msgWidget = userInterfaceWidget.getMessageWidget();
          msgWidget.setText("GUI snapshot");
          msgWidget.addClass("warning");
          msgWidget.setHidden(false);
          messageService.addMessage("guisnapshot", msgWidget);
          messageService.handlePositions();
          this._registerTimeout(function() {
            msgWidget.setHidden(true);
          }.bind(this), 3000);

          let jsonData = {
            type: text
          };
          this._application.scheduler.eventVMCommand(new cls.VMLogEvent(JSON.stringify(jsonData)));
        },

        /**
         * @return {boolean} false if the application is waiting in background
         * @private
         */
        _canProcessEvent: function() {
          const curSession = context.SessionService.getCurrent();
          const application = curSession && curSession.getCurrentApplication();

          if (application) {
            return application.canProcessEvent();
          }

          return true;
        }
      };
    });
    cls.ApplicationServiceFactory.register("Keyboard", cls.KeyboardApplicationService);
  });
;

"use strict";

modulum('LayoutApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory', 'LayoutInvalidationService'],
  function(context, cls) {
    /**
     * @class LayoutApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.LayoutApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.LayoutApplicationService.prototype */ {
        __name: "LayoutApplicationService",

        /**
         * flag to identify layout from resizing
         * @type {boolean}
         */
        _resizing: false,

        /**
         * flag to detect if document is visible (and not running layout computing if not)
         * @type {boolean}
         */
        _documentIsVisible: true,

        /**
         * invalidation number
         * index to compare to measure and allocated space invalidations
         * Used to filter and optimize layout traversal.
         * @type {number}
         */
        _lastInvalidated: 0,

        /**
         * Handle to watch document visibility changes.
         * @type {HandleRegistration}
         */
        _visibilityChangeHandler: null,

        /**
         * flag to know if layout is currently idle.
         * @type {boolean}
         */
        _idle: true,

        /**
         * flag to know if a bonus (adjustMeasure - adjustStretchability - prepareApplyLayout) is needed
         * @type {boolean}
         */
        _backLayout: false,

        /**
         * Only in gbc.qaMode, count the number of layout
         * @type {number}
         */
        _qaLayoutCount: 0,

        /**
         * @inheritDoc
         */
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._updateDocumentVisibility();
          this._visibilityChangeHandler = context.InitService.when(
            context.constants.widgetEvents.visibilityChange,
            this._updateDocumentVisibility.bind(this)
          );
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          if (this._visibilityChangeHandler) {
            this._visibilityChangeHandler();
            this._visibilityChangeHandler = null;
          }
          $super.destroy.call(this);
        },

        /**
         * update document visibility info and run layout if needed
         * @private
         */
        _updateDocumentVisibility: function() {
          this._documentIsVisible = !document.hidden;
          if (this._documentIsVisible && this._application.scheduler) {
            this._application.scheduler.layoutCommand();
          }
        },

        /**
         * reset all layout and rerun it
         */
        reset: function() {
          this._application.getUI().getWidget().getLayoutEngine().reset(true);
          this._registerAnimationFrame(function() {
            this._updateDocumentVisibility();
          }.bind(this));
        },

        /**
         * request a layout refresh
         * @param {Object} [options] options to pass
         * @param {boolean} [options.resize] true if invoked by window resize
         * @param {boolean} [options.noLayout] true if layout must not be done
         */
        refreshLayout: function(options) {
          options = options || {};
          this._idle = false;
          this._resizing = Boolean(options.resize);
          if (this._resizing && this._application && this._application.getUI()) {
            this._application.getUI().getWidget().getLayoutEngine().invalidateAllocatedSpace();
          }

          if (this._application) {
            this._executeLayout(Boolean(options.noLayout));
          }
        },

        /**
         * get a list of all children of the given widget that will be renderable
         * @param {classes.WidgetBase} widget the widget
         * @return {classes.WidgetBase[]} a list of renderable children
         */
        _internalChildrenSelector: function(widget) {
          let result = [];
          if (widget && !widget.isHidden()) {
            result = widget.getLayoutEngine() && widget.getLayoutEngine().getRenderableChildren() || [];
          }
          return result;
        },

        /**
         * run the whole layout algorithm
         * @param {boolean} noLayout if true the layout is not executed but the signals are sent
         * @private
         */
        _executeLayout: function(noLayout) {
          let documentConsideredAsVisible = this._documentIsVisible;
          gbc.LogService.ui.log("LayoutApplicationService - execute layout - noLayout=" + noLayout);

          // DocumentVisibility API seems not to be well implemented on android webview, this should do the trick
          if (!documentConsideredAsVisible && (window.gbcWrapper.isGMA())) {
            const appUI = this._application.getUI();
            const appDimensions = appUI.getWidget().getElement().getBoundingClientRect();
            if (appDimensions.width > 0 && appDimensions.height > 0) {
              gbc.LogService.ui.log(
                "DocumentVisibility API override, consider as visible as we are hosted by GMA and application's widget has a size");
              documentConsideredAsVisible = true;
            }
          }
          if (!documentConsideredAsVisible) {
            return;
          }
          const app = this._application, // we only get application if document is visible
            node = app?.model?.getNode(0),
            ctrl = node?.getController(),
            widget = ctrl?.getWidget();
          let traversal = null;

          if (widget && document.body.contains(widget.getElement()) && this._application.getUI().isLayoutable()) {
            if (ctrl && noLayout === false) {
              context.styler.bufferize();
              const measureInfo = {
                needMeasureSwitching: false,
                needMeasureWidgets: []
              };

              /// Here we declare the whole scenario to compute Genero layout on the whole application tree
              traversal = new window.Throu(widget);

              /// 1. set a default traversal function to run through the widget tree
              traversal.setChildrenSelector(this._internalChildrenSelector.bind(this));

              /// 2. beforeLayout can be defined on each layout engine
              ///    here is to adapt or initiate layout information
              traversal.pass(this.beforeLayout.bind(this));

              /// 3. walk the whole tree to update layouting information (hidden state, need measure switching)
              traversal.pass(this._refreshLayoutPassHidden.bind(this, measureInfo), false, this._hasChildrenFunction);

              /// 4. switch g_measured to g_measuring css class if needed
              traversal.unique(this._switchMeasuring.bind(this, true, measureInfo));

              /// 5. walk the whole tree (from children to parents) to prepare DOM/values to futures measures
              traversal.pass(this.prepareMeasure.bind(this), true);

              /// 6. walk the whole tree (from children to parents) to measure DOM / set values from DOM measures
              traversal.pass(this.measure.bind(this), true);

              /// 7. walk the whole tree (from children to parents) to adjust measures from children information
              traversal.pass(this.adjustMeasure.bind(this), true);

              /// 8. walk the whole tree (from children to parents) to adjust stretchability indices from children information
              traversal.pass(this.adjustStretchability.bind(this), true);

              /// 9. walk the whole tree (from children to parents) to re-adjust measures from children information
              ///    needed for example to manage auto overflow (change shrink rules if form must overflow in all cases)
              traversal.pass(this.reAdjustMeasure.bind(this), true);

              /// 10. walk the whole tree (from children to parents) to re-adjust stretchability indices from children information
              traversal.pass(this.reAdjustStretchability.bind(this), true);

              /// 11. walk the whole tree to compute space to loss/gain and distsribute it amongst the children
              traversal.pass(this.prepareApplyLayout.bind(this));

              // ### this pass is only done if stack layout has autoscaled image widgets
              ///    12. walk the whole tree (from children to parents) to adjust measures from children information
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.adjustMeasure.bind(this), true);

              ///    13. walk the whole tree (from children to parents) to adjust stretchability indices from children information
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.adjustStretchability.bind(this), true);

              ///    14. walk the whole tree to compute space to loss/gain and distribute it amongst the children
              traversal.passIf(this.isBackLayoutActivated.bind(this), this.prepareApplyLayout.bind(this));
              // ###

              /// 15. walk the whole tree to apply computed sizes to elements
              traversal.pass(this.applyLayout.bind(this));

              /// 16. switch g_measuring to g_measured css class if needed
              traversal.unique(this._switchMeasuring.bind(this, false, measureInfo));

              /// 17. walk the whole tree to notify listeners of g_layoutApplied
              traversal.pass(this.notifyLayoutApplied.bind(this));

              /// 18. update invalidation indices
              traversal.unique(this._updateInvalidation.bind(this));

              // run the declared passes
              traversal.run();

              if (gbc.qaMode) {
                this._qaLayoutCount++;
              }

              context.styler.flush();
              this._resizing = false;
            }

            if (traversal) {
              traversal.destroy();
            }
            this._idle = true;

            this.emit(context.constants.widgetEvents.afterLayout, this._resizing);
          }
        },

        /**
         * update invalidation indice
         * @private
         */
        _updateInvalidation: function() {
          this._lastInvalidated = context.LayoutInvalidationService.nextInvalidation();
        },

        /**
         * get list of children of given widget
         * @param {classes.WidgetBase|classes.WidgetGroupBase} widget the widget
         * @return {null|classes.WidgetBase[]}
         * @private
         */
        _hasChildrenFunction: function(widget) {
          return widget && widget.getChildren && widget.getChildren();
        },

        /**
         * toggle css classes to measure DOM elements
         * @param {boolean} measuring true if measuring
         * @param {{needMeasureSwitching: boolean}} measureInfo data bag
         * @private
         */
        _switchMeasuring: function(measuring, measureInfo) {
          if (measureInfo.needMeasureSwitching && !(
              !measureInfo.needMeasureWidgets.length ||
              (measureInfo.needMeasureWidgets.length === 1 && measureInfo.needMeasureWidgets[0].isInstanceOf(cls.FormWidget))
            )) {
            const rootElement = this._application.getUI().getWidget().getElement();
            if (measuring) {
              rootElement.addClass("g_measuring").removeClass("g_measured");
            } else {
              rootElement.addClass("g_measured").removeClass("g_measuring");
            }
          }
          this._backLayout = false;
        },

        /**
         * call beforeLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        beforeLayout: function(widget) {
          if (widget?.getLayoutEngine()) {
            widget.getLayoutEngine().beforeLayout();
          }
        },

        /**
         * update layouting information (hidden state, need measure switching)
         * @param {{needMeasureSwitching: boolean}} measureInfo data bag
         * @param {classes.WidgetBase} widget the widget
         * @param {classes.WidgetBase} parentWidget the parent widget
         * @param {Object} traversal
         * @private
         */
        _refreshLayoutPassHidden: function(measureInfo, widget, parentWidget, traversal) { //TODO if only form, no measureSwitching
          const itemLayoutInformation = widget && widget.getLayoutInformation(),
            itemLayoutEngine = widget && widget.getLayoutEngine(),
            parentLayoutInformation = parentWidget && parentWidget.getLayoutInformation();
          if (itemLayoutInformation && itemLayoutEngine && parentLayoutInformation) {
            itemLayoutInformation.__layoutPassHidden = parentLayoutInformation.__layoutPassHidden || !widget.isVisible();
            itemLayoutInformation.__ignoreMeasureInvalidation =
              (parentLayoutInformation.__ignoreMeasureInvalidation) || itemLayoutEngine.ignoreMeasureInvalidation();

            if (
              (!itemLayoutInformation.__ignoreMeasureInvalidation &&
                (itemLayoutEngine.isInvalidatedMeasure(this._lastInvalidated) && itemLayoutEngine.needMeasureSwitching()))
            ) {
              measureInfo.needMeasureWidgets.push(widget);
              measureInfo.needMeasureSwitching = true;
            }
          }
        },

        /**
         * call prepareMeasure of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        prepareMeasure: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidatedMeasure(this._lastInvalidated)) {
            layoutEngine.prepareMeasure();
          }
        },

        /**
         * call different measure steps of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        measure: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine) {
            if (layoutEngine.isInvalidatedMeasure(this._lastInvalidated) && widget.getElement().isInDOM()) {
              layoutEngine.resetSizes(this._lastInvalidated, this);

              if (!widget.ignoreLayout()) {
                layoutEngine.measureChar();
              }
              layoutEngine.DOMMeasure();
              layoutEngine.measureDecoration(this._lastInvalidated, this);
              layoutEngine.measure(this._lastInvalidated, this);
              layoutEngine.afterMeasure(this._lastInvalidated, this);
            }
            if (layoutEngine.isInvalidated(this._lastInvalidated)) {
              layoutEngine.prepareAdjustments();
            }
          }
        },

        /**
         * call adjustMeasure of widget's layout engine
         * @param {classes.WidgetBase} widget
         */
        adjustMeasure: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.adjustMeasure(this._lastInvalidated);
            layoutEngine.afterAdjustMeasure(this._lastInvalidated);
          }
        },

        /**
         * call adjustStretchability of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        adjustStretchability: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.adjustStretchability(this._lastInvalidated);
          }
        },

        /**
         * call adjustMeasure of widget's layout engine if auto overflow is activated
         * @param {classes.WidgetBase} widget the widget
         */
        reAdjustMeasure: function(widget) {
          if (this.isAutoOverflowActivated(widget)) {
            this.adjustMeasure(widget);
          }
        },

        /**
         * call adjustStretchability of widget's layout engine if auto overflow is activated
         * @param {classes.WidgetBase} widget the widget
         */
        reAdjustStretchability: function(widget) {
          if (this.isAutoOverflowActivated(widget)) {
            this.adjustStretchability(widget);
          }
        },

        /**
         * Check if auto overflow is activated
         * @param {classes.WidgetBase} widget the widget
         * @returns {boolean} if auto overflow is activated on the parent form
         */
        isAutoOverflowActivated: function(widget) {
          const form = widget.getFormWidget();
          const formLayoutEngine = form && form.getLayoutEngine();
          return (!form || !formLayoutEngine ||
            (formLayoutEngine.isAutoOverflowActivated && formLayoutEngine.isAutoOverflowActivated()));
        },

        /**
         * call prepareApplyLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        prepareApplyLayout: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated)) {
            layoutEngine.prepareApplyLayout(this);
          }
        },

        /**
         * call applyLayout of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        applyLayout: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          //Only element in DOM are measured
          if (layoutEngine && layoutEngine.isInvalidated(this._lastInvalidated) &&
            (widget.getElement().isInDOM() || widget.ignoreLayout())) {
            layoutEngine.applyLayout();
            layoutEngine.updateInvalidated(this._lastInvalidated);
          }
        },

        /**
         * call notifyLayoutApplied of widget's layout engine
         * @param {classes.WidgetBase} widget the widget
         */
        notifyLayoutApplied: function(widget) {
          const layoutEngine = widget.getLayoutEngine();
          if (layoutEngine) {
            layoutEngine.notifyLayoutApplied();
          }
        },

        /**
         * activate back layout
         */
        activateBackLayout: function() {
          this._backLayout = true;
        },

        /**
         * return true if back layout is activated
         * @return {boolean} true if back layout is activated
         */
        isBackLayoutActivated: function() {
          return this._backLayout;
        },

        /**
         * return true if layout is not running
         * @return {boolean} true if layout is not running
         */
        isIdle: function() {
          return this._idle;
        },

        /**
         * attach to afterLayout event
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        afterLayout: function(hook, once) {
          return this.when(context.constants.widgetEvents.afterLayout, hook, once);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Layout", cls.LayoutApplicationService);
  });
;

"use strict";

modulum('MessageApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {

    /**
     * @class MessageApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.MessageApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.MessageApplicationService.prototype */ {
        __name: "MessageApplicationService",

        /**
         * @type classes.EventListener
         */
        _eventListener: null,

        _messageList: null,
        _maxMessageStack: 10,

        constructor: function(app) {
          $super.constructor.call(this, app);
          this._messageList = {};
        },

        /**
         * Add a message to the stack
         * @param {string} id - count param
         * @param {classes.MessageWidget} widget - message to add
         */
        addMessage: function(id, widget) {
          this._messageList[id] = widget;
        },

        /**
         * Remove a message by its id
         * @param {string} id - count param
         * @param {Boolean?} allWindows - remove messages from all window with same id if true
         */
        removeMessage: function(id, allWindows) {
          if (this._messageList[id]) {
            this._messageList[id].setHidden(true);
            delete(this._messageList[id]);
          }
          this.handlePositions();

          // if multi pages
          const userInterfaceNode = this._application.getNode(0),
            session = userInterfaceNode.getApplication().getSession();
          if (session.hasServerFeature("browser-multi-page") && allWindows) {
            // for each window of the session, send the message
            session._childWindows.forEach((win) => {
              const winSession = win.gbc.SessionService.getCurrent();
              if (winSession) {
                winSession.getApplications().forEach((app) => {
                  if (app !== this._application) { // no notif on same app
                    app.message.removeMessage(id);
                  }
                });
              }
            });

            // In case this window has been opened by another app in the session
            if (window._opener) {
              const openerWinSession = window._opener.gbc.SessionService.getCurrent();
              if (openerWinSession) {
                openerWinSession.getApplications().forEach((app) => {
                  if (app !== this._application) { // no notif on same app
                    app.message.removeMessage(id);
                  }
                });
              }
            }
          }

        },

        /**
         * Allow messages and error defined at same position to stack
         * @private
         */
        handlePositions: function() {
          if (this._messageList) {
            const messageKeys = Object.keys(this._messageList).sort(function(a, b) {
              return a - b;
            });
            if (messageKeys.length <= 0) {
              return;
            }
            const bodyRect = document.body.getBoundingClientRect();

            const stack = context.ThemeService.getValue("theme-message-display-position") === context.ThemeService.getValue(
              "theme-error-display-position");

            for (let i = 0; i < messageKeys.length; i++) {
              const messageWidget = this._messageList[messageKeys[i]];
              if (messageWidget && messageWidget.getElement()) {
                const prevWidget = i >= 1 && messageKeys[i - 1] && this._messageList[messageKeys[i - 1]];
                const positionName = messageWidget.getForcedPosition() || messageWidget.getPosition();
                const style = {};
                // TODO : Need to remove margins if screen is really small;
                const margin = context.ThemeService.getValue("theme-margin-ratio") * 14;
                const drift = {
                  top: 0,
                  bottom: 0,
                  left: 0,
                  right: 0
                };

                const uiWidget = messageWidget.getUserInterfaceWidget();
                if (uiWidget && !uiWidget._destroyed && uiWidget.getContainerElement()) {
                  const userInterfaceRect = uiWidget.getContainerElement().getBoundingClientRect();
                  const messageRect = messageWidget.getElement().getBoundingClientRect();

                  // Push message above bottom toolbar if any
                  const tbPosition = this._application && this._application.getCurrentWindow() &&
                    this._application.getCurrentWindow().getWidget() &&
                    this._application.getCurrentWindow().getWidget().getToolBarPosition();
                  if (tbPosition === "bottom") {
                    drift.bottom = drift.bottom + 40; //TODO: 40 is hardcoded: not good
                  }

                  // Use body and ui RECT for position calculations
                  drift.bottom = drift.bottom + bodyRect.height - userInterfaceRect.height - userInterfaceRect.top;
                  drift.top = drift.top + userInterfaceRect.top;
                  drift.left = drift.left + bodyRect.left + userInterfaceRect.left;
                  drift.center = drift.left + (userInterfaceRect.width / 2) - (messageRect.width / 2);

                  const overlap = prevWidget && this._checkOverlap(messageWidget, prevWidget);
                  const anyHidden = messageWidget.isHidden() || (prevWidget && prevWidget.isHidden());

                  // Handle stack if more than 1 message and none of the widgets is hidden
                  if ((i >= 1 && (stack || overlap)) && !anyHidden) {
                    drift.bottom += messageRect.height + (margin / 2);
                    drift.top += messageRect.height + (margin / 2);
                  }

                  if (positionName.indexOf("top") >= 0) {
                    style.top = (margin + drift.top).toFixed() + "px";
                    style.bottom = null;
                  }
                  if (positionName.indexOf("bottom") >= 0) {
                    style.top = null;
                    style.bottom = (margin + drift.bottom).toFixed() + "px";
                  }
                  if (positionName.indexOf("right") >= 0) {
                    style.left = null;
                    style["margin-left"] = margin.toFixed() + "px";
                    style.right = margin.toFixed() + "px";
                  }
                  if (positionName.indexOf("left") >= 0) {
                    style.left = (margin + drift.left).toFixed() + "px";
                    style.right = null;
                    style["margin-right"] = margin.toFixed() + "px";
                  }
                  if (positionName.indexOf("center") >= 0) {
                    style.left = (margin + drift.center).toFixed() + "px";
                    style.right = null;
                    style["margin-right"] = margin.toFixed() + "px";
                  }

                  if (!messageWidget.isHidden()) {
                    style.opacity = 1;
                    style["z-index"] = context.ThemeService.getValue("gbc-MessageWidget-z-index");
                  } else {
                    style.opacity = 0;
                    style["z-index"] = -1;
                  }
                  messageWidget.setStyle(style);
                }
              }
            }
          }
        },

        /**
         * Check if 2 widgets overlap in the view
         * @param w1 - first widget to compare
         * @param w2 - second widget to compare
         * @return {boolean} - true if it overlaps, false otherwise
         * @private
         */
        _checkOverlap: function(w1, w2) {
          if (w1.isHidden() || w2.isHidden()) {
            return false;
          }
          const rect1 = w1.getElement().getBoundingClientRect();
          const rect2 = w2.getElement().getBoundingClientRect();
          return !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);
        },

        /**
         * Special message to display when X-FourJs-Message header is set
         * @param {String} message - Message to send
         * @param {Boolean?} messageAllWin - deep look for all windows to notify
         */
        gasAdminMessage: function(message, messageAllWin) {
          const userInterfaceNode = this._application.getNode(0);
          if (!userInterfaceNode) {
            return;
          }

          const userInterfaceWidget = userInterfaceNode.getController().getWidget(),
            msgWidget = userInterfaceWidget.getMessageWidget();
          msgWidget.setText(message);
          msgWidget.setMessageKind("admin");
          msgWidget.setMessageDisplayTime(0); // always displayed until clicked
          msgWidget.setHtmlFormat(false);
          msgWidget.setHidden(false);
          msgWidget.setPosition(gbc.ThemeService.getValue("gbc-MessageWidget-gasadmin-display-position"));

          // Redefine click action
          msgWidget.manageMouseClick = () => {
            msgWidget.setHidden(true);
            this.removeMessage("gasadmin", true);
          };
          this.addMessage("gasadmin", msgWidget);
          this.handlePositions();

          // if multi pages, display on all related pages
          const session = userInterfaceNode.getApplication().getSession();
          if (session.hasServerFeature("browser-multi-page") && messageAllWin) {

            // for each window of the session, send the message
            session._childWindows.forEach((win) => {
              win.gbc.SessionService.getCurrent().getApplications().forEach((app) => {
                if (app !== this._application) { // no notif on same app
                  app.message.gasAdminMessage(message);
                }
              });
            });

            // In case this window has been opened by another app in the session
            if (window._opener) {
              window._opener.gbc.SessionService.getCurrent().getApplications().forEach((app) => {
                if (app !== this._application) { // no notif on same app
                  app.message.gasAdminMessage(message);
                }
              });
            }
          }
        },

        /**
         * @inheritDoc
         */
        destroy: function() {
          this._messageList = null;
          $super.destroy.call(this);
        }
      };
    });
    cls.ApplicationServiceFactory.register("Message", cls.MessageApplicationService);
  });
;

"use strict";

modulum('BrowserBackSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class BrowserBackSpecialAction
     * @memberOf classes
     */
    cls.BrowserBackSpecialAction = context.oo.Class(function() {
      return /** @lends classes.BrowserBackSpecialAction.prototype */ {
        __name: "BrowserBackSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = this._onBrowserBack.bind(this);
          if (history.pushState) {
            history.replaceState("back", "");
            history.pushState("", "");
            history.pushState("forward", "");
            history.back();
          }
          window.addEventListener("popstate", this._listener);
        },

        destroy: function() {
          window.removeEventListener("popstate", this._listener);
          this._actionService = null;
        },
        _onBrowserBack: function(event) {
          if (this._actionService && this._actionService.hasAction("browser_back")) {
            if (event.state && event.state === "back") { //back or forward
              this._actionService.executeByName("browser_back");
              history.forward();
            }
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("browser_back", cls.BrowserBackSpecialAction);
  });
;

"use strict";

modulum('BrowserForwardSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class BrowserForwardSpecialAction
     * @memberOf classes
     */
    cls.BrowserForwardSpecialAction = context.oo.Class(function() {
      return /** @lends classes.BrowserForwardSpecialAction.prototype */ {
        __name: "BrowserForwardSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = this._onBrowserForward.bind(this);
          if (history.pushState) {
            history.replaceState("back", "");
            history.pushState("", "");
            history.pushState("forward", "");
            history.back();
          }
          window.addEventListener("popstate", this._listener);
        },

        destroy: function() {
          window.removeEventListener("popstate", this._listener);
          this._actionService = null;
        },
        _onBrowserForward: function(event) {
          if (this._actionService && this._actionService.hasAction("browser_forward")) {
            if (event.state && event.state === "forward") { //back or forward
              this._actionService.executeByName("browser_forward");
              history.back();
            }
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("browser_forward", cls.BrowserForwardSpecialAction);
  });
;

"use strict";

modulum('WindowResizedSpecialAction', ['ActionApplicationService'],
  function(context, cls) {
    /**
     * @class WindowResizedSpecialAction
     * @memberOf classes
     */
    cls.WindowResizedSpecialAction = context.oo.Class(function() {
      return /** @lends classes.WindowResizedSpecialAction.prototype */ {
        __name: "WindowResizedSpecialAction",
        /** @type {classes.ActionApplicationService} */
        _actionService: null,
        _listener: null,
        constructor: function(actionService) {
          this._actionService = actionService;
          this._listener = context.HostService.onScreenResize(this._onResized.debounce().bind(this));
        },

        destroy: function() {
          if (this._listener) {
            this._listener();
            this._listener = null;
          }
          this._actionService = null;
        },
        _onResized: function() {
          if (this._actionService?.hasAction("windowresized")) {
            this._actionService.executeByName("windowresized", undefined, {
              sendValue: true
            });
          }
        }
      };
    });
    cls.ActionApplicationService.registerSpecialAction("windowresized", cls.WindowResizedSpecialAction);
  });
;

"use strict";

modulum('TreeModificationTracker', [],
  function(context, cls) {
    /**
     * Records AUI tree modifications
     * @class TreeModificationTracker
     * @memberOf classes
     */
    cls.TreeModificationTracker = context.oo.Class(function($super) {
      return /** @lends classes.TreeModificationTracker.prototype */ {
        __name: "TreeModificationTracker",

        $static: /** @lends classes.TreeModificationTracker */ {
          stylesTag: ["StyleList", "Style", "StyleAttribute"]
        },

        /** @type {Map<number,*>}*/
        _modifications: null,
        _involvesStyle: false,

        constructor: function() {
          this._modifications = new Map();
        },

        /**
         * Returns the tree modifications for the given node. Creates a new entry if not found
         * @param {number} nodeId node idRef
         * @return {*} the modifications for the given node
         * @private
         */
        _fetch: function(nodeId) {
          let mods = this._modifications.get(nodeId);
          if (!mods) {
            mods = {
              createdSubTreeRoot: false,
              created: false,
              removed: false,
              updatedAttributes: {}
            };
            this._modifications.set(nodeId, mods);
          }
          return mods;
        },

        /**
         * @param {number} nodeId
         * @return {*} the node's modifications or undefined
         */
        get: function(nodeId) {
          return this._modifications.get(nodeId);
        },

        /**
         * @param {number} nodeId
         * @return {boolean} true if the node's modifications exists
         */
        has: function(nodeId) {
          return this._modifications.has(nodeId);
        },

        /**
         * @param {number[]} nodeIds
         * @param {Set<string>} watchedAttributes
         * @param watchesStyleNodeBinding
         * @return {boolean} true if the node's modifications exists
         */
        hasOne: function(nodeIds, watchedAttributes, watchesStyleNodeBinding) {
          if (watchesStyleNodeBinding && this._involvesStyle) {
            return true;
          }
          let find = nodeIds.find(id => {
            let modification = this._modifications.get(id);
            if (modification) {
              if (modification.created || modification.createdSubTreeRoot || modification.removed ||
                Object.keys(modification.updatedAttributes).find(attr => watchedAttributes.has(attr))) {
                return true;
              }
            }
            return false;
          });
          return find >= 0;
        },

        /**
         * Records a node creation
         * @param {number} nodeId node idRef
         * @param {string} tag
         * @param subTreeRoot true if this is a VM order subtree root node
         */
        nodeCreated: function(nodeId, tag, subTreeRoot) {
          const mods = this._fetch(nodeId);
          mods.created = true;
          mods.tag = tag;
          mods.isStyleTag = cls.TreeModificationTracker.stylesTag.indexOf(tag) >= 0;
          this._involvesStyle = this._involvesStyle || mods.isStyleTag;
          mods.createdSubTreeRoot = Boolean(subTreeRoot);
        },

        /**
         * @param {number} nodeId node idRef
         * @return {boolean} true if the node has been created
         */
        isNodeCreated: function(nodeId) {
          const mods = this._modifications.get(nodeId);
          return mods ? mods.created : false;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {*} true if the node is a VM subtree root node
         */
        isNodeCreatedAndSubTreeRoot: function(nodeId) {
          const mods = this._modifications.get(nodeId);
          return mods ? mods.createdSubTreeRoot : false;
        },

        /**
         * Records a removed node
         * @param {number} nodeId node idRef
         * @param {string} tag
         */
        nodeRemoved: function(nodeId, tag) {
          let mods = this._fetch(nodeId);
          mods.removed = true;
          mods.tag = tag;
          mods.isStyleTag = cls.TreeModificationTracker.stylesTag.indexOf(tag) >= 0;
          this._involvesStyle = this._involvesStyle || mods.isStyleTag;
        },

        /**
         * Clean the tree modification tracker for a given aui node
         * @param {classes.NodeBase} node AUI node
         */
        clean: function(node) {
          const children = node.getChildren();
          for (const child of children) {
            this.clean(child);
          }
          //Remove definitely a node from tree modification tracker
          this._modifications.delete(node.getId());
        },

        /**
         * @param {number} nodeId node idRef
         * @return {boolean} true if the node has been removed
         */
        isNodeRemoved: function(nodeId) {
          const mods = this._modifications.get(nodeId);
          return mods ? mods.removed : false;
        },

        /**
         * Records an attribute modification
         * @param {number} nodeId node idRef
         * @param {string} attributeName name of the attribute
         */
        attributeChanged: function(nodeId, attributeName) {
          this._fetch(nodeId).updatedAttributes[attributeName] = true;
        },

        /**
         * @param {number} nodeId node idRef
         * @return {{string:boolean}} the updated attributes
         */
        getChangedAttributes: function(nodeId) {
          const mods = this._modifications.get(nodeId);
          return mods ? mods.updatedAttributes : {};
        },

        /**
         * @param {number} nodeId node idRef
         * @param attributeName attribute name
         * @return {boolean} true if the attribute value has changed
         */
        isNodeAttributeChanged: function(nodeId, attributeName) {
          const mods = this._modifications.get(nodeId);
          return mods ? mods.updatedAttributes[attributeName] : false;
        },

        /**
         * Iterate over all modifications
         * @param {Function} handler callback with value, keys arguments
         */
        forEach: function(handler) {
          this._modifications.forEach(handler);
        }
      };
    });
  }
);
;

"use strict";
modulum('UIApplicationService', ['ApplicationServiceBase', 'ApplicationServiceFactory'],
  function(context, cls) {
    /**
     * @class UIApplicationService
     * @memberOf classes
     * @extends classes.ApplicationServiceBase
     */
    cls.UIApplicationService = context.oo.Class(cls.ApplicationServiceBase, function($super) {
      return /** @lends classes.UIApplicationService.prototype */ {
        __name: "UIApplicationService",
        /**
         * @type {classes.ApplicationWidget}
         */
        _applicationWidget: null,
        /** @type {?number} */
        _currentWindowIdRef: null,
        constructor: function(app) {
          $super.constructor.call(this, app);
          this._applicationWidget = cls.WidgetFactory.createWidget("Application", {
            appHash: this._application.applicationHash
          });
          this._applicationWidget.setApplicationHash(app.applicationHash);
          this._applicationWidget.onActivate(this._onActivate.bind(this));
          this._application.getSession().addApplicationWidget(app, this._applicationWidget);
          this._applicationWidget.onLayoutRequest(this._onLayoutRequest.bind(this));
        },
        _onActivate: function() {
          this._application.getSession().setCurrentApplication(this._application);
        },
        _onLayoutRequest: function() {
          this._application.scheduler.layoutCommand();
        },
        destroy: function() {
          if (!this._destroyed) {
            this._applicationWidget.destroy();
            this._applicationWidget = null;
            $super.destroy.call(this);
          }
        },
        /**
         *
         * @returns {classes.ApplicationWidget}
         */
        getWidget: function() {
          return this._applicationWidget;
        },
        setRunning: function(running) {
          if (running) {
            this.getWidget().hideWaiter();
          }
        },
        isLayoutable: function() {
          return this.getWidget() && this.getWidget().getElement() && !this.getWidget().getElement().hasClass("gbc_out_of_view");
        },
        setCurrentWindow: function(currentWindowId) {
          if (this._currentWindowIdRef !== currentWindowId) {
            this._currentWindowIdRef = currentWindowId;
            this.syncCurrentWindow();
          }
        },

        syncCurrentWindow: function() {
          let currentWin = null;
          const session = this._application && this._application.getSession(),
            model = this._application && this._application.model,
            UINode = model && model.getNode(0),
            UIController = UINode && UINode.getController(),
            UIWidget = UIController && UIController.getWidget(),
            children = UIWidget && UIWidget.getChildren();

          currentWin = children && this._currentWindowIdRef && (
            children.find(win => win._auiTag === this._currentWindowIdRef) ||
            // If no window has been found, return the traditional window container
            children.find(win => win.hasClass("gbc_TraditionalContainerWindow")) ||
            null);

          if (currentWin) {
            const currentWinNode = model && model.getNode(currentWin._auiTag);
            // before displaying window we display its corresponding application
            session.getWidget().setCurrentWidget(currentWin.getApplicationWidget());
            context.HostService.setDisplayedWindowNode(currentWinNode);

            gbc.HostService.updateDisplay(); // re-align everything in window

            this.emit(context.constants.applicationEvents.startMenuPositionUpdate, currentWin._auiTag);
          }
        }
      };
    });
    cls.ApplicationServiceFactory.register("UI", cls.UIApplicationService);
  });
;

"use strict";
modulum('VMApplication', ['EventListener'],
  function(context, cls) {
    /**
     * Object that represents an application of a VM Session
     * @class VMApplication
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMApplication = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMApplication.prototype */ {
        $static: /** @lends classes.VMApplication */ {
          styleListLoaded: "gStyleListLoaded"
        },
        __name: "VMApplication",
        /** General information for this application
         * @type classes.VMApplicationInfo
         */
        applicationInfo: null,
        procId: null,
        /** Indicator to know if the application is running or not */
        running: false,
        /** Indicator to know if the application is ending */
        ending: false,
        ended: false,
        /** Indicator to know if the application has protocol error */
        hasError: false,
        /** protocolInterface
         * @type classes.ProtocolInterface
         */
        protocolInterface: null,
        /** dvm management
         * @type classes.DVMApplicationService
         */
        dvm: null,
        /** model (aui) management
         * @type classes.AuiApplicationService
         */
        model: null,
        /** layout management
         * @type classes.LayoutApplicationService
         */
        layout: null,
        /** actions
         * @type classes.ActionApplicationService
         */
        action: null,
        /** file transfer management
         * @type classes.FileTransferApplicationService
         */
        filetransfer: null,
        /** Scheduler
         * @type classes.SchedulerApplicationService
         */
        scheduler: null,
        /** keyboard management
         * @type classes.KeyboardApplicationService
         */
        keyboard: null,

        /** input management
         * @type classes.InputApplicationService
         */
        input: null,

        /** Focus management
         * @type classes.FocusApplicationService
         */
        focus: null,
        /** application ui
         * @type classes.UIApplicationService
         * */
        _ui: null,
        /**
         * @type {classes.VMSession}
         */
        _session: null,

        /** @type {Array} */
        styleAttributesChanged: null,

        /** @type {boolean} */
        styleListsChanged: false,

        /** @type {Object} */
        usedStyleAttributes: {},

        /** @function */
        _afterLayoutHandler: null,

        _currentlyProcessing: false,
        _processingDelayer: 0,

        _title: null,
        _icon: null,

        _currentWindow: null,
        /**
         *
         * @param {classes.VMApplicationInfo} info - application info
         * @param {classes.VMSession} session

         */
        constructor: function(info, session) {
          $super.constructor.call(this);
          this._session = session;
          this.applicationInfo = info;
          this.applicationHash = session.getApplicationIdentifier();
          if (!info.inNewWindow) {
            this._ui = cls.ApplicationServiceFactory.create('UI', this);
            this.dvm = cls.ApplicationServiceFactory.create('Dvm', this);
            this.model = cls.ApplicationServiceFactory.create('Model', this);
            this.layout = cls.ApplicationServiceFactory.create('Layout', this);
            this.action = cls.ApplicationServiceFactory.create('Action', this);
            this.filetransfer = cls.ApplicationServiceFactory.create('FileTransfer', this);
            this.scheduler = cls.ApplicationServiceFactory.create('Scheduler', this);
            this.keyboard = cls.ApplicationServiceFactory.create('Keyboard', this);
            this.input = cls.ApplicationServiceFactory.create('Input', this);
            this.focus = cls.ApplicationServiceFactory.create('Focus', this);
            this.message = cls.ApplicationServiceFactory.create('Message', this);
            session.getNavigationManager().addApplication(this);

            // emit gbcReady signal when gbc seems to be ready for user interaction
            this._afterLayoutHandler = this.layout.afterLayout(function() {
              if (this.scheduler.hasNoCommandToProcess()) {
                this._registerTimeout(function() {
                  this.emit(context.constants.widgetEvents.gbcReady);
                }.bind(this), 50);
              }
            }.bind(this), false);
            if (gbc.qaMode) {
              gbc.QAService.bindToScheduler(this.scheduler);
            }
          }
          this.protocolInterface = cls.ApplicationServiceFactory.create(this._getProtocolInterface(info), this);

          this.styleAttributesChanged = [];
          context.WidgetService.registerVMApplication(this);

          //We must notify native app that the app is ready to obtain the focus on the webview
          this.gbcReady(function() {
            context.__wrapper.nativeCall(context.__wrapper.param({
              name: "gbcReady",
              args: {
                "windowState": gbc.HostService.getWindowState()
              }
            }, this));
          }, true);
        },
        /**
         * Get the owning session
         * @returns {classes.VMSession} The owning session
         * @publicdoc
         */
        getSession: function() {
          return this._session;
        },

        waitForApplicationInNewWindow: function(onSuccess, onFailure) {
          this.protocolInterface.waitForApplicationInNewWindow(onSuccess, onFailure);
        },
        prepareEmergencyClose: function() {
          this._emergencyClose = cls.UANetwork._prepared.close(this);
          window.requestAnimationFrame(function() {
            try {
              if (window.opener && window.opener._emergencyClose) {
                window.opener._emergencyClose[context.uid].push(this._emergencyClose);
              }
            } catch (e) {
              if (e.name === "SecurityError") {
                context.LogService.networkProtocol.log("GBC opened from a cross domain origin", e);
              }
            }
          }.bind(this));
        },
        _getProtocolInterface: function(info) {
          let result = "NoProtocolInterface";
          switch (info.mode) {
            case "direct":
              result = "DirectProtocolInterface";
              break;
            case "ua":
              result = "UAProtocolInterface";
              break;
            default:
              break;
          }
          return result;
        },
        /**
         * @inheritDoc
         */
        destroy: function() {
          if (!this._destroyed) { // TODO whe should not call destroy on a destroyed object

            if (this._afterLayoutHandler) {
              this._afterLayoutHandler();
              this._afterLayoutHandler = null;
            }

            this._ui.destroy();
            this.filetransfer.destroy();
            this._session.remove(this);
            this.model.destroy();

            this.applicationInfo = null;

            this._session = null;
            this._ui = null;
            this.dvm = null;
            this.model = null;
            this.layout = null;
            this.action = null;
            this.filetransfer = null;
            this.scheduler = null;
            this.keyboard = null;
            this.input = null;
            this.focus = null;
            this.message = null;
            this.protocolInterface = null;

            this._currentWindow = null;

            $super.destroy.call(this);

            context.WidgetService.unregisterVMApplication(this);
          }
        },

        start: function() {
          this.protocolInterface.start(this.applicationInfo);
        },
        stop: function(message) {
          if (!this.stopping) {
            this.stopping = true;
            if (!this.ended && this.applicationInfo) {
              if (message) {
                this.applicationInfo.ending = cls.ApplicationEnding.notok(message);
              }
              if (!this.applicationInfo.ending) {
                this.applicationInfo.ending = cls.ApplicationEnding.ok;
              }
              if (this.applicationInfo.urlParameters && this.applicationInfo.urlParameters.logPlayer) {
                this.applicationInfo.ending = cls.ApplicationEnding.logPlayer;
              }

              context.styler.bufferize();
              // TODO reorder, why we don't call this in destroy ??
              this.scheduler.destroy();
              this.model.remove();
              this.setEnding();
              this.action.destroy();
              this.layout.destroy();
              this.model.stop();
              this.dvm.destroy();
              this.protocolInterface.destroy();
              this.keyboard.destroy();
              this.input.destroy();
              this.focus.destroy();
              this.filetransfer.destroy();
              this.message.destroy();

              this.destroy();
              context.styler.flush();
              this.ended = true;
            }
          }
        },
        /**
         * Set status of application
         * @param {boolean} running Status
         */
        setRunning: function(running) {
          this.running = running;
          this._ui.setRunning(running);
        },

        /**
         * Set the error status at application's protocol error
         */
        setError: function() {
          this.hasError = true;
        },

        /**
         * Set the ending status at application's end
         */
        setEnding: function() {
          if (!this.ending && !this.ended && !this._destroyed) {
            this.ending = true;
            this.setIdle();
          }
        },

        /**
         * Returns this application's info.
         * @returns {classes.VMApplicationInfo}
         */
        info: function() {
          return this.applicationInfo;
        },
        /**
         * Get application instantiated node by its Aui ID
         * @param {number} id the node id
         * @returns {classes.NodeBase} the node, if found
         * @publicdoc
         */
        getNode: function(id) {
          return this.model && this.model.getNode(id);
        },
        uiNode: function() {
          return this.getNode(0);
        },

        /**
         * Check if a widget has the VM focus
         * @param {classes.WidgetBase} widget
         * @returns {boolean} true if widget has the VM focus
         */
        hasVMFocus(widget) {
          const widgetNode = this.getNode(widget.getAuiTag());
          return widgetNode?.hasVMFocus() === true;
        },

        /**
         * Get the VM Focused Node instance
         * @returns {classes.NodeBase} The VM focused node
         * @publicdoc
         */
        getFocusedVMNode: function() {
          const uiNode = this.uiNode();
          if (uiNode) {
            const id = uiNode.attribute("focus");
            return this.getNode(id);
          }
          return null;
        },

        /**
         * Get the VM Focused Node instance
         * or if the focused node is a table or a matrix get the current value node
         * @param {boolean} [inputModeOnly] - return value node only if is node is in INPUT mode
         * @returns {*|classes.NodeBase}
         */
        getFocusedVMNodeAndValue: function(inputModeOnly) {
          let focusedNode = this.getFocusedVMNode();
          if (focusedNode && focusedNode.getCurrentValueNode) {
            const currentValueNode = focusedNode.getCurrentValueNode(inputModeOnly);
            if (currentValueNode) {
              focusedNode = currentValueNode;
            }
          }
          return focusedNode;
        },

        newTask: function() {
          let session = context.BrowserWindowsService.getRootSession();
          if (session) {
            session.newTask();
          } else {
            this.protocolInterface.newTask();
          }
        },
        /**
         * Set the idle status to true
         */
        setIdle: function() {
          this._setProcessingStyle(false);
          this.dvm.setIdle(true);
          this.action.setInterruptablesActive(false);
        },

        /**
         * Bypass Idle Time excecution in case of GMA UR background service
         * @param {Boolean} bypass - true to bypass, false to get back to normal
         */
        bypassIdleTimer: function(bypass) {
          if (context.__wrapper.isGMA()) {
            this._bypassTimer = bypass;
          }
        },

        /**
         * Check if Idle Timer execution is bypassed
         * @return {Boolean} true if byPassed, false otherwise
         */
        isBypassedIdleTimer: function() {
          return this._bypassTimer;
        },

        /**
         * Set the processing status to true
         */
        setProcessing: function() {
          this._setProcessingStyle(true);
          this.dvm.setIdle(false);
          this.action.setInterruptablesActive(true);
        },

        _setProcessingStyleImpl: function(processing) {
          this._processingDelayer = 0;
          if (this._ui && this._ui.getWidget()) {
            this._session.getNavigationManager().setApplicationProcessing(this, processing);
            const windows = this.model.getNodesByTag("Window"),
              len = windows.length;
            let i = 0;
            for (; i < len; i++) {
              if (windows[i] && windows[i]._setProcessingStyle) {
                windows[i]._setProcessingStyle(processing);
              }
            }
          }
        },

        _setProcessingStyle: function(processing) {
          if (!processing) {
            if (this._processingDelayer !== 0) {
              this._clearAnimationFrame(this._processingDelayer);
              this._processingDelayer = 0;
            }
            this._setProcessingStyleImpl(false);
          } else {
            if (this._processingDelayer === 0) {
              this._processingDelayer = this._registerAnimationFrame(this._setProcessingStyleImpl.bind(this, true));
            }
          }
        },
        /**
         * Check if the application is idle
         * @returns {boolean} true if idle, false otherwise
         */
        isIdle: function() {
          return this.dvm.idle;
        },

        /**
         * Check if the application is running
         * @returns {boolean} true if running, false otherwise
         */
        isProcessing: function() {
          return !this.dvm?.idle;
        },
        /**
         * Send an Interrupt order
         */
        interrupt: function() {
          this.protocolInterface.interrupt();
        },
        close: function() {
          if (!this.ended && !this._destroyed) {
            if (this.ending) {
              this.destroy();
            } else {
              this.protocolInterface.close();
            }
          }
        },
        error: function() {
          this.setEnding();
        },
        /**
         * fail application gracefully,
         * @param ending ending message
         */
        fail: function(ending) {
          if (ending && this.applicationInfo) {
            this.applicationInfo.ending = cls.ApplicationEnding.notok(ending);
          }
          this._registerTimeout(function() {
            this.protocolInterface.stop(ending); // send destroy event to the VM
          }.bind(this));
        },
        /**
         * get active window
         * @returns {classes.WindowNode}
         */
        getVMWindow: function() {
          if (this.ending) {
            return null;
          }
          const uiNode = this.uiNode();
          const uiCurrentWindow = uiNode &&
            uiNode.isAttributeSetByVM("currentWindow") &&
            uiNode.attribute("currentWindow");
          if (uiCurrentWindow) { // we don't consider the value 0 as it is not a Window node
            return this.model.getNode(uiCurrentWindow);
          } else {
            return null;
          }
        },

        getActionApplicationService: function() {
          return this.action;
        },

        /**
         *
         * @param {classes.WidgetBase} widget
         */
        attachRootWidget: function(widget) {
          this._ui.getWidget().addChildWidget(widget);
        },
        /**
         *
         * @returns {classes.UIApplicationService}
         */
        getUI: function() {
          return this._ui;
        },

        /**
         * Get items from the chromebar or from the applicationHostWidget if legacy mode enabled
         * @param {String} name
         * @return {*}
         */
        getMenu: function(name) {
          const menu = this.getUI().getWidget().getUserInterfaceWidget().getChromeBarWidget();
          return menu.getGbcMenuItem(name);
        },

        /**
         * Get the Chromebar
         * @return {classes.ChromeBarWidget|null} the chromebar
         */
        getChromeBar: function() {
          const uiNode = this.model && this.model.getNode(0),
            uiWidget = uiNode && uiNode.getWidget();
          return uiWidget && uiWidget.getChromeBarWidget();
        },

        hasActiveKeyEventNode: function() {
          const uiNode = this.uiNode();
          if (uiNode) {
            const focusId = uiNode.attribute('focus');
            const focusedNode = this.getNode(focusId);
            if (['Table', 'Matrix', 'Menu', 'MenuAction', 'Dialog', 'Action'].indexOf(focusedNode.getTag()) !== -1) {
              const isActive = focusedNode.attribute('active') === 1;
              return isActive && (!focusedNode.isAttributePresent("dialogType") || focusedNode.attribute("dialogType").startsWith(
                "Display")); // if node is table and is in display or displayarray mode (only send keys to VM if not in edit mode)
            }
          }
          return false;
        },

        setTabbedContainerMode: function(activation, windowNode) {
          if (this._session && activation) {
            this._session.activateTabbedContainerMode(windowNode);
          }
        },

        /** Return the action node of active dialog according to vmKey param
         *
         * @param vmKey
         * @returns {*} vm event
         */
        getActiveDialogAction: function(vmKey) {

          let actionNode = null;
          const window = this.getVMWindow();
          let acceleratorName = null;
          let acceleratorName2 = null;
          let acceleratorName3 = null;
          let acceleratorName4 = null;

          if (window) { // search the action in the current dialog
            const dialog = window.getActiveDialog();
            if (dialog) {
              const actions = dialog.getChildren();
              for (const action of actions) {
                const isActive = (action.attribute("active") !== 0);
                if (isActive) {
                  acceleratorName = action.attribute("acceleratorName");
                  acceleratorName2 = action.attribute("acceleratorName2");
                  acceleratorName3 = action.attribute("acceleratorName3");
                  acceleratorName4 = action.attribute("acceleratorName4");
                  if (acceleratorName && acceleratorName.toString().toLowerCase() === vmKey ||
                    acceleratorName2 && acceleratorName2.toString().toLowerCase() === vmKey ||
                    acceleratorName3 && acceleratorName3.toString().toLowerCase() === vmKey ||
                    acceleratorName4 && acceleratorName4.toString().toLowerCase() === vmKey) {
                    actionNode = action;
                  }
                }
              }
            }
          }
          return actionNode;
        },

        /** Return the action node of default action list according to vmKey param
         * @param vmKey
         * @param formNode - optional form node to focus research on. If not specified we look for action defaults in user interface
         * @returns {*} vm event
         */
        getDefaultAction: function(vmKey, formNode) {
          let acceleratorName = null;
          let acceleratorName2 = null;
          let acceleratorName3 = null;
          let acceleratorName4 = null;

          // search the action in the action default list
          const containerNode = formNode || this.uiNode();
          if (containerNode) {
            const actionDefaultList = containerNode.getFirstChild("ActionDefaultList");
            if (actionDefaultList) {
              const actionDefaults = actionDefaultList.getChildren();
              for (const actionDefault of actionDefaults) {
                acceleratorName = actionDefault.attribute("acceleratorName");
                acceleratorName2 = actionDefault.attribute("acceleratorName2");
                acceleratorName3 = actionDefault.attribute("acceleratorName3");
                acceleratorName4 = actionDefault.attribute("acceleratorName4");
                if (acceleratorName && acceleratorName.toString().toLowerCase() === vmKey ||
                  acceleratorName2 && acceleratorName2.toString().toLowerCase() === vmKey ||
                  acceleratorName3 && acceleratorName3.toString().toLowerCase() === vmKey ||
                  acceleratorName4 && acceleratorName4.toString().toLowerCase() === vmKey) {
                  return actionDefault;
                }
              }
            }
          }
          return null;
        },

        /**
         * Return default action with provided name and optionally declared in form node
         * @param name
         * @param formNode - optional form node to focus research on. If not specified we look for action defaults in user interface
         * @returns {*} vm event
         */
        getDefaultActionForName: function(name, formNode) {
          const containerNode = formNode || this.uiNode();
          const actionDefaultList = containerNode.getFirstChild("ActionDefaultList");
          if (actionDefaultList) {
            const actionDefaults = actionDefaultList.getChildren();
            for (const actionDefault of actionDefaults) {
              if (name === actionDefault.attribute("name")) {
                return actionDefault;
              }
            }
          }
          return null;
        },

        getTitle: function() {
          return this._title;
        },

        setTitle: function(title) {
          this._title = title;
          this.emit(context.constants.widgetEvents.titleChanged, title);
        },

        getImage: function() {
          return this._image;
        },

        setImage: function(image) {
          this._image = image;
          this.emit(context.constants.widgetEvents.iconChanged, image);
        },

        /**
         * transforms a resource path
         * GBC internal
         * DO NOT IMPLEMENT
         * @param {string} path raw path
         * @param {string} [nativePrefix] native prefix if any
         * @param {string} [browserPrefix] browser prefix if any
         * @return {string} the transformed resource path
         */
        wrapResourcePath: function(path, nativePrefix, browserPrefix) {
          path = "" + path; // force path to string if not
          // if the path has a scheme, don't change it
          if (!path || /^(http[s]?|[s]?ftp|data|file|font)/i.test(path)) {
            return path;
          }
          const startPath = context.__wrapper.isNative() ?
            this.info().nativeResourcePrefix + (nativePrefix ? nativePrefix + "/" : "") :
            (browserPrefix ? browserPrefix + "/" : "");

          // In case there is a queryString, we should not encode it, keep it aside before adding it to returnPath
          const queryIndex = path && path.indexOf("?");
          let queryStr = "";
          if (queryIndex > 0) {
            queryStr = path.substring(queryIndex);
            path = path.replace(queryStr, "");
          }

          // Prevent Windows path like C:\foo\too.ttf
          if (context.__wrapper.isNative()) {
            // clean path
            path = encodeURIComponent(path).replace("%2F", "/");
          }

          return startPath + path + queryStr;
        },

        getCurrentWindow: function() {
          return this._currentWindow;
        },

        setCurrentWindow: function(windowNode) {
          this._currentWindow = windowNode;
        },

        /**
         * get the application procId
         * @return {String}
         */
        getProcId: function() {
          return this.applicationInfo.connectionInfo.procId;
        },

        /**
         * get the parent application procId
         * @return {String}
         */
        getParentProcId: function() {
          return this.applicationInfo.connectionInfo.procIdParent;
        },

        /**
         * Return true if we can accept events on this application
         * @return {boolean}
         */
        canProcessEvent: function() {
          const curSession = context.SessionService.getCurrent();
          const navigationManager = curSession && curSession.getNavigationManager();

          return !(this.isProcessing() && navigationManager.getChildApplication(this));
        },

        /**
         * attach to gbcReady event
         * @param {Function} hook the hook
         * @param {boolean} [once] true to free handle after first call
         * @return {HandleRegistration} the event handle
         */
        gbcReady: function(hook, once) {
          return this.when(context.constants.widgetEvents.gbcReady, hook, once);
        }
      };
    });
  });
;

"use strict";
modulum('VMApplicationInfo',
  function(context, cls) {
    /**
     * Stores application general information like VM dialog configuration and parameters.
     * @class VMApplicationInfo
     * @memberOf classes
     */
    cls.VMApplicationInfo = context.oo.Class(function() {
      return /** @lends classes.VMApplicationInfo.prototype */ {
        __name: "VMApplicationInfo",
        /**
         * Application VM dialog mode : 'ua' or 'direct'
         * @type {?string}
         */
        mode: null,
        /**
         * Application identifier
         * @type {?string}
         */
        appId: null,
        /**
         * First front-end identifier (VM dialog)
         * @type {?string}
         */
        frontEndId1: null,
        /**
         * Second front-end identifier (VM dialog)
         * @type {?string}
         */
        frontEndId2: null,
        /**
         * Default time to ping VM (ms)
         * @type {number}
         */
        pingTimeout: 1000,
        /**
         * VM connection info
         * @type {Object}
         */
        connectionInfo: null,
        /**
         * Session identifier in UA dialog
         * @type {?string}
         */
        session: null,
        /**
         * Page number in UA dialog
         * @type {number}
         */
        page: 1,
        /**
         * Aui dialog om order increment
         * @type {number}
         */
        auiOrder: 0,
        /**
         * Default relative path to Web components
         * @type {?string}
         */
        webComponent: null,
        /**
         * User defined relative path to Web components
         * @type {?string}
         */
        webComponentUsrPath: null,
        /**
         * If style browserMultiPage is activated, helps to know where to open the new application
         * @type {boolean}
         */
        inNewWindow: false,
        /**
         *
         * @param {classes.VMApplicationInfo|Object} info - info definition
         */
        constructor: function(info) {
          this.mode = "ua";
          const keys = Object.keys(info);
          for (const element of keys) {
            this[element] = info[element];
          }
          this.ending = null;
        }
      };
    });
  });
;

"use strict";
modulum('VMActionEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMActionEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMActionEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMActionEvent.prototype */ {
        __name: "VMActionEvent",
        type: "actionEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * to know that the action is not from a user interaction (ON IDLE)
         * @type {boolean}
         */
        noUserActivity: false,

        /**
         * @param {string} idRef reference of the node holding the action
         */
        constructor: function(idRef) {
          this.attributes = {
            idRef: idRef
          };
        }
      };
    });
  });
;

"use strict";
modulum('VMConfigureEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMConfigureEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMConfigureEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMConfigureEvent.prototype */ {
        __name: "VMConfigureEvent",
        type: "configureEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @type {Function}
         */
        lazyResolve: null,
        /**
         * @param {string} idRef reference of the node to update
         * @param {object} attr dictionary of attributes to update
         * @param {function} lazyResolve
         */
        constructor: function(idRef, attr, lazyResolve) {
          this.attributes = {
            idRef: idRef
          };
          const keys = Object.keys(attr);
          for (const element of keys) {
            this.attributes[element] = attr[element];
          }
          this.lazyResolve = lazyResolve;
        }
      };
    });
  });
;

"use strict";
modulum('VMDestroyEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMDestroyEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMDestroyEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMDestroyEvent.prototype */ {
        __name: "VMDestroyEvent",
        type: "destroyEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * Will send an event: "{DestroyEvent 0{{status "INTEGER"}{message "STRING"}"}}
         * @param {number} status - status according to the spec:
         *  DecorationDeleted = -4,
         *  MDIContainerExists = -100
         *  MDIContainerDestroyed = -101
         *  MDIContainerNotExists = -102
         *  MDIContainerRenamed = -103
         *  InvalidAUITree = -3
         *  InvalidCompatMode = -5
         *  InvalidUniversalRendering = -7
         *  and win only:
         *  UserObjectCountToHigh = -1000
         * @param {string} message - message to pass to the VM
         */
        constructor: function(status, message) {
          this.attributes = {
            status: status,
            message: message
          };
        }
      };
    });
  });
;

"use strict";
modulum('VMDragDropEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMDragDropEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMDragDropEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMDragDropEvent.prototype */ {
        __name: "VMDragDropEvent",
        type: "dragDropEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * @param {string} idRef
         * @param {object} attr
         */
        constructor: function(idRef, attr) {
          this.attributes = {
            idRef: idRef
          };
          const keys = Object.keys(attr);
          for (const element of keys) {
            this.attributes[element] = attr[element];
          }

        }
      };
    });
  });
;

"use strict";
modulum('VMEventBase',
  function(context, cls) {
    /**
     * Base class of vm events
     * @class VMEventBase
     * @memberOf classes
     */
    cls.VMEventBase = context.oo.Class(function() {
      return /** @lends classes.VMEventBase.prototype */ {
        __name: "VMEventBase",
        directFire: false
      };
    });
  });
;

"use strict";
modulum('VMFunctionCallEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMFunctionCallEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMFunctionCallEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMFunctionCallEvent.prototype */ {
        $static: /** @lends classes.VMFunctionCallEvent */ {
          success: 0, // Success
          unknownFunction: -1, // The function is not defined in the specified package
          unknownModule: -2, // Unknown module or shared library could not be loaded
          stackError: -3, // Wrong number of parameters or return values. Stack problem.
          functionError: -4 // Function call failed - fatal error in front-end function
        },

        __name: "VMFunctionCallEvent",
        type: "functionCallEvent",
        status: null,
        message: null,
        values: null,

        /**
         * @param status
         * @param message
         * @param values
         */
        constructor: function(status, message, values) {
          this.status = status;
          this.message = message;
          this.values = values;
        }
      };
    });
  });
;

"use strict";
modulum('VMKeyEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMKeyEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMKeyEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMKeyEvent.prototype */ {
        __name: "VMKeyEvent",
        type: "keyEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @param keyName {string} keyName name of the pressed key
         * @param idRef {string?} optional idRef (used for canvas)
         */
        constructor: function(keyName, idRef) {
          this.attributes = {
            keyName: keyName
          };
          if (idRef !== undefined) {
            this.attributes.idRef = idRef;
          }
        }
      };
    });
  });
;

"use strict";
modulum('VMLogEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     * Insert a marker in GUI Log
     * @class VMLogEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMLogEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMLogEvent.prototype */ {
        __name: "VMLogEvent",
        type: "logEvent",
        /**
         * @type {Object}
         */
        attributes: null,

        /**
         * @param {String} data - text data to pass
         */
        constructor: function(data) {
          this.attributes = {
            data: data
          };
        }
      };
    });
  });
;

"use strict";
modulum('VMRowSelectionEvent', ['VMEventBase'],
  function(context, cls) {
    /**
     *
     * @class VMRowSelectionEvent
     * @memberOf classes
     * @extends classes.VMEventBase
     */
    cls.VMRowSelectionEvent = context.oo.Class({
      base: cls.VMEventBase
    }, function() {
      return /** @lends classes.VMRowSelectionEvent.prototype */ {
        __name: "VMRowSelectionEvent",
        type: "rowSelectionEvent",
        /**
         * @type {Object}
         */
        attributes: null,
        /**
         * @param {string} idRef reference of the table
         * @param {object} attr row update information
         */
        constructor: function(idRef, attr) {
          this.attributes = {
            idRef: idRef
          };
          const keys = Object.keys(attr);
          for (const element of keys) {
            this.attributes[element] = attr[element];
          }
        }
      };
    });
  });
;

"use strict";

modulum('ProtocolFactory', ['ApplicationServiceFactory'],

  function(context, cls) {
    cls.ApplicationServiceFactory.register("NoProtocolInterface", cls.NoInterface);
    cls.ApplicationServiceFactory.register("UAProtocolInterface", cls.UAInterface);
    cls.ApplicationServiceFactory.register("DirectProtocolInterface", cls.DirectInterface);
  });
;

"use strict";

modulum("VMSession", ["EventListener", "VMSessionTabbedContainerMode", "VMSessionBrowserMultiPageMode"],
  function(context, cls) {
    /**
     * A VM driven Session
     * @class VMSession
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMSession = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMSession.prototype */ {
        __name: "VMSession",
        /**
         * @type {?string}
         */
        _identifier: null,
        /**
         * @type {?string}
         */
        _sessionId: null,
        /**
         * @type {classes.VMApplication[]}
         */
        _applications: null,

        /**
         * app id bootstrapped by the GAS
         * if not 0, it is loaded as a new tab/window in browser
         * @type {number}
         */
        _htmlHostPageAppId: 0,

        _baseInfos: null,
        _closeHandler: null,
        _restartHandler: null,
        /**
         * @type {classes.SessionWidget}
         */
        _widget: null,
        _applicationIdentifier: 0,
        _applicationQueue: null,

        _waitingNewTasks: 0,
        _showEnding: false,
        _flushingApplications: false,
        _flushingApplicationsListener: false,
        _unloadListener: false,
        _flushableApplications: null,
        /** @type {?string} */
        _logPromptUrl: null,
        /** @type Window */
        _logPromptWindow: null,
        /** @type classes.SessionLogPromptWidget */
        _logPromptWidget: null,
        /** @type string[] */
        _serverFeatures: null,
        /** @type {?string} */
        _endUrl: null,

        _sessionMode: null,
        _childWindows: null,

        /** @type {classes.VMSessionNavigationManager} */
        _navigationManager: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {?string} identifier session identifier
         */
        constructor: function(identifier) {
          $super.constructor.call(this);
          this._navigationManager = new cls.VMSessionNavigationManager(this);
          this._htmlHostPageAppId = context.bootstrapInfo.subAppInfo;
          this._widget = cls.WidgetFactory.createWidget("Session", {
            appHash: gbc.systemAppId,
            session: this
          });
          this._widget.when(context.constants.widgetEvents.titleChanged,
            (title) => context.HostService.setDocumentTitle());
          context.HostService.getApplicationHostWidget().addChildWidget(this._widget);
          context.HostLeftSidebarService.addSession(this);
          this._identifier = identifier;
          this._applications = [];
          this._applicationQueue = [];
          this._childWindows = [];
          this._closeHandler = this._widget.getEndWidget().when(context.constants.widgetEvents.close, () => this.destroy());
          this._restartHandler = this._widget.getEndWidget().when(context.constants.widgetEvents.restart, () => this._onRestart());

          this._flushableApplications = [];
          context.HostLeftSidebarService.setTitle(i18next.t("gwc.main.sidebar.title"));
          // if context.bootstrapInfo.subAppInfo > 0, we are in a child window
          if (this._htmlHostPageAppId) {
            this.activateBrowserMultiPageMode();
          }
          this._flushingApplicationsListener = context.InitService.when(
            gbc.constants.widgetEvents.onBeforeUnload, () => this._flushWaitingApplications());
          this._unloadListener = context.InitService.when(
            gbc.constants.widgetEvents.onUnload, () => this._destroyChildrenWindows());
          this._serverFeatures = [];
        },
        _onRestart: function() {
          if (context.bootstrapInfo.reloadOnRestart === "true") {
            window.location.reload(true);
            return;
          }
          const info = this._baseInfos;
          this.destroy(true);
          context.SessionService.startApplication(info.appId, info.urlParameters);
        },
        getWidget: function() {
          return this._widget;
        },
        getIdentifier: function() {
          return this._identifier;
        },

        getApplicationIdentifier: function() {
          return this._applicationIdentifier++;
        },

        destroy: function(restarting) {
          context.SessionService.remove(this, true === restarting);
          if (this._sessionMode) {
            this._sessionMode.destroy();
            this._sessionMode = null;
          }
          this._closeHandler();
          this._restartHandler();

          if (this._navigationManager) {
            this._navigationManager.destroy();
            this._navigationManager = null;
          }
          this._widget.destroy();
          this._widget = null;
          this._applications.length = 0;
          this._applicationQueue.length = 0;
          this._flushingApplicationsListener();
          this._destroyChildrenWindows();
          $super.destroy.call(this);
        },
        getConnector: function() {
          return this._baseInfos.connector;
        },
        /**
         * Get the session ID
         * @return {string} the session ID
         * @publicdoc
         */
        getSessionId: function() {
          return this._sessionId;
        },

        setSessionId: function(id) {
          if (!this._sessionId) {
            this._sessionId = id;
            context.SessionService.updateSessionId(this, id);
          } else if (id !== this._sessionId) {
            this.error("Session Id Changed");
          }
        },
        getAppId: function() {
          return this._baseInfos.appId;
        },
        error: function(msg) {

        },

        /**
         * @returns {classes.VMSessionNavigationManager}
         */
        getNavigationManager: function() {
          return this._navigationManager;
        },

        /**
         *
         * @param {classes.VMApplication} application
         */
        add: function(application) {
          let queueSize = this._applicationQueue.length;
          this._applications.push(application);

          if (queueSize === 0 || this._applicationQueue[queueSize - 1] !== application) {
            this._applicationQueue.push(application);
          }

          application.__idleChangedSessionHook = application.dvm.onIdleChanged(
            () => this._onIdleChanged(application));
          this.emit(context.constants.baseEvents.applicationAdded, application);
        },
        /**
         *
         * @param {classes.VMApplication} application
         */
        remove: function(application) {
          application.__idleChangedSessionHook();
          this._navigationManager.removeApplication(application);
          this._applications.remove(application);
          this._applicationQueue.remove(application);
          this._applicationEnding = application.info().ending;
          let pos = 0;

          while (pos < this._applicationQueue.length) {
            if (this._applicationQueue[pos] === this._applicationQueue[pos + 1]) {
              this._applicationQueue.splice(pos, 1);
            } else {
              pos++;
            }
          }

          this.emit(context.constants.baseEvents.applicationRemoved, application);
          const currentApp = this.getNewApplication(application);

          if (currentApp) {
            this.setCurrentApplication(currentApp);
            const currentWindow = currentApp.getVMWindow();
            if (currentWindow) {
              const appWidget = currentApp.getUI().getWidget(),
                winWidget = currentWindow.getController().getWidget();

              this.getNavigationManager().setLastActiveWindow(currentApp, currentWindow.getId());
              winWidget.domAttributesMutator(() => appWidget.removeClass("inactiveWindow"));

              this._widget.setCurrentWidget(appWidget);
              context.HostService.setDisplayedWindowNode(currentWindow);
            }
          }

          this._showEnding = true;
          this._updateDisplayEnd();
        },

        _updateDisplayEnd: function() {
          if (this._showEnding && !this._applications.length) {
            if (!this._destroyed) {
              this.getWidget().showWaitingEnd();
            }
            context.HostService.unsetDisplayedWindowNode();

            let delay = 0;

            if (context.BrowserWindowsService.isRootWindow() && this.isInBrowserMultiPageMode()) {
              delay = 1000;
            }

            this._registerTimeout(() => {
              if (!(
                  (context.BrowserWindowsService.isRootWindow() &&
                    context.BrowserWindowsService.countChildWindows(
                      (w) => (!/monitor=true/.test(window._multiWindowData.directChildren[0].location.search)))) ||
                  (this.isInBrowserMultiPageMode() && this._waitingNewTasks > 0))) {
                if (this._waitingNewTasks === 0 && !this._destroyed) {
                  context.HostLeftSidebarService.setContent();
                  if (this.isInTabbedContainerMode()) {
                    this._sessionMode.freeIdleHook();
                  }
                }
                this.displayEnd();
              }
            }, delay);
          }
        },
        _autoclose: function() {
          this._registerTimeout(() => {
            const can = !this._flushableApplications || !this._flushableApplications.length;
            if (can) {
              cls.WindowHelper.closeWindow();
            } else {
              this._autoclose();
            }
          }, 200);
        },

        /**
         * Terminate the session
         * (This is always called by window.onunload with forceServer=true)
         * @param {boolean} [forceServer] true to send a session close (/ua/close) to the server (if supported)
         * @publicdoc
         */
        closeSession: function(forceServer) {
          // if forceServer and is not child of another tab (stantdalone or browserMultiPage activated),
          // send session /ua/close if it has feature
          if (forceServer && this.isMasterBrowserPage() && this.hasServerFeature("close-session")) {
            if (this._applications && this._applications[0]) {
              this._applications[0].protocolInterface.closeSession();
            }
            // if forceServer and is child of another tab (browserMultiPage activated)
            // try to send app /ua/close (will free parent app processing if RUN was called)
          } else if (forceServer && !this.isMasterBrowserPage() && this._applications[0]) {
            this._applications[0].close();
          } else {
            while (this._applications.length) {
              this._applications[0].stop();
            }
          }
        },

        setEndUrl: function(url) {
          this._endUrl = url;
        },

        displayEnd: function() {
          if (!this.isMasterBrowserPage()) {
            this._autoclose();
            return;
          }
          this.emit(context.constants.baseEvents.displayEnd, this._baseInfos.session);
          if (this.getWidget()) {
            this.getWidget().getEndWidget().setHeader(i18next.t("gwc.app.ending.title"));
            // disable sidebar on session end
            context.HostLeftSidebarService.enableSidebar(false);
            if (this._baseInfos.session) {
              this.getWidget().getEndWidget().showSessionActions();
              this.getWidget().getEndWidget().setSessionLinks(this._baseInfos.customUA || this._baseInfos.connector || "",
                this._baseInfos.session);
              this.getWidget().getEndWidget().setSessionID(this._baseInfos.session);
            }
            if (this._baseInfos.mode === "ua") {
              this.getWidget().getEndWidget().showUAActions();
            }
            if (!this._applicationEnding.normal) {

              switch (this._applicationEnding.flag) {
                case "notFound":
                  this.getWidget().getEndWidget().setHeader(i18next.t("gwc.app.notFound.title"));
                  this.getWidget().getEndWidget().setMessage(i18next.t("gwc.app.notFound.message", {
                    appId: "<strong>\"" + this._baseInfos.appId + "\"</strong>"
                  }));
                  break;
                case "notok":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='notok'>" + i18next.t("gwc.app.error.message") + ".</p><p>" + this._applicationEnding
                    .message +
                    "</p>");
                  break;
                case "forbidden":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='forbidden'>" + i18next.t("gwc.app.forbidden.message") + ".</p><p>" + this._applicationEnding
                    .message + "</p>");
                  break;
                case "autoLogout":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='autoLogout'>" + i18next.t("gwc.app.autologout.message") + ".</p>");
                  break;
                case "uaProxy":
                  this.getWidget().getEndWidget().setMessage(
                    "<p data-details='uaProxy'>" + i18next.t("gwc.app.uaProxy.message") + ".</p><p>" + this._applicationEnding
                    .message +
                    "</p>");
                  break;
              }
            }
            if (this._endUrl) {
              this.getWidget().showRedirectEnd();
              window.location.href = this._endUrl;
            } else if (this._applicationEnding.flag !== "hidden") {
              this.getWidget().showEnd();
            }
          }
          this.displayLogPrompt();
          context.HostService.unsetDisplayedWindowNode();
        },

        displayLogPrompt: function(promptUrl) {
          const latePromptHandling = !this._logPromptUrl && Boolean(promptUrl);
          if (!latePromptHandling) {
            this._trackPromptEnding();
          }
          if (this._logPromptUrl !== promptUrl) {
            this._logPromptUrl = promptUrl;
            if (!this._logPromptUrl) {
              document.body.removeClass("logPrompting");
              if (this._logPromptWindow) {
                this._logPromptWindow.close();
                this._logPromptWindow = null;
              }
              if (this._logPromptWidgetHandle) {
                this._logPromptWidgetHandle();
              }
              if (this._logPromptWidget) {
                this._logPromptWidget.destroy();
                this._logPromptWidget = null;
              }
            } else {
              if (latePromptHandling) {
                this._trackPromptEnding();
              }
              if (!this._logPromptWidget) {
                this._logPromptWidget = cls.WidgetFactory.createWidget("SessionLogPrompt", {
                  appHash: gbc.systemAppId
                });
                this._logPromptWidgetHandle = this._logPromptWidget.when(context.constants.widgetEvents.click, function() {
                  if (this.isMasterBrowserPage()) {
                    this._displayLogPopup();
                  } else {
                    const opener = window.opener,
                      openerSession = opener && opener.gbc && opener.gbc.SessionService.getCurrent();
                    if (openerSession) {
                      openerSession._displayLogPopup();
                    }
                  }
                }.bind(this));
                document.body.appendChild(this._logPromptWidget.getElement());
              }
              if (this.isMasterBrowserPage()) {
                if (!this._logPromptWindow) {
                  document.body.addClass("logPrompting");
                } else {
                  this._logPromptWindow.location.href = this._logPromptUrl;
                }
              }
            }
          }
        },
        _displayLogPopup: function() {
          if (!this._logPromptWindow || this._logPromptWindow.closed) {
            this._logPromptWindow = window.open(this._logPromptUrl, "",
              "resizable,scrollbars,status,width=" + window.innerWidth + ",height=" + window.innerHeight +
              ",top=" + window.screenTop + ",left=" + window.screenLeft);
          } else if (this._logPromptWindow) {
            this._logPromptWindow.focus();
          }
        },

        _trackPromptEnding: function() {
          if (this._logPromptUrl) {
            let hasOnlyIdle = true;
            const protocolInterface = this.getApplications()[0] && this.getApplications()[0].protocolInterface,
              protocolAlive = protocolInterface && protocolInterface.isAlive();
            this.getApplications().forEach(function(app) {
              hasOnlyIdle = hasOnlyIdle && app.isIdle();
            });
            if (hasOnlyIdle && protocolAlive) {
              protocolInterface.trackPrompt();
            }
          }
        },

        /**
         *
         * @param {string[]} features
         */
        addServerFeatures: function(features) {
          for (const item of features) {
            const feature = item.trim();
            if (this._serverFeatures.indexOf(feature) < 0) {
              this._serverFeatures.push(feature);
            }
          }
        },
        /**
         *
         * @param {string} feature
         * @return {boolean}
         */
        hasServerFeature: function(feature) {
          return Boolean(this._serverFeatures) && this._serverFeatures.indexOf(feature) >= 0;
        },
        /**
         *
         * @returns {boolean}
         */
        isEmpty: function() {
          return !this._applications.length;
        },

        start: function(appName, params) {
          const info = new cls.VMApplicationInfo({
            appId: appName,
            urlParameters: params || (
              context.bootstrapInfo.queryString ?
              new cls.QueryString(context.bootstrapInfo.queryString).copyContentsObject() :
              context.UrlService.currentUrl().getQueryStringObject()
            )
          });
          info.connector = info.urlParameters.connector || context.bootstrapInfo.connectorUri || "";
          info.customUA = info.urlParameters.customUA || null;
          info.mode = info.urlParameters.mode || "ua";
          info.inNewWindow = !this.isMasterBrowserPage();
          if (info.inNewWindow) {
            info.session = this._sessionId = context.bootstrapInfo.sessionId;
            context.HostLeftSidebarService.setTitle(i18next.t("gwc.main.sidebar.multitab_title"));
          }
          this._baseInfos = info;
          const application = new cls.VMApplication(info, this);
          const appWidget = application.getUI().getWidget();
          this.add(application);
          this._widget.setCurrentWidget(appWidget);
          application.start();
          this._registerNewTask(application.protocolInterface);
          return application;
        },

        startSubTask: function(taskId, taskProcIdParent = null, taskWaiting = null, callback = () => {}) {
          let info = {
            ...(this._baseInfos || {})
          };
          info.connectionInfo = {};
          info.urlParameters = {
            ...(this._baseInfos.urlParameters || {})
          };
          info.inNewWindow = this.isInBrowserMultiPageMode() || (!this.isMasterBrowserPage() && (this._htmlHostPageAppId !== taskId));

          if (info.inNewWindow) {
            info.urlParameters = context.bootstrapInfo.queryString ?
              new cls.QueryString(context.bootstrapInfo.queryString).copyContentsObject() :
              context.UrlService.currentUrl().getQueryStringObject();
            info.connector = info.urlParameters.connector || context.bootstrapInfo.connectorUri || "";
            info.customUA = info.urlParameters.customUA || null;
            info.mode = info.urlParameters.mode || "ua";
          }
          if (!this.isMasterBrowserPage()) {
            context.HostLeftSidebarService.setTitle(i18next.t("gwc.main.sidebar.multitab_title"));
            this._sessionId = context.bootstrapInfo.sessionId;
            info.session = this._sessionId;
          }

          info.task = true;
          info.page = 2;
          info.app = taskId;
          info.taskProcIdParent = taskProcIdParent;
          info.taskWaiting = taskWaiting;

          let hostingWindow = taskWaiting && window._multiWindowData.findWindowBy((w) => {
            const session = w && w.gbc && w.gbc.SessionService.getCurrent();
            if (session) {
              return session.getApplications().find(
                (app) => app.info() && app.info().connectionInfo.procId === taskProcIdParent);
            }
            return null;
          });
          info.inNewWindow = info.inNewWindow && !hostingWindow;
          if (!info.inNewWindow) {
            const session = hostingWindow ? hostingWindow.gbc.SessionService.getCurrent() : this;
            session._startSubTaskLocally(info, callback);
          } else {
            let application = new cls.VMApplication(new cls.VMApplicationInfo(info), this);
            application.waitForApplicationInNewWindow(() => {
              this.waitedForNewTask();
              callback(application);
            }, () => {});
          }
        },

        _startSubTaskLocally: function(info, callback) {
          let application = new cls.VMApplication(new cls.VMApplicationInfo(info), this);
          const appWidget = application.getUI().getWidget();
          this._widget.setCurrentWidget(appWidget);
          this.add(application);
          application.start();
          this.waitedForNewTask();
          callback(application);
        },

        /**
         *
         * @param {window.gbcWrapper} wrapper
         * @param {Object<string, *>} readyData
         */
        startDirect: function(wrapper, readyData) {
          context.HostLeftSidebarService.enableSidebar(true);
          let meta = cls.AuiProtocolReader.translate(readyData.meta)[0];
          const info = new cls.VMApplicationInfo({
            pingTimeout: 1000,
            connectionInfo: meta.attributes,
            procId: meta.attributes.procId,
            page: 1,
            auiOrder: 0,
            mode: "direct",
            nativeResourcePrefix: readyData.nativeResourcePrefix.replace(/\/$/, "") + "/__dvm__/"
          });
          if (readyData.headers) {
            const headersKeys = Object.keys(context.constants.network.startHeaders);
            for (const key of headersKeys) {
              const value = context.constants.network.startHeaders[key];
              info[value.prop || key] = readyData.headers[context.constants.network.headers[key]];
            }
          }

          gbc.classes.EncodingHelper.setVMEncoding(meta.attributes.encoding.toLowerCase());

          info.wrapper = wrapper;
          this._baseInfos = info;
          const application = new cls.VMApplication(info, this);
          application.setProcessing();
          application.procId = info.procId;
          const appWidget = application.getUI().getWidget();
          this._widget.setCurrentWidget(appWidget);
          this.add(application);
          this._navigationManager.updateApplicationInformation(application);
          application.start();
        },
        onApplicationAdded: function(hook) {
          return this.when(context.constants.baseEvents.applicationAdded, hook);
        },
        onApplicationRemoved: function(hook, once) {
          return this.when(context.constants.baseEvents.applicationRemoved, hook, once);
        },

        info: function() {
          return this._baseInfos;
        },

        /**
         * Get all running applications
         * @returns {classes.VMApplication[]} an array of applications or null
         * @publicdoc
         */
        getApplications: function() {
          return this._applications;
        },

        /**
         * Get the current application
         * @returns {classes.VMApplication}
         */
        getCurrentApplication: function() {
          if (this._applications.length && this._applications[this._applications.length - 1]) {
            return this._applications[this._applications.length - 1];
          }
          return null;
        },

        /**
         *
         * @returns {classes.VMApplication}
         */
        getApplicationByHash: function(hash) {
          return this._applications && this._applications.filter(function(item) {
            return item.applicationHash === hash;
          })[0];
        },
        getApplicationByProcId: function(procId) {
          return this._applications && this._applications.filter(function(item) {
            return item.procId === procId ||
              (item.info() && item.info().procId === procId) ||
              (item?.info()?.connectionInfo.procId === procId);
          })[0];
        },
        setCurrentApplication: function(application) {
          const index = this._applications.indexOf(application);
          if (index !== -1) {
            this._applications.splice(index, 1);
            this._applications.push(application);
          }
        },
        _onIdleChanged: function(application) {
          this.emit(context.constants.baseEvents.idleChanged, application);
        },
        whenIdleChanged: function(hook) {
          return this.when(context.constants.baseEvents.idleChanged, hook);
        },
        isCurrentIdle: function() {
          const app = this.getCurrentApplication();
          return !app || app.dvm.processed && app.dvm.idle && app.layout.isIdle() && app.scheduler.hasNoCommandToProcess();
        },

        _addWaitingApplication: function(application) {
          this._flushableApplications.push(application);
        },
        _removeWaitingApplication: function(application) {
          this._flushableApplications.remove(application);
        },
        _flushWaitingApplications: function() {
          this._flushingApplications = true;
          while (this._flushableApplications && this._flushableApplications.length) {
            cls.WindowHelper.openWindow(cls.UANetwork.newApp(this._flushableApplications.shift(), null, null, {
              noQueryString: true
            }), true);
          }
        },
        _registerNewTask: function(protocolInterface) {
          this._storedProtocol = protocolInterface;
        },
        newTask: function() {
          if (this._storedProtocol) {
            this._storedProtocol.newTask();
          }
        },
        _registerChildWindow: function(win) {
          if (win) {
            window._emergencyClose = window._emergencyClose || {};
            win._opener = window;
            win.addEventListener("load", function() {
              window._emergencyClose[win.gbc.uid] = [];
              win.addEventListener("unload", function() {
                if (window.browserInfo.isFirefox) {
                  const emergencyCloses = window._emergencyClose[win.gbc.uid];
                  for (const closeInfo of emergencyCloses) {
                    cls.UANetwork.querySend("close", null, closeInfo, function() {}, null, null);
                  }
                }
                if (win.location.href !== "about:blank") { // thank you firefox
                  this._updateDisplayEnd();
                }
              }.bind(this));
            }.bind(this));
            this._childWindows.push(win);
          }
        },
        _destroyChildrenWindows: function() {
          this._childWindows = [];
          context.BrowserWindowsService.closeAllChildren();
        },
        waitingForNewTask: function() {
          this._waitingNewTasks++;
        },

        waitedForNewTask: function() {
          if (this._waitingNewTasks > 0) {
            this._waitingNewTasks--;
          }
          this._updateDisplayEnd();
        },

        isInBrowserMultiPageMode: function() {
          return this._sessionMode && this._sessionMode.isInstanceOf(cls.VMSessionBrowserMultiPageMode);
        },

        isMasterBrowserPage: function() {
          return !this._htmlHostPageAppId;
        },

        isInTabbedContainerMode: function() {
          return this._sessionMode && this._sessionMode.isInstanceOf(cls.VMSessionTabbedContainerMode);
        },

        displayChanged: function() {
          let app = null;
          if (this.isInTabbedContainerMode()) {
            app = this._sessionMode.triggerDisplayChanged();
          }
          return app;
        },

        /**
         *
         * @param {classes.WindowNode} windowNode
         */
        activateTabbedContainerMode: function(windowNode) {
          if (!this._sessionMode && windowNode) {
            this._sessionMode = new cls.VMSessionTabbedContainerMode(this);
            this._sessionMode.activate(windowNode);
            context.HostLeftSidebarService.setApplicationListVisibility(true);
            context.HostLeftSidebarService.setTabbedContainerMode(true);
          }
        },

        getHostApplication: function() {
          return this.isInTabbedContainerMode() && this._sessionMode.getHostApplication();
        },

        activateBrowserMultiPageMode: function() {
          if (!this._sessionMode && (this.getApplications().length === 1)) {
            this._sessionMode = new cls.VMSessionBrowserMultiPageMode(this);
            context.HostLeftSidebarService.setTitle(i18next.t("gwc.main.sidebar.multitab_title"));
          }
        },

        /**
         * '
         * @param {classes.VMApplication} app
         * @param {classes.ApplicationWidget} appWidget
         */
        addApplicationWidget: function(app, appWidget) {
          if (this.isInTabbedContainerMode()) {
            this._sessionMode.addApplicationWidget(app, appWidget);
          } else {
            this.getWidget().addChildWidget(appWidget);
          }
        },

        manageStartMenu: function(startMenuNode, widget) {
          if (this.isInTabbedContainerMode() && this._sessionMode.willManageStartMenu()) {
            this._sessionMode.manageStartMenu(startMenuNode, widget);
          } else {
            startMenuNode.getAncestor("UserInterface").getController().getWidget().addStartMenu(widget);
          }
        },

        /**
         * Get the running application corresponding to the remove application
         * @param removedApplication
         * @return {classes.VMApplication}
         */
        getNewApplication: function(removedApplication) {
          let parentProcId = removedApplication.getParentProcId();

          if (!parentProcId || this._applicationQueue.length === 1) {
            return this._applicationQueue[this._applicationQueue.length - 1];
          }

          let app = null;
          let childApp = null;
          let procId = parentProcId;
          //Search the running child
          do {
            app = this._navigationManager.getApplicationByProcId(procId);
            childApp = app && this._navigationManager.getChildApplication(app);
            procId = childApp && childApp.getProcId();
          } while (app && app.isProcessing() && childApp);

          return app;
        },

        /**
         * Get the application with identifier = applicationIdentifier
         * @param {number} applicationIdentifier
         * @return {classes.VMApplication|undefined}
         */
        getApplicationByIdentifier: function(applicationIdentifier) {
          return this._applications.find((app) => {
            return app.applicationHash === applicationIdentifier;
          });
        }
      };
    });
  });
;

"use strict";

modulum("VMSessionBrowserMultiPageMode", ["EventListener"],
  function(context, cls) {
    /**
     * A VM driven Session
     * @class VMSessionBrowserMultiPageMode
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMSessionBrowserMultiPageMode = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMSessionBrowserMultiPageMode.prototype */ {
        __name: "VMSessionBrowserMultiPageMode",
        /**
         * @type {?classes.VMSession}
         */
        _session: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.VMSession} session session
         */
        constructor: function(session) {
          $super.constructor.call(this);
        },

        /**
         * get owning session
         * @returns {?classes.VMSession}
         */
        getSession: function() {
          return this._session;
        },

        /**
         * @override
         */
        destroy: function() {
          this._session = null;
          $super.destroy.call(this);
        }
      };
    });
  });
;

"use strict";

modulum("VMSessionNavigationManager", ["EventListener"],
  function(context, cls) {
    const Wevents = context.constants.widgetEvents;
    /**
     * session mode tooling when tabbed container is activated
     * @class VMSessionNavigationManager
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMSessionNavigationManager = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMSessionNavigationManager.prototype */ {
        __name: "VMSessionNavigationManager",
        /** @type {classes.VMSession} */
        _session: null,

        /** @type {classes.VMApplication} */
        _currentApplication: null,

        /** @type {classes.SessionSidebarWidget} */
        _sidebarWidget: null,

        /** @type {classes.ChromeBarTitleWidget} */
        _chromeBarTitleWidget: null,

        /** @type {classes.ChromeBarWidget} */
        _currentChromeBarWidget: null,
        _stackCurrentApplication: null,
        /**
         * @type {Map<classes.VMApplication, classes.SessionSidebarApplicationItemWidget>}
         */
        _applicationItems: null,

        /**
         * @type {Map<classes.WindowNode, classes.SessionSidebarWindowItemWidget>}
         */
        _windowItems: null,

        /**
         * @type {WeakMap<classes.WindowNode|classes.VMApplication, {nameHandle:HandleRegistration, iconHandle:HandleRegistration}>}
         */
        _handles: null,

        /** @type {Map<string, classes.SessionSidebarApplicationStackItemWidget>} */
        _applicationStackRootWidgets: null,

        /** @type {Map<string, classes.SessionSidebarApplicationStackListWidget>} */
        _applicationStackWidgets: null,

        /** @type {Map<string, Array<string>>} */
        _applicationStacks: null,

        /** @type {Map<string, Array<classes.WindowNode>>} */
        _windowStacks: null,

        /** @type {Map<string, string>} */
        _rootStackLookup: null,

        /** @type {Map<string, classes.VMApplication>} */
        _applicationLookupByProcId: null,

        /** @type {Map<string, string>} */
        _applicationParentLookup: null,

        /** @type {WeakMap<classes.VMApplication, string>} */
        _applicationProcIds: null,

        _currentStackItem: null,

        /** @type {Map<string, Object>} */
        _lastActiveWindow: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.VMSession} session session
         */
        constructor: function(session) {
          $super.constructor.call(this);
          this._session = session;
          this._sidebarWidget = cls.WidgetFactory.createWidget("SessionSidebar", {
            appHash: gbc.systemAppId
          });

          this._chromeBarTitleWidget = cls.WidgetFactory.createWidget("ChromeBarTitle", {
            appHash: gbc.systemAppId
          });

          this._chromeBarTitleWidget.onDropDownBeforeOpen(() => {
            const appId = this._applicationProcIds.get(this._currentApplication),
              rootProcId = this._rootStackLookup.get(appId),
              dropDownContent = this._applicationStackWidgets.get(rootProcId);
            this._chromeBarTitleWidget.setDropDownContent(dropDownContent);
          });

          this._chromeBarTitleWidget.onDropDownClose(() => {
            this._chromeBarTitleWidget.setDropDownContent(null);
          });

          this._applicationItems = new Map();
          this._windowItems = new Map();
          this._handles = new WeakMap();

          this._stackCurrentApplication = new Map();
          this._applicationStackWidgets = new Map();
          this._applicationStackRootWidgets = new Map();
          this._applicationStacks = new Map();
          this._windowStacks = new Map();
          this._rootStackLookup = new Map();

          this._applicationLookupByProcId = new Map();
          this._applicationParentLookup = new Map();

          this._applicationProcIds = new WeakMap();
          this._lastActiveWindow = new Map();
        },

        /**
         * @override
         */
        destroy: function() {
          this._applicationItems = null;
          this._windowItems = null;
          this._handles = null;

          for (const rootWidget of this._applicationStackRootWidgets.values()) {
            this._sidebarWidget.removeChildWidget(rootWidget);
          }

          this._applicationStackRootWidgets = null;
          this._applicationStackWidgets = null;
          this._applicationStacks = null;
          this._rootStackLookup = null;

          this._applicationLookupByProcId = null;
          this._applicationParentLookup = null;

          this._sidebarWidget.destroy();
          this._sidebarWidget = null;
          this._chromeBarTitleWidget.destroy();
          this._chromeBarTitleWidget = null;

          this._session = null;
          this._lastActiveWindow.clear();
          this._lastActiveWindow = null;

          $super.destroy.call(this);
        },

        /**
         * Get the owning session
         * @returns {classes.VMSession}
         */
        getSession: function() {
          return this._session;
        },

        /**
         *
         * @returns {classes.ChromeBarTitleWidget}
         */
        getChromeBarTitleWidget: function() {
          return this._chromeBarTitleWidget;
        },

        /**
         * @returns {classes.SessionSidebarWidget}
         */
        getWidget: function() {
          return this._sidebarWidget;
        },

        /**
         *
         * @param {classes.WindowNode} windowNode
         */
        setCurrentWindow: function(windowNode) {
          const app = windowNode.getApplication(),
            appId = this._applicationProcIds.get(app);
          this._currentApplication = app;
          this._currentWindow = windowNode;
          const rootProcId = this._rootStackLookup.get(appId);
          this._stackCurrentApplication.set(rootProcId, appId);
          if (windowNode.getTitle()) {
            windowNode.setTitle(windowNode.getTitle()); // force title sync if any
          }
        },

        getCurrentWindow: function() {
          return this._currentWindow;
        },

        /**
         * Adding an app in Manager
         * @param {classes.VMApplication} application
         * @returns {?classes.WidgetBase}
         */
        addApplication: function(application) {
          if (this._applicationItems.has(application)) {
            console.warn("Application already added");
            return;
          }
          // TODO what is the meaning of this widget ? it seems to be not used anymore... refactor task GBC-4368
          // TODO The widget displayed in the sidebar is "SessionSidebarApplication**Stack**Item"
          const applicationSidebarWidget = cls.WidgetFactory.createWidget("SessionSidebarApplicationItem",
            application.getUI().getWidget().getBuildParameters());
          this._applicationItems.set(application, applicationSidebarWidget);
          this._handles.set(application, {
            /**
             * Handler when *application* title changed
             */
            nameHandle: application.when(Wevents.titleChanged, (evt, src, title) => {
              this.syncHost();
              applicationSidebarWidget.setApplicationName(title);
              const appInfo = application.applicationInfo.connectionInfo,
                rootWidget = this._applicationStackRootWidgets.get(appInfo && appInfo.procId);
              if (rootWidget) {
                // Root widget are parent apps
                rootWidget.setApplicationTitle(title);
              } else if (gbc.ThemeService.getValue("theme-sidebar-show-child-name")) {
                // application is not a root app, but a child app: if theme says to display child name: do it here
                this._currentStackItem.setApplicationTitle(application.getTitle());
              }
            }),
            iconHandle: application.when(Wevents.iconChanged, (evt, src, icon) => {
              this.syncHost();
              applicationSidebarWidget.setApplicationIcon(icon);
              const appInfo = application.applicationInfo.connectionInfo,
                rootWidget = this._applicationStackRootWidgets.get(appInfo && appInfo.procId);
              if (rootWidget) {
                rootWidget.setIcon(icon);
              }
            }),
            clickHandle: applicationSidebarWidget.when(Wevents.click, () => {
              const ui = application.getUI();
              ui.syncCurrentWindow();
              if (gbc.StoredSettingsService.isSideBarVisible()) {
                context.HostLeftSidebarService.hideSidebar();
              }
            })
          });

          application.dvm.onOrdersManaged(() => {
            applicationSidebarWidget.setApplicationName(application.getTitle());
            applicationSidebarWidget.setApplicationIcon(application.getImage());
          }, true);

          gbc.HostService.updateDisplay(); // re-align everything in window

          return applicationSidebarWidget;
        },

        updateApplicationInformation: function(application) {
          const appInfo = application.applicationInfo.connectionInfo;
          let procId = null,
            procIdParent = null,
            procIdWaiting = null;
          if (appInfo) {
            procId = appInfo.procId;
            procIdParent = appInfo.procIdParent || null;
            procIdWaiting = Boolean(appInfo.procIdWaiting);
            this._applicationLookupByProcId.set(procId, application);
            this._applicationParentLookup.set(procId, procIdParent);
            this._applicationProcIds.set(application, procId);
          }
          if (procId) {
            if (!procIdParent || !procIdWaiting || !this._rootStackLookup.get(procIdParent)) {
              if (!this._applicationStackRootWidgets.has(procId)) {
                const rootWidget = cls.WidgetFactory.createWidget("SessionSidebarApplicationStackItem", {
                  ...(application.getUI().getWidget().getBuildParameters()),
                  appHash: gbc.systemAppId
                });
                rootWidget.setApplicationTitle(application.getTitle());
                rootWidget.setIcon(application.getImage());
                rootWidget.when(context.constants.widgetEvents.click, () => {
                  let app = this._applicationLookupByProcId.get(this._stackCurrentApplication.get(procId));
                  if (!app) {
                    const stack = this._applicationStacks.get(procId);
                    app = this._applicationLookupByProcId.get(stack[stack.length - 1]);
                  }
                  const ui = app.getUI();
                  ui.syncCurrentWindow();

                  // Hide left topmenu if any
                  context.HostLeftSidebarService.showTopMenu(false); // hide + fast
                  context.TopmenuService.syncTopMenus(app.applicationHash);

                  if (gbc.StoredSettingsService.isSideBarVisible()) {
                    context.HostLeftSidebarService.hideSidebar();
                  }
                });
                const listWidget = cls.WidgetFactory.createWidget("SessionSidebarApplicationStackList", {
                  ...(application.getUI().getWidget().getBuildParameters()),
                  appHash: gbc.systemAppId
                });
                this._applicationStackRootWidgets.set(procId, rootWidget);
                this._applicationStackWidgets.set(procId, listWidget);
                this._applicationStacks.set(procId, [procId]);
                this._windowStacks.set(procId, []);
                this._rootStackLookup.set(procId, procId);
                listWidget.addChildWidget(this._applicationItems.get(application));
                this._sidebarWidget.addChildWidget(rootWidget);
                this.emit(context.constants.VMSessionNavigationManagerEvents.addSessionSidebarApplicationStackItem,
                  application, rootWidget);

              }
            } else {
              const rootProcId = this._rootStackLookup.get(procIdParent),
                stack = this._applicationStacks.get(rootProcId),
                listWidget = this._applicationStackWidgets.get(rootProcId);
              stack.push(procId);
              listWidget.addChildWidget(this._applicationItems.get(application));
              this._rootStackLookup.set(procId, rootProcId);
            }
            context.HostLeftSidebarService.updateApplicationCount(1);
          }
        },

        removeApplication: function(application) {
          context.HostLeftSidebarService.updateApplicationCount(-1);

          const {
            nameHandle,
            iconHandle,
            clickHandle
          } = this._handles.get(application);
          nameHandle();
          iconHandle();
          clickHandle();
          this._handles.delete(application);
          const applicationSidebarWidget = this._applicationItems.get(application),
            parentWidget = applicationSidebarWidget.getParentWidget();

          if (parentWidget) {
            parentWidget.removeChildWidget(applicationSidebarWidget);
          }
          applicationSidebarWidget.destroy();
          this._applicationItems.delete(application);

          if (this._applicationProcIds.has(application)) {
            const procId = this._applicationProcIds.get(application);
            this._applicationProcIds.delete(application);
            this._applicationLookupByProcId.delete(procId);
          }
          const appInfo = application.applicationInfo.connectionInfo,
            procId = appInfo.procId,
            rootProcId = this._rootStackLookup.get(procId),
            stack = this._applicationStacks.get(rootProcId);
          stack.remove(procId);
          if (!stack.length) {
            this._applicationStacks.delete(rootProcId);
            this._sidebarWidget.removeChildWidget(this._applicationStackRootWidgets.get(rootProcId));
            if (this._currentStackItem === this._applicationStackRootWidgets.get(rootProcId)) {
              this._currentStackItem = null;
            }

            this.emit(context.constants.VMSessionNavigationManagerEvents.removeSessionSidebarApplicationStackItem,
              application, this._applicationStackRootWidgets.get(rootProcId));

            this._applicationStackRootWidgets.get(rootProcId).destroy();
            this._applicationStackRootWidgets.delete(rootProcId);
            [...this._rootStackLookup.keys()].filter(k => this._rootStackLookup[k] === rootProcId)
              .forEach(k => {
                this._rootStackLookup.delete(k);
                this._applicationParentLookup.delete(k);
              });
            this._sidebarWidget.removeChildWidget(this._applicationStackWidgets.get(rootProcId));
          } else {
            // App has been removed from list! restore original parent name
            const parentApp = this._applicationLookupByProcId.get(application.getParentProcId());
            const stackItem = this._applicationStackRootWidgets.get(application.getParentProcId());
            stackItem?.setApplicationTitle(parentApp.getTitle());
          }
        },

        setApplicationProcessing: function(application, processing) {
          this._applicationItems.get(application).setProcessing(processing);
        },

        freezeApplication: function(application) {
          const item = this._applicationItems.get(application);
          if (item) {
            item.freeze();
          }
        },

        unfreezeApplication: function(application) {
          const item = this._applicationItems.get(application);
          if (item) {
            item.unfreeze();
          }
        },

        /**
         *
         * @param {classes.WindowNode} windowNode
         * @returns {?classes.WidgetBase}
         */
        addWindow: function(windowNode) {
          if (this._windowItems.has(windowNode)) {
            console.warn("Window already added");
            return;
          }

          const application = windowNode.getApplication();
          windowNode.whenControllerCreated(() => {
            const windowSidebarWidget = cls.WidgetFactory.createWidget("SessionSidebarWindowItem",
              windowNode.getWidget().getBuildParameters());

            if (!windowNode.isModal()) {
              this._applicationItems.get(application).addChildWidget(windowSidebarWidget);
            }

            this._windowItems.set(windowNode, windowSidebarWidget);
            const windowList = this._windowStacks.get(this._getRootProcId(application));
            if (!windowNode.isModal()) {
              windowList.add(windowNode);
              windowSidebarWidget.setWindowName(windowNode.attribute("text") || windowNode.attribute("name"));
              windowSidebarWidget.setWindowIcon(windowNode.getWidget().getImage());
            }

            this._handles.set(windowNode, {
              nameHandle: windowNode.when(Wevents.titleChanged, (evt, src, title) => {
                if (!windowNode.isModal()) {
                  this.syncHost();
                  windowSidebarWidget.setWindowName(title);
                }
              }),
              iconHandle: windowNode.when(Wevents.iconChanged, (evt, src, icon) => {
                if (!windowNode.isModal()) {
                  this.syncHost();
                  windowSidebarWidget.setWindowIcon(icon);
                }
              }),
              clickHandle: windowSidebarWidget.when(Wevents.click, () => {
                if (!windowNode.isModal()) {

                  const ui = application.getUI();
                  const uiWidget = ui.getWidget();
                  ui.syncCurrentWindow();
                  ui.setCurrentWindow(windowNode.getId());

                  const infoLastWindow = this._lastActiveWindow.get(this.getRootWaitingApplication(application).getProcId());

                  if (ui !== infoLastWindow.ui || windowNode.getId() !== infoLastWindow.windowId) {
                    uiWidget.domAttributesMutator(() => uiWidget.addClass("inactiveWindow"));
                  } else {
                    uiWidget.domAttributesMutator(() => uiWidget.removeClass("inactiveWindow"));
                  }

                  if (gbc.StoredSettingsService.isSideBarVisible()) {
                    context.HostLeftSidebarService.hideSidebar();
                  }
                }
              })
            });

            this.emit(context.constants.VMSessionNavigationManagerEvents.addSessionSidebarWindowItem,
              application, windowSidebarWidget);

            return windowSidebarWidget;
          }, true);
        },
        /**
         *
         * @param {classes.WindowNode} windowNode
         */
        removeWindow: function(windowNode) {
          const {
            nameHandle,
            iconHandle,
            clickHandle
          } = this._handles.get(windowNode);
          nameHandle();
          iconHandle();
          clickHandle();
          this._handles.delete(windowNode);
          const windowSidebarWidget = this._windowItems.get(windowNode);
          const application = windowNode.getApplication();

          this.emit(context.constants.VMSessionNavigationManagerEvents.removeSessionSidebarWindowItem,
            application, windowSidebarWidget);

          this._applicationItems.get(windowNode.getApplication()).removeChildWidget(windowSidebarWidget);
          windowSidebarWidget.destroy();
          this._windowItems.delete(windowNode);

          const windowList = this._windowStacks.get(this._getRootProcId(application));

          windowList.remove(windowNode);
          this.syncHost();
        },

        /**
         * @param {classes.WindowNode} windowNode
         * @param {boolean} isNextModal
         */
        freezeWindow: function(windowNode, isNextModal) {
          const windowWidget = windowNode && windowNode.getWidget();
          if (windowWidget) {
            windowWidget.freeze(isNextModal);
          }
          if (windowNode) {
            this._windowItems.get(windowNode).setFrozen(true);
          }
        },

        unfreezeWindow: function(windowNode) {
          const windowWidget = windowNode && windowNode.getWidget();
          if (windowWidget) {
            windowWidget.unfreeze();
          }
          if (windowNode) {
            this._windowItems.get(windowNode).setFrozen(false);
          }
          //Sync top menu if any
          context.TopmenuService.syncTopMenus(windowWidget.getApplicationIdentifier());
        },

        /**
         *
         * @param {classes.WindowNode} currentWindowNode
         */
        updateItemsStatuses: function(currentWindowNode) {
          if (currentWindowNode && !currentWindowNode.isModal()) {
            const currentApp = currentWindowNode && currentWindowNode.getApplication(),
              currentSession = currentApp && currentApp.getSession(),
              rootProcId = this._rootStackLookup.get(this._applicationProcIds.get(currentApp)),
              applicationStackItemWidget = this._applicationStackRootWidgets.get(rootProcId);

            if (this._session) {
              if (currentWindowNode) {
                if (currentSession && (!currentSession.isInTabbedContainerMode() || currentSession.getHostApplication() === currentApp)) {
                  const chromeBarWidget = currentApp && currentApp.getChromeBar();

                  const windowList = this._windowStacks.get(this._getRootProcId(currentApp));
                  this._applicationStackRootWidgets.get(this._getRootProcId(currentApp));
                  this._chromeBarTitleWidget.setListingVisible(windowList.length > 1);
                  if (currentWindowNode.getTitle()) {
                    this._chromeBarTitleWidget.setWindowTitle(currentWindowNode.getTitle(), currentApp);
                  }
                  this._chromeBarTitleWidget.setIcon(currentWindowNode.getIcon());
                  if (this._currentChromeBarWidget !== chromeBarWidget) {
                    if (this._currentChromeBarWidget) {
                      this._currentChromeBarWidget.setTitle();
                      this._currentChromeBarWidget = null;
                    }
                    if (chromeBarWidget) {
                      chromeBarWidget.setTitle(this._chromeBarTitleWidget, currentApp);
                      this._currentChromeBarWidget = chromeBarWidget;
                    }
                  }
                }
                if (this._currentStackItem) {
                  this._currentStackItem.setVisible(false);
                  this._currentStackItem = null;
                }
                if (applicationStackItemWidget) {
                  this._currentStackItem = applicationStackItemWidget;
                  applicationStackItemWidget.setVisible(true);
                }
              }
              this._session.getApplications().forEach(app => {
                const appItem = this._applicationItems.get(app);
                if (appItem) {
                  appItem.toggleClass("activeWindow", app === currentApp);
                  app.model.getNodesByTag("Window").forEach(win => {
                    const winItem = this._windowItems.get(win);
                    if (winItem) {
                      winItem.toggleClass("activeWindow", app.getVMWindow() === win);
                      winItem.toggleClass("visibleWindow", win === currentWindowNode);
                    }
                  });
                }
              });
            }
          } else if (currentWindowNode && currentWindowNode.isModal()) {
            const currentApp = currentWindowNode && currentWindowNode.getApplication(),
              currentSession = currentApp && currentApp.getSession(),
              rootProcId = this._rootStackLookup.get(this._applicationProcIds.get(currentApp)),
              applicationStackItemWidget = this._applicationStackRootWidgets.get(rootProcId);
            const windowList = this._windowStacks.get(this._getRootProcId(currentApp));
            const lastNonModalWin = windowList ? windowList.filter(w => !w.isModal())[0] : null;

            // Do not change chromebar title when in tabbed container
            if (!currentSession.isInTabbedContainerMode()) {
              this._chromeBarTitleWidget.setWindowTitle(lastNonModalWin ? lastNonModalWin.getTitle() : "", currentApp);
            }

          }
        },
        /**
         *
         * @param {classes.VMApplication} application
         * @private
         */
        _getRootProcId: function(application) {
          return this._rootStackLookup.get(this._applicationProcIds.get(application));
        },

        syncHost: function() {
          this.updateItemsStatuses(context.HostService._currentWindowNode);
        },

        /**
         * Get the application widget list
         * @return {Map<string, classes.SessionSidebarApplicationStackItemWidget>}
         */
        getApplicationWidgetList: function() {
          return this._applicationStackRootWidgets;
        },

        /**
         * Get the application by is procId
         * @param procId
         * @return {classes.VMApplication}
         */
        getApplicationByProcId: function(procId) {
          return this._applicationLookupByProcId.get(procId);
        },

        /**
         * Get the window widget list
         * @return {Map<classes.WindowNode, classes.SessionSidebarWindowItemWidget>}
         */
        getWindowWidgetList: function() {
          return this._windowItems;
        },

        /**
         * get the root waiting application for application procId
         * @param {classes.VMApplication} application
         * @return {classes.VMApplication|null}
         */
        getRootWaitingApplication: function(application) {
          let app = application;
          let appInfo = application.applicationInfo.connectionInfo;
          let procId = appInfo.procId;

          do {
            if (!appInfo.procIdWaiting || !appInfo.procIdParent) {
              return app;
            }

            procId = appInfo.procIdParent;
            app = this._applicationLookupByProcId.get(procId);
            appInfo = app && app.applicationInfo.connectionInfo;
          } while (app && appInfo);

          return null;
        },

        /**
         * Get parent application
         * @param {classes.VMApplication} application
         * @return {null|classes.VMApplication}
         */
        getParentApplication: function(application) {
          let parentProcId = application.applicationInfo.connectionInfo.procIdParent;

          if (parentProcId) {
            return this._applicationLookupByProcId.get(parentProcId);
          }

          return null;
        },

        /**
         * Get the child application
         * @param {classes.VMApplication} application
         * @return {null|classes.VMApplication}
         */
        getChildApplication: function(application) {
          let appProcId = application.getProcId();

          for (let [procId, app] of this._applicationLookupByProcId.entries()) {
            if (app.applicationInfo.connectionInfo.procIdParent === appProcId) {
              return app;
            }
          }

          return null;
        },

        /**
         * Save the last VMApplication and active window id
         * @param {classes.VMApplication} application
         * @param {number} lastActiveWindowId
         */
        setLastActiveWindow: function(application, lastActiveWindowId) {
          let rootApp = this.getRootWaitingApplication(application);

          if (!rootApp) {
            return;
          }

          this._lastActiveWindow.set(rootApp.getProcId(), {
            ui: application.getUI(),
            windowId: lastActiveWindowId
          });
        },

        /**
         * Go back to the last active window id
         * @param {classes.VMApplication} application
         */
        goBackToLastActiveWindow: function(application) {
          const procId = this.getRootWaitingApplication(application || this.getSession().getCurrentApplication()).getProcId();
          const info = this._lastActiveWindow.get(procId);

          info.ui.syncCurrentWindow();
          info.ui.setCurrentWindow(info.windowId);

          const uiWidget = info.ui.getWidget();
          uiWidget.domAttributesMutator(() => uiWidget.removeClass("inactiveWindow"));

          if (gbc.StoredSettingsService.isSideBarVisible()) {
            context.HostLeftSidebarService.hideSidebar();
          }
        },

        /**
         * Get all the applications
         * @return {classes.VMApplication[]}
         */
        getApplications: function() {
          const res = [];

          this._applicationLookupByProcId.forEach((value) => {
            res.push(value);
          });

          return res;
        }
      };
    });
  });
;

"use strict";

/**
 * @readonly
 * @enum {string};
 */
gbc.constants.VMSessionNavigationManagerEvents = {
  addSessionSidebarApplicationStackItem: "g_addSessionSidebarApplicationStackItem",
  removeSessionSidebarApplicationStackItem: "g_removeSessionSidebarApplicationStackItem",
  addSessionSidebarWindowItem: "g_addSessionSidebarWindowItem",
  removeSessionSidebarWindowItem: "g_removeSessionSidebarWindowItem"
};
;

"use strict";

modulum("VMSessionTabbedContainerMode", ["EventListener"],
  function(context, cls) {

    const nullRect = {
      top: null,
      left: null,
      right: null,
      bottom: null,
      width: "auto",
      height: "auto",
      "max-width": "100%",
      "max-height": "100%"
    };

    /**
     * session mode tooling when tabbed container is activated
     * @class VMSessionTabbedContainerMode
     * @memberOf classes
     * @extends classes.EventListener
     * @publicdoc Base
     */
    cls.VMSessionTabbedContainerMode = context.oo.Class(cls.EventListener, function($super) {
      return /** @lends classes.VMSessionTabbedContainerMode.prototype */ {
        __name: "VMSessionTabbedContainerMode",
        /**
         * @type {classes.VMSession}
         */
        _session: null,

        /** @type {classes.VMApplication} */
        _app: null,

        /** @type {classes.WindowNode} */
        _windowNode: null,

        /** @type {classes.TabbedContainerWidget} */
        _tabbedContainerWidget: null,

        /** @type {classes.WidgetBase[]} */
        _tabbedApplications: null,

        /** @type {classes.WidgetBase} */
        _currentTabbedWidget: null,

        _currentTabbedRect: null,

        _appIdleHook: null,

        /**
         * @inheritDoc
         * @constructs
         * @param {classes.VMSession} session session
         */
        constructor: function(session) {
          $super.constructor.call(this);

          this._session = session;
          this._tabbedApplications = [];

          this._currentTabbedRect = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: "auto",
            height: "auto"
          };
        },

        /**
         * Get the owning session
         * @returns {classes.VMSession}
         */
        getSession: function() {
          return this._session;
        },

        /**
         * @override
         */
        destroy: function() {
          this._app = null;
          this._session = null;
          this._tabbedApplications = null;
          this._currentTabbedWidget = null;
          this._tabbedContainerWidget = null;
          this._currentTabbedRect = null;
          if (this._appIdleHook) {
            this._appIdleHook();
            this._appIdleHook = null;
          }
          $super.destroy.call(this);
        },

        /**
         * get host application
         * @returns {classes.VMApplication}
         */
        getHostApplication: function() {
          return this._app;
        },

        /**
         * activate this mode
         * @param {classes.WindowNode} hostingWindowNode
         */
        activate: function(hostingWindowNode) {
          let hostingApplication = hostingWindowNode.getApplication(),
            hostingApplicationUIWidget = hostingApplication.getUI().getWidget();

          this._session.getWidget().setCurrentWidget(hostingApplicationUIWidget);
          this._app = hostingApplication;
          this._windowNode = hostingWindowNode;
          this._tabbedContainerWidget = cls.WidgetFactory.createWidget("TabbedContainer", {
            appHash: gbc.systemAppId
          });
          this._session.getWidget().setTabbedContainer(this._tabbedContainerWidget);
          const widget = hostingWindowNode.getController() && hostingWindowNode.getController().getWidget();
          if (widget) {
            this._session.getWidget().setTabbedContainerHost(hostingApplicationUIWidget);
            // 1. prepare the window
            widget.getContainerElement().empty();
            widget.when(gbc.constants.widgetEvents.unfrozen, () => {
              if (this._currentTabbedWidget && this._currentTabbedWidget._tabbedPage) {
                this._currentTabbedWidget._tabbedPage._tabbedApp.scheduler.layoutCommand({
                  resize: true
                });
              }
            });
            widget.when(context.constants.widgetEvents.destroyed, () => {
              let apps;
              while ((apps = this._session.getApplications().filter(app => !app._tabbedClosing)).length) {
                if (apps[0] !== this._app) {
                  apps[0].close();
                }
                apps[0]._tabbedClosing = true;
              }
            });
            widget.addTabbedContainer(this._tabbedContainerWidget);
            this._tabbedContainerWidget.when(context.constants.widgetEvents.change, (event, src, page) => this._onTabChange(page));

            hostingApplication.layout.afterLayout(() => this._onHostingApplicationAfterLayout());

            // 2. manage sidebar
            this._session.manageStartMenu();

            context.HostService.setTabbedHost(hostingWindowNode);

            this._app.uiNode().getDescendants("Window").map(function(w) {
              if (w?.getParentNode()?.getWidget()) {
                // Since registerClosableWindow can take an optional argument, use it to pass chromeBar to it
                context.HostService.registerClosableWindow(w, null, {
                  chromeBar: w.getParentNode().getWidget().getChromeBarWidget()
                });
              }
            });
            // 3. manage existing apps
            let apps = this._session.getApplications(),
              appslen = apps.length;
            for (let i = 0; i < appslen; i++) {
              let app = apps[i];
              if (!app.getUI().getWidget()._tabbedPage && app !== this._app) {
                this._session.addApplicationWidget(app, app.getUI().getWidget());

                // jshint ignore:start
                if (app.uiNode()) {
                  app.uiNode().getDescendants("Window").map(function(w) {
                    if (w?.getParentNode()?.getWidget()) {
                      context.HostService.registerClosableWindow(w, null, {
                        chromeBar: w.getParentNode().getWidget().getChromeBarWidget()
                      });
                    }
                  });
                }
                // jshint ignore:end

              }
            }

            context.HostService.setDisplayedWindowNode(hostingWindowNode);
          }
        },

        /**
         * on tab change handler
         * @param page
         * @private
         */
        _onTabChange: function(page) {
          if (this._currentTabbedWidget && this._currentTabbedWidget.getElement()) {
            this._currentTabbedWidget.getElement().addClass("gbc_out_of_view");
            this._currentTabbedWidget.setStyle(nullRect);
            this._currentTabbedWidget = null;
          }
          if (page && page._tabbedAppWidget) {
            this._currentTabbedWidget = page._tabbedAppWidget;
            this._currentTabbedWidget.getElement().removeClass("gbc_out_of_view");
            this._currentTabbedWidget.setStyle(this._currentTabbedRect);
            this._session.setCurrentApplication(page._tabbedApp);
            if (page._tabbedApp.layout) {
              page._tabbedApp.scheduler.layoutCommand({
                resize: true
              });
            }
            const displayedWindow = page._tabbedApp.getVMWindow(),
              displayedWindowWidget = displayedWindow && displayedWindow.getController() &&
              displayedWindow.getController().getWidget();
            if (displayedWindowWidget) {
              context.HostService.setDisplayedWindowNode(displayedWindow);
            }
          }
        },

        /**
         * Hosting application afterLayout handler
         * @private
         */
        _onHostingApplicationAfterLayout: function() {
          const rectPages = this._tabbedContainerWidget.getContainerElement().getBoundingClientRect(),
            rect = this._session._widget.getElement().getBoundingClientRect();
          this._currentTabbedRect = {
            top: "" + (rectPages.top - rect.top) + "px !important",
            left: "" + (rectPages.left - rect.left) + "px !important",
            right: "" + (rect.right - rectPages.right) + "px !important",
            bottom: "" + (rect.bottom - rectPages.bottom) + "px !important",
            width: "auto",
            height: "auto"
          };
          for (let app of this._tabbedApplications) {
            let appWidget = app.getUI().getWidget();
            if (appWidget._tabbedPage === this._tabbedContainerWidget.getCurrentPage()) {
              appWidget.setStyle(this._currentTabbedRect);
            } else {
              appWidget.setStyle(nullRect);
            }
            if (!appWidget.getElement().hasClass("gbc_out_of_view") &&
              appWidget._tabbedPage.getElement().parent("gbc_ApplicationWidget") && app.layout) {
              app.layout.refreshLayout({
                resize: true
              });
            }
          }
          this._registerAnimationFrame(() => {
            if (this._tabbedContainerWidget && this._tabbedContainerWidget.updateScrollersVisibility) {
              this._tabbedContainerWidget.updateScrollersVisibility();
            }
          });
        },
        /**
         * add application
         * @param {classes.VMApplication} app
         * @param {classes.ApplicationWidget} appWidget
         */
        addApplicationWidget: function(app, appWidget) {
          if (this._windowNode) {
            this._tabbedApplications.push(app);
            appWidget.getElement().addClass("gbc_out_of_view");
            appWidget.setStyle(nullRect);
            const tabbedContainerPage = cls.WidgetFactory.createWidget("Page", {
              appHash: gbc.systemAppId
            });

            const win = app.getVMWindow() && app.getVMWindow().getController().getWidget();
            tabbedContainerPage.setText(win ? (win.getText() || win.getUserInterfaceWidget().getText()) : "");
            tabbedContainerPage.setImage(win ? (win.getImage() || win.getUserInterfaceWidget().getImage()) : "");
            appWidget._tabbedPage = tabbedContainerPage;
            tabbedContainerPage._tabbedApp = app;
            tabbedContainerPage._tabbedAppWidget = appWidget;

            this._session.getWidget().addChildWidget(appWidget, {
              noDOMInsert: false
            });
            appWidget.when(context.constants.widgetEvents.destroyed, function() {
              this._tabbedApplications.remove(app);
              this._tabbedContainerWidget.removeChildWidget(appWidget._tabbedPage);
              appWidget._tabbedPage = null;
              tabbedContainerPage._tabbedApp = null;
              tabbedContainerPage._tabbedAppWidget = null;
              this._registerAnimationFrame(function() {
                if (this._tabbedContainerWidget && this._tabbedContainerWidget.updateScrollersVisibility) {
                  this._tabbedContainerWidget.updateScrollersVisibility();
                }
              }.bind(this));
            }.bind(this));
            this._tabbedContainerWidget.addChildWidget(tabbedContainerPage);
            this._registerAnimationFrame(function() {
              if (this._tabbedContainerWidget && this._tabbedContainerWidget.updateScrollersVisibility) {
                this._tabbedContainerWidget.updateScrollersVisibility();
              }
            }.bind(this));
          }
        },

        /**
         * idle hoor management
         */
        freeIdleHook: function() {
          if (this._appIdleHook) {
            this._appIdleHook();
          }
        },

        /**
         * layout concern
         * @returns {classes.VMApplication}
         */
        triggerDisplayChanged: function() {
          let host = this._tabbedContainerWidget && this._tabbedContainerWidget.getParentWidget();
          if (host) {
            host.getLayoutEngine().forceMeasurement();
            host.getLayoutEngine().invalidateAllocatedSpace();
            host.getLayoutInformation().invalidateMeasure();
          }
          return this._app;
        },

        /**
         * test if start menu can be managed
         * @param startMenuNode
         * @returns {boolean}
         */
        willManageStartMenu: function(startMenuNode) {
          return this._windowNode && (!startMenuNode ||
            this._windowNode.getAncestor("UserInterface") === startMenuNode.getAncestor("UserInterface"));
        },

        /**
         * manage start menu
         * @param startMenuNode
         * @param widget
         */
        manageStartMenu: function(startMenuNode, widget) {
          if (this._windowNode && (!startMenuNode ||
              this._windowNode.getAncestor("UserInterface") === startMenuNode.getAncestor("UserInterface"))) {
            switch (this._windowNode.getStyleAttribute("startMenuPosition")) {
              case "menu":
                context.HostLeftSidebarService.enableSidebar(false);
                break;
              case "tree":
                context.HostLeftSidebarService.enableSidebar(true);
                const startMenuWidget = widget || this._windowNode.getParentNode() &&
                  this._windowNode.getParentNode().getController() &&
                  this._windowNode.getParentNode().getController().getWidget().getStartMenuWidget();
                if (this._app) {
                  this._appIdleHook = this._app.dvm.onIdleChanged(function() {
                    startMenuWidget.setProcessing(this._app && !this._app.isIdle());
                  }.bind(this));
                }
                context.HostLeftSidebarService.setContent(startMenuWidget);
                break;
              default:
                context.HostLeftSidebarService.enableSidebar(false);
                break;
            }
          }
        }
      };
    });
  });
;

"use strict";

/*
 starter for gbc environment
 script has to be the last to load to run the environment
 */

(function(context) {
  context.gbcWrapper.__prepare();
  context.gbcWrapper.on(context.gbcWrapper.events.READY, function() {
    context.gbc.run(function() {
      context.gbcWrapper.__gbcReady();
    });
  });
})(window);
